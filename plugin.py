import os
import hashlib
from io       import open as ioOpen
from json      import loads as jLoads, dumps as jDumps
from glob      import glob as iGlob
from re       import match as iMatch, escape as iEscape
from re       import sub as iSub, subn as iSubn, split as iSplit
from re       import search as iSearch, compile as iCompile
from re       import findall as iFindall, finditer as iFinditer
from re       import IGNORECASE
from math      import floor as iFloor, ceil as iCeil, log as iLog
from time      import localtime, mktime, strftime, time as iTime
from time      import sleep as iSleep, timezone as iTimezone
from threading     import Thread as iThread, enumerate as iEnumerate
from threading     import currentThread
from datetime     import datetime, timedelta
from collections    import Counter as iCounter
from base64      import b64encode, b64decode
from sys      import version_info as pyVersion
from skin      import parseColor
from Tools.Directories   import resolveFilename, SCOPE_PLUGINS, SCOPE_FONTS
from Tools.Directories   import SCOPE_CURRENT_SKIN, SCOPE_SKIN
from Plugins.Plugin    import PluginDescriptor
from Screens.Screen    import Screen
from Screens.ChannelSelection import ChannelContextMenu, ChannelSelectionBase
from Screens.ChannelSelection import service_types_tv, service_types_radio
from Screens.InfoBar   import InfoBar
from Tools.BoundFunction  import boundFunction as BF
from Tools.LoadPixmap   import LoadPixmap
from Components.PluginComponent import plugins as iPlugins
from Components.Harddisk  import harddiskmanager
from Components.Label   import Label
from Components.ScrollLabel  import ScrollLabel
from Components.Button   import Button
from Components.MenuList  import MenuList
from Components.ActionMap  import ActionMap
from Components.Pixmap   import Pixmap
from Components.NimManager  import nimmanager
from Components.Slider   import Slider
from enigma      import getDesktop, ePoint, eSize, gFont, eRect
from enigma      import eTimer, eDVBDB, addFont, fontRenderClass
from enigma      import iServiceInformation
from enigma      import eServiceReference, eServiceCenter
from enigma      import eListboxPythonMultiContent
from enigma      import RT_HALIGN_LEFT as LEFT
from enigma      import RT_HALIGN_RIGHT as RIGHT
from enigma      import RT_HALIGN_CENTER as CENTER
from enigma      import RT_VALIGN_CENTER
from Components.ConfigList  import ConfigListScreen
from Components.config   import config, ConfigSubsection, configfile
from Components.config   import getConfigListEntry, ConfigDirectory
from Components.config   import ConfigYesNo, ConfigElement, ConfigText
from Components.config   import ConfigSelection, ConfigSelectionNumber
from Components.config   import ConfigSubList, ConfigInteger
try:  import tarfile as iTar
except: iTar = None
try:  import zipfile as iZip
except: iZip = None
try: from xml.etree import ElementTree as iElem
except: iElem = None
try: from shutil import move as iMove, rmtree, copyfile as iCopyfile, copymode as iCopymode
except: iMove = iCopyfile = iCopymode = None
try:
 from urllib2 import Request as iRequest, urlopen as iUrlopen, URLError as iURLError, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
 from urllib  import unquote as iUnquote, quote as iQuote
 from urlparse import urlparse as iUrlparse, parse_qs as iUrlparse_qs
except:
 try:
  from urllib.request import Request as iRequest, urlopen as iUrlopen, build_opener, install_opener, HTTPPasswordMgrWithDefaultRealm, HTTPDigestAuthHandler, HTTPHandler
  from urllib.error import URLError as iURLError
  from urllib.parse import unquote as iUnquote, quote as iQuote, urlparse as iUrlparse, parse_qs as iUrlparse_qs
 except:
  iRequest = iUrlopen = iURLError = iUnquote = iQuote = iUrlparse = build_opener = install_opener = HTTPPasswordMgrWithDefaultRealm = HTTPDigestAuthHandler = HTTPHandler = None
VVh9hj    = "AJPanel"
VVzOp7  = "Enigma2 Tools"
VVJ6zn   = "v10.8.5"
VVPAan    = "14-10-2025"
VV5xkJ    = 0
VVNA43   = 0
VVS9Q2   = 0
VVUytA  = resolveFilename(SCOPE_PLUGINS, base="Extensions/")
VVhDOZ  = resolveFilename(SCOPE_PLUGINS, base="SystemPlugins/")
VVXRGG   = "AJPan"
VVSBbs  = "AUTO FIND"
VVoeMl  = "Custom"
VVTCq1    = "/usr/share/enigma2/picon/"
VVQe79   = "/etc/enigma2/"
VVfBVj   = VVQe79 + "settings"
VV3W4d = VVQe79 + "blacklist"
VVl57H = VVQe79 + "whitelist_streamrelay"
VVLtQt    = ""
VV8nt5 = "Regular"
VV2DFQ = "Fixed"
VVNj6e  = "AJP_Main"
VVUm9t = "AJP_Terminal"
VVLn2O  = "AJP_Added"
VVnvzh = "AJP_System"
VVNhAq  = VV8nt5
VV3knk    = ""
VV1jg5   = " && echo 'Successful' || echo 'Failed!'"
VVfDY7  = "Cannot continue (No Enough Memory) !"
VVq9cv  = ["#119f1313","#11005500","#11a08000","#1118188b"]
VVzu3t    = ["KeyMap_RC"]
VV9iuh  = "utf8"
VV8oe7  = False
VVAL3j    = ("-" * 100, )
SEP      = "-" * 80
VVWe5f = 0
VVBvqf = 0
VVWp3I     = 0
VVibAL    = 1
VVvJlJ    = 2
VVkFCt   = 3
VVHfYH   = 4
VVDEl1 = 5
VVUcno    = 6
VVsVfC    = 7
VVmSQ6 = 8
VVf2e8 = 9
VVQrjc  = 10
VV5jiO   = 11
VVnhJ8  = 12
VVujxw  = 13
VVpLGo   = 14
VVakGB    = 15
VVnUU2   = 16
VVsg3D   = 17
VVrQU9    = 18
VVspuu    = 19
VVoNDw  = 20
VVlrZA    = 21
VVje9A   = 0
VV5jA8   = 1
VVYAtm   = 2
if not "VVG5aE" in globals(): VVG5aE = set()
def FFXcbU(path, alias, scale=100, isRepl=0, save=True):
 try:
  addFont(path, alias, scale, isRepl)
  if save: VVG5aE.add(alias)
  return True
 except:
  try:
   addFont(path, alias, scale, isRepl, 0)
   if save: VVG5aE.add(alias)
   return True
  except:
   pass
 return False
VVmJwX = os.path.exists
def FFCyVu(f, mode="r"):
 return os.access(f, {"r": os.R_OK, "w":os.W_OK}.get(mode, os.F_OK)) if f else False
def FFq2rn(f):
 return (os.path.exists(f) or os.path.islink(f)) if f else False
def FF7YkR(path):
 lst = []
 try:
  for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
   if elem.tag == "include":
    incF = elem.get("filename", "")
    incF = incF and resolveFilename(SCOPE_CURRENT_SKIN, incF)
    if FFCyVu(incF):
     lst.append(incF)
 except:
  pass
 return lst
def FF85qp():
 defSk = resolveFilename(SCOPE_SKIN, "skin_default/skin.xml")
 subSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin_subtitles.xml")
 curSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin.xml")
 lst = []
 for f in set((defSk, subSk, curSk)):
  if FFCyVu(f):
   lst.append(f)
   lst.extend(FF7YkR(f))
 return list(set(lst))
def FFcFmA():
 lst = []
 for skinF in FF85qp():
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(skinF, events=("start", ))):
    if elem.tag == "fonts":
     for fnt in elem.findall("font"):
      name = fnt.get("name", "Regular")
      scale = fnt.get("scale", "100")
      repl = fnt.get("replacement", "")
      fName = fnt.get("filename", "")
      if fName and scale.isdigit():
       if fName.startswith("/"): fPath = fName
       else     : fPath = resolveFilename(SCOPE_FONTS, fName)
       if FFCyVu(fPath): lst.append((name, scale, repl, fName, fPath, skinF))
     break
  except:
   pass
 return lst
def FFNEkd(isSort=True):
 lst = []
 for name, scale, repl, fName, fPath, skinF in FFcFmA():
  lst.append(name)
 curSk = resolveFilename(SCOPE_CURRENT_SKIN, "skin.xml")
 fbFnt = resolveFilename(SCOPE_FONTS, "fallback.font", path_prefix=curSk)
 if FFCyVu(fbFnt): lst.append("Fallback")
 if isSort: return list(set(lst))
 else  : return lst
def FFPaMe(isSort=True):
 lst = []
 try:
  from enigma import getFontFaces
  lst = getFontFaces()
 except:
  try:
   from skin import getFontFaces
   lst = getFontFaces()
  except:
   lst = FFNEkd(isSort)
 if isSort: return list(set(lst))
 else  : return lst
def FFNOP7():
 lst = FFPaMe()
 lst.extend(VVG5aE)
 if lst:
  global VVNhAq
  if VVNj6e in lst and CFG.fontPathMain.getValue(): VVNhAq = VVNj6e
  else               : VVNhAq = VV8nt5
  return sorted(list(set(lst)))
 else:
  return [VV8nt5]
config.plugins.AJPanel = ConfigSubsection()
CFG = config.plugins.AJPanel
CFG.showInMainMenu    = ConfigYesNo(default=False)
CFG.showInExtensionMenu   = ConfigYesNo(default=True)
CFG.showInChannelListMenu  = ConfigYesNo(default=True)
CFG.EventsInfoMenu    = ConfigYesNo(default=True)
CFG.keyboard     = ConfigSelection(default="v", choices=[("v", "Virtual Keyboard"),("s", "System Default")])
CFG.FileManagerExit    = ConfigSelection(default="d", choices=[("d", "Directory Up"),("e", "Exit")])
CFG.hotkey_signal    = ConfigSelection(default="lesc", choices=[("off", "Disable"),("lok", "Long-OK"),("lesc", "Long-Exit"),("lred", "Long-Red")])
CFG.subtDefaultEnc    = ConfigDirectory(default=VV9iuh)
CFG.screenshotFType    = ConfigSelection(default="jpg", choices=[("off", "Disable"),("jpg", "JPG"),("png", "PNG"),("bmp", "BMP")])
CFG.iptvAddToBouquetRefType  = ConfigSelection(default="4097", choices=[("1", "1     (DVB Stream)"),("4097", "4097 (ServiceMp3)"),("5001", "5001 (GST Player)"),("5002", "5002 (Ext-3 EPlayer)"),("8192", "8192 (HDMI input)"),("8193", "8193 (eServiceUri)"),("8793", "8793 (ServiceUrl)")])
CFG.autoResetFrozenIptvChan  = ConfigSelection(default="1", choices=[("off", "Off"),("on+", "Refresh + Notify"),("on", "Silent Refresh")])
CFG.hideIptvServerAdultWords = ConfigYesNo(default=False)
CFG.hideIptvServerChannPrefix = ConfigYesNo(default=False)
CFG.iptvHostsMode    = ConfigDirectory(default=VVSBbs, visible_width=45)
CFG.resumeMovies    = ConfigSelection(default="a", choices=[("off", "Disabled"),("a", "All"),("i", "IPTV Only"),("l", "All (Except IPTV)")])
CFG.MovieDownloadPath   = ConfigDirectory(default="/media/hdd/movie/", visible_width=45)
CFG.portalConnTimeout   = ConfigSelectionNumber(default=2, stepwidth=1, min=1, max=5, wraparound=False)
CFG.PIconsPath     = ConfigDirectory(default=VVTCq1, visible_width=45)
CFG.customMenuPath    = ConfigDirectory(default="/", visible_width=45)
CFG.backupPath     = ConfigDirectory(default="/", visible_width=45)
CFG.iptvHostsDirs    = ConfigText(default="")
CFG.subtitleEventLang   = ConfigSelection(default="o", choices=[("o", "Original"),("s", "English")])
CFG.subtitleFavPath    = ConfigText(default="/")
CFG.favServerPlaylist   = ConfigText(default="")
CFG.favServerPortal    = ConfigText(default="")
CFG.simplePortal    = ConfigYesNo(default=False)
CFG.browserStartPath   = ConfigText(default="/")
CFG.browserBookmarks    = ConfigText(default="/media/,/tmp/,/")
CFG.browserSortMode    = ConfigInteger(default=0, limits=(0, 5))
CFG.browserSortMix    = ConfigYesNo(default=False)
CFG.signalPos     = ConfigInteger(default=5, limits=(1, 9))
CFG.signalSize     = ConfigInteger(default=3, limits=(1, 13))
CFG.mixedColorScheme   = ConfigInteger(default=4, limits=(0, 4))
CFG.checkForUpdateAtStartup  = ConfigYesNo(default=False)
CFG.downloadAutoResume   = ConfigYesNo(default=True)
CFG.downloadMonitor    = ConfigYesNo(default=False)
CFG.lastTerminalCustCmdLineNum = ConfigInteger(default=0)
CFG.lastFileManFindPatt   = ConfigText(default="")
CFG.lastSubtFManFindDir   = ConfigText(default="/media/")
CFG.lastPkgProjDir    = ConfigText(default="/media/")
CFG.lastFeedPkgsDir    = ConfigText(default="/media/")
CFG.lastCustMenuPicDir   = ConfigText(default="")
CFG.lastCustMenuXmlDir   = ConfigText(default="")
CFG.lastCopyMoveDir    = ConfigText(default="")
CFG.lastFindTerminal   = ConfigText(default="")
CFG.lastFindServers    = ConfigText(default="")
CFG.lastFindIptv    = ConfigText(default="")
CFG.lastFindMovie    = ConfigText(default="")
CFG.lastFindSubtitle   = ConfigText(default="")
CFG.lastFindPackages   = ConfigText(default="")
CFG.lastFindServices   = ConfigText(default="")
CFG.lastFindSatName    = ConfigText(default="")
CFG.lastFindContextFind   = ConfigText(default="")
CFG.lastFindEditor    = ConfigText(default="")
CFG.lastFindGeneral    = ConfigText(default="")
CFG.lastFindRepl_fnd   = ConfigText(default="")
CFG.lastFindRepl_rpl   = ConfigText(default="")
CFG.fontPathMain    = ConfigText(default="")
CFG.fontPathTerm    = ConfigText(default="")
CFG.fontPathAdd     = ConfigText(default="")
CFG.fontPathSys     = ConfigText(default="")
CFG.fontScaleSys    = ConfigInteger(default=100)
CFG.fontAllPerc     = ConfigInteger(default=0)
CFG.transpColorPicons   = ConfigText(default="#11404040")
CFG.transpColorChannels   = ConfigText(default="#88004040")
CFG.epgLangTitle    = ConfigText(default="")
CFG.epgLangDescr    = ConfigText(default="")
CFG.lastFtpLocalPath   = ConfigText(default="")
CFG.lastNetworkDevice   = ConfigInteger(default=0)
CFG.terminalCmdFile    = ConfigText(default="ajpanel_cmd")
CFG.ConfirmTerminalExit   = ConfigYesNo(default=False)
CFG.terminalTextWrap   = ConfigYesNo(default=True)
CFG.terminalFontSizeCmd   = ConfigInteger(default=26, limits=(22, 35))
CFG.terminalFontSizeHist  = ConfigInteger(default=26, limits=(22, 35))
CFG.xmlTvNameCompRatio   = ConfigSelectionNumber(default=50, stepwidth=10, min=40, max=100)
CFG.xmlTvChannelRefFile   = ConfigText(default="")
CFG.wsAutoStart     = ConfigYesNo(default=True)
CFG.wsPort      = ConfigInteger(default=8383)
tmp = [("0", "No Timeout")]
for i in range(3,11): tmp.append((str(i), str(i)))
tmp.extend((("15", "15"), ("20", "20")))
CFG.playerPos     = ConfigInteger(default=0, limits=(0, 1))
CFG.playerJumpMin    = ConfigInteger(default=5, limits=(1, 10))
CFG.playerTimeout     = ConfigSelection(default="0", choices=tmp)
CFG.playerRedBtn    = ConfigSelection(default="e", choices=[("e", "Close Bar & Recall Last DVB Service"),("s", "Show Signal Monitor")])
tmp = [("srt","FROM SRT FILE"),("#00FFFF","Aqua"),("#000000","Black"),("#0000FF","Blue"),("#FF00FF","Fuchsia"),("#808080","Gray"),("#008000","Green"),("#00FF00","Lime"),("#800000","Maroon"),("#000080","Navy"),("#808000","Olive"),("#800080","Purple"),("#FF0000","Red"),("#C0C0C0","Silver"),("#008080","Teal"),("#FFFFFF","White"),("#FFFF00","Yellow")]
CFG.subtBGTransp    = ConfigSelectionNumber(default=100, stepwidth=10, min=0, max=100, wraparound=False)
CFG.subtTextFg     = ConfigSelection(default="#FFFFFF", choices=tmp)
CFG.subtTextFont    = ConfigSelection(default=VVNhAq, choices=[(x,  x) for x in FFNOP7()])
CFG.subtTextSize    = ConfigSelectionNumber(default=50, stepwidth=5, min=30, max=100, wraparound=False)
CFG.subtTextAlign    = ConfigSelection(default="1", choices=[("0", "Left"),("1", "Center"),("2", "Right")])
CFG.subtShadowColor    = ConfigSelection(default="#000080", choices=tmp[1:])
CFG.subtShadowSize    = ConfigSelectionNumber(default=5, stepwidth=1, min=0, max=10, wraparound=False)
CFG.subtVerticalPos    = ConfigSelectionNumber(default=90, stepwidth=1, min=0, max=100, wraparound=False)
CFG.subtDelayMax    = ConfigSelectionNumber(default=10, stepwidth=10, min=10, max=60, wraparound=False)
CFG.subtDelaySec    = ConfigSelectionNumber(default=0, stepwidth=1, min=-CFG.subtDelayMax.getValue() * 60, max=CFG.subtDelayMax.getValue() * 60, wraparound=False)
del tmp
def FFE2vO():
 mode = CFG.mixedColorScheme.getValue()
 if mode == 4:
  if os.path.isfile("/etc/apt/apt.conf"): return 0
  try:
   with open("/etc/issue", "r") as f:
    if iMatch(r"open.*vision", f.read(), IGNORECASE):
     return 1
  except: pass
  return 3
 else:
  return max(min(3, mode), 0)
VVHByN = FFE2vO()
VVo7S9 = VVA4XU = VVYjI5 = VVyFI2 = VVz22H = VVIH76 = VV9nWG = VVMibI = VVSGsk = VVJEMb = VV1fx4 = VVFuwR = VVGCYL = VVZtfx = VVcPtB = VVwdUw = ""
def FFR9If()  : FFonTy(FF5V4z())
def FFNKC6()  : FFonTy(FFBcJb())
def FFNXJk(tDict): FFonTy(jDumps(tDict, indent=4, sort_keys=True))
def FFEcpq(*args): FFNX0y(1, 1,  *args)
def FFonTy(*args) : FFNX0y(1 ,0,  *args)
def FFU8n7(*args): FFNX0y(0, 0,  *args)
def FFNX0y(addSep=1, isArray=1, *args):
 if not VVNA43: return
 sep = (">>>> %s\n" % ("#" * 80)) if addSep else ""
 txt = sep
 if isArray:
  for item in args:
   if type(item) in (list, tuple, set):
    txt += ">>>> --> LIST START <--\n"
    for itm in item: txt += ".... %s\n" % str(itm)
    txt += ">>>> --> LIST END <--\n"
   elif isinstance(item, dict):
    txt += ">>>> LIST START <--\n"
    Len = 0
    for key, val in item.items(): Len = max(Len, len(str(key)))
    for key, val in item.items(): txt += ".... %s: %s\n" % (str(str(key).ljust(Len)), str(val))
    txt += ">>>> LIST END <--\n"
   else:
    txt += "---> %s\n" % str(item)
 else:
  cr = "\n" if addSep else ""
  txt += ">>>> %s%s" % (" , ".join(list(map(str, args))), cr)
 txt += sep.replace("#", "-")
 os.system("cat << '_EOF' \n" + str(txt) + "\n_EOF")
def FFdDxT(fnc):
 def VVuE0i(*args, **kwargs):
  t1 = iTime()
  fnc(*args, **kwargs)
  FFonTy(">>>>>> Elapsed : %s sec\nargs = %s\nkwargs = %s" % (("%.6f" % (iTime() - t1)).rstrip("0"), args, kwargs))
 return VVuE0i
def FFGlWm(*args):
 t = "[%s] %s >> %s" % (VVh9hj, datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'), " , ".join(list(map(str, args))))
 os.system("cat << '_EOF' \n%s\n_EOF" % t)
def FFA8G3(*args):
 with open("/tmp/ajpanel_log.txt", "a") as f:
  t =  datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
  f.write("%s %s\n" % (t, " , ".join(list(map(str, args)))))
def FFllYj(tDict): FFH9VS(jDumps(tDict, indent=4, sort_keys=True))
def FFH9VS(*args):
 if not VVNA43: return
 path = "/tmp/ajp_log.txt"
 with open(path, "a") as f:
  f.write(">>>> %s\n" % (" , ".join(list(map(str, args)))))
 FFU8n7("Added to : %s" % path)
def FFLUsX(txt, isAppend=True, ignoreErr=False):
 if not VVNA43: return
 tm = FFRvLH()
 err = "" if not ignoreErr else FFBcJb()
 fileName = "/tmp/ajp_log.txt"
 with open(fileName, "a" if isAppend else "w") as f:
  if err: f.write(err)
  f.write("%s >> %s\n" % (tm, str(txt)))
 if err: FFonTy(err)
 FFonTy("Output Log File : %s" % fileName)
def FFBcJb():
 try:
  from traceback import format_exc, format_stack
  trace = format_exc()
  if trace and len(trace) > 5:
   tm = FFRvLH()
   stack = format_stack()[:-1]
   sep = "*" * 70
   err = "\n%s\n*** %s\n%s\n\n" % (sep, tm, sep)
   err += "%s\n\n%s\n%s\n" % ("".join(stack), trace, sep)
   return err
 except:
  return "Cannot Trace !"
def FF5V4z():
 import inspect
 lst = []
 for ndx, f in enumerate(inspect.stack()):
  if ndx > 0:
   lst.append("%s\t>> %s" % (os.path.basename(f[1]).ljust(20), f[3]))
 return "Last Fncs:\n" + "\n".join(lst)
VVNXcy = 0
def FFUNbz():
 global VVNXcy
 VVNXcy = iTime()
def FFp2S4(txt=""):
 FFonTy(">>>>>> Elapsed : %s sec\t%s" % (("%.6f" % (iTime() - VVNXcy)).rstrip("0"), txt))
def FFlpqQ(*args):
 for arg in args:
  if VVh9hj[:5].lower() in os.path.basename(arg).lower():
   return True
 return False
def FFPCZY(SELF, keep=""):
 lst = []
 try:
  for w in SELF.session.dialog_stack[::-1]:
   w = w[0]
   if keep and keep in str(w): break
   elif "Plugins.Extensions.AJPan." in str(w): lst.append(w)
 except:
  pass
 return lst
def FFHxAC(SELF):  FFWCqk(SELF, "")
def FF8lJ1(*args): FFWCqk(args[0], ".CC6cFV")
def FFWCqk(SELF, keep):
 SELF.close()
 for w in FFPCZY(SELF, keep):
  try: w.close()
  except: pass
def FFYDZ6(vTxt):
 if vTxt in globals(): del globals()[vTxt]
def FFXpOB():
 BT_SCALE = BT_KEEP_ASPECT_RATIO = None
 try:
  from enigma import BT_SCALE, BT_KEEP_ASPECT_RATIO
 except:
  try  : from enigma import BT_SCALE, BT_FIXRATIO as BT_KEEP_ASPECT_RATIO
  except : pass
 if BT_SCALE and BT_KEEP_ASPECT_RATIO: return BT_SCALE | BT_KEEP_ASPECT_RATIO
 else        : return None
VVGpHg = FFXpOB()
def getDescriptor(fnc, where, name, descr="", needsRestart=False):
 w = getDesktop(0).size().width()
 if w and w < 1920 : icon="icon.png"
 else    : icon="iconhd.png"
 if name == VVh9hj:
  descr = VVzOp7
 else:
  if not descr:
   descr = "%s %s" % (VVh9hj, name or VVzOp7)
  name = "AJ - %s" % name
 return PluginDescriptor(fnc=fnc, where=where, needsRestart=needsRestart, name=name, description=descr, icon=icon)
def FFsfSz()  : return getDescriptor(FFPyES , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "File Manager")
def FFttL1() : return getDescriptor(FFNt2R  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "IPTV Menu")
def FF2V0Y()  : return getDescriptor(FFuMiy   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Movies Resume History")
def FF2aef()  : return getDescriptor(FFCORE  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Player Bar")
def FFQRKB(): return getDescriptor(FFdgj8, [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Plugin Browser")
def FFT9Fx()  : return getDescriptor(FFFp5I   , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Signal Monitor")
def FFYbQt() : return getDescriptor(FFhx52  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], "Terminal")
def FFpUEE() : return getDescriptor(FFLedO  , [ PluginDescriptor.WHERE_EXTENSIONSMENU ], CCRlkm.VVazeJ())
def FFxu4x()      : return getDescriptor(FF9dNV , [ PluginDescriptor.WHERE_EVENTINFO  ], "Service Information")
def Plugins(**kwargs):
 lst = [ getDescriptor(FFtmfS , [PluginDescriptor.WHERE_PLUGINMENU], VVh9hj, needsRestart=True)
  ,   getDescriptor(FFsQm4 , [PluginDescriptor.WHERE_MENU]   , VVh9hj)
  ,   PluginDescriptor(fnc=FFTqiW, where=[PluginDescriptor.WHERE_SESSIONSTART], needsRestart=True, description="AJPanel Startup")
  ]
 if CFG.showInExtensionMenu.getValue():
  lst.append(FFsfSz())
  lst.append(FFttL1())
  lst.append(FF2aef())
  lst.append(FFQRKB())
  lst.append(FFT9Fx())
  lst.append(FFYbQt())
  lst.append(FFpUEE())
  lst.append(FF2V0Y())
 if CFG.EventsInfoMenu.getValue():
  lst.append(FFxu4x())
 return lst
def FFTqiW(reason, **kwargs):
 if reason == 0:
  FFzcnD()
  CC9hzi.VV3xGy()
  CC6cFV.VVAeob()
  if "session" in kwargs:
   session = kwargs["session"]
   FFBJ7Q(session)
   CCo1b7(session)
   if CFG.wsAutoStart.getValue():
    CCMTfv(session).VVeTpx(True)
def FFsQm4(menuid, **kwargs):
 if menuid == "mainmenu" and CFG.showInMainMenu.getValue():
  return [(VVh9hj, FFtmfS, VVh9hj, 1)]
 else:
  return []
def FFtmfS(session, **kwargs):
 session.open(CC6cFV)
def FFPyES(session, **kwargs) : session.open(CClYaF)
def FFNt2R(session, **kwargs)  : session.open(CCkEI5)
def FFuMiy(session, **kwargs)    : session.open(CC6F0F)
def FFCORE(session, **kwargs)  : CCqWM2.VVHc02(session, VV1rS5=2)
def FFdgj8(session, **kwargs): CCFZr4.VVsCNi(session)
def FFFp5I(session, **kwargs)   : FFdXBl(session, reopen=True)
def FFhx52(session, **kwargs)  : session.open(CCtzVm)
def FFLedO(session, **kwargs)  : CCRlkm.VVEYRT(session, True)
def FF9dNV(session, **kwargs):
 CCvjVs.VVUxTg(session)
def FFBJ7Q(session):
 hk = None
 dm = FFgrjX()
 if dm:
  try:
   from keymapparser import readKeymap
   readKeymap(VV231J + "keymap.xml")
   from GlobalActions import globalActionMap as hk
  except:
   pass
 else:
  cont = ["KeyMap_HK"]
  try: hk = ActionMap(contexts=cont, prio=1, parentScreen=session.screen)
  except: hk = ActionMap(contexts=cont, prio=0 if CC674y.VV1LWx() else 1)
  hk.execBegin()
 if hk:
  hk.actions["longOK"] = BF(FFmlMt, session, "lok")
  hk.actions["longCancel"]= BF(FFmlMt, session, "lesc")
  hk.actions["longRed"] = BF(FFmlMt, session, "lred")
  for k in (CC6u6z.VVjbK6, CC6u6z.VVOdU6, CC6u6z.VV9Iya):
   hk.actions[k] = BF(CC6u6z.VVTqPs, session, k, dm)
def FFmlMt(session, key):
 if CC6u6z.VVgrEx(session) or CFG.hotkey_signal.getValue() != key:
  return
 try:
  if CCtKqU.VV0DI2:
   CCtKqU.VV0DI2.close()
  if not CCqWM2.VVyLCv:
   CCqWM2.VVHc02(session, VV1rS5=1)
 except:
  pass
def FFjt1c(confItem, val):
 confItem.setValue(val)
 confItem.save()
 configfile.save()
def FFI3NO(confItem):
 if isinstance(confItem, ConfigSelectionNumber):
  if confItem.saved_value is None and str(confItem.value) == str(confItem.default):
   return False
  return str(confItem.value) != str(confItem.saved_value)
 else:
  return confItem.isChanged()
def FFZMxC(SELF, title="", addLabel=False, addScrollLabel=False, VV3wat=None, addCloser=False):
 Screen.__init__(SELF, SELF.session)
 if title: title = "  %s  " % title
 else : title = "" if SELF.VVfOli["VVON3k"] == VVlrZA else FFGNZA()
 SELF["myTitle"] = Label(title)
 SELF["myBody"] = Label()
 SELF["myWP"] = Pixmap()
 SELF["myInfoFrame"] = Label()
 SELF["myInfoBody"] = Label()
 SELF.VV0bxL = eTimer()
 try: SELF.VVYnJH = SELF.VV0bxL.timeout.connect(BF(FFxjE5, SELF))
 except: SELF.VV0bxL.callback.append(BF(FFxjE5, SELF))
 SELF.onClose.append(SELF.VV0bxL.stop)
 FFxjE5(SELF)
 btnMode = SELF.VVfOli["VV0Ay7"]
 if btnMode in (1, 2): SELF["keyMenu"] = Pixmap()
 if btnMode in (2, 3): SELF["keyInfo"] = Pixmap()
 if SELF.VVfOli["VVeFSs"] > 0:
  SELF["myBar"]  = Label()
  SELF["myLine"]  = Label()
  SELF["keyRed"]  = Label()
  SELF["keyGreen"] = Label()
  SELF["keyYellow"] = Label()
  SELF["keyBlue"]  = Label()
  SELF["keyRed"].hide()
  SELF["keyGreen"].hide()
  SELF["keyYellow"].hide()
  SELF["keyBlue"].hide()
 if addLabel:
  SELF["myLabel"] = Label()
 if addScrollLabel:
  SELF["myLabel"] = CCyjWK(SELF)
 if VV3wat:
  SELF["myMenu"] = MenuList(VV3wat, True)
  FFHlAU(SELF,
  {
   "ok" : SELF.VVPr1F ,
   "cancel": SELF.close ,
  })
 if addCloser:
  FFHlAU(SELF,
  {
   "ok" : SELF.close,
   "cancel": SELF.close,
   "red" : SELF.close
  })
def FFHlAU(SELF, tDict, name="", prio=-1):
 name = name or "myActionMap"
 try: SELF[name] = ActionMap(contexts=VVzu3t, actions=tDict, prio=prio, parentScreen=SELF.session.screen)
 except: SELF[name] = ActionMap(contexts=VVzu3t, actions=tDict, prio=prio)
def FFBep1(SELF, tDict, name=""):
 SELF[name or "myActionMap"].actions.update(tDict)
def FFDuEn(SELF, name=""):
 SELF[name or "myActionMap"].actions.clear()
def FFGNZA():
 return ("  %s" % VV3knk)
def FFTmHZ(SELF):
 global VV3knk
 VV3knk = SELF["myMenu"].l.getCurrentSelection()[0]
 return SELF["myMenu"].l.getCurrentSelection()[1]
def FFRLNq(btn, txt):
 btn.setText(txt)
 if txt : btn.show()
 else : btn.hide()
def FFzBfi(txt):
 if r"\c" in txt:
  txt = iSub(r"\\c(.){8}" ,"" , txt, flags=IGNORECASE)
 return txt
def FFd1WZ(txt):
 while txt.startswith(("#f#", "#b#")):
  txt = txt[12:]
 return txt
def FFRUST(color):
 return parseColor(color).argb()
def FFGUI5(obj, fg): FF7hy1(obj, fg, "", inv=True)
def FFZ0AC(obj, bg): FF7hy1(obj, "", bg, inv=True)
def FF7hy1(obj, fg, bg, inv=True):
 if fg: obj.instance.setForegroundColor(parseColor(fg))
 if bg: obj.instance.setBackgroundColor(parseColor(bg))
 if inv: obj.instance.invalidate()
def FFSPDv(txt, color):
 if color:
  if "/" in txt: txt = txt.replace("/", r"\/")
  return r" | sed 's/%s/\\%s&\%s/gI'" % (txt, color, VVwdUw)
 else:
  return ""
def FFGTFw(word, color):
 if color: return r"echo -e '\%s%s\n--- %s\n%s\%s';" % (color, SEP, word, SEP, VVwdUw)
 else : return r"echo -e '%s\n--- %s\n%s';" % (SEP, word, SEP)
def FFjt5L(word, color, backToColor=None):
 if backToColor : return color + str(word) + backToColor
 else   : return color + str(word) + VVwdUw
def FFyiTS(color):
 if color: return "echo -e '%s' %s;" % (SEP, FFSPDv(SEP, VV1fx4))
 else : return "echo -e '%s';" % SEP
def FFGEAF(title, color):
 title = "%s\n%s\n%s\n" % (SEP, title, SEP)
 return FFjt5L(title, color)
def FF4IPF(menuObj, fg="#00ffffff", bg="#08005555"):
 menuObj.instance.setForegroundColorSelected(parseColor(fg))
 menuObj.instance.setBackgroundColorSelected(parseColor(bg))
def FFIElK(fncCB):
 FF4iwG(":", BF(FFmfNh, fncCB))
def FFmfNh(fncCB, result, retval):
 fncCB()
def FFOKt0(SELF, delay, fnc):
 SELF.timedFncTimer = eTimer()
 try: SELF.timedFncTimer_conn = SELF.timedFncTimer.timeout.connect(fnc)
 except: SELF.timedFncTimer.callback.append(fnc)
 SELF.timedFncTimer.start(delay, True)
def FFimQ3(SELF, fnc, title="Processing ...", clearMsg=True):
 FF28n1(SELF, title)
 FF4iwG(":", BF(FFqMON, SELF, fnc, clearMsg))
def FFqMON(SELF, fnc, clearMsg, result, retval):
 fnc()
 if clearMsg:
  FF28n1(SELF)
def FF2JFr(session, fnc, title="Processing ..."):
 session.open(CCtm4v, fnc, title)
def FFOAKH(title="Processing ...", clearMsg=True, par=0, tNdx=-1):
 def VV7A8E(fnc):
  def VVuE0i(*args, **kwargs):
   FFimQ3(args[par], BF(fnc, *args, **kwargs), args[tNdx] if tNdx > -1 else title, clearMsg)
  return VVuE0i
 return VV7A8E
def FFQ45w(cmd):
 from subprocess import Popen, PIPE
 try:
  process = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
  stdout, stderr = process.communicate()
  stdout = stdout.strip()
  stderr = stderr.strip()
  if stderr : return stderr
  else  : return stdout
 except Exception as e:
  if "memory" in str(e).lower(): return VVfDY7
  else       : return ""
def FF3xOt(cmd, trim=True):
 lst = FFQ45w(cmd).splitlines()
 if trim : return list(map(str.strip, lst))
 else : return lst
def FFTKR0(cmd):
 lines = FF3xOt(cmd)
 if lines: return lines[0]
 else : return ""
def FFycDu(cmd):
 tFile = "/tmp/ajp_lines"
 FFwgGB(tFile)
 FFQ45w("%s > %s" % (cmd, tFile))
 lst = FFL19l(tFile)
 FFwgGB(tFile)
 return lst
def FF4iwG(cmd, cbFnc):
 global VVAVHg
 VVAVHg = CCaTk8()
 VVAVHg.VVtIZD(cmd, cbFnc)
def FFpwZS(cmd):
 return os.system(FFb2oQ(cmd)) == 0
def FF7ymp(cmd):
 return os.system(FFMdhJ(cmd)) == 0
def FFb2oQ(cmd)  : return cmd.rstrip("\t; ") + " > /dev/null 2>&1;"
def FFMdhJ(cmd) : return cmd.rstrip("\t; ") + " 2> /dev/null;"
def FFZQVC(    SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVgoZo=True, VV47Xm=VV5jA8, **kwargs)
def FFIdSm(  SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, **kwargs)
def FFXD60(   SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVB4JK=True, VVS7yC=True, VV47Xm=VV5jA8, **kwargs)
def FFiOUV(  SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVB4JK=True, VVS7yC=True, VV47Xm=VVYAtm, **kwargs)
def FFbi5l(  SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VV4naX=True , **kwargs)
def FF7yGJ(  session, cmd, **kwargs):      session.open(CCp90q, VVmbsE=cmd, VV4naX=True , **kwargs)
def FF28Zd( SELF, cmd, **kwargs): SELF.session.open(CCp90q, VVmbsE=cmd, VVIk01=True  , **kwargs)
def FFayeZ(cmd):
 return FFpwZS("which %s" % cmd)
def FFmCnY(cmd):
 if FFayeZ(cmd): return True, "BusyBox" in FFQ45w("%s --help" % cmd)
 else   : return False, False
def FFUaC8():
 cmd = "if [ -f /etc/apt/apt.conf ]; then echo dpkg; else if [ -f /etc/opkg/opkg.conf ]; then echo opkg; else if which dpkg; then echo dpkg; else if which opkg; then echo opkg; else if which ipkg; then echo ipkg; else echo ''; fi; fi; fi; fi; fi"
 return FFTKR0(cmd)
def FFgrjX():
 return FFCyVu("/etc/apt/apt.conf")
def FF5W9s(mode, moreDirs=None):
 if mode == 0:
  dirs = [ "*boot*", "*/ba", "/proc" ]
 else:
  dirs = [  "*boot*"
    , "*picon*"
    , "*/ba"
    , "/bin"
    , "/dev"
    , "/hdd"
    , "/lib"
    , "/linuxrc"
    , "/mnt"
    , "/newroot"
    , "/proc"
    , "/run"
    , "/sbin"
    , "/sys"
    , "/usr"
    ]
 if moreDirs:
  dirs.extend(moreDirs)
 paths = []
 for item in dirs:
  paths.append("-ipath '%s'" % item)
 txt = " -o ".join(paths)
 return r"-type d \( %s \) -prune -o " % txt
VVaNvq     = 0
VVZDGE      = 1
VVaS8u      = 2
VVjZ1L      = 3
VV0RRE     = 4
VVUty9     = 5
VVwFAi     = 6
VVj9MD = 7
VVD9EU = 8
VVRA2G = 9
VVA8Es  = 10
VVAdjB     = 11
VV9Fg4  = 12
VVYJEp  = 13
VVofV3      = 14
VVw6qo     = 15
def FFoY7E(parmNum, grepTxt=""):
 if   parmNum == VVaNvq: param = ["update" , "apt-get update" ]
 elif parmNum == VVZDGE : param = ["list" , "apt list"  ]
 pkg = FFUaC8()
 if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], grepTxt)
 elif pkg == "dpkg"   : return "%s %s" % (param[1]  , grepTxt)
 return ""
def FF5sZa(mode, package):
 if   mode == VVaS8u      : param = ["info"      , "apt show"]
 elif mode == VVjZ1L     : param = ["files"      , "dpkg -L"]
 elif mode == VV0RRE     : param = ["search"      , "dpkg -S"]
 elif mode == VVUty9     : param = ["download"     , "apt-get download"]
 elif mode == VVwFAi     : param = ["install"     , "apt-get install -y"]
 elif mode == VVj9MD : param = ["install --force-reinstall" , "apt-get install --reinstall -y"]
 elif mode == VVD9EU : param = ["install --force-overwrite" , "dpkg -i --force-all"]
 elif mode == VVRA2G : param = ["install --force-downgrade" , "apt-get install --allow-downgrades -y"]
 elif mode == VVA8Es : param = ["install --force-depends" , "apt-get install --no-install-recommends -y"]
 elif mode == VVAdjB     : param = ["remove"      , "apt-get purge --auto-remove -y"]
 elif mode == VV9Fg4  : param = ["remove --force-remove"  , "dpkg --purge --force-all"]
 elif mode == VVYJEp : param = ["remove --force-depends"  , "dpkg --remove --force-depends"]
 elif mode == VVofV3      : param = ["flag hold"     , "apt-mark hold"]
 elif mode == VVw6qo     : param = ["flag user"     , "apt-mark unhold"]
 else           : return ""
 if package:
  package = "'%s'" % package
 pkg = FFUaC8()
 if   pkg in ("ipkg", "opkg"): return "%s %s %s" % (pkg, param[0], package)
 elif pkg == "dpkg"   : return "%s %s" % (param[1], package)
def FFvQ9y():
 result = FFTKR0("ar -V 2> /dev/null | grep 'GNU ar'")
 if result.startswith("GNU ar"):
  cmd = " allOK='1';"
 else:
  notFoundCmd = " echo -e 'GNU \"ar\" command not found!';"
  installCmd = FF5sZa(VVwFAi, "")
  if installCmd:
   verCmd = "FOUND=$(ar -V 2> /dev/null | grep 'GNU ar');"
   failed1 = "Please update your software or manually install \"ar\" command and try again."
   failed2 = "(\"ar\" is available in the packages : \"opkg-tools\" or \"binutils\")"
   failed3 = "Process Failed."
   cmd  = " allOK='0';"
   cmd += verCmd
   cmd += 'if [[ -z "$FOUND" ]]; then '
   cmd +=   notFoundCmd
   cmd += "  echo -e 'Trying to install \"opkg-Tools\" ...';"
   cmd +=    FFb2oQ("%s enigma2-plugin-extensions-opkg-tools" % installCmd)
   cmd +=   verCmd
   cmd += ' if [[ -z "$FOUND" ]]; then '
   cmd += " echo -e 'Trying to install \"binutils\" ...';"
   cmd +=   FFb2oQ("%s binutils" % installCmd)
   cmd += " fi;"
   cmd +=   verCmd
   cmd += ' if [[ -z "$FOUND" ]]; then '
   cmd += "  echo -e 'Installation failed !';"
   cmd += "  echo -e '%s' %s;"  % (failed1, FFSPDv(failed1, VV1fx4))
   cmd += "  echo -e '%s' %s;"  % (failed2, FFSPDv(failed2, VV1fx4))
   cmd += "  echo -e '\n%s' %s;" % (failed3, FFSPDv(failed3, VVYjI5))
   cmd += " else"
   cmd += "  echo -e 'Installed successfully.';"
   cmd += "  allOK='1';"
   cmd += " fi;"
   cmd += "else"
   cmd += "  allOK='1';"
   cmd += "fi;"
  else:
   cmd = " allOK='0';"
   cmd += notFoundCmd
 return cmd
def FFMAzK(commandTool, toolPkgName, displayedName):
 cmd1 = ""
 installCmd = FF5sZa(VVwFAi , "")
 if installCmd:
  failed1 = "Please update your software and try again."
  failed2 = "Process Failed."
  cmd1 += " echo -e '%s not found.';" % displayedName
  cmd1 += " echo -e 'Trying to install ...';"
  cmd1 +=   FFb2oQ("%s %s" % (installCmd, toolPkgName))
  cmd1 += " FOUND=$(which  %s);"  % commandTool
  cmd1 += ' if [[ -z "$FOUND" ]]; then '
  cmd1 += "  echo -e 'Installation failed !';"
  cmd1 += "  echo -e '%s\n' %s;" % (failed1, FFSPDv(failed1, VV1fx4))
  cmd1 += "  echo -e '%s' %s;" % (failed2, FFSPDv(failed2, VVYjI5))
  cmd1 += " else"
  cmd1 += "  echo -e 'Installed successfully.';"
  cmd1 += "  allOK='1';"
  cmd1 += " fi;"
 else:
  cmd1 += " echo -e '%s not found.';" % displayedName
 cmd  = " allOK='0';"
 cmd += "FOUND=$(which %s);" % commandTool
 cmd += 'if [[ -z "$FOUND" ]]; then '
 cmd +=   cmd1
 cmd += "else"
 cmd += "  allOK='1';"
 cmd += "fi;"
 return cmd
def FFKbNE():
 pFound, pBBox = FFmCnY("xz")
 if pFound:
  if pBBox:
   failed1 = "Please update your software and try again."
   failed2 = "Process Failed."
   cmd  = " allOK='0';"
   cmd += "echo -e 'Found BusyBox xz';"
   cmd += "echo -e 'Upgrading xz ...';"
   cmd +=  FFb2oQ("%s" % FF5sZa(VVwFAi , "xz"))
   cmd += "if [ $? -eq 0 ]; then"
   cmd += " echo -e 'Installed successfully.';"
   cmd += " allOK='1';"
   cmd += "else"
   cmd += " echo -e 'Installation failed !';"
   cmd += " echo -e '%s' %s;" % (failed1, FFSPDv(failed1, VV1fx4))
   cmd += " echo -e '\n\n%s' %s;" % (failed2, FFSPDv(failed2, VVYjI5))
   cmd += "fi;"
   return cmd
  else:
   return " allOK='1';"
 else:
  return FFMAzK("xz", "xz", "XZ")
def FFYVq0(path, maxSize=-1, encLst=None):
 if   encLst is None    : encLst = CC7ocD.VVmFe6()
 elif isinstance(encLst, str) : encLst = [encLst]
 txt = ""
 for enc in encLst:
  try:
   with ioOpen(path, "r", encoding=enc) as f:
    txt = f.read(maxSize)
    txt = str(txt)
   break
  except:
   pass
 if txt.startswith(chr(239) + chr(187) + chr(191)):
  txt = txt[3:]
 return txt
def FFL19l(path, keepends=False, maxSize=-1, encLst=None):
 txt = FFYVq0(path, maxSize, encLst=encLst)
 return txt.splitlines(keepends)
def FFaOUK(SELF, path, encLst=None):
 title = os.path.basename(path)
 if FFCyVu(path):
  maxSize = 60000
  if (FFXhoc(path) > maxSize):
   title="File too big (showing first 60kB only)"
  else:
   maxSize = -1
  lines = FFYVq0(path, maxSize=maxSize, encLst=encLst)
  if lines: FF4lCP(SELF, lines, title=title, VV47Xm=VV5jA8, width=1600, height=1000, VVllEU=30, resize=False)
  else : FFNICS(SELF, path, title=title)
 else:
  FF8Wsn(SELF, path, title)
def FFw2rR(SELF, fName, title):
 path = VVIp2p + fName
 if FFCyVu(path):
  txt = FFYVq0(path)
  for k, v in {"#W#":VVwdUw,"#Y#":VVFuwR,"#G#":VVA4XU,"#Gn#":VVSGsk,"#C#":VVZtfx,"#P#":VVz22H}.items():
   txt = txt.replace(k, v)
  FF4lCP(SELF, txt, title=title, width=1600)
 else:
  FF8Wsn(SELF, path, title)
def FFkES0(path):
 if VVmJwX(path):
  tList = os.listdir(path)
  if tList:
   dirs = []
   for item in tList:
    if os.path.isdir(path + item):
     dirs.append(item)
   if dirs:
    dirs.sort()
    return dirs
 return []
def FFx9pN(path, addTrailingSlash):
 parent = os.path.abspath(os.path.join(path, os.pardir))
 if addTrailingSlash : return FFoWxR(parent)
 else    : return FFVc4H(parent)
def FFxtW5(path):
 return os.path.basename(os.path.normpath(path))
def FFENxa(path):
 try:
  os.mkdir(path)
  return "" if VVmJwX(path) else "Cannot create dir !"
 except Exception as e:
  return str(e)
def FFXhoc(path):
 try:
  if os.path.islink(FFVc4H(path)): return os.lstat(path).st_size
  elif os.path.isfile(path)    : return os.path.getsize(path)
 except:
  pass
 return -1
def FFTWKU(path):
 p = FFVc4H(path)
 if   os.path.islink(p) : return "SymLink"
 elif os.path.ismount(p) : return "Mount"
 elif os.path.isfile(p) : return "File"
 elif os.path.isdir(p) : return "Directory"
 else     : return ""
def FF4oMa(path):
 size = 0
 for Dir, dirs, files in os.walk(path):
  files = os.listdir(Dir)
  for f in files:
   fp = os.path.join(Dir, f)
   try:
    if os.path.islink(FFVc4H(fp)) : size += os.lstat(fp).st_size
    elif os.path.isfile(fp)     : size += os.path.getsize(fp)
   except:
    pass
 return size
def FFK6he(path):
 totDir = totFile = totLink = 0
 for Dir, dirs, files in os.walk(path):
  files = os.listdir(Dir)
  for f in files:
   fp = os.path.join(Dir, f)
   if os.path.islink(FFVc4H(fp)) : totLink += 1
   elif os.path.isfile(fp)     : totFile += 1
   else         : totDir += 1
 return totDir, totFile, totLink
def FFwgGB(path):
 try: os.remove(path)
 except: pass
def FFVyW4(path):
 try: rmtree(path)
 except: pass
def FFOzbr(path):
 FFpwZS("chattr -AacDdijsStu '%s' &> /dev/null; rm -fr '%s'" % (path, path))
 FFwgGB(path)
 FFVyW4(path)
def FFIFeD():
 FFpwZS("rm -rf /tmp/ajp_*")
def FFJvhj(path):
 with open(path, "rb+") as f:
  try:
   f.seek(-1, 2)
   if ord(f.read(1)) not in (10, 13):
    f.write(b"\n")
  except:
   pass
def FFj2hO(path):
 return FFpwZS("cp -f '%s' '%s.bak'" % (path, path))
def FFoWxR(path):
 if not path.endswith("/"):
  path += "/"
 return path
def FFVc4H(path):
 if not path == "/":
  path = path.rstrip("/")
 return path
def FFkzic(path, patt):
 if "[" in path or "]" in path:
  newPath = ""
  for char in path:
   if   char == "[": char = "[[]"
   elif char == "]": char = "[]]"
   newPath += char
 else:
  newPath = path
 return iGlob("%s%s" % (FFoWxR(newPath), patt))
def FFIUAb():
 sigFile = "ajpanel_res_marker"
 try:
  p = os.path.abspath(os.path.dirname(__file__))
  if p:
   mainP = os.path.join(p, "")
   resP = os.path.join(p, "res", "")
   if FFCyVu(os.path.join(resP, sigFile)):
    return mainP, resP
 except:
  pass
 paths = []
 paths.append(VVUytA)
 paths.append(VVUytA.replace("lib", "lib64"))
 ba = "/media/ba/ba/"
 list = FFkES0(ba)
 for p in list:
  p = ba + p + VVUytA
  paths.append(p)
 for p in paths:
  p = os.path.join(p, VVXRGG, "")
  if FFCyVu(os.path.join(p, "res", sigFile)):
   mainP = os.path.join(p, "")
   resP = os.path.join(mainP, "res", "")
   return mainP, resP
 mainP = os.path.join(VVUytA, VVXRGG , "")
 resP = os.path.join(mainP, "res", "")
 return mainP, resP
VV231J, VVIp2p = FFIUAb()
def FFzcnD(SELF=None):
 tLst = ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", "/")
 bDir = FF0cqc()
 if not VVmJwX(bDir) or bDir in tLst:
  for p in tLst:
   newP = p + "ajpanel_backup/"
   if VVmJwX(p) and FFpwZS("mkdir -p %s" % newP):
    bDir = newP
    break
 VVrgp4 = ""
 mvDir = FFoWxR(CFG.MovieDownloadPath.getValue())
 if not VVmJwX(mvDir) or not mvDir.endswith("/movie/"):
  for p in ("/media/hdd/", "/media/usb/", "/media/mmc/", "/media/", bDir, "/"):
   tmpP = p + "movie/"
   if VVmJwX(p) and FFpwZS("mkdir -p %s" % tmpP):
    CFG.MovieDownloadPath.setValue(tmpP)
    CFG.MovieDownloadPath.save()
    VVrgp4 = mvDir
    break
 def VVzSlC(item):
  path = item.getValue()
  if not VVmJwX(path) or path in tLst:
   item.setValue(bDir)
   item.save()
   return path
  return ""
 VV7hAV  = VVzSlC(CFG.backupPath)
 VV4p3V = VVzSlC(CFG.customMenuPath)
 if any((VV7hAV or VV4p3V or VVrgp4)):
  configfile.save()
  if SELF:
   VVJi7Q = lambda subj, oldP, newP: "%s:\n    From\t: %s\n    To\t: %s\n\n" % (FFjt5L(subj, VVFuwR), FFjt5L(oldP, VVYjI5), FFjt5L(newP, VVJEMb)) if oldP and newP and oldP != "/" and oldP != newP else ""
   txt  = VVJi7Q("Backup/Restore Path"    , VV7hAV   , CFG.backupPath.getValue())
   txt += VVJi7Q("Custom Menu"      , VV4p3V  , CFG.customMenuPath.getValue())
   txt += VVJi7Q("Movie/Series Download"   , VVrgp4 , CFG.MovieDownloadPath.getValue())
   if txt.strip():
    txt = "The following directories were reset to default:\n\n%s\nYou can change paths from Settings.\n" % txt
    FF4lCP(SELF, txt, title="Settings Paths")
def FF0cqc():    return FFoWxR(CFG.backupPath.getValue())
def FFeAlZ():  return FFBmjd("export")
def FF7BT0():   return FFBmjd("iptv")
def FFriZ7():     return FFBmjd("logo")
def FFzQP1(): return FFBmjd("pkg_download")
def FFoUor():  return FFBmjd("pkg_project")
def FFCq6F():   return FFBmjd("screenshot")
def FF7TOv():  return FFBmjd("share")
def FFBmjd(p):
 bPath = FF0cqc()
 p = bPath + FFoWxR("ajpanel_" + p)
 return p if (VVmJwX(p) or FFpwZS("mkdir -p '%s'" % p)) else bPath
def FFf6kX():
 lst = []
 for nm in ("Portal", "Playlist"): lst.extend(FFkzic(FF0cqc(), "%s_Bookmarks*.txt" % nm))
 for oldF in lst:
  if os.path.isfile(oldF):
   newF = FF7BT0() + os.path.basename(oldF)
   if not FFCyVu(newF): FFpwZS("mv '%s' '%s'" % (oldF, newF))
def FFb0NN():
 lst = []
 for nm in ("ref", "data"): lst.extend(FFkzic(FF0cqc(), "ajpanel_share_%s_*.xml" % nm))
 for oldF in lst:
  if os.path.isfile(oldF):
   newF = FF7TOv() + os.path.basename(oldF)
   if not FFCyVu(newF): FFpwZS("mv '%s' '%s'" % (oldF, newF))
def FFHQjU():
 lst = FFkzic(FF0cqc(), "ajpanel_package_*")
 for oldP in lst:
  if os.path.isdir(oldP):
   newP = FFoUor() + os.path.basename(oldP)
   if not VVmJwX(newP):
    FFpwZS("cp -r '%s' '%s' && rm -r '%s'" % (oldP, newP, oldP))
def FFtu2k(path):
 path = FFVc4H(path)
 target = ""
 try:
  if VVmJwX(path) and os.path.islink(path):
   target = os.readlink(path)
 except:
  pass
 return target
def FF6W0I(SELF):
 btnMode = SELF.VVfOli["VV0Ay7"]
 if btnMode in (1, 2): FFkDgm(SELF["keyMenu"], "menu")
 if btnMode in (2, 3): FFkDgm(SELF["keyInfo"], "info")
def FFBFPY(pixmap, path):
 p = FFmNfu(path)
 if p:
  pixmap.instance.setScale(1)
  pixmap.instance.setPixmap(p)
 return p
def FFkDgm(pixmap, fName):
 return FFBFPY(pixmap, "%s%s%s" % (VVIp2p, fName, ".png"))
def FFmNfu(path):
 try:
  p = LoadPixmap(path)
  if p: return p
 except:
  pass
 return None
def FFycBE(satNum):
 satNum  = int(satNum)
 if   satNum == 0xeeee: return "DVB-T"
 elif satNum == 0xffff: return "DVB-C"
 else:
  satName = ""
  try:
   satName = nimmanager.getSatName(satNum)
  except:
   pass
  if not satName or "N/A" in satName:
   satName = FFS0T2(satNum)
  return satName
def FFS0T2(satNum):
 satNum  = int(satNum)
 if   satNum == 0xeeee: return "DVB-T"
 elif satNum == 0xffff: return "DVB-C"
 else:
  satDir = "E"
  if satNum > 1800:
   satDir = "W"
   satNum = 3600 - satNum
  satNum /= 10.0
  return "%s%s" % (str(satNum), satDir)
def FFec0y(VVPxk5, isLong):
 sat = ""
 if VVPxk5.count(":") > 8:
  nameSpace = VVPxk5.split(":")[6]
  s   = nameSpace.zfill(8)[:4]
  val   = int(s, 16)
  if isLong : sat = FFycBE(val)
  else  : sat = FFS0T2(val)
 return sat
def FFR9yH(sat):
 try:
  s = sat.upper()
  if s.endswith("E") or s.endswith("W"):
   num = float(sat[:-1]) * 10
   if s.endswith("W"):
    num = 3600 - num
   return FFycBE(num)
 except:
  pass
 return sat
def FF2qmC(satNumStr):
 satDir = "E"
 satNum = int(satNumStr)
 if satNum < 0:
  satDir = "W"
 satNum /= 10.0
 return "%s%s" % (str(abs(satNum)), satDir)
def FFIBUH(SELF):
 s = CC3rDi(SELF.session)
 return s.VVPxk5, s.VVZcRP, s.VV57TX, s.VVfaDB, s.VV1wIO
def FFMzWf(info, param):
 if info:
  v = info.getInfo(param)
  if   v == -1  : return ""
  elif v in (-2, 1) : return info.getInfoString(param)
  else    : return str(v)
 else:
  return ""
def FFxWB5(info, param):
 if info:
  v = info.getInfo(param)
  if   v == -1: return ""
  elif v == -2: return info.getInfoString(param)
  else  : return str(v)
 else:
  return ""
def FFtCD7(VVPxk5, VVfaDB, VV1wIO):
 if VVfaDB : return VVfaDB.replace(":" + VV1wIO, "")
 else  : return VVPxk5
def FFCjjv(VVPxk5):
 info = FFKDjv(VVPxk5)
 return info and info.getName(eServiceReference(VVPxk5)) or ""
def FFARk6(VVPxk5):
 try:
  ns = VVPxk5.split(":")[6]
  ns = ns.zfill(8)[:4]
 except:
  ns = ""
 return ns.upper()
def FFZK2V(path, fName):
 if os.path.isfile(path + fName):
  return fName
 else:
  if fName.count("_") > 8:
   parts = fName.split("_")
   parts[2] = "1"
   fName = "_".join(parts)
   if os.path.isfile(path + fName):
    return fName
 return ""
def FFKDjv(VVPxk5):
 service = eServiceReference(VVPxk5)
 info = None
 if service:
  VVX5XV = eServiceCenter.getInstance()
  if VVX5XV:
   info = VVX5XV.info(service)
 return info
def FFnfiC(session, VVPxk5, checkParentalControl=False, VV9rup=False):
 if VVPxk5.count(":") > 8:
  serviceRef = eServiceReference(str(VVPxk5))
  servRef = eServiceReference(VVPxk5)
  session.nav.playService(servRef, checkParentalControl=checkParentalControl)
 try:
  VVCy6c = InfoBar.instance
  if VVCy6c:
   VVFp6v = VVCy6c.servicelist
   if VVFp6v:
    servRef = eServiceReference(VVPxk5)
    VVFp6v.saveChannel(servRef)
    if VV9rup: VVFp6v.VVeI3W(servRef)
 except:
  pass
def FFqb3C(session, serviceRef, checkParentalControl=False):
 session.nav.playService(serviceRef, checkParentalControl=checkParentalControl)
def FFUPnc(VVPxk5):
 return iMatch(r"([A-Fa-f0-9]+[:]){10}.+\/\/.+", VVPxk5)
def FFhPtm(ref):
 return bool(iMatch(r"^[A-Fa-f0-9]+:64:", ref or ""))
def FFWpih(ref):
 return "FROM BOUQUET " in ref.upper()
def FFHgaY(ref):
 if "chcm=" in ref.lower(): return False
 else      : return bool(iMatch(r".*https?(:|%3a)\/\/((127|0)\.\d+\.\d+\.\d+|localhost)(:|%3a)\d+\/.*", ref, IGNORECASE))
def FFBYGm(url)  : return CCjZbZ.VVZXSg(url)
def FFKxIH(url)  : return FFBYGm(url) == "VOD"
def FF1BEt(url)  : return FFBYGm(url) == "Series"
def FFUl6q(url): return FFBYGm(url) in ("VOD", "Series")
def FFXarh(url):
 if url and iUnquote : return iUnquote(url)
 else    : return url
def FFSiPR(url):
 if url and iQuote : return iQuote(url)
 else    : return url
def FFbhOc(txt):
 return hashlib.md5(txt.encode("UTF-8")).hexdigest()
def FFiPNn(txt):
 try:
  return str(b64encode(txt.encode("utf-8")).decode("utf-8"))
 except:
  return txt
def FFQqEJ(txt):
 try:
  return str(b64decode(txt).decode("utf-8"))
 except:
  return txt
def FFBAsJ(txt):
 try:
  return FFiPNn(FFQqEJ(txt)) == txt
 except:
  return False
def FFdXBl(session, reopen=False):
 if reopen:
  try:
   session.openWithCallback(BF(FFdXBl, session), CCtKqU)
  except:
   try:
    FFzcnp(session, "Cannot launch Signal Monitor !", title="Signal Monitor")
   except:
    pass
def FF4qbN(VVPxk5):
 tp = CC3Z54()
 if tp.VVoQfv(VVPxk5) : return True
 else        : return False
def FFz2bQ(VVPxk5, isHide, skipReload=False):
 if VVPxk5.count(":") > 8:
  sRef = eServiceReference(VVPxk5)
  if sRef:
   db = eDVBDB.getInstance()
   if db:
    if isHide : ret = db.addFlag(sRef , 0x2)
    else  : ret = db.removeFlag(sRef, 0x2)
    if skipReload:
     return True if ret == 0 else False
    elif ret == 0:
     FFfpyJ(True)
     return True
 return False
def FFfpyJ(save=False):
 db = eDVBDB.getInstance()
 if db:
  if save:
   db.saveServicelist()
  db.reloadServicelist()
  db.reloadBouquets()
 FF9PMc()
def FF9PMc():
 VVCy6c = InfoBar.instance
 if VVCy6c:
  VVFp6v = VVCy6c.servicelist
  if VVFp6v:
   VVFp6v.setMode()
def FFZcDI(root, mode=0):
 lst = []
 try:
  servicelist  = root and eServiceCenter.getInstance().list(root)
  VVX5XV = eServiceCenter.getInstance()
  if servicelist:
   while True:
    service = servicelist.getNext()
    if not service.valid():
     break
    flags = service.flags
    if mode == 0 and service.flags & (eServiceReference.isDirectory | eServiceReference.isMarker):
     continue
    ref, info = service.toString(), VVX5XV.info(service)
    name = info.getName(service)
    if   mode == 0: lst.append((ref, name))
    elif mode == 1: lst.append((ref, name, flags))
 except:
  pass
 return lst
def FF07Sg():
 VVvwHc = {0x01:"TV MPEG-2 SD",0x02:"Radio MPEG-1",0x03:"Teletext",0x04:"NVOD SD",0x05:"NVOD SD T.Shift",0x06:"Mosaic",0x07:"FM Radio",0x08:"DVB SRM",0x09:"Res. 9",0x0A:"Radio Adv. Codec",0x0B:"AVC Mosaic",0x0C:"Data",0x0D:"CI",0x0E:"RCS Map",0x0F:"RCS FLS",0x10:"DVB MHP",0x11:"TV HD MPEG-2",0x16:"TV SD H.264",0x17:"NVOD SD T.Sh.",0x18:"NVOD SD Ref.",0x19:"TV HD H.264",0x1A:"NVOD HD T.Sh.",0x1B:"NVOD HD Ref.",0x1C:"TV HD H.264",0x1D:"NVOD HD T.Sh.",0x1E:"NVOD HD Ref.",0x1F:"TV HEVC",0x20:"TV HEVC (HDR)",0x80:"User Def.",0x64:"Custom",0x81:"Custom",0x82:"Custom",0x84:"Custom",0x95:"Custom",0x98:"Custom",0x9B:"Custom",0xAB:"Custom",0xB4:"Custom",0xB5:"Custom",0xC6:"Custom",0xFA:"Custom",0xFB:"Custom",0xFC:"Custom"}
 VVY1oT = list(VVvwHc)
 return VVY1oT, VVvwHc
def FF2Wqb():
 try:
  iPlugins.clearPluginList()
  iPlugins.readPluginList(resolveFilename(SCOPE_PLUGINS))
 except:
  pass
def FFZVA0(delta=0):
 Time = datetime.now() + timedelta(delta)
 midnight = Time.replace(hour=0, minute=0, second=0, microsecond=0)
 return mktime(midnight.timetuple())
def FFTS4w(unixTime, wDay=False):
 return datetime.fromtimestamp(unixTime).strftime("%Y-%m-%d %H:%M:%S" + (" %a" if wDay else ""))
def FFIPdt():
 year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
 return "%04d-%02d-%02d %02d:%02d:%02d" % (year, month, day, hour, minute, second)
def FFwjLg(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
def FFRvLH(): return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
def FFjTQe():
 return FFIPdt().replace(" ", "_").replace("-", "").replace(":", "")
def FFFHEC(secs):
 m, s = divmod(secs, 60)
 h, m = divmod(m   , 60)
 return "%02d:%02d:%02d" % (h, m, s)
def FFvTve(head, fixName=True):
 try : cont = head.get("content-disposition")
 except: cont = None
 if cont:
  span = iSearch(r'filename=([^;]+)', str(cont), IGNORECASE)
  if span:
   fName = span.group(1).strip('" ')
   if fixName : return FFOu5Y(fName)
   else  : return fName
 return ""
def FFx9uM(url, outFile, timeout=3, VVzHui=False, tmpPath="", VVf6G8=True):
 tmpDir = tmpPath or "/tmp/"
 outFile = tmpDir + outFile
 span = iSearch(r".*data.+base64,(.+)", url, IGNORECASE)
 if span:
  b64 = span.group(1)
  with open(outFile, "wb") as f:
   f.write(b64decode(b64))
  return outFile, ""
 if not CCkEI5.VVNeuG(url, justValidate=True):
  return "", "Invalid URL"
 if not iRequest:
  return "" , "Cannot import URLLIB/URLLIB2 !"
 try:
  req = iRequest(url.strip())
  req.add_header("User-Agent", CCkEI5.VVQNEW())
  res = iUrlopen(req, timeout=timeout)
  resCode = res.code
  if resCode == 200 :
   if VVzHui and "text/html" in res.headers.get("Content-Type"):
    return "", "Received TEXT/HTML (instead of image)"
   with open(outFile, "wb") as f:
    f.write(res.read())
   if VVf6G8:
    fName = FFvTve(res.headers)
    if fName:
     newPath = tmpDir + fName
     if FFpwZS("mv -f '%s' '%s'" % (outFile, newPath)):
      outFile = newPath
   if FFCyVu(outFile) : return outFile, ""
   else     : return "", "Cannot create file."
  else:
   if   resCode == 401 : err = "Unauthorized"
   elif resCode == 402 : err = "Payment Required"
   elif resCode == 408 : err = "Request Timeout"
   else    : err = "err=%d" % resCode
   return "", "Download Failed (%s)" % err
 except iURLError as e:
  return "",  FFWVTk(e)
 except Exception as e:
  return "", str(e)
def FFWVTk(e):
 err = ""
 if hasattr(e, "code") : err = "Error Code : %s\n" % str(e.code)
 if hasattr(e, "reason") : err += "Reason : %s\n" % str(e.reason)
 if not err    : err += "Error : %s"  % str(e)
 return err.strip()
def FFajKn(numStr):
 return iMatch(r"^([-+]?\d+(\.\d*)?$)", numStr) is not None
def FFcacr(num):
 return "s" if num > 1 else ""
def FFsRWN(num, minNum, maxNum):
 return max(min(maxNum, num), minNum)
def FFqmPQ(s):
 return ''.join([chr(int(s[i:i+2], 16)) for i in range(0, len(s), 2)])
def FFWEt2(txt, repl):
 return iSub(r"[^\x00-\x7F]", repl, txt)
def FFfCtV(txt, repl):
 return iSub(r"[^A-Za-z0-9._-]", repl, txt)
def FFOu5Y(txt, repl="_"):
 for ch in " ():/\\,;*/:*?<>|\"'": txt = txt.replace(ch, repl)
 txt = txt.replace("_-_", repl).replace("-_-", repl)
 txt = FFMYNg(txt, repl)
 return txt.strip(".") or "File"
def FFMYNg(txt, repl):
 while repl * 2 in txt: txt = txt.replace(repl * 2, repl)
 return txt.strip(repl) or repl
def FFjFSv(OldValue, OldMin, OldMax, NewMin, NewMax):
 return (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
def FFyH6N(a, b):
 return (a > b) - (a < b)
def FFa9eD(a, b):
 def VVjU8e(var):
  return [ (int(c) if c.isdigit() else c) for c in iSplit(r'(\d+)', var) ]
 a = VVjU8e(a)
 b = VVjU8e(b)
 return (a > b) - (a < b)
def FFgEff(mycmp):
 class CC3MqF(object):
  def __init__(self, obj, *args) : self.obj = obj
  def __lt__(self, other): return mycmp(self.obj, other.obj) < 0
  def __gt__(self, other): return mycmp(self.obj, other.obj) > 0
  def __eq__(self, other): return mycmp(self.obj, other.obj) == 0
  def __le__(self, other): return mycmp(self.obj, other.obj) <= 0
  def __ge__(self, other): return mycmp(self.obj, other.obj) >= 0
  def __ne__(self, other): return mycmp(self.obj, other.obj) != 0
 return CC3MqF
def FFax4p(elem):
 return str(elem.text.encode("UTF-8").decode()).strip() if elem is not None and elem.text else ""
def FFwW5m(elem, attrib):
 return str(elem.attrib.get(attrib, "").encode("UTF-8").decode()).strip() if elem is not None else ""
def FF6Tbq(elem, child):
 return FFax4p(elem.find(child))
def FFaJfl(elem, child, attrib):
 x = elem.find(child)
 if not x is None:
  return str(x.attrib.get(attrib, "").encode("UTF-8").decode()).strip()
 return ""
def FFFE2m(elem, child):
 lst = []
 for el in elem.findall(child):
  lst.append(FFax4p(el))
 return lst
def FFT8ma(elem):
 return str(iElem.tostring(elem, encoding="utf-8").decode()).strip()
def FFYjVd(item, key, isDate=False, is_base64=False, isToHHMMSS=False):
 if key in item:
  val = str(item[key])
  try:
   if   isDate  : val = FFTS4w(int(val))
   elif is_base64 : val = FFQqEJ(val)
   elif isToHHMMSS : val = FFFHEC(float(val))
  except:
   pass
  if val == "None": return ""
  else   : return val.strip()
 else:
  return ""
def FFipXT(SELF, message, title="", VVbYwR=None):
 SELF.session.openWithCallback(VVbYwR, CCn30s, title=title, message=message, VViOjF=True)
def FF4lCP(SELF, message, title="", VV47Xm=VV5jA8, VVbYwR=None, **kwargs):
 return SELF.session.openWithCallback(VVbYwR, CCn30s, title=title, message=message, VV47Xm=VV47Xm, **kwargs)
def FFSqRh(SELF, txt):
 SELF.session.open(CCea0a, txt)
def FF8D5P(session, *args, **kwargs):
 session.open(CC8Nur, *args, **kwargs)
def FFdw58(SELF, message, title="")  : FFzcnp(SELF.session, message, title)
def FF8Wsn(SELF, path, title="") : FFzcnp(SELF.session, "File not found:\n\n%s" % path, title)
def FFNICS(SELF, path, title="") : FFzcnp(SELF.session, "File is empty !\n\n%s"  % path, title)
def FFfone(SELF, title="")  : FFzcnp(SELF.session, "No Packaging Tools:\n\n(OPKG / IPKG / DPKG )", title)
def FFzcnp(session, message, title="") : session.open(CCtjms, title=title, message=message)
def FF28n1(SELF, txt="", timeout=0, isGrn=False):
 if len(txt) > 0:
  try:
   FFZ0AC(SELF["myInfoBody"], "#00004040" if isGrn else "#00550000")
   SELF["myInfoFrame"].show()
   SELF["myInfoBody"].show()
   SELF["myInfoBody"].setText(str(txt))
   if timeout > 0: SELF.VV0bxL.start(timeout, True)
  except: pass
 else: FFxjE5(SELF)
def FF1mVE(SELF, txt="", timeout=1000):
 FF28n1(SELF, txt, timeout=timeout, isGrn=True)
def FFG2sB(SELF, txt="", timeout=1000):
 FFIElK(BF(FF28n1, SELF, txt=txt, timeout=timeout, isGrn=True))
def FFjADj(*kargs, **kwargs):
 FFIElK(BF(FF28n1, *kargs, **kwargs))
def FFxjE5(SELF):
 try:
  SELF.VV0bxL.stop()
  SELF["myInfoFrame"].hide()
  SELF["myInfoBody"].hide()
 except:
  pass
def FFmZaT(SELF):
 try: return SELF["myInfoBody"].visible
 except: return False
def FF4z45(SELF, VVbYwR, title="", defaultText="", message=""):
 mode = CFG.keyboard.getValue()
 allOK = False
 if mode == "v":
  try:
   from Screens.VirtualKeyBoard import VirtualKeyBoard
   obj = SELF.session.openWithCallback(VVbYwR, VirtualKeyBoard, title=message, text=defaultText)
   allOK = True
   obj.setTitle(title)
  except:
   pass
 elif mode == "s":
  try:
   from Screens.InputBox import InputBox
   SELF.session.openWithCallback(VVbYwR, InputBox, windowTitle=title, title=message.replace("\n", " "), text=defaultText)
   allOK = True
  except:
   pass
 if not allOK:
  try:
   FFdw58(SELF, "Cannot run the Input Dialog (keyboard) !", title="Keyboard Error")
  except:
   pass
def FFRMYv(SELF, callBack_Yes, VVsWSA, callBack_No=None, title="", VVAgUy=False, VV4Moq=True, VV1rS5=False):
 session = SELF if VV1rS5 else SELF.session
 return session.openWithCallback(BF(FFqrO8, callBack_Yes, callBack_No)
         , BF(CC032e, title=title, VVsWSA=VVsWSA, VV4Moq=VV4Moq, VVAgUy=VVAgUy))
def FFqrO8(callBack_Yes, callBack_No, FFRMYved):
 if FFRMYved : callBack_Yes()
 elif callBack_No: callBack_No()
def FFUQ0v(SELF, callBackFunc, **kwargs):
 try:
  if callBackFunc : return SELF.session.openWithCallback(callBackFunc, BF(CCnES5, **kwargs))
  else   : return SELF.session.open(CCnES5, **kwargs)
 except:
  return None
def FFLFTC(SELF, callBackFunc, **kwargs):
 return SELF.session.openWithCallback(callBackFunc, BF(CCUwDo, **kwargs))
def FF0TBx(pixmapObj, path, VVemyB=None, fncCb_ok=None, fncCb_fail=None):
 return CCWhOL(pixmapObj, path, VVemyB, fncCb_ok, fncCb_fail).VVcRk2()
def FF0bQE(txt):
 return ("--[ %s ]%s" % (txt,  "-" * 100), )
def FFsLU5(txt, ref, cond, color=""):
 return (color + txt, ref) if cond else (txt,)
def FFWgBS(SELF, isTopBar=False):
 if isTopBar : names = [ "keyRedTop" , "keyGreenTop" , "keyYellowTop", "keyBlueTop"  ]
 else  : names = [ "keyRed" , "keyGreen" , "keyYellow" , "keyBlue"  ]
 for name in names:
  try:
   FFK4PQ(SELF[name], "#000000", 3)
  except:
   pass
def FFK4PQ(label, color, w):
 try:
  inst = label.instance
  inst.setBorderColor(parseColor(color))
  inst.setBorderWidth(w)
 except:
  try:
   inst = label.instance
   inst.setShadowColor(parseColor(color))
   inst.setShadowOffset(ePoint(-2, -2))
  except:
   pass
def FFJmzh(SELF, menuObj):
 try:
  menuObj.instance.setFont(gFont(VVNhAq, SELF.VVfOli["VVgbF2"]))
 except:
  try: menuObj.l.setFont(gFont(VVNhAq, SELF.VVfOli["VVgbF2"]))
  except: pass
def FFzKEr(menuObj, offset):
 if hasattr(menuObj.instance, "setTextOffset"):
  menuObj.instance.setTextOffset(ePoint(offset, 0))
 else:
  try:
   menuObj.l.setLeftOffset(offset)
   menuObj.l.setRightOffset(offset)
  except:
   pass
def FF2GM8(SELF, menuObj=None, VVyRCy=0, offset=20):
 if not menuObj:
  menuObj = SELF["myMenu"]
 FFJmzh(SELF, menuObj)
 FFzKEr(menuObj, offset)
 winInst  = SELF.instance
 menuInst = menuObj.instance
 maxH = SELF.VVfOli["height"]
 winW = winInst.size().width()
 winH = winInst.size().height()
 menuW = menuInst.size().width()
 menuH = menuInst.size().height()
 lineH = menuObj.l.getItemSize().height()
 menuH1 = (max(VVyRCy, len(menuObj.list))) * lineH
 diff = menuH1 - menuH
 winNewH = winH + diff
 btnDiff = diff
 if winNewH > winH:
  if winH + lineH <= maxH:
   btnDiff = lineH
   menuH = menuH + lineH
   menuInst.resize(eSize(*(menuW, menuH)))
   winInst.resize(eSize(*(winW, winH + lineH)))
  else:
   btnDiff = 0
  pos  = menuObj.getPosition()
  part = menuInst.size().height() % lineH
  half = int(part / 2)
  menuInst.resize(eSize(*(menuW, menuH - part)))
  menuInst.move(ePoint(pos[0], pos[1] + half))
 else:
  menuInst.resize(eSize(*(menuW, menuH + diff)))
  winInst.resize(eSize(*(winW, winNewH)))
 winH = winInst.size().height()
 screenSize = getDesktop(0).size()
 winInst.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winH) // 2))
 names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
 for name in names:
  try:
   obj = SELF[name]
   pos = obj.getPosition()
   obj.instance.move(ePoint(pos[0], pos[1] + btnDiff))
  except:
   pass
 winSize = winInst.size()
 w, h = winSize.width(), winSize.height()
 SELF["myWP"].instance.resize(eSize(*(w, h)))
 FF9sDw(SELF, w, h)
def FF9sDw(SELF, w, h):
 fSize = SELF["myInfoFrame"].instance.size()
 bSize = SELF["myInfoBody"].instance.size()
 SELF["myInfoFrame"].instance.move(ePoint((w - fSize.width()) // 2, (h - fSize.height()) // 2))
 SELF["myInfoBody"].instance.move(ePoint((w - bSize.width()) // 2, (h - bSize.height()) // 2))
def FFIGbj(win, mode):
 inst = win.instance
 pos, sz = inst.position(), inst.size()
 x, y = pos.x(), pos.y()
 w, h = sz.width(), sz.height()
 sz = getDesktop(0).size()
 sW, sH = sz.width(), sz.height()
 if   mode == 0: x = (sW - w) // 2
 elif mode == 1: y = (sH - h) // 2
 elif mode == 2: x, y = (sW - w) // 2,  (sH - h) // 2
 inst.move(ePoint(int(x), int(y)))
def FFpMtN(w):
 pos, sz = w.instance.position(), w.instance.size()
 return pos.x(), pos.y(), sz.width(), sz.height()
def FFrPd1():
 s = getDesktop(0).size()
 return (s.width(), s.height())
def FFqCn5(VVwdmN):
 screenSize  = FFrPd1()
 screenH   = screenSize[1]
 ratioH   = screenH / 1080.0
 VVgbF2 = int(ratioH  * VVwdmN)
 return VVgbF2
def FFGrBZ(VVwdmN, extraSpace):
 font = gFont(VVNhAq, VVwdmN)
 VV8c7y = fontRenderClass.getInstance().getLineHeight(font) or (VVwdmN * 1.25)
 return int(VV8c7y + VV8c7y * extraSpace)
def FFiNEe(VVON3k, width, height, VVllEU, VVSZWt, VVpeQE, VVOJKe, VVPTnB, VVgbF2, VVeFSs=0, VVt3Ak=0, VV0Ay7=0, VVptue=0.15, VVdrEC=None, VVOde7=False, VVFz5T=1, VVU4ws=True, VVrz9u=0, VVUuJZ={}):
 screenSize = FFrPd1()
 screenW = int(screenSize[0] * VVFz5T)
 screenH = int(screenSize[1] * VVFz5T)
 if width == 0 : width  = screenW
 if height == 0: height = screenH
 retPar   = None
 ratioW   = screenW / 1920.0
 ratioH   = screenH / 1080.0
 width   = int(ratioW  * width)
 height   = int(ratioH  * height)
 titleH   = int(ratioH  * 50)
 VVSZWt  = int(ratioW  * VVSZWt)
 VVpeQE  = int(ratioH  * VVpeQE)
 VVgbF2 = int(ratioH  * VVgbF2)
 VVeFSs  = int(ratioH  * VVeFSs)
 VVt3Ak  = int(ratioW  * VVt3Ak)
 VVpeQE  = max(1, VVpeQE)
 scrollBarW  = int(ratioW * 15)
 bodyFontStr  = 'font="%s;%d"' % (VVNhAq, VVgbF2)
 alignCenter  = 'halign="center" valign="center"'
 alignLeftTop = 'halign="left" valign="top"'
 alignLeftCenter = 'halign="left" valign="center"'
 alignRightCenter= 'halign="right" valign="center"'
 VVllEU = min(int(ratioH  * VVllEU), int(0.7  * titleH))
 bodyLineH  = FFGrBZ(VVgbF2, VVptue)
 bodyW   = width - VVSZWt * 2
 bodyTop   = titleH + 1 + VVpeQE
 bodyH   = height - bodyTop - VVpeQE
 if VVeFSs > 0: bodyH -= VVeFSs
 zPos = 'zPosition="10000000"' if VVON3k == VVoNDw else ""
 tmp  = '<screen position="center,center" size="%d,%d" backgroundColor="%s" title="%s" flags="wfNoBorder" %s >' % (width, height, VVPTnB, VVh9hj, zPos)
 tmp += '<widget  name="myBody" position="0,0" size="%d,%d" zPosition="-1" backgroundColor="%s" />' % (width, height, VVPTnB)
 if VVU4ws:
  tmp += '<eLabel position="0,%d" size="%d,1" zPosition="1" backgroundColor="#00666666" />' % (titleH + 1, width)
 tmp += '<widget name="myTitle" position="0,0" size="%d,%d" zPosition="2" noWrap="1" backgroundColor="%s" font="%s;%d" foregroundColor="#ffffbb" %s />' % (width, titleH, VVOJKe, VVNhAq, VVllEU, alignLeftCenter)
 tmp += '<widget name="myWP" position="0,0" size="%d,%d" alphatest="blend" />' % (width, height)
 if VVON3k == VVlrZA:
  pass
 elif VVON3k in (VVWp3I, VVibAL):
  if VVON3k == VVibAL : menuName = "config"
  else      : menuName = "myMenu"
  menuW = bodyW - int(bodyW * VVrz9u / 100.0) - VVSZWt if VVrz9u else bodyW
  tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="3" foregroundColor="#eeeeee" backgroundColor="%s" itemHeight="%d" scrollbarMode="showOnDemand" />' % (menuName, VVSZWt, bodyTop, menuW, bodyH, VVPTnB, bodyLineH)
  if VVrz9u:
   param = 'backgroundColor="%s" foregroundColor="#ffffff" %s' % (VVPTnB, bodyFontStr)
   x, w, gap = menuW + VVSZWt * 2, bodyW - menuW - VVSZWt, int(VVSZWt / 2.0)
   tmp += '<widget name="myLabelFrm" position="%d,%d" size="%d,%d" zPosition="3" %s />' % (x - gap, bodyTop, w + gap * 2, bodyH, param)
   tmp += '<widget name="myLabelTit" position="%d,%d" size="%d,%d" zPosition="4" %s %s />' % (x, bodyTop + 10, w, titleH, alignCenter, param)
   tmp += '<widget name="myLabelTxt" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" %s %s />' % (x, bodyTop + titleH + gap , w, bodyH - titleH - gap * 2, alignLeftCenter, param)
 elif VVON3k == VVoNDw:
  tmp += '<widget name="myWinTitle" position="0,0" size="%d,%d" zPosition="3" noWrap="1" transparent="1" foregroundColor="#ffffff" shadowColor="#440000" shadowOffset="-2,-2" %s %s />' % (width, titleH, bodyFontStr, alignCenter)
 elif VVON3k == VVspuu:
  names = ("Red", "Green", "Yellow", "Blue")
  colors = [ "#229f1313", "#22005500", "#22a08000", "#2218188b"]
  totBtns = len(names)
  gap  = 5
  btnW = int(width * 0.09)
  btnH = int(titleH * 0.7)
  left = width - btnW - titleH * 2
  top  = int((titleH - btnH) / 2.0)
  fSize = int(0.45  * titleH)
  for i in range(totBtns-1, -1, -1):
   tmp += '<widget name="key%s" position="%d,%d" size="%d,%d" zPosition="3" font="%s;%d" backgroundColor="%s" %s />' % (names[i], left, top, btnW, btnH, VVNhAq, fSize, colors[i], alignCenter)
   left -= (btnW + gap)
  names = ("Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos")
  totBtns = len(names)
  btnW = int((width - gap * (totBtns + 1)) / totBtns)
  btnH = titleH
  left = gap
  param = 'size="%d,%d" zPosition="3" backgroundColor="#33222222" %s %s ' % (btnW, btnH, bodyFontStr, alignCenter)
  for i in range(totBtns):
   tmp += '<widget name="mySubt%s"  position="%d,%d" foregroundColor="#00cccccc" %s />' % (names[i], left, titleH + gap  , param)
   tmp += '<widget name="mySubt%s1" position="%d,%d" foregroundColor="#00ffff88" %s />' % (names[i], left, titleH + btnH + 1, param)
   left += btnW + gap
  tmp += '<widget name="mySubtCursor" position="0,%d" size="%d,%d" zPosition="2" backgroundColor="#00ffff00" />' % (titleH + 1, btnW + gap * 2, btnH * 2 + gap - 1)
  top = titleH + 1 + btnH * 2 + gap
  tmp += '<widget name="mySubtCover" position="0,0" size="%d,%d" zPosition="5" backgroundColor="#ff000000" />' % (width, top - 1)
  tmp += '<widget name="mySubtFr" position="0,%d" size="%d,%d" zPosition="3" backgroundColor="#ff002233" />' % (top, width, height - top)
  for i in range(4):
   tmp += '<widget name="mySubtSep%d" position="1,%d" size="%d,1" zPosition="7" backgroundColor="#00555555" />' % (i, top + 1, width - 2)
   if i < 3:
    tmp += '<widget name="mySubt%d" position="1,%d" size="%d,%d" zPosition="6" noWrap="1" backgroundColor="#00000000" %s %s />' % (i, top + 1, width - 2, titleH - 2, bodyFontStr, alignCenter)
   top += titleH
  y, w1, = 1, int(width / 3.0)
  x = int((width - w1) / 2.0)
  tmp += '<widget name="mySubtChng0" position="%d,0" size="%d,%d" zPosition="8" backgroundColor="#22555555" />' % (x-1, w1+2, btnH*3 + 5)
  fnt = 'font="%s;%d"' % (VVNhAq, int(btnH * 0.63))
  for i in range(1, 4):
   fg, bg = ("#00FFFF00", "#22220000") if i == 1 else ("#00ffffff", "#33002233")
   tmp += '<widget name="mySubtChng%d" position="%d,%d" size="%d,%d" zPosition="9" foregroundColor="%s" backgroundColor="%s" %s %s />' % (i, x, y, w1, btnH, fg, bg, fnt, alignCenter)
   y += btnH + 1
  w = int(w1 / 6.5)
  h = int(btnH * 0.65)
  gap = int((btnH - h)/ 2)
  x += w1 - w - gap
  y = y - btnH + gap
  tmp += '<widget name="myRest1" position="%d,%d" size="%d,%d" zPosition="90" backgroundColor="#22a08000" font="%s;%d" %s />' % (x, y, w, h, VVNhAq, int(h * 0.7), alignCenter)
 elif VVON3k == VVakGB:
  barH = int((bodyH + VVpeQE - VVpeQE * 3.0) / 3.0)
  picW = int(bodyW * 0.07)
  barW = bodyW - picW - VVSZWt
  b1Top = bodyTop
  b2Top = b1Top + barH + VVpeQE
  b3Top = b2Top + barH + VVpeQE
  timeW = int(barW * 0.1)
  b2Left1 = VVSZWt
  b2Left2 = timeW + VVSZWt * 2
  b2Left4 = barW - timeW + VVSZWt
  b2Left3 = b2Left4 - VVSZWt - timeW
  pLeft = width - picW - VVSZWt
  FFipXTL = b2Left2 + timeW + VVSZWt
  FFipXTW = b2Left3 - VVSZWt - FFipXTL
  name = "myPlay"
  tmp += '<widget name="%sBarF"  position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#0a444444" />' % (name, VVSZWt, b1Top, barW, barH)
  tmp += '<widget name="%sBarBG" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#11000000" />' % (name, VVSZWt + 1, b1Top + 1, barW - 2, barH - 2)
  tmp += '<widget name="%sBar"   position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#06445566" />' % (name, VVSZWt + 1, b1Top + 1, barW - 2, barH - 2)
  tmp += '<widget name="%sMov"   position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#0aff8000" />' % (name, VVSZWt + 1, b1Top - 4, 3, barH + 8)
  tmp += '<widget name="%sVal"   position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#0a005555" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" %s %s />' % (name, VVSZWt + 1, b1Top + 1, barW - 2, barH - 2, bodyFontStr, alignCenter)
  param = 'zPosition="1" noWrap="1" backgroundColor="%s" %s' % (VVPTnB, bodyFontStr)
  tmp += '<widget name="%sPos"  position="%d,%d" size="%d,%d" %s foregroundColor="#00aacccc" %s />' % (name, b2Left1, b2Top, timeW, barH, param, alignLeftCenter)
  tmp += '<widget name="%sSkp"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffff00" %s />' % (name, b2Left2, b2Top, timeW, barH, param, alignCenter)
  tmp += '<widget name="%sMsg"  position="%d,%d" size="%d,%d" %s foregroundColor="#00ffffff" %s />' % (name, FFipXTL , b2Top, FFipXTW , barH, param, alignCenter)
  tmp += '<widget name="%sRem"  position="%d,%d" size="%d,%d" %s foregroundColor="#00CDAE77" %s />' % (name, b2Left3, b2Top, timeW, barH, param, alignCenter)
  tmp += '<widget name="%sDur"  position="%d,%d" size="%d,%d" %s foregroundColor="#00B1C177" %s />' % (name, b2Left4, b2Top, timeW, barH, param, alignRightCenter)
  sepTop = int(b3Top - VVpeQE / 2.0)
  tmp += '<widget name="myPlaySep" position="0,%d" size="%d,1" zPosition="1" backgroundColor="#11444444" />' % (sepTop, pLeft)
  color = ["#0a004400", "#00555555", "#00bbbb55", "#00bbbb55", "#00999999", "#00999999", "#00999999", "#00FFFF88" , "#0a18188b"]
  names = ["Grn"  , "Jmp"   , "Dat"   , "Tim"    , "Res"   , "Fps"   , "Asp"   , "Yel"  , "Blu"]
  Len  = len(names)
  b3W  = int((barW - VVSZWt * (Len - 1)) / Len)
  left = VVSZWt
  for i in range(Len):
   if i in (0, Len-1) : bg = 'foregroundColor="#00FFFFFF" backgroundColor="%s"' % color[i]
   else     : bg = 'foregroundColor="%s"'        % color[i]
   tmp += '<widget name="myPlay%s" position="%d,%d" size="%d,%d" zPosition="1" noWrap="1" %s %s %s />' % (names[i], left, b3Top + 1, b3W, barH, bodyFontStr, alignCenter, bg)
   if names[i] == "Blu":
    txtW = 25
    barH2 = (barH - 8) // 3
    barTop = b3Top + 2
    barTL = left + 15
    barL = barTL + txtW + 5
    bW  = pLeft - barL - VVSZWt
    fSz  = int(barH2 * 0.9)
    namesB = ("SNR", "AGC", "BER")
    for i1 in range(3):
     tmp += '<widget name="mySliderTxt%s" position="%d,%d" size="%d,%d" zPosition="4" noWrap="1" font="%s;%d" foregroundColor="#00aaaaaa" backgroundColor="#1100102a" %s />' % (namesB[i1], barTL, barTop, txtW, barH2, VVNhAq, fSz, alignRightCenter)
     tmp += '<widget name="mySliderFrm%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#333333" />' % (namesB[i1], barL-1, barTop-1, bW+2, barH2+2)
     tmp += '<widget name="mySliderBak%s" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="%s" />' % (namesB[i1], barL, barTop, bW, barH2, VVPTnB)
     tmp += '<widget name="mySliderPic%s" position="%d,%d" size="%d,%d" zPosition="6" alphatest="blend" />' % (namesB[i1], barL, barTop, bW, barH2)
     tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="7" />' % (namesB[i1], barL, barTop, bW, barH2)
     barTop += barH2 + 4
   left += b3W + VVSZWt
  pTop = titleH + 6
  pW  = width - pLeft - 8
  pH  = height - pTop - 4
  tmp += '<eLabel position="%d,%d" size="1,%d" zPosition="1" backgroundColor="#00333333" />' % (pLeft, titleH + 2, height - titleH + 1)
  tmp += '<widget name="myPlayPic" position="%d,%d" size="%d,%d" zPosition="1" alphatest="blend" />' % (pLeft + 4, pTop, pW, pH)
  tmp += '<widget name="myPlayTyp" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#1100202a" %s %s />' % (pLeft + 4, pTop, pW, pH, alignCenter, bodyFontStr)
  sz = int(titleH * 0.6)
  top = int((titleH - sz) / 2.0)
  gap = 6
  lft = width - sz - (titleH * 2 + gap * 2)
  for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="10" alphatest="blend" />' % (nm, lft, top, sz, sz)
   lft -= sz + gap
  params = 'zPosition="10" backgroundColor="#11444411"'
  tmp += '<eLabel %s position="0,0"  size="%d,1" />' % (params, width)
  tmp += '<eLabel %s position="0,%d" size="%d,1" />' % (params, height - 1, width)
  tmp += '<eLabel %s position="0,0"  size="1,%d" />' % (params, height)
  tmp += '<eLabel %s position="%d,0" size="1,%d" />' % (params, width - 1, height -1)
 elif VVON3k == VVnUU2:
  w  = int((width - 10) / 4.0)
  h  = bodyH - 10
  left = 5
  top  = bodyTop + 5
  tmp += '<widget name="myColorF" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00ffffff" />' % (left, top, w, h)
  for i in range(4):
   tmp += '<widget name="myColor%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (i, left + 4, top + 4, w - 8, h - 8, VVPTnB, bodyFontStr, alignLeftCenter)
   left += w
 elif VVON3k == VVUcno:
  itemsH  = bodyLineH * 2.0
  menuH  = int(bodyLineH * 2.5)
  menuW  = int(ratioW  * 200)
  menuLeft = int((width - menuW) / 2.0)
  textH  = bodyH - menuH
  menuTop  = bodyTop + textH
  itemsTop = int(menuTop + VVpeQE / 2.0 + (menuH - itemsH) / 2.0)
  tmp += '<widget name="myLine"  position="0,%d"  size="%d,1"  zPosition="3" backgroundColor="#11444444" />' % (menuTop, width)
  tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" %s %s />' % (VVSZWt, bodyTop, bodyW, textH, VVPTnB, alignCenter, bodyFontStr)
  tmp += '<widget name="myMenu"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" foregroundColor="#ffffff" scrollbarMode="showOnDemand" itemHeight="%d" />' % (menuLeft, itemsTop, menuW, itemsH, VVPTnB, bodyLineH)
 elif VVON3k == VVvJlJ:
  tmp += '<widget name="myTableH" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVSZWt, bodyTop, bodyW, 0, VVPTnB, scrollBarW)
  tmp += '<widget name="myTable"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" scrollbarMode="showOnDemand" scrollbarWidth="%d" />' % (VVSZWt, bodyTop, bodyW, bodyH, VVPTnB, scrollBarW)
 elif VVON3k == VVkFCt:
  perc1, perc2, tbg1, tbg2, bg1, bg2 = VVUuJZ["perc1"], VVUuJZ["perc2"], VVUuJZ["tbg1"], VVUuJZ["tbg2"], VVUuJZ["bg1"], VVUuJZ["bg2"]
  lblH = int(titleH * 0.75)
  lblF = int(lblH * 0.65)
  mnuF = int(lblH * 0.7)
  w1 = int((width - VVSZWt * 4) * perc1 / 100.0)
  w2 = int((width - VVSZWt * 4) * (100 - perc1) / 100.0)
  wt1 = int(w2 * perc2 / 100.0)
  wt2 = w2 - wt1
  bgW = width // 2
  lft2 = VVSZWt + w1 + VVSZWt * 2
  mTop = bodyTop + lblH + 3
  h = bodyH - lblH
  h = height - VVeFSs - mTop - VVpeQE
  lblP = 'noWrap="1" font="%s;%d" %s' % (VVNhAq, lblF, alignCenter)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle1" backgroundColor="%s" %s />' % (VVSZWt, bodyTop, w1, lblH, tbg1, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle2" backgroundColor="%s" %s />' % (lft2, bodyTop , wt1-3, lblH, tbg2, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myTitle3" backgroundColor="%s" %s />' % (lft2 + wt1 + 2, bodyTop, wt2-2, lblH, tbg2, lblP)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm1" backgroundColor="%s" />' % (VVSZWt, mTop, w1, h, bg1)
  tmp += '<widget position="%d,%d" size="%d,%d" name="myFrm2" backgroundColor="%s" />' % (lft2, mTop, w2, h, bg2)
  gap, gap2 = 8, 16
  mnuP = 'transparent="1" scrollbarMode="showOnDemand" scrollbarWidth="%d"' % scrollBarW
  tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="list"   %s />' % (VVSZWt + gap, mTop + gap, w1 - gap2, h - gap2, mnuP)
  tmp += '<widget position="%d,%d" zPosition="2" size="%d,%d" name="myMenu" %s />' % (lft2 + gap, mTop + gap, w2 - gap2, h - gap2, mnuP)
 elif VVON3k == VVHfYH:
  titleFont = int(VVgbF2 * 0.6)
  boxFont  = int(VVgbF2 * 1.2)
  boxH  = int(VVgbF2 * 2.0)
  digitW  = int(VVgbF2 * 1.3)
  names  = ["year", "month", "day", "gap", "hour", "min", "sec"]
  boxW  = [  4   ,    2   ,   2  ,   1  ,   2   ,   2  ,   2  ]
  gap   = 4
  boxLeft  = int((width - digitW * 15) / 2.0 - gap)
  btnTitleH = titleFont * 2
  titleTop = int(bodyTop + (height - VVeFSs - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
  boxTop  = titleTop + btnTitleH + gap
  tmp += '<widget name="curTime" position="0,%d" size="%d,%d" zPosition="2" foregroundColor="white" transparent="1" %s %s />' % (titleH + 1, width, titleTop - titleH - 2, bodyFontStr, alignCenter)
  par = 'zPosition="3" foregroundColor="white" backgroundColor="#11404040" %s' % alignCenter
  for i in range(0, 7):
   tmpW = digitW * boxW[i]
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VVNhAq, titleFont, par)
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VVNhAq, boxFont, par)
   boxLeft += tmpW + boxW[i]
 elif VVON3k == VVDEl1:
  titleFont = int(VVgbF2 * 0.6)
  boxFont  = int(VVgbF2 * 1.2)
  boxH  = int(VVgbF2 * 2.0)
  digitW  = int(VVgbF2 * 1.3)
  names, boxW = ["sign", "hour", "min"], [2, 4, 4]
  gap   = 6
  boxLeft  = int((width - digitW * 10) / 2.0 - gap)
  btnTitleH = titleFont * 2
  titleTop = int(bodyTop + (height - VVeFSs - bodyTop - (btnTitleH + boxH + gap)) / 2.0)
  boxTop  = titleTop + btnTitleH + gap
  par   = 'zPosition="3" foregroundColor="white" backgroundColor="%s" %s' % (VVPTnB, alignCenter)
  for i in range(0, 3):
   tmpW = digitW * boxW[i]
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i]+"Title", boxLeft, titleTop, tmpW - gap, btnTitleH, VVNhAq, titleFont, par)
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" font="%s;%d" %s />' % (names[i], boxLeft, boxTop, tmpW - gap, boxH, VVNhAq, boxFont, par)
   boxLeft += tmpW + boxW[i]
 elif VVON3k == VVnhJ8:
  barW = int(ratioW  * 500)
  infH = int(titleH * 0.8)
  infTop = height - infH
  infFont = int(0.5  * infH)
  bAreaH = int(height - titleH - infH)
  barH = int((bAreaH - VVpeQE * 4) / 3)
  barTop = titleH + VVpeQE
  barL = int(width - barW - titleH / 2)
  txtW = barL - VVSZWt - 4
  name = [ "SNR", "AGC", "BER"]
  tmp += '<widget name="mySNRdB" text="0 dB" position="%d,%d" size="%d,%d" %s %s zPosition="4" transparent="1" foregroundColor="white" />' % (0, 0, width - 20, titleH, bodyFontStr, alignRightCenter)
  for i in range(3):
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="5" text="%s" %s %s backgroundColor="%s" foregroundColor="white" />' % (VVSZWt, barTop, txtW, barH, name[i], bodyFontStr, alignLeftCenter, VVPTnB)
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#ffffff" />' % (barL-1, barTop-1, barW+2, barH+2)
   tmp += '<eLabel position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="%s" />' % (barL, barTop, barW, barH, VVPTnB)
   tmp += '<widget name="mySlider%s" position="%d,%d" size="%d,%d" zPosition="5" alphatest="blend" />' % (name[i], barL, barTop, barW, barH)
   tmp += '<widget name="mySliderCov%s" position="%d,%d" size="%d,%d" zPosition="6" />' % (name[i], barL, barTop, barW, barH)
   tmp += '<widget name="my%s" position="%d,%d" size="%d,%d" %s %s zPosition="7" text="0 " foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" />' % (name[i], barL, barTop, barW, barH, bodyFontStr, alignCenter)
   barTop += barH + VVpeQE
  tmp += '<widget name="myTPInfo" position="0,%d" size="%d,%d" zPosition="8" backgroundColor="%s" font="%s;%d" %s />' % (infTop, width, infH, VVOJKe, VVNhAq, infFont, alignCenter)
  tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="9" backgroundColor="#22aaaaaa" />' % (infTop -1, width)
 elif VVON3k == VVsg3D:
  totBars = VVUuJZ.get("totBars")
  h1  = int(bodyH / 2.0) if totBars == 2 else bodyH
  barL = VVSZWt
  barT = bodyTop
  barW = bodyW
  barH = int((height - bodyTop - VVpeQE * 2 ) / 2.0) if totBars == 2 else int(height - bodyTop - VVpeQE)
  fontH= int(0.7  * barH)
  for i in range(1, 3):
   tmp += '<widget name="myProgFr%s" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#ffffff" />' % (i, barL-1, barT-1, barW+2, barH+2)
   tmp += '<widget name="myProgBG%s" position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="%s" />' % (i, barL, barT, barW, barH, VVPTnB)
   tmp += '<widget name="myProgFG%s" position="%d,%d" size="%d,%d" zPosition="4" backgroundColor="#884422" foregroundColor="#ffffff" />' % (i, barL, barT, barW, barH)
   tmp += '<widget name="myProgVal%s" position="%d,%d" size="%d,%d" zPosition="5" foregroundColor="#ffffff" transparent="1" shadowColor="#00000000" shadowOffset="-1,-1" font="%s;%d" %s />' % (i, barL, barT, barW, barH, VVNhAq, fontH, alignCenter)
   barT += h1 + int(VVpeQE / 2.0)
 elif VVON3k in (VVujxw, VVpLGo):
  totRows , totCols= VVUuJZ.get("rows"), VVUuJZ.get("cols")
  picR , lblR  = VVUuJZ.get("picR"), VVUuJZ.get("lblR")
  w1  , w2  = int(width * VVUuJZ.get("w1R")), int(width * VVUuJZ.get("w2R"))
  transpBG = VVUuJZ.get("trC")
  upSBar  = VVUuJZ.get("upSBar", False)
  bGap  = VVUuJZ.get("bGap", 0)
  infH = int(height * 0.092)
  addH = int(infH * (1000 - height) / 1000.0)
  infH += addH if addH > 0 else 0
  infT = titleH + 1
  boxT = infT + infH + VVpeQE + 2
  boxW = int((width - bGap * (totCols - 1) - (0 if upSBar else VVt3Ak) - VVSZWt * 2)  / totCols)
  boxH = int((height - bGap  * (totRows - 1)  - VVeFSs - boxT - VVpeQE) / totRows)
  s = '<widget name="myPiconInf%d" position="%d,%d" size="%d,%d" zPosition="1" foregroundColor="%s" noWrap="1" backgroundColor="%s" font="%s;%d" %s />'
  h = int(infH * 0.3333)
  y = infT
  fg= "#00ffffff"
  if VVON3k == VVujxw:
   totInf = 6
   fntSz, bg = int(h * 0.7), ("#00002828", "#00003333", "#00004444", "#00002233", "#00003344", "#00004455")
   for i in range(3):
    tmp += s % (i  , 0   , y, w1, h, fg, bg[i]  , VVNhAq, fntSz, alignLeftCenter)
    tmp += s % (i+3, w1+1, y, w2, h, fg, bg[i+3], VVNhAq, fntSz, alignLeftCenter)
    y += h
  else:
   totInf = 4
   h1, h2 = int(infH * 0.58), int(infH * 0.42)
   tmp += s % (0, 0, y  , w1, h1 , "#0088ff88", "#00333333", VVNhAq, int(h1 * 0.7), alignLeftCenter)
   tmp += s % (1, 0, y + h1, w1, h2 , "#00aaaaaa", "#002a2a2a", VVNhAq, int(h2 * 0.7), alignLeftCenter)
   h, fntSz, fg, bg = int(infH * 0.50), int(h2 * 0.60), "#00888888", "#0a111111"
   tmp += s % (2, w1, y , w2, h, fg, bg, VVNhAq, fntSz, alignCenter)
   tmp += s % (3, w1, y + h, w2, h, fg, bg, VVNhAq, fntSz, alignCenter)
  retPar = VVSZWt, boxT, boxW, boxH, infT, infH, totInf, bGap
  tmp += '<eLabel position="0,%d"  size="%d,1"  zPosition="1" backgroundColor="#00555555" />' % (infT + infH, width)
  pT = infT + 3
  pH = infH - 6
  pW = int(pH * 1.66)
  pL = width - pW - 12
  tmp += '<widget name="myPiconF"   position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#0a555500" />' % (pL    , pT    , pW  , pH)
  tmp += '<widget name="myPiconBG"  position="%d,%d" size="%d,%d" zPosition="3" backgroundColor="#0a220000" />' % (pL + 1, pT + 1, pW - 2 , pH - 2)
  tmp += '<widget name="myPiconPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />'    % (pL + 2, pT + 2, pW - 4 , pH - 5)
  tmp += '<widget name="myCursorLbl" position="%d,%d" size="%d,%d" zPosition="5" backgroundColor="#00ffff66" />' % (VVSZWt, boxT + VVpeQE, boxW-2, boxH-2)
  tmp += '<widget name="myCursorPic" position="%d,%d" size="%d,%d" zPosition="5" alphatest="on" scale="1" />' % (VVSZWt, boxT + VVpeQE, boxW-2, boxH-2)
  picBgTr = 'transparent="1"' if VVUuJZ.get("picBgTr", 0) else ""
  lblTr = 'transparent="1"' if VVUuJZ.get("lblTr", 0) else ""
  lblFR = VVUuJZ.get("lblFR", 0.65)
  lblFg = VVUuJZ.get("lblFg", "#00ffffff")
  lblBg = VVUuJZ.get("lblBg", VVPTnB)
  gapX = VVUuJZ.get("gapX", 4)
  gapY = VVUuJZ.get("gapY", 4)
  midGap = VVUuJZ.get("mGap", 0)
  percBar = VVUuJZ.get("percBar", 0)
  areaW = boxW - gapX * 2
  areaH = boxH - gapY * 2 - midGap
  picT = boxT + gapY
  picH = int(areaH * picR)
  lblH = int(areaH * lblR)
  lblT = boxT + gapY + picH + midGap
  lblFS= int(lblH * lblFR)
  transpBG = 'backgroundColor="%s"'% transpBG if transpBG else ""
  boxT1 = boxT
  for row in range(totRows):
   left = VVSZWt + gapX
   for col in range(totCols):
    tmp += '<widget name="myPosterBak%d%d" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" scale="1" />' % (row, col, left-gapX, boxT1, boxW, boxH)
    tmp += '<widget name="myPosterRep%d%d" position="%d,%d" size="%d,%d" zPosition="6" %s %s />' % (row, col, left, picT, areaW, picH, transpBG, picBgTr)
    tmp += '<widget name="myPosterLbl%d%d" position="%d,%d" size="%d,%d" zPosition="7" foregroundColor="%s" backgroundColor="%s" noWrap="1" %s font="%s;%d" %s />' % (row, col, left, lblT, areaW, lblH, lblFg, lblBg, lblTr, VVNhAq, lblFS, alignCenter)
    tmp += '<widget name="myPosterPic%d%d" position="%d,%d" size="%d,%d" zPosition="13" alphatest="blend" />' % (row, col, left, picT, areaW, picH)
    if percBar:
     x, y, w, h =  left, lblT + lblH + 5, areaW, lblH // 3
     tmp += '<widget name="myPercFr%d%d" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#00ffffff" />' % (row, col, x, y, w, h)
     tmp += '<widget name="myPercBG%d%d" position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" />'   % (row, col, x+1, y+1, w-2, h-2, lblBg)
     tmp += '<widget name="myPercFG%d%d" position="%d,%d" size="%d,%d" zPosition="12" backgroundColor="#0055aabb" />' % (row, col, x+1, y+1, w-2, h-2)
    left += boxW + bGap
   boxT1 += boxH + bGap
   picT += boxH + bGap
   lblT += boxH + bGap
 elif VVON3k == VVrQU9:
  totRows = 6
  totCols = 8
  tstW = int(width - VVSZWt  * 2)
  tstH = int(height * 0.15)
  tstT = int(height - VVeFSs - tstH)
  boxT = titleH + 2
  boxW = int(width  / totCols)
  boxH = int((height - VVeFSs - tstH - boxT) / totRows)
  tmp += '<widget name="myColorPtr" position="%d,%d" size="%d,%d" zPosition="1" backgroundColor="#00aaaa00" />' % (0, boxT, boxW, boxH)
  gap  = VVpeQE
  gap1 = int(gap / 2.0)
  for row in range(totRows):
   boxL = 0
   for col in range(totCols):
    tmp += '<widget name="myColor%d%d" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00000000" />' % (row, col, boxL+gap1, boxT+gap1, boxW-gap, boxH-gap)
    boxL += boxW
   boxT += boxH
  tmp += '<widget name="myColorTst" position="%d,%d" size="%d,%d" zPosition="2" backgroundColor="#00aaaaaa" %s %s />' % (VVSZWt, tstT, tstW, tstH, alignCenter, bodyFontStr)
 elif VVON3k == VVsVfC:
  tmp += '<widget name="myPic" position="0,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (bodyTop+1, bodyW, bodyH-1)
 else:
  if   VVON3k == VVf2e8 : align = alignLeftCenter
  elif VVON3k == VVmSQ6 : align = alignLeftTop
  else          : align = alignCenter
  if VVON3k == VV5jiO:
   iconSize = 60
   iconLeft = int(ratioH  * 20)
   iconTop  = int(bodyTop + (height - bodyTop - iconSize) / 2.0)
   iconW  = iconSize + iconLeft * 2
   VVSZWt += iconW
   bodyW  -= iconW
   tmp += '<widget name="errPic" position="%d,%d" size="%d,%d" zPosition="4" alphatest="blend" />' % (iconLeft, iconTop, iconSize, iconSize)
  fontName = VVNhAq
  if VVOde7 and VVON3k == VVmSQ6:
   fLst = FFNOP7()
   if   VVUm9t in fLst and CFG.fontPathTerm.getValue(): fontName = VVUm9t
   elif VV2DFQ in fLst         : fontName = VV2DFQ
  VVpRUN = 'backgroundColor="%s" foregroundColor="#ffffff" font="%s;%d" %s ' % (VVPTnB, fontName, VVgbF2, align)
  tmp += '<widget name="myLabel" position="%d,%d" size="%d,%d" zPosition="4" %s />' % (VVSZWt, bodyTop, bodyW, bodyH, VVpRUN)
 infoW  = int(ratioW  * 500)
 infoH  = int(ratioH  * 100)
 infoLeft = int((width - infoW) / 2.0)
 infoTop  = int((height - infoH) / 2.0)
 VVwdmN = int(ratioH  * 30)
 tmp += '<widget name="myInfoFrame" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#aaaa00" />' % (infoLeft, infoTop, infoW, infoH)
 tmp += '<widget name="myInfoBody"  position="%d,%d" size="%d,%d" zPosition="21" backgroundColor="#550000" foregroundColor="#ffff00" font="%s;%d" %s />' % (infoLeft+2, infoTop+2, infoW-4, infoH-4, VVNhAq, VVwdmN, alignCenter)
 if VV0Ay7 > 0:
  gap = 6
  sz = titleH - gap * 2
  mnuL= width - sz - gap * 2
  infL= mnuL if VV0Ay7 == 3 else mnuL - sz - gap
  par = 'size="%d,%d" zPosition="20" alphatest="blend"' % (sz, sz)
  if VV0Ay7 in (1, 2): tmp += '<widget name="keyMenu" position="%d,%d" %s />' % (mnuL, gap, par)
  if VV0Ay7 in (2, 3): tmp += '<widget name="keyInfo" position="%d,%d" %s />' % (infL, gap, par)
  if VVON3k == VVvJlJ:
   w = int(ratioH  * 200)
   tmp += '<widget name="myTotSel" position="%d,%d" size="%d,%d" zPosition="20" backgroundColor="#550055" font="%s;%d" %s />' % (infL - gap - w, gap, w, sz, VVNhAq, int(sz * 0.6), alignCenter)
 if VVeFSs > 0:
  lineTop = height - VVeFSs
  topGap = max(3, int(ratioH  * 3))
  btnTop = lineTop + topGap
  btnH = height - btnTop - topGap
  barFont = int(0.7  * btnH)
  gap  = btnH
  spaceW = gap * (5)
  btnW = int((width - spaceW) / 4)
  left = gap
  name = [ "keyRed"   , "keyGreen" , "keyYellow", "keyBlue"  ]
  tmp += '<widget name="myBar"  position="0,%d"  size="%d,%d" zPosition="7" backgroundColor="%s" font="%s;%d" %s />' % (lineTop, width, height - lineTop, VVOJKe, VVNhAq, barFont, alignLeftCenter)
  tmp += '<widget name="myLine" position="0,%d"  size="%d,1"  zPosition="8" backgroundColor="#22aaaaaa" />' % (lineTop, width)
  for i in range(4):
   tmp += '<widget name="%s" position="%d,%d" size="%d,%d" zPosition="9" backgroundColor="%s" font="%s;%d" foregroundColor="white" noWrap="1" %s />' % (name[i], left, btnTop, btnW, btnH, VVq9cv[i], VVNhAq, barFont, alignCenter)
   left += btnW + gap
 if VVt3Ak:
  par = 'position="0,0" size="20,20"'
  tmp += '<widget name="mySbFrm" zPosition="13" %s />' % par
  tmp += '<widget name="mySbBak" zPosition="14" %s />' % par
  tmp += '<widget name="mySbSld" zPosition="15" %s />' % par
 if VVON3k == VVmSQ6 or VVUuJZ.get("topBtnEW", 0):
  btnW = int(ratioW  * (85 + VVUuJZ.get("topBtnEW", 0)))
  btnH = int(titleH * 0.6)
  btnTop = int(titleH * 0.2)
  btnLeft = width - (btnW + btnTop) * 4
  btnFont = int(btnH * 0.65)
  name = [ "Red", "Green", "Yellow", "Blue" ]
  for i in range(4):
   tmp += '<widget name="key%sTop1" position="%d,%d" size="%d,%d" zPosition="10" backgroundColor="#0affffff" />' % (name[i], btnLeft, btnTop, btnW, btnH)
   tmp += '<widget name="key%sTop"  position="%d,%d" size="%d,%d" zPosition="11" backgroundColor="%s" font="%s;%d" foregroundColor="white" %s />' % (name[i], btnLeft+1, btnTop+1, btnW-2, btnH-2, VVq9cv[i], VVNhAq, btnFont, alignCenter)
   btnLeft += (btnW + btnTop)
 if VVdrEC:
  w, h = VVdrEC
  w = int(ratioW  * w) if w > 0 else int(width  * 0.2)
  h = int(ratioH  * h) if h > 0 else int(w * 0.75)
  x, y = width - w - VVSZWt - scrollBarW * 2, bodyTop
  tmp += '<widget name="myPicF" position="%d,%d" size="%d,%d" zPosition="7" backgroundColor="#0affffff" />' % (x-1, y-1, w+2, h+2)
  tmp += '<widget name="myPicB" position="%d,%d" size="%d,%d" zPosition="8" backgroundColor="%s" />'   % (x, y, w, h, VVPTnB)
  tmp += '<widget name="myPic"  position="%d,%d" size="%d,%d" zPosition="9" alphatest="blend" />'    % (x, y, w, h)
  retPar = x, y, w, h
 tmp += '</screen>'
 VVfOli = {"VVON3k":VVON3k, "width":width, "height":height, "titleH":titleH, "VVSZWt":VVSZWt, "VVpeQE":VVpeQE, "VVOJKe":VVOJKe, "VVPTnB":VVPTnB, "VVgbF2":VVgbF2, "VVeFSs":VVeFSs, "VV0Ay7":VV0Ay7, "bodyLineH":bodyLineH, "scrollBarW":scrollBarW, "VVptue":VVptue, "retPar":retPar, "VVUuJZ":VVUuJZ}
 return tmp, VVfOli
class CC6cFV(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 800, 1050, 40, 40, 20, "#1a002244", "#10002233", 33, VVeFSs=40, VV0Ay7=2)
  self.session  = session
  self.VVG4nJ = ""
  self.VVYh0m  = r"0{4}t{2}f?$"
  self.themsList  = []
  self.Title   = "%s - %s" % (VVh9hj, VVJ6zn)
  self.timer   = eTimer()
  self.chkVerResult = ""
  self.VVpQCY = True
  VV3wat = []
  if VVS9Q2:
   VV3wat.append(("-- MY TEST --", "myTest" ))
  VV3wat.append(("File Manager"  , "fMan" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("IPTV"    , "iptv" ))
  VV3wat.append(("Movies Browser" , "movie" ))
  VV3wat.append(("Services/Channels", "chan" ))
  VV3wat.append(("Bouquet Editor" , "bouq" ))
  VV3wat.append(("PIcons"   , "picon" ))
  VV3wat.append(("EPG"    , "epg"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Terminal"   , "term" ))
  VV3wat.append(("SoftCam"   , "soft" ))
  VV3wat.append(("Plugins"   , "plug" ))
  VV3wat.append(("Backup & Restore" , "bakup" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Date/Time"  , "date" ))
  VV3wat.append(("Network"   , "net"  ))
  FFZMxC(self, title=self.Title, VV3wat=VV3wat)
  FFRLNq(self["keyRed"] , "Exit")
  FFRLNq(self["keyGreen"] , "Settings")
  FFRLNq(self["keyYellow"], "Dev. Info.")
  FFRLNq(self["keyBlue"] , "Color/Font")
  FFBep1(self,
  {
   "red" : self.close     ,
   "green" : self.VVvcU7    ,
   "yellow": self.VV9fkx    ,
   "blue" : self.VVfK2F   ,
   "info" : self.VV6Vdq    ,
   "menu" : self.VV8DSN  ,
   "text" : BF(self.VVtMoq, "t")  ,
   "f4" : BF(self.VVtMoq, "f")  ,
   "0"  : BF(self.VVTDgd, 0) ,
   "1"  : BF(self.VVeDfm, "fMan") ,
   "2"  : BF(self.VVeDfm, "iptv") ,
   "3"  : BF(self.VVeDfm, "movie") ,
   "4"  : BF(self.VVeDfm, "chan") ,
   "5"  : BF(self.VVeDfm, "bouq") ,
   "6"  : BF(self.VVeDfm, "picon") ,
   "7"  : BF(self.VVeDfm, "epg") ,
   "8"  : BF(self.VVeDfm, "term") ,
   "9"  : BF(self.VVeDfm, "soft") ,
   "last" : BF(self.VVeDfm, "plug") ,
   "next" : BF(self.VVeDfm, "bakup")
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
  global VVWe5f, VVBvqf, VVaWs8
  VVWe5f = VVBvqf = 0
  VVaWs8 = 1
 def VVPr1F(self):
  self.VVeDfm(self["myMenu"].l.getCurrentSelection()[1])
 def VVeDfm(self, item):
  if item is not None:
   for ndx, param in enumerate(self["myMenu"].list):
    if len(param) > 1 and param[1] == item:
     self["myMenu"].moveToIndex(ndx)
     break
   global VV3knk
   VV3knk = self["myMenu"].l.getCurrentSelection()[0].strip()
   if   item == "myTest" : self.VVMtb4()
   elif item == "fMan"  : self.session.open(CClYaF)
   elif item == "iptv"  : self.session.open(CCkEI5)
   elif item == "movie" : CCG2jh.VV7hTj(self)
   elif item == "chan"  : self.session.open(CCYrUm)
   elif item == "bouq"  : self.session.open(CCLSIv)
   elif item == "picon" : self.VVD3q5()
   elif item == "epg"  : self.session.open(CC5TsO)
   elif item == "term"  : self.session.open(CCtzVm)
   elif item == "soft"  : FFimQ3(self, BF(self.session.open, CCid3A))
   elif item == "plug"  : self.session.open(CCeSkW)
   elif item == "bakup" : self.session.open(CCxSED)
   elif item == "date"  : self.session.open(CCbQCK)
   elif item == "net"  : self.session.open(CCJIaP)
 def VV7OzD(self):
  FF2GM8(self)
  if self.VVpQCY:
   self.VVpQCY = False
   FF4IPF(self["myMenu"])
   FFWgBS(self)
   FF6W0I(self)
   self.VVxS6b()
 def VVxS6b(self):
  if not hasattr(self["myMenu"].instance, "setTextOffset"):
   for ndx, item in enumerate(self["myMenu"].list):
    if len(item) == 2:
     self["myMenu"].list[ndx] = ("   %s" % item[0], item[1])
  FFzcnD(self)
  self.VVsLLY()
  if (VV5xkJ or VVNA43 or VVS9Q2):
   FFZ0AC(self["myTitle"], "#ff0000")
  var = "PLUGIN" + "_VERSION"
  if var in globals():
   FF28n1(self, "Welcome", 300)
  if CFG.checkForUpdateAtStartup.getValue():
   self["myTitle"].instance.setFont(gFont(VVNhAq, 30))
   self["myTitle"].setText("  %s      %s" % (VVh9hj, FFjt5L("Checking for updates ...", VVA4XU)))
   try: self.timer_conn = self.timer.timeout.connect(self.VV1bB4)
   except: self.timer.callback.append(self.VV1bB4)
   self.timer.start(500, False)
   myThread = iThread(name="ajp_chk_ver", target=self.VVjUSC)
   myThread.start()
 def VV1bB4(self):
  if self.chkVerResult:
   self.timer.stop()
   if self.chkVerResult == "no":
    fnt = gFont(VVNhAq, 33)
    txt = self.Title
   else:
    fnt = gFont(VVNhAq, 30)
    txt = "%s    (v%s available)" % (self.Title, self.chkVerResult)
   self["myTitle"].instance.setFont(fnt)
   self["myTitle"].setText("  %s" % txt)
 def VVjUSC(self):
  url = CCJaSw.VVYs9i()
  curVer = VVJ6zn
  path, err = FFx9uM(url + "version", "ajp_tmp.ver", timeout=2)
  if err or not FFCyVu(path):
   self.chkVerResult = "no"
  else:
   cVer, wVer, isHigher = CCeSkW.VV2PRQ(curVer, FFYVq0(path))
   FFwgGB(path)
   self.chkVerResult = wVer if isHigher else "no"
 def onExit(self):
  self.timer.stop()
  FFIFeD()
  global VVWe5f, VVBvqf
  VVWe5f = VVBvqf = 0
  FFYDZ6("VVaWs8")
 def VVTDgd(self, digit):
  self.VVG4nJ += str(digit)
  ln = len(self.VVG4nJ)
  global VVWe5f
  if ln == 4:
   if self.VVG4nJ == "0" * ln:
    VVWe5f = 1
    FFZ0AC(self["myTitle"], "#11805040")
   else:
    self.VVG4nJ = "x"
 def VVtMoq(self, s):
  self.VVG4nJ += s
  if iMatch(self.VVYh0m, self.VVG4nJ):
   global VVBvqf
   VVBvqf, c = (2, "#ff8000") if self.VVG4nJ.endswith("f") else (1, "#dd5588")
   FFZ0AC(self["myTitle"], c)
 def VVD3q5(self):
  found = False
  pPath = CCafIt.VVjkKT()
  if VVmJwX(pPath):
   for fName, fType in CCafIt.VVq4T1(pPath):
    if fName:
     found = True
     break
  if found:
   self.session.open(CCafIt)
  else:
   VV3wat = []
   VV3wat.append(("PIcons Tools" , "CCafIt" ))
   VV3wat.append(VVAL3j)
   VV3wat.append(CCafIt.VVdmZZ())
   VV3wat.append(VVAL3j)
   VV3wat += CCafIt.VVC3jQ()
   FFLFTC(self, self.VVWtJl, VV3wat=VV3wat)
 def VVWtJl(self, item=None):
  if item:
   if   item == "CCafIt"   : self.session.open(CCafIt)
   elif item == "VVZxA1"  : CCafIt.VVZxA1(self)
   elif item == "VVS8ig"  : CCafIt.VVS8ig(self)
   elif item == "findPiconBrokenSymLinks" : CCafIt.VVqb9O(self, True)
   elif item == "FindAllBrokenSymLinks" : CCafIt.VVqb9O(self, False)
 @FFOAKH()
 def VV6Vdq(self):
  fil = VVIp2p + "_changeLog.txt"
  title = "%s %s  -  %s  (by AMAJamry)" % (VVh9hj, VVJ6zn, VVzOp7)
  if FFCyVu(fil):
   txt = "\n%s%s\n" % (FFjt5L("Home Page : ", VVFuwR), FFjt5L(CCJaSw.VVCcoN(), VVJEMb))
   lines  = FFL19l(fil)
   for line in lines:
    line = line.strip()
    if line and not line.startswith("#"):
     if line.startswith("[") and line.endswith("]"):
      line = line.replace("[", "").replace("]", "")
      line = FFjt5L("\n%s\n%s\n%s" % (SEP, line, SEP), VV1fx4, VVwdUw)
     elif line.strip().startswith("-"): line = "\n" + line
     elif line.strip().startswith(".."): line = FFjt5L(line, VVo7S9, VVwdUw)
     txt += line +"\n"
   FF4lCP(self, txt.strip(), title=title, VVwdmN=28, width=1600, height=1000, titleBg="#11000020", VVemyB="#0a00000a")
  else:
   FFdw58(self, "Change Log file not found:\n\n%s" % fil, title=title)
 def VV8DSN(self):
  VV3wat = []
  VV3wat.append(("Open Custom Menu ", "cMenu"))
  VV3wat.append(("Custom Menu Help" , "cmHlp"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Movies Resume History", "resum"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("%s Optional Dependencies" % VVh9hj, "libr"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("General Guide", "ghHlp" ))
  VV3wat.append(("Keys Help" , "hlp"  ))
  FFLFTC(self, self.VVRTdI, VV3wat=VV3wat, width=650, title="Options")
 def VVRTdI(self, item=None):
  if item:
   if   item == "cMenu": CCRlkm.VVEYRT(self)
   elif item == "cmHlp": FFw2rR(self, "_help_cmenu", "Custom Menu Help")
   elif item == "resum": self.session.open(CC6F0F)
   elif item == "libr" : self.VVwxzq()
   elif item == "ghHlp": self.VVLqG9()
   elif item == "hlp" : FFw2rR(self, "_help_main", "Main Page (Keys Help)")
 def VVLqG9(self):
  lst = [tuple(line.split("@")) for line in FFL19l(VVIp2p + "_hlpG") if "@" in line]
  if lst: FFLFTC(self, None, title="General Guide", VV3wat=sorted(lst), width=1200, height=1000, VVwltY="#11101100", VVkxBG="#11112222", VVOa1G=self.VV3DNo, VVU8mZ=True)
 def VV3DNo(self, item=None):
  if item:
   VV7tND, title, pic, ndx = item
   self.VVnppw(VV7tND, title, pic)
 @FFOAKH("Loading ...", par=1)
 def VVnppw(self, VV7tND, title, pic):
  url = CCJaSw.VVYs9i()
  path, err = FFx9uM(url + "help/%s" % pic, "ajp_tmp%s" % os.path.splitext(pic)[1], timeout=2)
  if err or not FFCyVu(path) : FFdw58(self, "Cannot get help file from server !", title=title)
  else       : CCf8zb.VVjnMn(self, path, title=title)
  FFwgGB(path)
 def VVvcU7(self) : self.session.open(CCJaSw)
 def VV9fkx(self) : self.session.open(CC674y)
 def VVfK2F(self):
  title = "Colors and Fonts"
  c1, c2, c3, c4, c5 = VVZtfx, VVyFI2, VVFuwR, VVJEMb, VVIH76
  added = CFG.fontPathAdd.getValue()
  VV3wat = []
  VV3wat.append((c1 + "Change Title Colors"   , "title"  ))
  VV3wat.append((c1 + "Change Menu Area Colors"  , "body"  ))
  VV3wat.append((c1 + "Change Menu Pointer Colors" , "cursor"  ))
  VV3wat.append((c1 + "Change Bottom Bar Colors" , "bar"   ))
  VV3wat.append((c2 + "Reset Colors"    , "resetColor" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Change %s Font" % VVh9hj, "mainFont" ))
  VV3wat.append((c3 + "Change Terminal Font"   , "termFont" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Add Extra Font to System" , "addFont", not added , c4))
  VV3wat.append(FFsLU5("Replace Extra Font"  , "rplFont", added  , c4))
  VV3wat.append(FFsLU5("Remove Extra Font"  , "delFont", added  , c4))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Change System Fonts Size" , "fntScl", not CFG.fontPathSys.getValue(), c5))
  VV3wat.append((c5 + "Change System Font"     , "sysFont" ))
  FFLFTC(self, BF(self.VVDebU, title), VV3wat=VV3wat, width=600, height=1000, title=title, VVwltY="#11001122", VVkxBG="#11001122")
 def VVDebU(self, title, item=None):
  if item:
   if item in ("title", "body", "cursor", "bar"):
    tDict = self.VVCMBG()
    fg = tDict.get("main_%s_fg" % item, "")
    bg = tDict.get("main_%s_bg" % item, "")
    self.session.openWithCallback(BF(self.VVh2PD, tDict, item), CC1FS2, defFG=fg, defBG=bg)
   elif item == "resetColor" : FFRMYv(self, self.VV7Rj8, "Reset to default colors ?", title=title)
   elif item == "mainFont"  : self.VVWtNV(VVNj6e)
   elif item == "termFont"  : self.VVWtNV(VVUm9t)
   elif item == "addFont"  : self.VVWtNV(VVLn2O)
   elif item == "rplFont"  : self.VVWtNV(VVLn2O)
   elif item == "delFont"  : FFRMYv(self, self.VVfQgy, "Remove Extra Font and Restart GUI ?", title="Remove Extra Font")
   elif item == "fntScl"  : self.VVgHDD()
   elif item == "sysFont"  : self.VVWtNV(VVnvzh, chFontSz=True)
 def VVfQgy(self):
  FFjt1c(CFG.fontPathAdd, "")
  CCp90q.VV6bHp(self)
 @FFOAKH()
 def VVwxzq(self):
  title = "%s Optional Dependencies (for more features)" % VVh9hj
  VVAkuK = self.VVcB2d()
  VVwSzI = ("Install"    , BF(self.VVnYkC, title), [])
  VV4QTJ  = ("Update Sys. Packages", self.VVhnZU , [])
  header  = ("Library", "State", "Usage" )
  widths  = (20   , 25  , 55  )
  VVLIqP = (LEFT  , CENTER , LEFT  )
  VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, width=1350, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVKDPJ=2)
 def VVnYkC(self, Title, VV6A99, title, txt, colList):
  pkg, state, usage = colList
  cbFnc = BF(self.VV47ii, VV6A99)
  if pkg == "xz" and "BusyBox" in state:
   FFbi5l(self, FF5sZa(VVwFAi, pkg), VVoasw=cbFnc, title=Title)
  elif "Installed" in state:
   FF1mVE(VV6A99, "Already installed.")
  else:
   pkgDict = self.VVX3o7()
   if   pkg == "requests" : CCwhE4.VVOJRa(self, cbFnc=cbFnc)
   elif pkg == "Imaging" : CC6u6z.VV181X(self, Title, False, cbFnc=cbFnc)
   elif pkg == "ar"  : FFbi5l(self, FFvQ9y(), VVoasw=cbFnc, title=Title)
   elif pkg in pkgDict  : FFbi5l(self, FFMAzK(pkgDict[pkg], pkg, pkg.capitalize()), VVoasw=cbFnc, title=Title)
 def VVhnZU(self, VV6A99, title, txt, colList):
  CCeSkW.VV3sSc(self)
 def VV47ii(self, VV6A99):
  VVAkuK = self.VVcB2d()
  VV6A99.VViSLW(VVAkuK[VV6A99.VVGTqU()])
 def VVcB2d(self):
  tDict = {}
  path = VVIp2p + "_sup_lib"
  if FFCyVu(path):
   for line in FFL19l(path):
    lib, _, txt = line.partition("=")
    tDict[lib] = txt
  def VVJi7Q(lib, ok):
   txt = tDict.get(lib, "")
   if ok: return (lib, "#f#0000ff00#" + "Installed" , txt)
   else : return (lib, "#f#00ff8000#" + "Not installed", txt)
  VVAkuK = []
  VVAkuK.append(VVJi7Q("requests", CCwhE4.VVOJRa(self, install=False)))
  VVAkuK.append(VVJi7Q("Imaging" , CC6u6z.VV181X(self, "", False, install=False)))
  VVAkuK.append(VVJi7Q("ar"   , CCeSkW.VVgrug()))
  for pkg, cmd in self.VVX3o7().items():
   row = VVJi7Q(pkg, FFayeZ(cmd))
   if pkg == "xz":
    pFound, pBBox = FFmCnY(pkg)
    if pFound and pBBox:
     c1 = VVYjI5
     stt = FFjt5L("BusyBox xz (old)", c1)
     usg = "%s  ...  %s" % (row[2], FFjt5L("xz v5 recommended", c1))
     row = (pkg, stt, usg)
   VVAkuK.append(row)
  VVAkuK.sort(key=lambda x: x[0].lower())
  return VVAkuK
 def VVX3o7(self):
  d = {}
  for pkg in ("xz", "zip", "p7zip", "unrar", "bzip2", "ffmpeg"):
   d[pkg] = pkg
  d["p7zip"] = "7za"
  return d
 def VVOaDJ(self):
  return FF0cqc() + "ajpanel_colors"
 def VVCMBG(self):
  tDict = { "main_title_fg" : ""
    , "main_title_bg" : ""
    , "main_body_fg" : ""
    , "main_body_bg" : ""
    , "main_cursor_fg" : ""
    , "main_cursor_bg" : ""
    , "main_bar_fg"  : ""
    , "main_bar_bg"  : ""
    }
  p = self.VVOaDJ()
  if FFCyVu(p):
   txt = FFYVq0(p)
   lst = iFindall(r"(.*[^\s])\s*=\s*(#(?:[A-Fa-f0-9]{8}))", txt, IGNORECASE)
   for txt, c in lst:
    tDict[txt] = c
  return tDict
 def VVh2PD(self, tDict, item, fg, bg):
  if fg:
   self.VV1Psn(item, fg)
   self.VVb1TK(item, bg)
   tDict["main_%s_fg" % item] = fg
   tDict["main_%s_bg" % item] = bg
   self.VVZ5At(tDict)
 def VVZ5At(self, tDict):
   p = self.VVOaDJ()
   with open(p, "w") as f:
    for key, val in tDict.items():
     f.write("%s=%s\n" % (key, val))
 def VV1Psn(self, item, fg):
  if   item == "title" : FFGUI5(self["myTitle"], fg)
  elif item == "body"  :
   FFGUI5(self["myMenu"], fg)
   FFGUI5(self["myBody"], fg)
  elif item == "cursor" : self["myMenu"].instance.setForegroundColorSelected(parseColor(fg))
  elif item == "bar"  :
   for item in ("myBar", "keyRed", "keyGreen", "keyYellow", "keyBlue"): FFGUI5(self[item], fg)
 def VVb1TK(self, item, bg):
  if   item == "title" : FFZ0AC(self["myTitle"], bg)
  elif item == "body"  :
   FFZ0AC(self["myMenu"], bg)
   FFZ0AC(self["myBody"], bg)
  elif item == "cursor" : self["myMenu"].instance.setBackgroundColorSelected(parseColor(bg))
  elif item == "bar"  : FFZ0AC(self["myBar"], bg)
 def VV7Rj8(self):
  FFpwZS("rm '%s'" % self.VVOaDJ())
  self.close()
 def VVsLLY(self):
  tDict = self.VVCMBG()
  for item in ("title", "body", "cursor", "bar"):
   self.VV3kNF(tDict, item)
 def VV3kNF(self, tDict, name):
  fg = tDict.get("main_%s_fg" % name, "")
  bg = tDict.get("main_%s_bg" % name, "")
  if fg: self.VV1Psn(name, fg)
  if bg: self.VVb1TK(name, bg)
 def VVgHDD(self):
  cur = CFG.fontAllPerc.getValue()
  tab = lambda sign, rng:  [("%s%s%s  %s %%" % (" " * 15, VVSGsk if i == cur else "", sign, abs(i)), i) for i in rng]
  lst = tab("+", [x for x in range(5, 45, 5)])
  lst.append(VVAL3j)
  lst.extend(tab("-", [x for x in range(-5,-45, -5)]))
  if cur != 0:
   lst.insert(0, VVAL3j)
   lst.insert(0, ("Reset Size %s" % FFjt5L(" (Requires GUI Restart)", VVIH76), 0))
  FFLFTC(self, self.VVs6ym, VV3wat=lst, title="Change Size", width=700, height=1050, VVwdmN=28, VVwltY="#22221122", VVkxBG="#22220022")
 @FFOAKH()
 def VVs6ym(self, addPerc):
  if addPerc is None or addPerc == CFG.fontAllPerc.getValue(): return
  if addPerc == 0:
   FFRMYv(self, self.VVdRGg, "Restore and Restart ?", title="Restore Original Font Size")
  else:
   FFjt1c(CFG.fontAllPerc, addPerc)
   if CC6cFV.VVVGio():
    self.hide()
    self.show()
   else:
    FFjADj(self, "Cannot change fonts", 1500)
 def VVdRGg(self):
  FFjt1c(CFG.fontAllPerc, 0)
  CCp90q.VV6bHp(self)
 @FFOAKH()
 def VVWtNV(self, which, chFontSz=False):
  if   which == VVNj6e  : rest, defFnt, title = False, CFG.fontPathMain.getValue(), VVh9hj
  elif which == VVUm9t : rest, defFnt, title = False, CFG.fontPathTerm.getValue(), "Terminal "
  elif which == VVLn2O  : rest, defFnt, title = True , CFG.fontPathAdd.getValue() , "System Extra"
  elif which == VVnvzh  : rest, defFnt, title = True , CFG.fontPathSys.getValue() , "System"
  CCEBvG.VVpZFB(self, "Change %s Font" % title, defFnt, rest, BF(self.VVorz3, which), chFontSz)
 def VVorz3(self, which, fntPar=None):
  if fntPar: path, scale = fntPar
  else  : return
  if path == "DEFAULT": path = ""
  if   which == VVNj6e  : FFjt1c(CFG.fontPathMain, path)
  elif which == VVUm9t: FFjt1c(CFG.fontPathTerm, path)
  elif which == VVLn2O  : FFjt1c(CFG.fontPathAdd , path)
  elif which == VVnvzh:
   FFjt1c(CFG.fontPathSys , path)
   FFjt1c(CFG.fontScaleSys, scale if path else 100)
  err = CC6cFV.VVSfcK(which)
  if err          : FFdw58(self, err, title=title)
  elif which == VVNj6e   : self.close()
  elif which == VVUm9t  : FF1mVE(self, "Terminal font applied", 1500)
  elif which == VVLn2O and path : FF1mVE(self, "Font Added", 1500)
  elif which == VVnvzh and path: FF1mVE(self, "System font applied", 1500)
  elif which == VVnvzh   : FFRMYv(self, BF(CCp90q.VV6bHp, self), "Font changed (will take effect after GUI Restart).\n\nRestart GUI ?", title="Reset font to default")
 @staticmethod
 def VVAeob():
  if CFG.fontPathSys.getValue():
   CC6cFV.VVSfcK(VVNj6e  )
   CC6cFV.VVSfcK(VVUm9t)
   CC6cFV.VVSfcK(VVLn2O  )
   CC6cFV.VVSfcK(VVnvzh  )
  elif CFG.fontAllPerc.getValue() != 0:
   CC6cFV.VVVGio()
 @staticmethod
 def VVVGio():
  perc, tot = CFG.fontAllPerc.getValue(), 0
  for name, scale, repl, fName, fPath, skinF in FFcFmA():
   newScale = int(int(scale) + float(scale) * int(perc) / 100.0)
   if FFXcbU(fPath, name, scale=newScale, isRepl=1 if repl else 0):
    tot += 1
  return tot
 @staticmethod
 def VVSfcK(name):
  if   name == VVNj6e : path, repl = CFG.fontPathMain.getValue(), 0
  elif name == VVUm9t: path, repl = CFG.fontPathTerm.getValue(), 0
  elif name == VVLn2O  : path, repl = CFG.fontPathAdd.getValue() , 1
  elif name == VVnvzh : path, repl = CFG.fontPathSys.getValue() , 1
  if not path:
   FFNOP7()
   return ""
  elif not FFCyVu(path):
   return "Font file not found"
  scale = 100
  nameLst = []
  if name == VVnvzh:
   scale = CFG.fontScaleSys.getValue()
   nameLst = []
   for nm in FFNOP7():
    if not nm in (VVNj6e, VVUm9t):
     nameLst.append(nm)
  else:
   nameLst = [name]
  totDone = 0
  for fntName in nameLst:
   if FFXcbU(path, fntName, scale=scale, isRepl=repl):
    totDone += 1
  if totDone > 0: FFNOP7()
  else    : return "Could not add font"
 def VVMtb4(self):
  CCqWM2.VVHc02(self.session)
class CChtNF(Screen):
 def __init__(self, session, mode=0, dstP="", evName=""):
  self.skin, self.VVfOli = FFiNEe(VVlrZA, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVU4ws=False)
  self.session = session
  self.mode  = mode
  self.dstP  = dstP
  self.evName  = evName or CC5TsO.VVMZqx(self)
  self.pDir  = "/tmp/ajp_p/"
  self.cleanName = CCa36K.VVD1PA()
  self.tbl  = None
  FFZMxC(self)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVobpU()
 def cancel(self, VV6A99=None, ret=None):
  if self.tbl: self.tbl.cancel()
  self.VV1omp()
  self.close(ret)
 def VVQ5VQ(self, err, end=False):
  FFdw58(self, err, self.evName or "Get Poster")
  if end: self.cancel()
 def VV1omp(self):
  FFpwZS("rm -rf '%s'" % self.pDir)
 @FFOAKH()
 def VVobpU(self):
  self.evName = self.cleanName(self.evName)
  if not self.evName:
   self.VVQ5VQ("Invalid Event Name", True)
   return
  self.VV1omp()
  if not FFpwZS("mkdir -p '%s'" % self.pDir):
   self.VVQ5VQ("Cannot create working directory", True)
   return
  if self.mode == 0:
   self.mode = 1
   lst, err = self.VVwuhm()
   if not lst:
    self.mode = 2
    lst, err = self.VVCYeR()
    if err:
     self.VVQ5VQ(err, True)
     return
  else:
   if self.mode == 1: lst, err = self.VVwuhm()
   else    : lst, err = self.VVCYeR()
   if err:
    self.VVQ5VQ(err, True)
    return
  if not lst:
   self.VVQ5VQ("Not found", True)
   return
  if self.mode == 1:
   for ndx, (titl, rel, ov, smlU, page, ratio) in enumerate(lst):
    ratio1 = CCafIt.VV8e0X(self.evName, self.cleanName(titl))
    lst[ndx] = (titl, rel, ov, smlU, page, ratio1)
   lst = sorted(lst, key=lambda x: (x[5], x[1].lower(), x[0].lower()), reverse=True)
  else:
   for ndx, (titl, cap, rel, topCr, picU, smlU, ratio) in enumerate(lst):
    ratio1 = CCafIt.VV8e0X(self.evName, self.cleanName(titl))
    lst[ndx] = (titl, cap, rel, topCr, picU, smlU, ratio1)
   lst = sorted(lst, key=lambda x: (x[6], x[2].lower(), x[0].lower()), reverse=True)
  picDic = self.VVJFKy(lst)
  VVAkuK = []
  if self.mode == 1:
   bg = VVkxBG="#22002233"
   for ndx, (titl, rel, ov, smlU, page, ratio) in enumerate(lst):
    VVAkuK.append((str(ndx + 1), "", titl, rel, ov, picDic.get(ndx, ""), page, str(ratio)))
  else:
   bg = VVkxBG="#22110011"
   for ndx, (titl, cap, rel, topCr, picU, smlU, ratio) in enumerate(lst):
    if cap and (cap == titl or cap == topCr or cap == "%s (%s)" % (titl, rel)): cap = ""
    if cap and topCr: ov = "%s ... %s" % (cap, topCr)
    else   : ov = cap or topCr
    VVAkuK.append((str(ndx + 1), "", titl, rel, ov, picDic.get(ndx, ""), picU, str(ratio)))
  VVu8qI = self.cancel
  VVu1YM  = ("View Poster"    , self.VVeCNN , [])
  VV2ytr = (""       , self.VVDj4v  , [])
  if self.dstP: VVScQz = ("Select"  , self.VVpBL3  , [])
  else  : VVScQz = ("Save Poster" , self.VVUCUp , [])
  VV4QTJ = ("More Posters"    , self.VVownO , []) if self.mode == 1 else None
  VVoGCy  = (1, None, 5)
  header  = ("Num" , "" , "Title" , "Release" , "Overview", "smlP", "picU", "ratio" )
  widths  = (6  , 3  , 42  , 10  , 39  , 0  , 0  , 0   )
  VVLIqP = (CENTER , LEFT , LEFT  , CENTER , LEFT  , LEFT , LEFT , LEFT  )
  self.tbl = FFUQ0v(self, None, title=self.evName, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, width=1800, height=950, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVu8qI=VVu8qI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVdrEC=(0, 240), VVoGCy=VVoGCy
    , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVoRat="#11ffff00", VVJKqd="#11220000", VVbcr0=bg, VVX9AA="#11400040")
  self.tbl.VVIOX6(self.VVwjNh)
 def VVownO(self, VV6A99, title, txt, colList):
  VV6A99.cancel()
  self.mode, self.tbl = 2, None
  self.VVobpU()
 def VVwjNh(self):
  if not self.tbl.VVacFr(self.tbl.VV5crm()[5]):
   self.tbl.VVTOb9()
 def VVeCNN(self, VV6A99, title, txt, colList):
  self.VVy7WX(0, colList[6])
 def VVDj4v(self, VV6A99, title, txt, colList):
  num, pstr, titl, rel, ov, smlP, picU, ratio = colList
  txt  = "Title\t: %s\n" % titl
  if rel: txt += "Release\t: %s\n" % rel
  if ov : txt += "\n%s\n%s" % (FFjt5L("Overview", VVFuwR), ov)
  FF4lCP(self, txt, title)
 def VVpBL3(self, VV6A99, title, txt, colList):
  self.VVy7WX(3, colList[6])
 def VVUCUp(self, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("Set as a Poster for a Local Media", "1"))
  VV3wat.append(("Save to backup directory"   , "2"))
  FFLFTC(self, BF(self.VVjQ8l, colList[6]), title="Save Poster", VV3wat=VV3wat)
 def VVjQ8l(self, picU, item=None):
  if  item == "1": self.VVy7WX(1, picU)
  elif item == "2": self.VVy7WX(2, picU)
 def VVwuhm(self):
  res, err = CCHRcZ.VVcUJs(("s%=yreuq?hcraes/gro.bdeivomeht.www//:sptth")[::-1] % FFSiPR(self.evName), timeout=5)
  if err: return [], "Netowrk Error"
  lst = []
  d1 = iCompile(r'"lazy".+src="(.+\.jpg)".+srcset="(.+)"\salt="(.+)"')
  d2 = iCompile(r'href="(.+)"')
  d3 = iCompile(r'<span class="release_date">.+(\d{4})<')
  d4 = iCompile(r'<p>(.+)<\/p>')
  src1 = src2 = titl = page = rel = ov = ""
  for line in res.text.split("\n"):
   if "lazy" in line: src1 = src2 = titl = page = rel = ov = ""
   elif "search_results person hide" in line:  break
   span = d1.search(line)
   if span: src1, src2, titl = span.groups()
   span = d2.search(line)
   if span: page = "gro.bdeivomeht.www//:sptth"[::-1] + span.group(1)
   span = d3.search(line)
   if span: rel = span.group(1)
   span = d4.search(line)
   if span: ov = span.group(1)
   if all((src1, src2, titl, page, rel, ov)):
    src1, src2, titl, page, rel, ov = [CCDJgl.VVZwxs(str(x.encode().decode())).strip() for x in (src1, src2, titl, page, rel, ov)]
    pics = [src1]
    for pic in iFindall(r"(http.+?.jpg)", src2):
     pic = str(pic.encode().decode())
     if not pic in pics: pics.append(pic)
    lst.append((titl, rel, ov, pics[-1] if pics else "", page, 0))
    src1 = src2 = titl = page = rel = ov = ""
  return lst, "" if lst else "Not found"
 def VVCYeR(self):
  res, err = CCHRcZ.VVcUJs(("ms_rs_vn=_fer&s%=q&tt=s?/dnif/moc.bdmi.www//:sptth")[::-1] % FFSiPR(self.evName), timeout=5)
  if err: return [], "Netowrk Error"
  lst, err = self.VVLTOC(res.text)
  if err: return [], err
  return lst, ""
 def VVLTOC(self, txt):
  x = txt.find("<img alt=")
  if x == -1: return [], "Tag-1 not found"
  txt = txt[x:].replace("<img alt=", "\n<img alt=").replace("<svg", "\n<svg").replace("</a>", "</a>\n")
  lst1 = []
  for line in [ln for ln in txt.split("\n")]:
   if line.startswith("<img ") and not "Get the IMDb app" in line:
    span = iSearch(r'alt="(.+?)"\s+src="(.+?)"\s+srcSet="(.+?)".+\/title\/(.+?)\/', line)
    if not span: continue
    nam1, src1, src2, id1 = [CCDJgl.VVZwxs(str(x.encode().decode())) for x in span.groups()]
    pics = [src1]
    for pic in iFindall(r"(http.+?.jpg)", src2):
     pic = str(pic.encode().decode())
     if not pic in pics: pics.append(pic)
    lst1.append((nam1, pics, id1))
  lst2 = []
  span = iSearch(r'"titleResults":(.+}),"companyResults"', txt)
  if not span: return [], "Tag-2 not found"
  try:
   tDic = jLoads(span.group(1))["results"]
   for item in tDic:
    id2  = FFYjVd(item, "id")
    titl = FFYjVd(item, "titleNameText")
    rel  = FFYjVd(item, "titleReleaseText")
    topCr = FFYjVd(item, "topCredits")
    if not "titlePosterImageModel" in item: continue
    item = item["titlePosterImageModel"]
    picU = FFYjVd(item, "url")
    cap  = FFYjVd(item, "caption")
    try: topCr = ", ".join([CCDJgl.VVZwxs(str(x.encode())) for x in eval(topCr)])
    except: pass
    if not picU: continue
    titl, cap, rel, picU, id2 = [CCDJgl.VVZwxs(str(x.encode().decode())) for x in (titl, cap, rel, picU, id2)]
    rel = rel.strip(str(u"\u2013"))
    lst2.append((titl, cap, rel, topCr, picU, id2))
  except Exception as e:
   return [], str(e)
  l1, l2 = len(lst1), len(lst2)
  if  not all((l1, l2)) : return [], "Not found"
  elif not (l1 == l2)  : return [], "Incorrect Lengths (%s/%s)" % (l1, l2)
  pLst = []
  for titl, cap, rel, topCr, picU, id2 in lst2:
   for nam1, pics, id1 in lst1:
    if id1 == id2:
     row = (titl, cap, rel, topCr, picU, pics[-1] if pics else "", 0)
     if not row in pLst: pLst.append(row)
     break
   else:
    return [], "Incorrect IDs (1 & 2)"
  return pLst, "" if pLst else "No searh result"
 def VVJFKy(self, lst):
  def VVZwiy(ndx, smlU):
   path, err = FFx9uM(smlU, "p%s.jpg" % ndx, timeout=3, VVzHui=True, tmpPath=self.pDir)
   if path: picDic[ndx] = path
  picDic, threads = {}, []
  for ndx, item in enumerate(lst):
   if self.mode == 1: titl, rel, ov, smlU, page, ratio = item
   else    : titl, cap, rel, topCr, picU, smlU, ratio = item
   if smlU:
    thr = iThread(target=VVZwiy, args=(ndx, smlU))
    thr.start()
    threads.append(thr)
  for thr in threads: thr.join()
  return picDic
 def VVy7WX(self, mode, picU):
  FFimQ3(self.tbl, BF(self.VVYvOY, mode, picU))
 def VVYvOY(self, mode, picU):
  if self.mode == 1:
   picU = self.VVadfn(picU)
   if not picU: return
  path, err = FFx9uM(picU, "p.jpg", timeout=2, VVzHui=True, tmpPath=self.pDir)
  if path:
   resized, curW, curH, curW, curH = CC6u6z.VVV85P(path, 1200, 1800)
   if  mode == 0: CCf8zb.VVjnMn(self, path, title=self.evName, cbFnc=self.VVygsO)
   elif mode == 1: self.session.openWithCallback(BF(self.VVupqU, path), BF(CClYaF, VV1gDA="movies", VV1pbK=CFG.MovieDownloadPath.getValue()))
   elif mode == 2: self.VV6gua("Save to backup directory", path, FF0cqc() + self.evName + ".jpg")
   elif mode == 3: self.VV6gua("Save as Local Media Poster", path, self.dstP)
  else:
   self.VVQ5VQ("Cannot download poster")
 def VVygsO(self, path):
  FFwgGB(path)
 def VVadfn(self, url):
  picU = ""
  res, err = CCHRcZ.VVcUJs(url, timeout=3)
  if err:
   self.VVQ5VQ("Cannot get poster")
  else:
   for line in res.text.split("\n"):
    span = iSearch(r'srcset=".+,(.+)\s2x"', line)
    if span:
     picU = span.group(1)
     break
   else:
    self.VVQ5VQ("Cannot download poster")
  return picU
 def VVupqU(self, path, mPath):
  if mPath:
   dstF = "%s%s" % (os.path.splitext(mPath)[0], os.path.splitext(os.path.basename(path))[1])
   self.VV6gua("Save as Local Media Poster", path, dstF)
 def VV6gua(self, title, path, dst):
  if FFCyVu(dst) : FFRMYv(self, BF(self.VVddAM, title, path, dst), "Overwrite existing file ?", title=title)
  else    : self.VVddAM(title, path, dst)
 def VVddAM(self, title, path, dst):
  if FFpwZS("mv -f '%s' '%s'" % (path, dst)):
   if self.dstP: self.cancel(ret=path)
   else  : FFipXT(self, "Saved to:\n\n%s" % dst, False)
  else:
   self.VVQ5VQ("Cannot save file.")
   FFwgGB(path)
class CCMTfv():
 VVf0Wz = "ajpWebServer"
 def __init__(self, session):
  self.session = session
  tw = skt = srv = None
  try: from twisted.internet import reactor as tw
  except: pass
  try: import SocketServer as skt
  except:
   try: import socketserver as skt
   except: pass
  try: import SimpleHTTPServer as srv
  except:
   try: import http.server as srv
   except: pass
  self.VVAfaV, self.VVQf8x, self.VVjlTM = skt, srv, tw
 def VV0G75(self):
  if not self.VVAfaV or not self.VVQf8x: return
  fnc = self.VVN7Qw
  VVjlTM = self.VVjlTM
  class CC1yD2(self.VVQf8x.SimpleHTTPRequestHandler):
   def do_GET(self):
    self.VVHRFn("")
   def do_POST(self):
    length = int(self.headers["Content-Length"])
    data = str(self.rfile.read(length))
    self.VVHRFn(data)
   def VVHRFn(self, data):
    if   len(self.path) > 100: mode, rCode, rTxt = 1, 414, "URI Too Long"
    elif not VVjlTM   : mode, rCode, rTxt = 1, 400, "Missing Twisted Module"
    else      : mode, rCode, rTxt = fnc(self.path, data)
    if mode == 1:
     cType = "application/json"
     dic = {VVh9hj: VVJ6zn, "Request": self.path, "Result" : rTxt}
     rTxt = jDumps(dic).encode()
    else:
     cType = "text/html"
    self.send_response(rCode)
    self.send_header("Content-type", cType)
    self.end_headers()
    self.wfile.write(rTxt)
  try:
   global VV7R9N
   handler = CC1yD2
   self.VVAfaV.TCPServer.allow_reuse_address = True
   VV7R9N = self.VVAfaV.TCPServer(("", CFG.wsPort.getValue()), handler)
   th = iThread(name=CCMTfv.VVf0Wz, target=VV7R9N.serve_forever)
   th.setDaemon(True)
   th.start()
  except:
   pass
 def VVN7Qw(self, uPath, data):
  uPath = uPath.lower()
  if  uPath.startswith("/player"): rCode, rTxt = self.VVi03A(data)
  else       : rCode, rTxt = 400, "Unknown request"
  mode = 1
  return mode, rCode, rTxt
 def VVXiXt(self, fnc):
  def VVZwiy():
   if currentThread().getName() == "MainThread": fnc()
  if self.VVjlTM: self.VVjlTM.callFromThread(VVZwiy)
 def VVi03A(self, data):
  try: dic = jLoads(data)
  except: dic = {}
  tab = lambda x: FFXarh(str(dic[x]).strip()) if x in dic else ""
  url = tab("url")
  ref = tab("ref")
  name= tab("name")
  logo= tab("logo")
  endRef= tab("endRef")
  if not name and url.startswith("/"): name = os.path.splitext(os.path.basename(url))[0]
  name = name or "No Name"
  if ref and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10})$", ref)   : return 400, "Incorrect ref format"
  if endRef and not iMatch(r"^((?:[A-Fa-f0-9]+[:]){10}).*", endRef): return 400, "Incorrect endRef format"
  chUrl = ""
  if url:
   ref = ref or "%s:0:1:0:0:0:0:0:0:0:" % CFG.iptvAddToBouquetRefType.getValue()
   if  url.startswith("http") : url = FFSiPR(url)
   elif url.startswith("/") : pass
   else      : return 400, "Incorrect URL"
   chUrl = "%s%s:%s" % (ref.upper(), url, name)
  elif ref:
   chUrl = ref
  if CCqWM2.VVyLCv:
   txt = "Channel Changed" if ref else "Player is already shown"
   fnc = BF(CCqWM2.VVyLCv.VVU96j, chUrl, endRef, logo)
  else:
   txt = "Player Started"
   fnc = BF(CCqWM2.VVHc02, self.session, VVaHNe=chUrl, endRef=endRef, VVAfO9=logo)
  self.VVXiXt(fnc)
  return 200, txt
 def VVeTpx(self, trunOn):
  err = ""
  if not all((self.VVAfaV, self.VVQf8x)):
   err = "Missing Python libraries"
  else:
   isOn = CCMTfv.VVy1jd()
   if trunOn:
    if isOn : err = "Already running"
    else : self.VV0G75()
   else:
    if isOn : CCMTfv.VVVTz6()
    else : err = "Already stopped"
  return err, CCMTfv.VV9cQA()
 @staticmethod
 def VVVTz6():
  if "VV7R9N" in globals():
   global VV7R9N
   if hasattr(VV7R9N, "_BaseServer__shutdown_request"):
    VV7R9N._BaseServer__shutdown_request = True
   VV7R9N.shutdown()
   VV7R9N.server_close()
   FFYDZ6("VV7R9N")
 @staticmethod
 def VV9cQA():
  return "Turned %s" % ("ON" if CCMTfv.VVy1jd() else "OFF")
 @staticmethod
 def VVy1jd():
  thrListUrls = []
  for thr in iEnumerate():
   if thr.name == CCMTfv.VVf0Wz:
    return True
  else:
   return False
class CC3rDi():
 def __init__(self, session):
  self.Session = session
  self.servPtr  = CC3rDi.VVvi2b(self.Session)
  self.VVPxk5  = ""
  self.VVZcRP  = ""
  self.VV57TX  = ""
  self.VVfaDB  = ""
  self.VV1wIO   = ""
  self.prov   = ""
  self.state   = ""
  self.isMarker  = False
  self.info   = self.servPtr and self.servPtr.info()
  if self.info:
   self.VV1wIO  = self.info.getName()
   ref     = FFMzWf(self.info, iServiceInformation.sServiceref)
   state   = FFMzWf(self.info, iServiceInformation.sDVBState)
   self.prov  = FFMzWf(self.info, iServiceInformation.sProvider)
   self.isMarker = FFhPtm(ref)
   if self.isMarker:
    self.state = "Marker"
    self.VVPxk5 = ref.rstrip(":")
    self.VV1wIO = self.VVfa5Q()
   else:
    self.VVfaDB = ref if self.VVZcRP else ""
    self.state = self.VVOXOJ(state)
    self.VVPxk5, self.VVZcRP, self.VV57TX, self.VVfaDB = CC3rDi.VVGg6H(ref)
  self.servRef = CC3rDi.VVrnMj(self.Session)
  if self.servRef:
   self.Name  = self.servRef.getName()
   self.VVu06s = self.servRef.toString()
   self.VVpJLI = self.servRef.toCompareString()
   self.refType = str(self.servRef.type)
   self.Path  = self.servRef.getPath()
   self.isValid = self.servRef.valid()
   self.flags  = self.servRef.flags
   try: self.chNum = self.servRef.getChannelNum()
   except: self.chNum = 0
  else:
   self.Name  = ""
   self.VVu06s = ""
   self.VVpJLI = ""
   self.refType = ""
   self.Path  = ""
   self.isValid = False
   self.flags  = 0
   self.chNum  = 0
  span = iSearch(r"^((?:[A-F0-9]+[:]){9}(?:[A-F0-9]+))", self.VVPxk5 or self.VVu06s, IGNORECASE)
  self.VVXbok = span.group(1).upper().rstrip(":") if span else ""
  span = iSearch(r"http.+\/((?:[A-Fa-f0-9]+:){10}):", self.VVZcRP)
  self.VVAQqG = span.group(1).rstrip(":") if span else ""
  self.isLocal = self.isIptv = self.isFtp = self.isDvb = self.isDvbS = self.isDvbC = self.isDvbT = self.VVDiQp = False
  typ = ""
  if   "file?file" in self.VVu06s or ":ftp%3a//" in self.VVu06s : typ, self.isFtp = "FTP", True
  elif FFHgaY(self.VVu06s) or self.VVAQqG    : typ, self.VVDiQp= "S. Relay", True
  elif FFUPnc(self.VVu06s)          : typ, self.isIptv = "IPTV", True
  elif self.Path.startswith("/")         : typ, self.isLocal = "Local Media", True
  elif not self.Path:
   self.isDvb = True
   ns = FFARk6(self.VVu06s)
   if   ns.startswith("EEEE") : typ, self.isDvbT = "DVB-T", True
   elif ns.startswith("FFFF") : typ, self.isDvbC = "DVB-C", True
   else      : typ, self.isDvbS = "DVB-S", True
  self.streamType = typ
  span = iSearch(r"(.+)(mode=.+end=)", self.VVZcRP, IGNORECASE)
  if span:
   self.VVev7q = span.group(1).rstrip("&?")
   self.myPhp = span.group(2)
  else:
   self.VVev7q = ""
   self.myPhp = ""
  self.uniqueId = self.myPhp if self.myPhp else self.Path or self.VVPxk5
  self.userTxt = self.VVev7q or self.Path or self.VVPxk5
 def VVfa5Q(self):
  for r, n, f in CCMvE7.VVqZTI(mode=1):
   if self.VVPxk5 in r:
    return n
  return self.VV1wIO + " (Marker)"
 def VVOXOJ(self, s):
  if   not s :s=""
  elif s=="0" :s="*No free tuner"
  elif s=="1" :s="*Tune Failed"
  elif s=="2" :s="*Timeout reading PAT"
  elif s=="3" :s="*SID not found in PAT"
  elif s=="4" :s="*Timeout reading PMT"
  elif s=="5" :s="New program info"
  elif s=="6" :s="Tuned"
  elif s=="7" :s="Pre-Start"
  elif s=="8" :s="SOF"
  elif s=="9" :s="EOF"
  elif s=="10":s="*Check tuner configuration"
  elif s=="11":s="HBBTV Info"
  elif s=="12":s="*Stopped"
  elif s=="13":s="Channel Allocated"
  return s
 @staticmethod
 def VVrnMj(session):
  return session.nav.getCurrentlyPlayingServiceReference()
 @staticmethod
 def VVvi2b(session):
  return session.nav.getCurrentService()
 @staticmethod
 def VVGg6H(ref):
  if ref.endswith(("%3a", "%3A")): ref = ref[:-3]
  span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})(.+\/\/.+)", ref)
  if span:
   VVPxk5 = span.group(1).upper().rstrip(":")
   VV57TX = span.group(2)
   return VVPxk5, FFXarh(VV57TX), VV57TX, VVPxk5 + ":" + VV57TX
  else:
   VVPxk5 = ref
  return VVPxk5.rstrip(":"), "", "", ""
class CCKg9B():
 def __init__(self, SELF, tableObj, colNum=0):
  self.SELF  = SELF
  self.tableObj = tableObj
  self.colNum  = colNum
  self.VVj2Pf = -1
  self.SERVICE = 0
  self.STRING  = 1
  self.MULTI  = 2
  s = str(type(self.tableObj.l))
  if   "'enigma.eListboxServiceContent'" in s  : self.mode = self.SERVICE
  elif "'enigma.eListboxPythonStringContent'" in s: self.mode = self.STRING
  elif "'enigma.eListboxPythonMultiContent'" in s : self.mode = self.MULTI
  else           : return
  from Tools.NumericalTextInput import NumericalTextInput
  self.numericalTextInput = NumericalTextInput(nextFunc=self.VVcBWk)
  self.numericalTextInput.setUseableChars('1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
  FFBep1(SELF, {str(i):BF(self.VVvXnM, i) for i in range(10)})
 def VVvXnM(self, key):
  self.VVj2Pf = self.numericalTextInput.getKey(key)
  for group in ("1", "2ABC", "3DEF", "4GHI", "5JKL", "6MNO", "7PQRS", "8TUV", "9WXYZ", "0"):
   if self.VVj2Pf in group:
    if VVwdUw:
     txt = " ".join(group)
     txt = txt.replace(self.VVj2Pf, VVwdUw + self.VVj2Pf + VVA4XU)
     txt = VVA4XU + txt
    else:
     sep = "    "
     txt = sep + sep.join(group) + sep
     txt = txt.replace(sep + self.VVj2Pf + sep, "   [%s]   " % self.VVj2Pf)
    FF28n1(self.SELF, txt)
 def VVcBWk(self):
  FF28n1(self.SELF)
  try:
   if not self.tableObj:
    return
   if self.mode == self.SERVICE:
    try: self.tableObj.moveToChar(self.VVj2Pf)
    except: self.tableObj.moveToChar(self.VVj2Pf.encode())
   elif self.tableObj.list:
    for ndx in range(len(self.tableObj.list)):
     item = self.tableObj.list[ndx]
     if self.mode == self.STRING : item = item[self.colNum]
     else      : item = item[self.colNum + 1][7]
     item = FFzBfi(item).strip().encode().decode()
     if item.upper()[:1] == self.VVj2Pf:
      self.tableObj.moveToIndex(ndx)
      break
  except:
   pass
class CCZCVj(Screen):
 def __init__(self, session, isMove, VVGape, srcDir, dstDir):
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", 30)
  self.session  = session
  self.isMove   = isMove
  self.VVGape   = VVGape
  self.srcDir   = FFoWxR(srcDir)
  self.dstDir   = FFoWxR(dstDir)
  self.isMoveFast  = isMove and CClYaF.VVuTcL(self.srcDir) == CClYaF.VVuTcL(self.dstDir)
  self.files   = []
  self.dirs   = []
  self.others   = []
  self.action   = "move" if isMove else "copy"
  self.Title   = self.action.capitalize()
  self.resText  = ""
  self.totPaths  = 0
  self.totFiles  = 0
  self.totDirs  = 0
  self.curItem  = ""
  self.curErr   = ""
  FFZMxC(self, addScrollLabel=True, title=self.Title)
  FFBep1(self, { "ok": self.VVfXzC, "cancel": self.VVfXzC })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH()
  err = ""
  itemExists = False
  if self.srcDir == self.dstDir:
   self.VVQ5VQ("Cannot %s to same directory" % self.action)
  else:
   itself = "Cannot %s a directory to itself" % self.action
   for name in self.VVGape:
    err = ""
    path = os.path.join(self.srcDir, name)
    if path == self.dstDir:
     err = itself
    elif os.path.islink(FFVc4H(path)):
     self.totPaths += 1
    elif os.path.ismount(path):
     err = "Cannot include mount"
    elif os.path.isdir(path):
     self.totPaths += 1
     if FFoWxR(path) == self.dstDir:
      err = itself
     else:
      totDir, totFile, totLink = FFK6he(path)
      self.totPaths += totDir + totFile + totLink
    else:
     self.totPaths += 1
    if err:
     self.VVQ5VQ("%s\n\n%s" % (err, path))
     return
    elif FFCyVu(os.path.join(self.dstDir, FFxtW5(path))):
     itemExists = True
  if itemExists: FFRMYv(self, self.VVuXXc, "Overwrite items in destination ?", callBack_No=self.close, title=self.Title)
  else   : self.VVuXXc()
 def VVfXzC(self):
  self.close()
 def VVDiQh(self, txt):
  self["myLabel"].appendText(str(txt))
 def VVQ5VQ(self, txt):
  FFdw58(self, txt, title=self.Title)
  self.VVfXzC()
 def VVuXXc(self):
  totBars = 1 if self.isMoveFast else 2
  CCh3tv.VV7Nf4(self, VVLL7M=self.Title, VVIZBP=CCh3tv.VVgJkc, titleBg="#22220022", bodyBg="#22220022", totBars=totBars
      , VVixvy  = self.VVK8ea
      , VVbYwR = self.VV3Kl4 )
 def VVK8ea(self, VVXyP6):
  VVXyP6.VVq8NF(self.totPaths)
  for name in self.VVGape:
   srcPath = os.path.join(self.srcDir, name)
   dstPath = os.path.join(self.dstDir, name)
   self.curItem = srcPath
   if not VVXyP6 or VVXyP6.isCancelled: return
   if os.path.islink(FFVc4H(srcPath)):
    self.totFiles += self.VVwlwh(srcPath, dstPath, VVXyP6)
   elif os.path.isdir(srcPath):
    for Dir, subdirs, files in os.walk(srcPath):
     if not VVXyP6 or VVXyP6.isCancelled: return
     if not subdirs and not files:
      VVXyP6.VVxtQs(1)
      dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
      try:
       if not VVmJwX(dstDir): os.makedirs(dstDir)
       self.totDirs += 1
      except Exception as e:
       self.curErr = str(e)
       VVXyP6.VVlmol()
       return
     else:
      VVXyP6.VVxtQs(1)
      dstDir = os.path.join(self.dstDir, Dir[len(self.srcDir):].lstrip("/"))
      try:
       if not VVmJwX(dstDir): os.makedirs(dstDir)
       self.totDirs += 1
      except Exception as e:
       self.curErr = str(e)
       VVXyP6.VVlmol()
       return
      for name in files:
       if not VVXyP6 or VVXyP6.isCancelled: return
       self.totFiles += self.VVwlwh(os.path.join(Dir, name), os.path.join(dstDir, name), VVXyP6)
    if self.isMove: FFOzbr(srcPath)
   else:
    self.totFiles += self.VVwlwh(srcPath, dstPath, VVXyP6)
 def VVwlwh(self, srcPath, dstPath, VVXyP6):
  title = "../" + os.path.join(FFxtW5(FFx9pN(srcPath, True)), os.path.basename(srcPath))
  VVXyP6.VVaks5(title)
  self.curItem = srcPath
  size = FFXhoc(srcPath)
  if size == -1:
   size = 0
  VVXyP6.VVV3RA(0)
  VVXyP6.VVUIH1(size)
  VVXyP6.VVxtQs(1)
  if os.path.islink(FFVc4H(srcPath)):
   FFOzbr(dstPath)
   try:
    os.symlink(os.readlink(srcPath), dstPath)
   except:
    self.curErr = "Cannot copy SymLink"
    VVXyP6.VVlmol()
    return 0
  elif self.isMoveFast:
   if not FFpwZS("mv -f '%s' '%s'" % (srcPath, dstPath)):
    VVXyP6.VVlmol()
    return 0
  else:
   try:
    with open(srcPath, "rb") as srcF:
     with open(dstPath, "wb") as dstF:
      while True:
       if not VVXyP6 or VVXyP6.isCancelled:
        FFwgGB(dstPath)
        return 0
       try:
        data = srcF.read(1024)
        if not data:
         break
        dstF.write(data)
        VVXyP6.VVg2Dw(len(data))
       except Exception as e:
        self.curErr = str(e)
        FFwgGB(dstPath)
        VVXyP6.VVlmol()
        return 0
      VVXyP6.VVaks5(FFjt5L(title, VVSGsk))
   except Exception as e:
    self.curErr = str(e)
    return 0
  try: iCopymode(srcPath, dstPath)
  except: pass
  if self.isMove: FFOzbr(srcPath)
  return 1
 def VV3Kl4(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  txt  = "Total\t: %s\n" % self.totPaths
  txt += "Processed\t: %s\n\n" % (FFjt5L(threadCounter, VVSGsk if threadCounter == self.totPaths else VVz22H))
  txt += "%s Files\t: %s\n" % ("Moved" if self.isMove else "Copied", self.totFiles)
  txt += "%s Dirs\t: %s\n" % ("Moved" if self.isMove else "Copied", self.totDirs)
  if not VVRI6P or self.curErr or threadErr or threadCounter != self.totPaths:
   txt += FFjt5L("\n\nLast Processed:\n", VVz22H)
   txt += "%s\n" % self.curItem
   if self.curErr:
    txt += FFjt5L("\nLast Error:\n", VVz22H)
    txt += "%s\n" % self.curErr
  self.VVDiQh(txt)
  self["myLabel"].VVfu0l()
class CCwklK():
 def __init__(self):
  self.nmUselessWords  = CCwklK.VVO6rU()
  self.nmComp2yearsPatt = iCompile(r".*\d{4}.+\d{4}")
  self.nmSkip2yearsPatt = iCompile(r"(.*\d{4}.+)\d{4}\s*(.*)")
  self.nmSkip1yearsPatt = iCompile(r" \d{4}")
  self.nmSkipWordsPatt = CCwklK.VVu30K()
  try:
   from difflib import get_close_matches as iClosest
   self.iClosest = iClosest
  except:
   self.iClosest = None
 def VVUziJ(self, textToFind, pathLst, maxRes=0, cutoff=0.3):
  if   not pathLst  : return [] , ""
  elif not self.iClosest : return [], 'Missing "difflib" library'
  if maxRes == 0:
   maxRes = len(pathLst)
  refLst = []
  for ndx, path in enumerate(pathLst):
   fName = os.path.splitext(os.path.basename(path))[0]
   fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
   words = []
   for word in fName.split():
    if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
     words.append(word)
   txt = " ".join(words)
   if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
   else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
   if txt:
    refLst.append("%d,%s" % (ndx, txt))
  bestLst = self.iClosest(textToFind, refLst, n=maxRes, cutoff=cutoff)
  lst = []
  if bestLst:
   for item in bestLst:
    ndx, fName = item.split(",", 1)
    lst.append(pathLst[int(ndx)])
  return lst, ""
 def VVQebZ(self, SELF, cbFnc, textToFind, pathLst, maxRes=0, cutoff=0.3):
  if  not pathLst  : cbFnc([] , "")
  elif not self.iClosest : cbFnc([], 'Missing "difflib" library')
  else:
   CCh3tv.VV7Nf4(self, VVLL7M="Searching ...", titleBg="#22220022", bodyBg="#22220022", VVIZBP=CCh3tv.VVgJkc
       , VVixvy  = BF(self.VVGnmo, textToFind, pathLst, maxRes, cutoff, cbFnc)
       , VVbYwR = BF(self.VVcnr1, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc))
 def VVGnmo(self, textToFind, pathLst, maxRes, cutoff, cbFnc, VVXyP6):
  VVXyP6.VVq8NF(len(pathLst))
  VVXyP6.VVNc18 = []
  if maxRes == 0:
   maxRes = len(pathLst)
  for ndx, path in enumerate(pathLst):
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   VVXyP6.VVxtQs(1)
   fName = os.path.splitext(os.path.basename(path))[0]
   fName = iSub(r"([^A-Za-z0-9])", " ", fName).strip()
   words = []
   for word in fName.split():
    if not word.lower() in self.nmUselessWords and not iMatch(self.nmSkipWordsPatt, word):
     words.append(word)
   txt = " ".join(words)
   if iMatch(self.nmComp2yearsPatt, txt): txt = iSub(self.nmSkip2yearsPatt, r"\1\2", txt).rstrip();
   else         : txt = iSub(self.nmSkip1yearsPatt, "", txt)
   if txt and VVXyP6 and not VVXyP6.isCancelled:
    VVXyP6.VVNc18.append("%d,%s" % (ndx, txt))
 @FFOAKH("Filtering ...", par=1)
 def VVcnr1(self, SELF, textToFind, pathLst, maxRes, cutoff, cbFnc, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  bestLst = self.iClosest(textToFind, VVNc18, n=maxRes, cutoff=cutoff)
  lst = []
  if bestLst:
   for item in bestLst:
    ndx, fName = item.split(",", 1)
    lst.append(pathLst[int(ndx)])
  cbFnc(lst, "")
 @staticmethod
 def VVO6rU():
  return ('4k','8k','aac5','am','ar','arabic','avc','blueray','bluray','brrip','ddp5','dts','en','english','evo','hd','hdr','hdrip','hevc','mora','multi','multisub','mx','netflix','nf','remux','srt','sub','utf8','web','webrip','xvid','yify','yts')
 @staticmethod
 def VVu30K():
  return iCompile(r"\d{3,4}p"
      r"|[A-Za-z]\d{3}"
      r"|\d{1,3}bit[s]?"
      r"|25r|25rat|25rate"
      r"|[A-Za-z]{2}\d"
      , IGNORECASE)
class CCJIaP(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 800, 950, 40, 50, 30, "#22300030", "#0a202020", 33)
  self.session  = session
  self.netEntryFile = FF0cqc() + "ajpanel_network"
  c1, c2 = VVFuwR, VVJEMb
  VV3wat = []
  VV3wat.append((c1 + "Network Storage (FTP)"   , "dev" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Network Scanner (ping)"    , "ping"))
  VV3wat.append(("Port Scanner (scan for famous ports)" , "port"))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Check Internet Connection"  , "intr"))
  FFZMxC(self, title="Network Tools", VV3wat=VV3wat)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if   item == "dev" : self.VVk1PK()
  elif item == "ping" : self.VVD9YS()
  elif item == "port" : CCuqoc.VVxG6z(self, self.VVmOM9, title="Select host to scan")
  elif item == "intr" : self.session.open(CCoFdR)
 @FFOAKH("Reading Devices ...")
 def VVk1PK(self, canCencel=False):
  title = "Network Devices"
  VVAkuK = self.VVW9Fl()
  if VVAkuK:
   bg = "#0a223333"
   VVAkuK.sort(key=lambda x: x[0].lower())
   VVu8qI = BF(self.VVgHxg, canCencel)
   VVu1YM  = ("Start FTP"   , self.VV8wVH    , [])
   VVScQz = ("Entry Options"  , self.VVkDjp  , [])
   VV4QTJ = ("Scan for Devices" , self.VV91lj , [])
   header  = ("Num" , "IP-Address" , "Username", "Password", "Default Path", "Remarks" )
   widths  = (7  , 25   , 19  , 19  , 0.01   , 30  )
   VVLIqP = (CENTER , LEFT   , LEFT  , LEFT  , LEFT   , LEFT  )
   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, width=1500, height=900, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVScQz=VVScQz, VV4QTJ=VV4QTJ
       , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVoRat="#11ffff00", VVJKqd="#11220000", VVbcr0="#00333333", VVX9AA="#11400040")
   ndx = CFG.lastNetworkDevice.getValue()
   if isinstance(ndx, int):
    VV6A99.VVrqBw(ndx)
  else:
   FFRMYv(self, BF(self.VVEzoy, canCencel=canCencel), "No devices found !\n\nScan network ?", callBack_No=BF(self.VVgHxg, canCencel), title=title)
 def VVkDjp(self, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("Change Username"   , "user"))
  VV3wat.append(("Change Password"   , "pass"))
  VV3wat.append(("Change Remarks"   , "rem"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Remove Selected Server" , "del"))
  FFLFTC(self, BF(self.VVIjs1, VV6A99), VV3wat=VV3wat, title="Entry Options")
 def VVIjs1(self, VV6A99, item=None):
  if item:
   if   item == "user" : self.VVVyBx("u", VV6A99)
   elif item == "pass" : self.VVVyBx("p", VV6A99)
   elif item == "rem" : self.VVVyBx("r", VV6A99)
   elif item == "del" : FFRMYv(self, BF(self.VVPhuf, VV6A99), "Continue ?", title="Delete Entry")
 def VVgHxg(self, canCencel, VV6A99=None):
  if VV6A99: VV6A99.cancel()
  if canCencel : self.close()
 def VV8wVH(self, VV6A99, title, txt, colList):
  num, ip, u, p, path, rem = colList
  entry = (ip, u, p, path, rem)
  FFjt1c(CFG.lastNetworkDevice, VV6A99.VVGTqU())
  self.session.openWithCallback(BF(self.VVeh0L, entry, VV6A99), CCJve5, entry)
 def VVeh0L(self, entry, VV6A99, newPath=None):
  if newPath:
   ip, u, p, path, rem = entry
   if path != newPath:
    self.VVgBlN("d", newPath, ip, u, p, path, rem)
    self.VVRrjo(VV6A99)
 @FFOAKH("Scanning Network ...", clearMsg=False, par=1)
 def VV91lj(self, VV6A99, title, txt, colList):
  self.VVEzoy(mainTableInst=VV6A99)
 @FFOAKH("Scanning ...")
 def VVEzoy(self, canCencel=False, mainTableInst=None):
  title = "Network Devices"
  ftpLst, err = CCuqoc.VVp3V6(CCuqoc.VVhT2I)
  if err:
   FFdw58(self, err, title=title)
   return
  telLst, err = CCuqoc.VVp3V6(CCuqoc.VVtfD0)
  if err:
   FFdw58(self, err, title=title)
   return
  tLst = list(set(ftpLst + telLst))
  lst = []
  for item in tLst:
   typ = []
   if item in ftpLst: typ.append("FTP")
   if item in telLst: typ.append("Telnet")
   lst.append((item[0], item[1], " / ".join(typ)))
  ftpLst = telLst = tLst = None
  if mainTableInst:
   mainTableInst.VVrmMb()
  if lst:
   def VVD3N9(p1, p2): return FFa9eD(p1[0], p2[0])
   lst.sort(key=FFgEff(VVD3N9))
   bg = "#0a202020"
   VVu8qI = BF(self.VVgHxg, canCencel)
   VVu1YM  = ("Add to Devices" , BF(self.VVpyCP, mainTableInst, canCencel), [])
   header  = ("IP-Address" , "MAC-Address" , "Open Ports" )
   widths  = (40   , 34   , 26   )
   VVLIqP = (LEFT   , CENTER  , CENTER  )
   FFUQ0v(self, None, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, VVwdmN=30, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVKDPJ=2
     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a225555", VVX9AA="#11403040")
  else:
   FFdw58(self, "No devices found !", title=title)
 @FFOAKH("Scanning ...")
 def VVD9YS(self):
  title = 'Hosts that responded to "ping"'
  lst, err = CCuqoc.VVp3V6(-1)
  if err:
   FFdw58(self, err, title=title)
  elif lst:
   def VVD3N9(p1, p2): return FFa9eD(p1[0], p2[0])
   lst.sort(key=FFgEff(VVD3N9))
   bg = "#0a202020"
   header  = ("IP-Address" , "MAC-Address" )
   widths  = (50   , 50   )
   VVLIqP = (LEFT   , LEFT   )
   FFUQ0v(self, None, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1000, height=700, VVwdmN=30
     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a225555", VVX9AA="#11403040")
  else:
   FFdw58(self, "Network scanning failed !", title=title)
 @FFOAKH("Scanning")
 def VVmOM9(self, ip=None):
  if not ip: return
  dct = {20: "FTP Data Transfer", 21: "FTP Control", 22: "SSH", 23: "Telnet", 25: "SMTP (eMail)", 80: "HTTP", 443: "HTTPS"}
  txt  = "IP:\n   %s\n\n" % ip
  txt += "Ping Result:\n   %s\n\n" % ("OK" if CCuqoc.VVZsjD(ip) else "Failed")
  txt += "Available Ports:\n"
  ports = ""
  for port, subj in dct.items():
   ok = CCuqoc.VV7fvo(ip, port, timeout=0.5)
   if ok:
    ports += "   %d : %s\n" % (port, subj)
  FF4lCP(self, txt + (ports or "   None"), title="Scanned ports : %s" % str(list(dct)).strip("[]"))
 def VVW9Fl(self):
  tLst = []
  if FFCyVu(self.netEntryFile):
   txt = FFYVq0(self.netEntryFile)
   data = iFindall(r"host\s*=(.+),\s*user\s*=(.+),\s*pass\s*=(.*),\s*path\s*=(.*),\s*rem\s*=(.*)", txt, IGNORECASE)
   for ip, u, p, path, rem in data:
    ip, u, p, path, rem = ip.strip(), u.strip(), p.strip(), path.strip() or "/", rem.strip()
    tLst.append((ip, u, p, path, rem))
  def VVD3N9(p1, p2): return FFa9eD(p1[0], p2[0])
  tLst.sort(key=FFgEff(VVD3N9))
  lst = []
  for num1, item in enumerate(tLst, start=1):
   ip, u, p, path, rem = item
   lst.append((str(num1), ip, u, p, path, rem))
  return lst
 def VVpyCP(self, mainTableInst, canCencel, VV6A99, title, txt, colList):
  ip, mac, typ = VV6A99.VVMADj(VV6A99.VVGTqU())
  if "Own" in ip:
   FF28n1(VV6A99, "Cannot add your device", 1500)
  else:
   gw = "Gateway"
   if gw in ip : ip, u, p, path, rem = ip.split()[0].strip(), "admin", "123456", "/", gw
   else  : ip, u, p, path, rem = ip, "root", "dreambox", "/", "No-name"
   for entry in self.VVW9Fl():
    num1, ip1, u1, p1, path1, rem1 = entry
    if (ip, u, p, path, rem) == (ip1, u1, p1, path1, rem1):
     break
   else:
    if FFCyVu(self.netEntryFile):
     FFJvhj(self.netEntryFile)
    with open(self.netEntryFile, "a") as f:
     f.write(self.VV6PMw(ip, u, p, path, rem))
   if mainTableInst: self.VVRrjo(mainTableInst, [ip, u, p, path, rem])
   else   : self.VVk1PK(canCencel)
   VV6A99.cancel()
 def VV6PMw(self, ip, u, p, path, rem):
  return "host=%s,user=%s,pass=%s,path=%s,rem=%s\n" % (ip, u, p, path, rem)
 @FFOAKH("Deleting ...", par=1)
 def VVPhuf(self, VV6A99):
  num, ip, u, p, path, rem = VV6A99.VVMADj(VV6A99.VVGTqU())
  lst = self.VVW9Fl()
  tot = 0
  with open(self.netEntryFile, "w") as f:
   for item in lst:
    num1, ip1, u1, p1, path1, rem1 = item
    if not (ip1, u1, p1, path1, rem1) == (ip, u, p, path, rem):
     f.write(self.VV6PMw(ip1, u1, p1, path1, rem1))
     tot += 1
  if tot:
   self.VVRrjo(VV6A99)
  else:
   VV6A99.cancel()
 def VVVyBx(self, col, VV6A99):
  num, ip, u, p, path, rem = VV6A99.VVMADj(VV6A99.VVGTqU())
  if   col == "u": orig, subj = u  , "User"
  elif col == "p": orig, subj = p  , "Password"
  elif col == "r": orig, subj = rem, "Remarks"
  FF4z45(self, BF(self.VVdh5B, col, orig, VV6A99, num, ip, u, p, path, rem), defaultText=orig, title="Change %s" % subj, message="Enter %s:" % subj)
 def VVdh5B(self, col, orig, VV6A99, num, ip, u, p, path, rem, newTxt):
  if not newTxt == None:
   newTxt = newTxt.strip()
   if orig == newTxt:
    FF28n1(VV6A99, "No change", 1500)
   elif not newTxt and col == "u":
    FF28n1(VV6A99, "No user !", 2000)
   else:
    self.VVgBlN(col, newTxt, ip, u, p, path, rem)
    self.VVRrjo(VV6A99)
 def VVgBlN(self, col, newTxt, ip, u, p, path, rem):
  lst = self.VVW9Fl()
  oldItem = (ip, u, p, path, rem)
  with open(self.netEntryFile, "w") as f:
   for item in lst:
    num1, ip1, u1, p1, path1, rem1 = item
    if (ip1, u1, p1, path1, rem1) == oldItem:
     if   col == "u": u1  = newTxt
     elif col == "p": p1  = newTxt
     elif col == "d": path1 = newTxt
     elif col == "r": rem1 = newTxt
    f.write(self.VV6PMw(ip1, u1, p1, path1, rem1))
 def VVRrjo(self, VV6A99, newEntry=None):
  VVAkuK = self.VVW9Fl()
  if VVAkuK : VV6A99.VVMqQ9(VVAkuK, VVDpzd=BF(self.VVNFyd, newEntry))
  else  : VV6A99.cancel()
 def VVNFyd(self, newEntry, VV6A99, title, txt, colList):
  if newEntry:
   for ndx, row in enumerate(VV6A99.VVrrm9()):
    if row[1:] == newEntry:
     VV6A99.VVrqBw(ndx)
 def VVgHxg(self, canCencel, VV6A99=None):
  if VV6A99: VV6A99.cancel()
  if canCencel : self.close()
class CCuqoc():
 VVhT2I = 21
 VVtfD0 = 23
 def __init__(self):
  self.VVQsoo()
 def VVQsoo(self):
  self.ftp  = None
  self.ftpIp  = ""
  self.ftpUser = ""
  self.ftpPass = ""
  self.ftpSys  = ""
 def VVEGGE(self, ip, User, Pass, timeout=5):
  myIp = CCuqoc.VVEZHZ()
  if ip != myIp:
   if CCuqoc.VV7fvo(ip, CCuqoc.VVhT2I):
    self.VVQsoo()
    err = ""
    try:
     from ftplib import FTP
     self.ftp  = FTP(ip, user=User, passwd=Pass, timeout=timeout)
     self.ftp.set_pasv(False)
     self.ftpIp  = ip
     self.ftpUser = User
     self.ftpPass = Pass
    except Exception as e:
     err = str(e)
   else:
    err = "Connection timed out !\n\n%s" % ip
  else:
   err = "Cannot FTP to your Device-IP:\n\n%s" % ip
  return err
 def VVNcyD(self):
  try: return self.ftp.sendcmd("SYST")
  except: return ""
 def VVwQa6(self):
  try: return self.ftp.sendcmd("NOOP")
  except: return ""
 def VVBAfQ(self, timeout=3):
  t1 = iTime()
  while True:
   state = self.VVwQa6()
   if not state or state == "200 OK" or iTime() - t1 >= timeout:
    break
 def VVaqgE(self):
  try: return self.ftp.sendcmd("STAT")
  except: return ""
 def VVQyPa(self, Dir, isLong=False):
  files, err = [], ""
  if self.ftp and self.VVejFu(Dir):
   try:
    if isLong: self.ftp.dir(files.append)
    else  : self.ftp.nlst()
   except Exception as e:
    err = str(e)
  else:
   err = "No FTP Connection !"
  return files, err
 def VVPc1T(self):
  try: return self.ftp.pwd()
  except: return ""
 def VVqA3B(self, path):
  try:
   size = self.ftp.sendcmd("SIZE %s" % path)
   return "f"
  except:
   VVXgOC = self.VVPc1T()
   if self.VVejFu(path) : typ = "d"
   else      : typ = "b"
   self.VVejFu(VVXgOC)
   return typ
 def VVNt99(self, path):
  try: return self.ftp.size(path)
  except: return -1
 def VVejFu(self, path):
  try:
   self.ftp.cwd(path)
   return True
  except:
   return False
 def VVxL8X(self, path):
  try:
   self.ftp.mkd(path)
   return True
  except:
   return False
 def VV8IY8(self, path, flag):
  try:
   if flag == "d" : self.ftp.rmd(path)
   else   : self.ftp.delete(path)
   return True
  except:
   return False
 def VVmIS9(self, fromN, toN):
  try:
   self.ftp.rename(fromN, toN)
   return True
  except:
   return False
 def VVWKNk(self, remFile, locFile="", maxSz=10000000):
  sz = self.VVNt99(remFile)
  if   sz == -1 : return "", sz, "Cannot read file size."
  elif sz > maxSz : return "", sz, "File too big."
  else   : err= ""
  locFile = locFile or "/tmp/%s" % os.path.basename(remFile)
  try:
   self.ftp.retrbinary("RETR %s" % remFile, open(locFile, "wb").write)
   if FFCyVu(locFile) : return locFile, sz, ""
   else     : return "", sz, "Download Failed."
  except Exception as e:
   FFwgGB(locFile)
   return "", sz, str(e)
 def VVmRZd(self):
  if self.ftp:
   try: self.ftp.quit()
   except: pass
  self.VVQsoo()
 @staticmethod
 def VVMOOa():
  from uuid import getnode
  return ':'.join(iFindall('..', '%012x' % getnode())).upper()
 @staticmethod
 def VVEZHZ():
  from socket import socket, setdefaulttimeout, AF_INET, SOCK_DGRAM
  try:
   setdefaulttimeout(1)
   s = socket(AF_INET, SOCK_DGRAM)
   s.connect(("1.1.1.1", 80))
   ip = s.getsockname()[0]
   s.close()
   return ip
  except:
   return ""
 @staticmethod
 def VVStKU():
  myIp = CCuqoc.VVEZHZ()
  if myIp.count(".") == 3:
   parts = myIp.split('.')
   return ".".join(parts[:3]) + "."
  return ""
 @staticmethod
 def VV6JG2():
  span = iSearch(r"((?:\d+.){3}\.\d+)", FFTKR0("ip route | grep default"), IGNORECASE)
  return span.group(1) if span else ""
 @staticmethod
 def VV6V4z(port=-1):
  lst = []
  def VVZwiy(ip):
   if port > -1: ok = CCuqoc.VV7fvo(ip, port)
   else  : ok = CCuqoc.VVZsjD(ip)
   if ok:
    lst.append(ip)
  try:
   baseIp = CCuqoc.VVStKU()
   thLst  = []
   for num in range(1, 255):
    ip = "%s%d" % (baseIp, num)
    th = iThread(name="ajp_scanIp%d" % num, target=BF(VVZwiy, ip))
    th.start()
    thLst.append(th)
   for th in thLst: th.join()
   return lst, ""
  except Exception as e:
   err = str(e)
   return [], err + '\n\nMax Threads = %d\nCheck your system "Max User Processes" with "ulimit -u"' % len(thLst) if "can't start new thread" in err else ""
 @staticmethod
 def VVp3V6(port):
  myIp = CCuqoc.VVEZHZ()
  myGw = CCuqoc.VV6JG2()
  tDict = { myIp: CCuqoc.VVMOOa() }
  devLst, err = CCuqoc.VV6V4z(port)
  if err:
   return [], err
  else:
   for ip in devLst:
    span = iSearch(r"((?:\d+.){3}\.\d+).+\s+((?:[a-f\d]{2}:){5}[a-f\d]{2})", FFQ45w("arp -n %s" % ip), IGNORECASE)
    if span    : tDict[ip] = span.group(2).upper()
    elif not ip == myIp : tDict[ip] = ""
   lst = []
   for key, val in tDict.items():
    if   key == myIp: txt = " %s Own" % VVFuwR
    elif key == myGw: txt = " %s Gateway" % VVFuwR
    else   : txt = ""
    lst.append((key + txt, val))
   return lst, ""
 @staticmethod
 def VVZsjD(ip):
  return FFpwZS("ping -W1 -q -c1 %s" % ip)
 @staticmethod
 def VV7fvo(host, port, timeout=1.0):
  from socket import socket, setdefaulttimeout, AF_INET, SOCK_STREAM
  setdefaulttimeout(timeout)
  try:
   socket(AF_INET, SOCK_STREAM).connect((host, port))
   return True
  except:
   return False
 @staticmethod
 def VVSuvZ(ip="1.1.1.1", timeout=1):
  if CCuqoc.VV7fvo(ip, 53, timeout):
   return True
  if CCuqoc.VVZsjD(ip):
   return True
  return FFpwZS("wget -q -T %d -t 1 --spider %s" % (timeout, ip))
 @staticmethod
 def VVxG6z(SELF, okFnc, title):
  baseIp = CCuqoc.VVStKU()
  lst = []
  for num in range(1, 255):
   item = "%s%d" % (baseIp, num)
   lst.append((item, item))
  FFLFTC(SELF, okFnc, VV3wat=lst, width=600, title=title, VVwltY="#222222", VVkxBG="#222222")
class CCJve5(Screen, CCuqoc):
 def __init__(self, session, entry):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 1400, 920, 40, 50, 30, "#11333344", "#08303030", 30, VVeFSs=40, VV0Ay7=2)
  self.session  = session
  self.ftpEntry  = entry
  self.VVwdmN  = self.VVfOli["VVgbF2"]
  self.VV8c7y  = self.VVfOli["bodyLineH"]
  self.VVVljT  = self.VVfOli["width"]
  self.VVXgOC   = "/"
  self.list   = []
  self.png_fil  = CCHmnm.VVKUQG("fil")
  self.png_dir  = CCHmnm.VVKUQG("dir")
  self.png_dirup  = CCHmnm.VVKUQG("dirup")
  self.png_slwfil  = CCHmnm.VVKUQG("slwfil")
  self.png_slbfil  = CCHmnm.VVKUQG("slbfil")
  self.png_slwdir  = CCHmnm.VVKUQG("slwdir")
  self.serverOrigData = None
  self.Title   = "FTP (%s)" % entry[0]
  CCuqoc.__init__(self)
  VV3wat = [("Item-%d" % x,) for x in range(50)]
  FFZMxC(self, title=self.Title, VV3wat=VV3wat)
  FFRLNq(self["keyRed"] , "Exit")
  self["myMenu"] = MenuList(VV3wat, True, eListboxPythonMultiContent)
  self["myMenu"].l.setFont(0, gFont(VVNhAq, self.VVwdmN))
  self["myMenu"].l.setItemHeight(self.VV8c7y)
  FFHlAU(self,
  {
   "red" : BF(self.VVfXzC, True) ,
   "ok" : self.VVPr1F    ,
   "cancel": self.VVfXzC    ,
   "menu" : self.VVghcE   ,
   "info" : self.VVASMR  ,
   "pageUp": self.VVn7lV    ,
   "chanUp": self.VVn7lV
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVkvel)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
  FFWgBS(self)
  FF6W0I(self)
  FFZ0AC(self["keyBlue"], "#11333333")
  self.VVsSrI()
 @FFOAKH("Connecting ...")
 def VVsSrI(self):
  ip, u, p, path, rem = self.ftpEntry
  err = self.VVEGGE(ip, u, p)
  if err:
   FFdw58(self, err, title=self.Title)
   FFRLNq(self["keyBlue"] , "")
   self.close()
  elif self.ftp:
   FFRLNq(self["keyBlue"], self.ftpIp)
   if not self.VVejFu(path):
    path = "/"
   self.VV35Mp(path)
   self.serverOrigData = (ip, u, p, path, rem)
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  if self.VVwQa6():
   self.VVmRZd()
 def VVPr1F(self):
  if self.VVaECA():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    if   flag == "d" or targetState == "d" : self.VV35Mp(os.path.join(self.VVXgOC, name))
    elif flag == "x"      : self.VVn7lV()
    else         : self.VVC1uy(os.path.join(self.VVXgOC, name))
 def VVfXzC(self, force=False):
  if force or CFG.FileManagerExit.getValue() == "e": self.close(self.VVXgOC)
  else            : self.VVn7lV()
 def VVaECA(self):
  if self.VVwQa6():
   return True
  else:
   FFdw58(self, "FTP Server is now diconnected !", title=self.Title)
   return False
 def VVC1uy(self, path):
  cat = CCHmnm.VVMyky(path)
  if cat in ("pic"):
   self.VVTKHt(path)
  elif cat in ("mov", "mus"):
   if CCkEI5.VVUDPe("5002"):
    url = "ftp%%3a//%s%%3a%s@%s%s" % (self.ftpUser, self.ftpPass, self.ftpIp, path)
    rType = "5002"
   else:
    rType = CFG.iptvAddToBouquetRefType.getValue()
    url = "http%%3a//%s/file?file=%s" % (self.ftpIp, path)
   FFimQ3(self, BF(CClYaF.VVTWR0, self, url, rType=rType), title="Playing Media ...")
 @FFOAKH()
 def VVTKHt(self, path):
  locFile, size, err = self.VVWKNk(path)
  if err: FFdw58(self, err, title="View Picture File")
  else  : CCf8zb.VVjnMn(self, locFile, fakePath="ftp:/%s" % path, cbFnc=BF(FFwgGB))
 def VVkvel(self):
  sel = self["myMenu"].l.getCurrentSelection()
  if sel: title = "  %s  " % os.path.join(self.VVXgOC, "" if sel[0][0] == CCHmnm.VVXivL else sel[0][0])
  else  : title=  VVYjI5 + "  No Files Found !"
  self["myTitle"].setText(title)
 def VVn7lV(self):
  if self.VVaECA():
   lastPart = FFxtW5(self.VVXgOC)
   parentDir = os.path.abspath(os.path.join(self.VVXgOC, os.pardir))
   self.VV35Mp(parentDir, lastPart, "d")
 @FFOAKH()
 def VV35Mp(self, Dir, moveTo="", moveToType=""):
  files, err = self.VVQyPa(Dir, isLong=True)
  self.VVXgOC = self.VVPc1T() or "/"
  self.VVjqEq(files)
  if moveTo:
   for ndx, item in enumerate(self.list):
    name, target, targetState, flag, sortSeq = item[0]
    if moveTo == name:
     if not moveToType or moveToType == flag:
      self["myMenu"].moveToIndex(ndx)
      break
  else:
   self["myMenu"].moveToIndex(0)
 def VVjqEq(self, files):
  self.list = []
  if self.VVXgOC != "/":
   self.list.append(self.VVcZ51(CCHmnm.VVXivL, CCHmnm.VVXivL, "", "", "x"))
  for item in files:
   linkTo = ""
   isDir = isFile = isLink = False
   item = item.strip()
   if   item.startswith("l")     : flag = "l"
   elif item.startswith("d") or "<DIR>" in item: flag = "d"
   else          : flag = "f"
   gaps = 3 if item[:1].isdigit() else 8
   name = item.split(None, gaps)[gaps]
   linkSep = " -> "
   origName = name
   target = targetState = ""
   if linkSep in name:
    flag = "l"
    name, _, target = name.partition(linkSep)
    if not target.startswith("/"):
     target = "/" + target
    targetState = self.VVqA3B(target)
    color = VVYjI5 if targetState == "b" else VVSGsk
    origName = name + VV1fx4 + linkSep + color + " "+ target
   self.list.append(self.VVcZ51(origName, name, target, targetState, flag))
  self.list.sort(key=lambda x: (x[0][4], x[0][0]))
  self["myMenu"].l.setList(self.list)
 def VVcZ51(self, origName, name, target, targetState, flag):
  if flag == "f":
   png = self.png_fil
   ext = os.path.splitext(name)[1]
   if ext:
    cat = CCHmnm.VVMyky(name)
    if cat: png = LoadPixmap("%s%s.png" % (VVIp2p, cat))
  elif flag == "d": png = self.png_dir
  elif flag == "l":
   if   targetState == "f" : png = self.png_slwfil
   elif targetState == "d" : png = self.png_slwdir
   elif targetState == "b" : png = self.png_slbfil
   else      : png = self.png_slwfil
  elif flag == "x": png = self.png_dirup
  else   : png = self.png_fil
  if   origName == CCHmnm.VVXivL: sortSeq = 0
  elif flag == "d" or targetState == "d"  : sortSeq = 1
  else          : sortSeq = 2
  tableRow = [ (name, target, targetState, flag, sortSeq) ]
  tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VV8c7y + 10, 0, self.VVVljT, self.VV8c7y, 0, LEFT | RT_VALIGN_CENTER, origName))
  tableRow.append(CCnES5.VVmxDV(0, 2, self.VV8c7y-4, self.VV8c7y-4, png))
  return tableRow
 def VVghcE(self):
  sel = self["myMenu"].l.getCurrentSelection()
  if sel : name, target, targetState, flag, sortSeq = sel[0]
  else : name = target = targetState = flag = ""
  isTop  = name == CCHmnm.VVXivL
  isDir  = flag == "d" or targetState == "d"
  isFile = flag == "f" or targetState == "f"
  def VVb94q(titl, ref, chk, color=""):
   if chk: return VV3wat.append((color + titl, ref))
   else  : return VV3wat.append((titl, ))
  VV3wat = []
  VVb94q("Properties", "VVASMR", not isTop)
  c = VVFuwR
  VV3wat.append(VVAL3j)
  VVb94q("Download Selected File ..."    , "VVQGeJ", isFile, c)
  VVb94q("Upload a Local File to Remote Server ...", "VVqeGJ" , True  , c)
  VV3wat.append(VVAL3j)
  VVb94q("Create new directory", "VV5THc", True)
  VVb94q("Rename", "VVlFvn", not isTop)
  VVb94q("DELETE", "VVgcbK", not isTop, VVz22H)
  VV3wat.append(VVAL3j)
  VVb94q("FTP Server Information", "VVJIrN", True)
  VV3wat.append(VVAL3j)
  VVb94q("Refresh File List", "refresh", True)
  FFLFTC(self, self.VV5Qsx, VV3wat=VV3wat, title="Options")
 def VV5Qsx(self, item=None):
  if item:
   if   item == "VVASMR"     : self.VVASMR()
   elif item == "VVQGeJ"   : self.VVQGeJ()
   elif item == "VVqeGJ"   : self.VVqeGJ()
   elif item == "VV5THc"   : self.VV5THc()
   elif item == "VVlFvn"   : self.VVlFvn()
   elif item == "VVgcbK"   : self.VVgcbK()
   elif item == "VVJIrN"    : self.VVJIrN()
   elif item == "refresh" and self.VVaECA(): self.VV35Mp(self.VVXgOC)
 def VVASMR(self):
  if self.VVaECA():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    path = os.path.join(self.VVXgOC, name)
    txt = "%s:\n%s\n\n" % (FFjt5L("Path", VVFuwR), path)
    typ = {"d": "Directory", "f": "File", "l": "SymLink", "x": ""}.get(flag, "")
    if typ: txt += "Type\t: %s%s\n" % (typ, " (Broken)" if targetState == "b" else "")
    if target: txt += "Target\t: %s\n" % target
    sz = self.VVNt99(path)
    if sz > -1: txt += "Size\t: %s" % CClYaF.VV99gM(sz)
   else:
    txt = "Nothing selected"
   FF4lCP(self, txt, title="Properties")
 def VVJIrN(self):
  if self.VVaECA():
   Sys  = self.VVNcyD() or " -"
   txt = "%s\n  %s\n\n" % (FFjt5L("System:", VVFuwR), Sys[4:] if Sys.startswith("215 ") else Sys)
   Stat = self.VVaqgE() or " -"
   txt += "%s\n" % (FFjt5L("Status:", VVFuwR))
   for line in Stat.splitlines():
    txt += "  %s\n" % (line[4:] if line.startswith("211-") or line.startswith("211 ") else line)
   FF4lCP(self, txt, title="FTP Server Information")
 def VV5THc(self, name=""):
  if self.VVaECA():
   title = "Add New Directory"
   FF4z45(self, BF(self.VV3kJe, title), defaultText=name, title=title, message="Enter Directory name")
 def VV3kJe(self, title, name):
  if name and name.strip():
   if self.VVxL8X(name) : self.VV35Mp(self.VVXgOC, name, "d")
   else     : FFdw58(self, "Failed to create : %s" % name, title)
 def VVlFvn(self):
  if self.VVaECA():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    title = "Rename"
    name, target, targetState, flag, sortSeq = sel[0]
    FF4z45(self, BF(self.VVuz7i, title, name, flag), defaultText=name, title=title, message="Enter new name")
 def VVuz7i(self, title, name, flag, newName):
  if newName and newName.strip():
   if self.VVmIS9(name, newName.strip()) : self.VV35Mp(self.VVXgOC, newName, flag)
   else          : FFdw58(self, "Failed to rename to : %s" % newName, title)
 def VVgcbK(self):
  if self.VVaECA():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    name, target, targetState, flag, sortSeq = sel[0]
    FFRMYv(self, BF(self.VV3hnb, name, flag), "Delete ?\n\n%s" % name, title="Delete")
 @FFOAKH("Deleting ...")
 def VV3hnb(self, name, flag):
  if self.VV8IY8(name, flag) : self.VV35Mp(self.VVXgOC)
  else         : FFdw58(self, "Failed to delete:\n\n%s" % name, "Delete")
 def VVQGeJ(self):
  if self.VVaECA():
   sel = self["myMenu"].l.getCurrentSelection()
   if sel:
    title = "Download File"
    name, target, targetState, flag, sortSeq = sel[0]
    remFile = os.path.join(self.VVXgOC, name)
    size = self.VVNt99(remFile)
    if size == -1:
     FFdw58(self, "Cannot get file size for:\n\n%s" % remFile, title=title)
    else:
     Dir = CFG.lastFtpLocalPath.getValue() if VVmJwX(CFG.lastFtpLocalPath.getValue()) else FF0cqc()
     self.session.openWithCallback(BF(self.VVs8BP, title, remFile, name, size), BF(CClYaF, mode=CClYaF.VV9N82, VVqlNR="Download here", VV1pbK=Dir, width=1200, height=840, pickTitleBG="#11002222", pickBodyBG="#11003333", VVoCB2="#11005566"))
 def VVs8BP(self, title, remFile, name, size, locPath):
  if locPath:
   FFjt1c(CFG.lastFtpLocalPath, locPath)
   locFile = os.path.join(locPath, name)
   CCh3tv.VV7Nf4(self, VVLL7M="Downloading ...", titleBg="#22220022", bodyBg="#22220022"
       , VVixvy  = BF(self.VVOIoL, remFile, size, locFile)
       , VVbYwR = BF(self.VVZPV3, remFile, size, locFile))
 def VVOIoL(self, remFile, size, locFile, VVXyP6):
  VVXyP6.VVq8NF(size)
  VVXyP6.VVNc18 = ""
  with open(locFile, "wb") as locFileObj:
   try:
    def VVxggW(data):
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     locFileObj.write(data)
     VVXyP6.VVxtQs(len(data))
    self.ftp.retrbinary("RETR %s" % remFile, VVxggW)
   except Exception as e:
    VVXyP6.VVNc18 = str(e)
 def VVZPV3(self, remFile, size, locFile, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  title = "File Download"
  delF = False
  if VVNc18:
   FFdw58(self, "%s\n\nftp:/%s" % (VVNc18, remFile), title="Download Error")
   delF = True
  elif not VVRI6P:
   FFdw58(self, "Download cancelled for:\n\nftp:/%s" % remFile, title=title)
   delF = True
  else:
   if size == FFXhoc(locFile):
    txt = "Successfully downloaded to:\n\n%s" % locFile
    FFipXT(self, txt, title=title)
   else:
    FFdw58(self, "Incorrect downloaded file size for:\n\nftp:/%s" % remFile, title=title)
    delF = True
  if delF:
   FFwgGB(locFile)
 def VVqeGJ(self):
  if self.VVaECA():
   Dir = CFG.lastFtpLocalPath.getValue() if VVmJwX(CFG.lastFtpLocalPath.getValue()) else FF0cqc()
   self.session.openWithCallback(self.VVS7dC, BF(CClYaF, VVqlNR="Upload selected file", VV1pbK=Dir, VV1gDA="all", width=1200, height=850, pickTitleBG="#11001122", pickBodyBG="#11330033", VVoCB2="#11662200"))
 def VVS7dC(self, locFile):
  if locFile:
   title = "Upload File to Remote Server"
   FFjt1c(CFG.lastFtpLocalPath, os.path.dirname(locFile))
   size = FFXhoc(locFile)
   if size == -1:
    FFdw58(self, "Cannot get file size for:\n\n%s" % locFile, title=title)
   else:
    remFile = os.path.join(self.VVXgOC, os.path.basename(locFile))
    CCh3tv.VV7Nf4(self, VVLL7M="Uploading ...", titleBg="#22220022", bodyBg="#22220022"
        , VVixvy  = BF(self.VV9WLi, locFile, size, remFile)
        , VVbYwR = BF(self.VVY5Vb, locFile, size, remFile))
 def VV9WLi(self, locFile, size, remFile, VVXyP6):
  VVXyP6.VVq8NF(size)
  VVXyP6.VVNc18 = ""
  with open(locFile, "rb") as locFileObj:
   try:
    def VVd7e8(data):
     if not VVXyP6 or VVXyP6.isCancelled:
      VVXyP6.VVNc18 = "Upload cancelled"
      locFileObj.close()
      return
     VVXyP6.VVxtQs(len(data))
    self.ftp.storbinary("STOR %s" % remFile, locFileObj, callback=VVd7e8)
   except Exception as e:
    VVXyP6.VVNc18 = VVXyP6.VVNc18 or str(e)
 def VVY5Vb(self, locFile, size, remFile, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  title = "File Upload"
  err = ""
  if VVRI6P:
   if size == FFXhoc(locFile) : FFipXT(self, "Successfully uploaded to:\n\n%s" % remFile, title=title)
   else       : err = "Incorrect uploaded file size for:\n\nftp:/%s" % remFile
  elif VVNc18 : err = "%s\n\n%s" % (VVNc18, locFile)
  else    : err = "Incomplete file transfer:\n\n%s" % locFile
  if err:
   FFdw58(self, err, title=title)
   self.VVBAfQ()
   self.VV8IY8(remFile, "")
  self.VV35Mp(self.VVXgOC)
class CC6u6z():
 VVjbK6  = "all"
 VVOdU6 = "vid"
 VV9Iya  = "osd"
 VVQjxm = "dreamboxctl"
 VVklE8  = "grab"
 @staticmethod
 def VVTqPs(session, k, dm):
  if CC6u6z.VVgrEx(session) or CFG.screenshotFType.getValue() == "off":
   return
  title = "%s Screenshot" % VVh9hj
  err = ""
  if   not FFayeZ(CC6u6z.VVklE8)   : err = "g"
  elif dm and not FFayeZ(CC6u6z.VVQjxm): err = "gd"
  if err:
   FFzcnp(session, "Missing %s-command !" % err, title=title)
   return
  winShown = session.current_dialog.shown
  if k == CC6u6z.VVOdU6 and winShown: session.current_dialog.hide()
  FFIElK(BF(CC6u6z.VVWcGy, title, session, k, winShown, dm))
 @staticmethod
 def VVWcGy(title, session, k, winShown, dm):
  fTitle = skinName = ""
  x = y = w = h = 0
  if k == CC6u6z.VV9Iya:
   if not winShown:
    FFzcnp(session, "No Window to capture !", title=title)
    return
   if not CC6u6z.VV181X(session, title, True):
    return
   valid, origTitle, clnTitle, skinName, x, y, w, h = CC6u6z.VV7K5o(session)
   fTitle = "%s_(%s)" % (clnTitle, skinName)
   if not valid:
    FFzcnp(session, "Cannot get Window Dimensions !", title=title)
    return
  if not fTitle:
   s = CC3rDi(session)
   fTitle = FFOu5Y(s.VV1wIO.strip(), "-") or s.VVXbok.replace(":", "_")
  ext = CFG.screenshotFType.getValue()
  path = "%sscreenshot_%s_%s.%s" % (FFCq6F(), fTitle, FFjTQe(), ext)
  fnc = BF(CC6u6z.VVjh1O, path, title, session, k, winShown, x, y, w, h)
  if dm:
   CCaTk8().VVtIZD("%s screenshot -f '%s'" % (CC6u6z.VVQjxm, path), fnc)
  else:
   FF7ymp("%s -q -s %s > '%s'" % (CC6u6z.VVklE8, {"jpg":"-j 100", "png":"-p"}.get(ext, ""), path))
   fnc()
 @staticmethod
 def VVjh1O(path, title, session, k, winShown, x, y, w, h, *args):
  if k == CC6u6z.VVOdU6 and winShown:
   session.current_dialog.show()
  elif k == CC6u6z.VV9Iya:
   ok = CC6u6z.VVOO8R(path, x, y, w, h)
   if not ok:
    FFwgGB(path)
    FFzcnp(session, "Error while cropping image file !", title=title)
    return
  if FFCyVu(path) : session.open(CCf8zb, VVPq2Z=path, title=path, menuFnc=CC6u6z.VVZSn1)
  else    : FFzcnp(session, "Error while capturing screen !", title=title)
 @staticmethod
 def VVZSn1(pvObj):
  def VVsXF6():
   FFwgGB(pvObj.VVPq2Z)
   pvObj.close()
  FFRMYv(pvObj, VVsXF6, "Delete Screenshot File ?\n\n%s" % pvObj.VVPq2Z, title="Screen Shot")
 @staticmethod
 def VV181X(SELF, title, VV1rS5, install=True, cbFnc=None):
  try:
   from PIL import Image
   return True
  except:
   if install:
    FFRMYv(SELF, BF(CC6u6z.VVG5xJ, SELF, VV1rS5, cbFnc=cbFnc), "Imaging Library is required.\n\nInstall ?", title=title, VV1rS5=VV1rS5)
   return False
 @staticmethod
 def VVG5xJ(SELF, VV1rS5, cbFnc=None):
  if pyVersion[0] >= 3: name = "python3-pillow"
  else    : name = "python-imaging"
  if VV1rS5: fnc = BF(FF7yGJ, VVoasw=cbFnc)
  else    : fnc = BF(FFbi5l , VVoasw=cbFnc)
  fnc(SELF, FF5sZa(VVwFAi, name), VV62hm=True, title="Installing Imaging Library")
 @staticmethod
 def VV7K5o(session):
  valid = False
  origTitle = clnTitle = skinName = ""
  x = y = w = h = 0
  obj = session.current_dialog
  if obj:
   skinName = obj.skinName
   if isinstance(skinName, list) : skinName = "-".join(skinName)
   else       : skinName = str(skinName)
   inst = obj.instance
   if inst:
    origTitle = inst.getTitle()
    pos, size = inst.position(), inst.size()
    x, y, w, h = pos.x(), pos.y(), size.width(), size.height()
    valid = w != 0 and h !=0
    clnTitle = FFOu5Y(origTitle.strip(), r"-")
    clnTitle = FFMYNg(clnTitle, "-")
  return valid, origTitle, clnTitle, skinName, x, y, w, h
 @staticmethod
 def VVgrEx(session):
  valid, origTitle, clnTitle, skinName, x, y, w, h = CC6u6z.VV7K5o(session)
  return skinName.lower() in ("hotkeysetup", "buttonsetup", "spaQButton")
 @staticmethod
 def VVOO8R(path, x, y, w, h, scaleToScreen=True):
  try:
   from PIL import Image
   im = Image.open(path)
   x1 = w + x
   y1 = h + y
   if scaleToScreen:
    scrW, scrH = FFrPd1()
    w, h = im.size
    if w != scrW or h != scrH:
     x  = FFjFSv(x , 0, scrW, 0, w)
     y  = FFjFSv(y , 0, scrH, 0, h)
     x1 = FFjFSv(x1, 0, scrW, 0, w)
     y1 = FFjFSv(y1, 0, scrH, 0, h)
   im = im.crop((x, y, x1, y1))
   im.save(path)
   return True
  except:
   return False
 @staticmethod
 def VV5h28(path):
  size = FFXhoc(path)
  sizeTxt = CClYaF.VV99gM(size) if size > -1 else ""
  try:
   from PIL import Image
   im = Image.open(path)
   form = im.format
   mode = im.mode
   resTxt = "%d x %d" % im.size
  except:
   resTxt = form = mode = ""
  return size, sizeTxt, resTxt, form, mode
 @staticmethod
 def VVZLHD(path):
  try:
   from PIL import Image
   im = Image.open(path)
   w, h = im.size
   return w, h, ""
  except IOError as e:
   return -1, -1, "Error: %s" % str(e)
  except:
   pass
  res = FFTKR0("ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=X:p=0 '%s' 2> /dev/null" % path)
  if "X" in res:
   w, h = res.split("X")
   if w.isdigit() and h.isdigit():
    w, h, = int(w), int(h)
    if w > 0 and h > 0:
     return w, h, ""
  return -1, -1, res or "Error"
 @staticmethod
 def VVV85P(path, maxW, maxH, toRgb=True):
  curW, curH, err = CC6u6z.VVZLHD(path)
  if err or (curW <= maxW and curH <= maxH): return False, curW, curH, curW, curH
  w, h = min(curW, maxW), min(curH, maxH)
  try:
   from PIL import Image
   im = Image.open(path)
   im = im.resize((w, h))
   if toRgb and im.mode == "CMYK": im = im.convert("RGB")
   im.save(path)
   return True, curW, curH, w, h
  except:
   if FFayeZ("ffmpeg") and FFpwZS("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, path)):
    return True , curW, curH, w, h
   else:
    return False, curW, curH, curW, curH
 @staticmethod
 def VVQuYE(pixMap, path, toPng=False):
  if not FFCyVu(path):
   return ""
  sz = pixMap.instance.size()
  w, h = sz.width(), sz.height()
  fil, ext = os.path.splitext(path)
  tFile = "%s_ajp_%sx%s%s" % (fil, w, h, ".png" if toPng else ext)
  if FFCyVu(tFile):
   return tFile
  else:
   try:
    from PIL import Image
    im = Image.open(path)
    im = im.resize((w, h))
    im.save(tFile)
    return tFile
   except:
    if FFayeZ("ffmpeg") and FFpwZS("ffmpeg -y -i '%s' -vf scale=%s:%s '%s'" % (path, w, h, tFile)):
     return tFile
    else:
     return ""
 @staticmethod
 def VVZKCF(path, headers=""):
  tab1 = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
  tab2 = lambda Dic, nm, k: tab1(nm, FFYjVd(Dic, k))
  mExt, mCat, mTitle = CC6u6z.VVQvWl(path)
  if not mExt:
   return ""
  txt  = "\n" + FFGEAF(("%s Metadata" % mTitle).strip(), VVFuwR )
  try:
   res = FFQ45w("ffprobe -loglevel 0 %s -of json -show_format -show_streams -show_chapters '%s'" % (headers, path))
   d = jLoads(res)
   d1 = d["format"]
   dur = FFYjVd(d1, "duration")
   if FFajKn(dur):
    dur = "%s\t( %s sec )" % (FFFHEC(float(dur)), dur.rstrip("0").rstrip("."))
   sz = FFYjVd(d1, "size")
   if sz.isdigit():
    sz = "%s\t( %s )" % (sz, CClYaF.VV99gM(int(sz), mode=4))
   txt += tab1("Duration"  , dur   )
   txt += tab1("File Size"  , sz   )
   txt += tab2(d1, "Bit Rate" , "bit_rate" )
   txt += tab2(d1, "Format" , "format_name" )
   txt += tab2(d1, "Streams" , "nb_streams" )
   txt += tab1("Chapters"  , len(d["chapters"]))
   if "tags" in d1:
    d1 = d1["tags"]
    tm = FFYjVd(d1, "creation_time")
    span = iSearch(r"(.+)T(.+)\.", tm)
    txt += tab2(d1, "Encoder" , "encoder")
    txt += tab1("Created", "  ".join(span.groups()) if span else tm)
   for d1 in d["streams"]:
    ind = FFYjVd(d1, "index"  )
    typ = FFYjVd(d1, "codec_type" )
    frmR= FFYjVd(d1, "r_frame_rate")
    frmR= frmR if frmR != "0/0" else ""
    w = FFYjVd(d1, "width" )
    h = FFYjVd(d1, "height" )
    dim = " x ".join((w, h)) if w and h else ""
    txt += "\n"
    txt += FFjt5L(tab1("Stream - %s" % ind, typ.title()), VVZtfx)
    txt += tab2(d1, "Codec"   , "codec_name"  )
    txt += tab1("Dimensions"  , dim    )
    txt += tab2(d1, "Aspect Ratio" , "display_aspect_ratio")
    txt += tab2(d1, "Pixel Format"  , "pix_fmt"   )
    txt += tab1("Frame Rate"  , frmR    )
    txt += tab2(d1, "Sample Rate" , "sample_rate"  )
    txt += tab2(d1, "Frames"  , "nb_frames"  )
    txt += tab2(d1, "Channels"  , "channels"  )
    txt += tab2(d1, "Ch. Layout"  , "channel_layout" ).title()
    if "tags" in d1:
     txt += tab2(d1["tags"], "Title"  , "title" )
     txt += tab2(d1["tags"], "Language"  , "language").title()
   return txt
  except:
   return ""
 @staticmethod
 def VVFs8l(path, headers=""):
  lst = []
  try:
   res = FFQ45w("ffprobe -loglevel 0 %s -of json -show_chapters '%s'" % (headers, path))
   for item in jLoads(res)["chapters"]:
    try:
     tm = float(FFYjVd(item, "start_time"))
     if tm > 0:
      tmTxt = FFFHEC(tm)
      pts = int(tm * 90000)
      name = ""
      if "tags" in item:
       name = FFYjVd(item["tags"], "title")
      lst.append(("%s   %s" % (tmTxt, name), pts))
    except:
     pass
  except:
   pass
  return lst
 @staticmethod
 def VVmdd5(VVZcRP, VV1wIO):
  path = headers = ""
  if FFUl6q(VVZcRP):
   url = VVZcRP.replace(":" + VV1wIO, "")
   if "chCode=" in url:
    if "j.php" in url:
     pass
    else:
     path = iSub(r"[&?]mode=.+end=", r"", url, flags=IGNORECASE)
     p, err = CC96QG.VV9eVr(VVZcRP)
     head = p.portal_latestResponse["headers"] if p else ""
     auth = "Authorization"
     if head and auth in head:
      headers  = '-headers "%s: %s"' % (auth, head[auth])
      headers += " -headers $'Cookie: mac=%s; stb_lang=en\r\n'" % p.VVvRlC
   else:
    path = url
  return path, headers
 @staticmethod
 def VVQvWl(path):
  ext = os.path.splitext(path)[1]
  mExt = mCat = mName = ""
  for cat, lst in CCHmnm.VViatp().items():
   if cat in ("mov", "pic", "mus"):
    if ext in lst:
     mExt, mCat = ext, cat
     break
    else:
     for x in lst:
      if "." + x in path:
       mExt, mCat = x, cat
       break
  return mExt, mCat, {"mov": "Video", "pic": "Picture", "mus": "Audio"}.get(mCat, "")
 @staticmethod
 def VVtAiS():
  try:
   import pickle, zlib
   with open("%sMisc/inf.png" % FF0cqc(), 'rb') as f:
    return pickle.loads(zlib.decompress(f.read().split(bytearray.fromhex("6082"))[1]))
  except:
   return None
 @staticmethod
 def VVZxjK(i):
  try: return FFqmPQ(CC6u6z.VVtAiS()[i][1:-1])
  except: return None
class CCEBvG(Screen):
 def __init__(self, session, title, fontsList, defFnt, withRestart, chFontSz, regF):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 1400, 1000, 40, 40, 30, "#0a001100", "#10110000", 30, VVeFSs=220, VVUuJZ={"topBtnEW":25})
  self.session = session
  self.fontsList = fontsList
  self.defFnt  = defFnt
  self.chFontSz = chFontSz
  self.regF  = regF
  self.defScale = CFG.fontScaleSys.getValue()
  txt = FFjt5L(" (Requires GUI Restart)", VVIH76) if withRestart else ""
  VV3wat = []
  for path in self.fontsList:
   VV3wat.append((os.path.splitext(os.path.basename(path))[0], path))
  VV3wat.sort(key=lambda x: x[0].lower())
  VV3wat.insert(0, VVAL3j)
  VV3wat.insert(0, ("Reset to Default%s" % txt, "DEFAULT"))
  self.VVBGsZ = 0
  if self.defFnt:
   for ndx, item in enumerate(VV3wat):
    if len(item) == 2 and item[1] == self.defFnt:
     VV3wat[ndx] = (VVSGsk + item[0] + "  (Current font)", item[1])
     self.VVBGsZ = ndx
     break
  else:
   VV3wat[self.VVBGsZ] = (VVSGsk + VV3wat[self.VVBGsZ][0], VV3wat[self.VVBGsZ][1])
  FFZMxC(self, VV3wat=VV3wat, title=title)
  self["keyRedTop"] = Label("%s%%" % self.defScale)
  self["keyGreenTop"] = Label("Current")
  self["keyYellowTop"]= Label("Font -")
  self["keyBlueTop"] = Label("Font +")
  for s in ("Red", "Green", "Yellow", "Blue"):
   self["key%sTop1" % s] = Label()
   if not chFontSz and s != "Green":
    self["key%sTop" % s].hide()
    self["key%sTop1" % s].hide()
  FFBep1(self,
  {
   "red" : BF(self.VVTpvn,  0),
   "green" : self.VVsl6c   ,
   "yellow": BF(self.VVTpvn, -5),
   "blue" : BF(self.VVTpvn,  5),
   "cancel": self.cancel
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FFWgBS(self, isTopBar=True)
  FF2GM8(self)
  self["myBar"].setText(self.VVE1ob())
  self["myBar"].instance.setHAlign(1)
  self["myMenu"].onSelectionChanged.append(self.VVcmBw)
  self.VVcmBw()
 def VVPr1F(self):
  self["myMenu"].onSelectionChanged = []
  self.close((self["myMenu"].l.getCurrentSelection()[1], self.defScale))
 def cancel(self):
  self["myMenu"].onSelectionChanged = []
  self.close("")
 def VVsl6c(self):
  self["myMenu"].moveToIndex(self.VVBGsZ)
 def VVTpvn(self, val):
  if not self.chFontSz:
   return
  ok = False
  if  val == 0       : self.defScale, ok = 100, True
  elif val < 0 and self.defScale == 70 : FF28n1(self, "Minimum Scale = 70%", 500)
  elif val > 0 and self.defScale == 140: FF28n1(self, "Maximum Scale = 140%", 500)
  else         : self.defScale, ok = self.defScale + val, True
  if ok : self.VVcmBw()
 def VVcmBw(self):
  path = self["myMenu"].l.getCurrentSelection()[1]
  if FFCyVu(path):
   fnt = "AJP_Sample"
   FFXcbU(path, fnt, scale=self.defScale, isRepl=1, save=False)
  elif FFCyVu(self.regF):
   fnt = "AJP_Sample"
   FFXcbU(self.regF, fnt, scale=self.defScale, isRepl=1, save=False)
  else:
   fnt = VV8nt5
  try:
   inst = self["myMenu"].instance
   inst.setFont(gFont(fnt, self.VVfOli["VVgbF2"]))
   inst.invalidate()
  except:
   try:
    l = self["myMenu"].l
    l.setFont(gFont(fnt, self.VVfOli["VVgbF2"]))
    l.invalidate()
   except:
    pass
  self["myBar"].instance.setFont(gFont(fnt, int(self.VVfOli["VVgbF2"] * 1.3)))
  self["myBar"].instance.invalidate()
  if self.chFontSz:
   self["keyRedTop"].setText("%s%%" % self.defScale)
   FFGUI5(self["keyRedTop"], "#00aaffaa" if self.defScale == 100 else "#00ffeebb")
 def VVE1ob(self):
  txt = ""
  for i in range(65, 91): txt += chr(i)
  txt += "\n"
  for i in range(97, 123): txt += chr(i)
  txt += "  "
  for i in range(48, 58): txt += chr(i)
  txt += "\n"
  txt += u"\u0623\u0628\u062c\u062f \u0647\u0648\u0632 \u062d\u0637\u064a \u0643\u0644\u0645\u0646 \u0633\u0639\u0641\u0635 \u0642\u0631\u0634\u062a \u062b\u062e\u0630 \u0636\u0638\u063a  \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669"
  return str(txt)
 @staticmethod
 def VV9FYu():
  lst, regF = set(), ""
  for name, scale, repl, fName, fPath, skinF in FFcFmA():
   lst.add(fPath)
   if name == "Regular": regF = fPath
  for fil in FFkzic(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"): lst.add(fil)
  return sorted(list(lst)), regF
 @staticmethod
 def VVpZFB(SELF, title, defFnt, rest, VVbYwR, chFontSz):
  fLst, regF = CCEBvG.VV9FYu()
  defFnt = defFnt or regF
  if fLst : SELF.session.openWithCallback(VVbYwR, CCEBvG, title, fLst, defFnt, rest, chFontSz, regF)
  else : FFdw58(SELF, "No fonts found.", title=title)
class CC3yRP(Screen):
 def __init__(self, session, path, VV3wat, title):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 1700, 1000, 40, 40, 30, "#11001122", "#11002233", 30, VVrz9u=50)
  self.session = session
  self.path  = path
  FFZMxC(self, VV3wat=VV3wat, title=title)
  self["myLabelFrm"] = Label()
  self["myLabelTit"] = Label("Result Sample")
  self["myLabelTxt"] = Label()
  FFHlAU(self,
  {
   "ok"  : self.VVPr1F   ,
   "cancel" : self.cancel   ,
   "pageUp" : self.VVeXFp,
   "chanUp" : self.VVeXFp,
   "pageDown" : self.VVQ0fH ,
   "chanDown" : self.VVQ0fH ,
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
  FFZ0AC(self["myLabelFrm"], "#11110000")
  FFZ0AC(self["myLabelTit"], "#11663322")
  FFZ0AC(self["myLabelTxt"], "#11110000")
  self["myMenu"].onSelectionChanged.append(self.VVE83j)
  self.VVE83j()
 def VVE83j(self):
  if FFCyVu(self.path): txt = FFYVq0(self.path, maxSize=1000, encLst=[self["myMenu"].l.getCurrentSelection()[1]])
  else     : txt = "Review error !"
  self["myLabelTxt"].setText(txt.strip())
 def VVPr1F(self):
  self["myMenu"].onSelectionChanged = []
  self.close(self["myMenu"].l.getCurrentSelection()[1])
 def cancel(self):
  self["myMenu"].onSelectionChanged = []
  self.close("")
 def VVeXFp(self) : self["myMenu"].moveToIndex(0)
 def VVQ0fH(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
class CC7ocD():
 @staticmethod
 def VVmFe6():
  return [None, "utf-8"] + ["iso-8859-%d" % i for i in range(1,17)] + ["windows-125%d" % i for i in range(1,9)]
 @staticmethod
 def VVOFk8(SELF):
  import sys, locale
  lst = []
  c1 = "#f#00ffbbff#"
  c2 = "#f#00ffffaa#"
  lst.append(("Language Code"     , locale.getdefaultlocale()[0]  ))
  lst.append(("Default Locale Encoding"  , locale.getdefaultlocale()[1]  ))
  lst.append((c1 + "Preferred Encoding"  , c1 + locale.getpreferredencoding(False)))
  lst.append((c2 + "System Default Encoding" , c2 + sys.getdefaultencoding()  ))
  lst.append((c2 + "Filesystem Encoding"  , c2 + sys.getfilesystemencoding() ))
  c = "#f#11aaffff#"
  for item in locale.setlocale(locale.LC_ALL).split(";"):
   parts = item.split("=")
   if len(parts) == 2:
    lst.append((c + parts[0], c +
    parts[1]))
  FFUQ0v(SELF, None, VVGape=lst, VVwdmN=30, VVKDPJ=1)
 @staticmethod
 def VV51oT(path, SELF=None):
  for enc in CC7ocD.VVmFe6():
   try:
    with ioOpen(path, "r", encoding=enc) as f:
     for line in f:
      pass
    return enc
   except:
    pass
  if SELF:
   FFdw58(SELF, "Cannot detect file encoding for:\n\n%s" % path)
  return -1
 @staticmethod
 def VVm9FZ(path):
  for enc in CC7ocD.VVmFe6():
   try:
    c = 0
    with ioOpen(path, "r", encoding=enc) as f:
     for line in f:
      c += 1
    return enc, c
   except:
    pass
  return -1, 0
 @staticmethod
 def VVRTBW(path, enc):
  try:
   with ioOpen(path, "r", encoding=enc) as f:
    for line in f:
     pass
   return True
  except:
   return False
 @staticmethod
 def VV9PZW(SELF, path, cbFnc, curEnc=VV9iuh, title="Select Encoding"):
  lst = CC7ocD.VVZyMn(SELF, path, "")
  if lst:
   SELF.session.openWithCallback(cbFnc, CC3yRP, path, lst, title)
 @staticmethod
 def VViA40(SELF, cbFnc, curEnc=VV9iuh, title="Select Encoding"):
  lst = CC7ocD.VVZyMn(SELF, "", "")
  if lst:
   FFLFTC(SELF, cbFnc, title=title, VV3wat=lst, width=1000, height=1000, VVwltY="#22220000", VVkxBG="#22220000")
 @staticmethod
 def VVZyMn(SELF, path, curEnc):
  lst = CC7ocD.VV5QBn(path)
  if lst:
   VV3wat = []
   for name, enc in lst:
    txt = "%s (%s)" % (name, enc)
    if   enc == curEnc   : c = VVSGsk
    elif enc == VV9iuh: c = VV1fx4
    else      : c = ""
    VV3wat.append((c + txt, enc))
   return VV3wat
  else:
   FFjADj(SELF, "No proper encoding", 2000)
 @staticmethod
 def VV5QBn(path=""):
  encLst = []
  cPath = VVIp2p + "_sup_codecs"
  if FFCyVu(cPath):
   lines = FFL19l(cPath)
   for line in lines:
    parts = line.split("\t")
    if len(parts) == 2:
     encLst.append((parts))
  if not encLst:
   tmp = list(CC7ocD.VVmFe6())
   tmp.pop(0)
   encLst = [("General", ",".join(tmp))]
  lst = []
  for item in encLst:
   for enc in (item[1].split(",")):
    if path:
     try:
      with ioOpen(path, "r", encoding=enc) as f:
       for line in f:
        pass
      lst.append((item[0], enc))
     except:
      pass
    else:
     lst.append((item[0], enc))
  return lst
class CC674y(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 900, 950, 50, 40, 30, "#22003300", "#22001100", 30)
  self.session  = session
  VV3wat = []
  VV3wat.append(("Settings File"   , "SettingsFile" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Box Info"     , "VVetBc"  ))
  VV3wat.append(("Tuners Info"    , "VVtK13" ))
  VV3wat.append(("Python Version"   , "VVUKRb" ))
  VV3wat.append(("Stream Relay Patch"  , "VVluJ6" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Screen Size"    , "ScreenSize"  ))
  VV3wat.append(("Language/Locale"   , "Locale"   ))
  VV3wat.append(("Processor"    , "Processor"  ))
  VV3wat.append(("Operating System"   , "VViKIV" ))
  VV3wat.append(("Drivers (Kernel Object)"     , "VVOcsB"))
  VV3wat.append(("Drivers (Loadable Kernel Modules - LKM)" , "VV1ECU" ))
  VV3wat.append(("Drivers (Built-in Kernel Modules)"  , "VVHkKI" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("System Users"    , "SystemUsers"   ))
  VV3wat.append(("Logged-in Users"   , "LoggedInUsers"  ))
  VV3wat.append(("Uptime"     , "Uptime"    ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Host Name"    , "HostName"   ))
  VV3wat.append(("MAC Address"    , "MACAddress"   ))
  VV3wat.append(("Network Configuration" , "NetworkConfiguration"))
  VV3wat.append(("Network Status"   , "NetworkStatus"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Disk Usage"    , "VVu1Uy"   ))
  VV3wat.append(("Mount Points"    , "VVTdXJ"  ))
  VV3wat.append(("File System Table (FSTAB)", "VVGciC"  ))
  VV3wat.append(("USB Devices"    , "USB_Devices"   ))
  VV3wat.append(("Block-Devices List"  , "blockDevices"  ))
  VV3wat.append(("Directory Size"   , "DirectorySize"  ))
  VV3wat.append(("Memory"     , "Memory"    ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Running Processes"  , "RunningProcesses" ))
  VV3wat.append(("Processes with open files", "ProcessesOpenFiles" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Bootloader Second-stage (old DreamBox only)" , "DreamBoxBootloader"))
  FFZMxC(self, VV3wat=VV3wat, title="Device Information")
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "SettingsFile"   : self.session.open(CCUImU)
   elif item == "VVetBc"   : self.VVetBc()
   elif item == "VVtK13"  : self.VVtK13()
   elif item == "VVUKRb"  : self.VVUKRb()
   elif item == "VVluJ6"  : self.VVluJ6()
   elif item == "ScreenSize"   : FF4lCP(self, "Width\t: %s\nHeight\t: %s" % (FFrPd1()[0], FFrPd1()[1]))
   elif item == "Locale"    : CC7ocD.VVOFk8(self)
   elif item == "Processor"   : self.VVyUAC()
   elif item == "VViKIV"  : self.VViKIV()
   elif item == "VVOcsB"  : self.VVOcsB()
   elif item == "VV1ECU"  : self.VV1ECU()
   elif item == "VVHkKI"  : self.VVHkKI()
   elif item == "SystemUsers"   : FFZQVC(self, "id")
   elif item == "LoggedInUsers"  : FFZQVC(self, "who -a")
   elif item == "Uptime"    : FFZQVC(self, "uptime")
   elif item == "HostName"    : FFZQVC(self, "hostname")
   elif item == "MACAddress"   : self.VVxHe9()
   elif item == "NetworkConfiguration" : FFZQVC(self, "ifconfig %s %s" % (FFSPDv("HWaddr", VVcPtB), FFSPDv("addr:", VV1fx4)))
   elif item == "NetworkStatus"  : FFZQVC(self, "netstat -tulpn", VVwdmN=24)
   elif item == "VVu1Uy"   : self.VVu1Uy()
   elif item == "VVTdXJ"  : self.VVTdXJ()
   elif item == "VVGciC"  : self.VVGciC()
   elif item == "USB_Devices"   : FFZQVC(self, "lsusb")
   elif item == "blockDevices"   : FFZQVC(self, "blkid")
   elif item == "DirectorySize"  : FFZQVC(self, "du -shc /* 2> /dev/null | sed '/total/i-----\t-------------' | sed 's/total/TOTAL/g'")
   elif item == "Memory"    : FFZQVC(self, "cat /proc/meminfo | sed 's/ //g' | sed 's/:/\t: /g' | sed '/MemAvailable/a%s'" % ("-" * 25), consFont=False)
   elif item == "RunningProcesses"  : FFZQVC(self, "ps")
   elif item == "ProcessesOpenFiles" : FFZQVC(self, "lsof")
   elif item == "DreamBoxBootloader"  : self.VVft8B()
   else        : self.close()
 def VVxHe9(self):
  res = FFQ45w("ip link")
  list = iFindall(r"[0-9]+:\s+(.+):\s+.+\n.+\s+(.+)brd", res, IGNORECASE)
  if list:
   txt = ""
   for item in list:
    brd = item[0].upper()
    mac = item[1].upper()
    if not brd == "LO":
     txt += "%s\t: %s\n" % (item[0].upper(), item[1].upper())
   FF4lCP(self, txt)
  else:
   FFZQVC(self, "ip link")
 @FFOAKH()
 def VVu1Uy(self):
  VVAkuK, cols = [], 0
  for cmd, cols in (("df -aTh", 7), ("df -ah", 6)):
   txt = FFQ45w(cmd)
   if not "invalid option" in txt:
    for line in txt.split("\n"):
     parts = line.split()
     if len(parts) >= cols and not "Mounted on" in line:
      VVAkuK.append(parts[:cols])
    break
  if VVAkuK:
   if cols == 7:
    header  = ("Filesystem" , "Type", "Size", "Used", "Available" , "Use %", "Mounted on" )
    widths  = (25   , 12 , 10 , 9  , 10   , 9  , 25   )
    VVLIqP = (LEFT   , CENTER, CENTER, CENTER, CENTER  , CENTER, LEFT   )
   else:
    header  = ("Filesystem" , "Size", "Used", "Available" , "Use %", "Mounted on" )
    widths  = (30   , 11 , 11 , 11   , 11 , 26   )
    VVLIqP = (LEFT   , CENTER, CENTER, CENTER  , CENTER, LEFT   )
   VVAkuK.sort(key=lambda x: x[0].lower())
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, width=1700, height=1000, VVpCEu=True, VV3cHe=widths, VVwdmN=28)
  else:
   FFdw58(self, "Cannot get data !")
 def VVTdXJ(self):
  lines = FF3xOt("mount")
  VVAkuK = []
  for line in lines:
   span = iSearch(r"(.+)\son\s(.+)\stype\s(.+)\s\((.+)\)", line, IGNORECASE)
   if span:
    VVAkuK.append(span.groups())
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   header  = ("Device/FS" , "Mount Point" , "VFS Type", "Mount Options")
   widths  = (20   , 25   , 13  , 42 )
   VVLIqP = (LEFT   , LEFT   , CENTER , LEFT )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVpCEu=True)
  else:
   FFdw58(self, "Cannot process data.")
 def VVGciC(self):
  lst =  []
  for line in FFL19l("/etc/fstab"):
   s1 = line.strip().split()
   if len(s1) == 6:
    lst.append(s1)
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   header  = ("Device" , "Mount Point" , "FS Type" , "Options" , "Backup" , "FS Check")
   widths  = (24  , 24   , 10  , 24  , 9   , 9   )
   VVLIqP = (LEFT  , LEFT   , CENTER , LEFT  , CENTER , CENTER )
   FFUQ0v(self, None, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVpCEu=True, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0="#0a282828")
  else:
   FFdw58(self, "Cannot read FSTAB !\n\n( or no data )")
 @FFOAKH()
 def VVHkKI(self):
  def VVZwiy(p1, bg=""):
   tLst =  []
   for line in FF3xOt("find '%s' -maxdepth 1 -type f | sort" % p1):
    vals = FFL19l(os.path.join(p1, line))
    if vals:
     tLst.append((bg + FFxtW5(line).strip().capitalize(), vals[0].strip()))
   return sorted(tLst, key=lambda x: x[0].lower())
  lst =  []
  for line in FF3xOt("cat /lib/modules/$(uname -r)/modules.builtin"):
   if line.startswith("kernel"):
    driv = os.path.splitext(os.path.basename(line))[0]
    p1 = "/sys/module/%s/" % driv
    p2 = os.path.join(p1, "parameters/")
    tot1 = len([f for f in os.listdir(p1) if FFL19l(p1 + f)]) if VVmJwX(p1) else 0
    tot2 = len([f for f in os.listdir(p2) if FFL19l(p2 + f)]) if VVmJwX(p2) else 0
    lst.append((driv, line, "Yes" if tot1 + tot2 > 0 else ""))
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   VV2ytr = ("", self.VVdw3L, [])
   header  = ("Driver" , "Name", "Info")
   widths  = (36   , 57 , 7  )
   VVLIqP = (LEFT  , LEFT, CENTER )
   FFUQ0v(self, None, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVpCEu=True, VVwdmN=28, VV2ytr=VV2ytr, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0="#0a282828")
  else:
   FFdw58(self, "Cannot read Builtin Drivers List !")
 @FFOAKH()
 def VVOcsB(self):
  lst = []
  for line in FF3xOt("find /lib/modules/ -iname *.ko"):
   lst.append((os.path.splitext(os.path.basename(line))[0], line))
  if lst : FFUQ0v(self, None, header=("Driver", "Path"), VVGape=sorted(lst, key=lambda x: x[0].lower()), VV3cHe=(20, 80), VVpCEu=True, VVwdmN=26)
  else : FFdw58(self, "No list found !")
 @FFOAKH()
 def VV1ECU(self):
  lst =  []
  for line in FF3xOt("lsmod"):
   s1 = line.split()
   Len = len(s1)
   if Len >= 3 and s1[1] != "Size":
    if   Len == 3: lst.append(s1)
    else   : lst.append(s1[:2] + [" ".join(s1[2:])])
  if lst:
   bg = "#11000600"
   lst.sort(key=lambda x: x[0].lower())
   VV2ytr = ("", self.VVdw3L, [])
   header  = ("Module" , "Size", "Used By" )
   widths  = (30  , 15 , 55  )
   VVLIqP = (LEFT  , CENTER, LEFT  )
   FFUQ0v(self, None, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVpCEu=True, VVwdmN=28, VV2ytr=VV2ytr, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0="#0a282828")
  else:
   FFdw58(self, "Cannot get drivers Info !")
 @FFOAKH(par=1)
 def VVdw3L(self, VV6A99, title, txt, colList):
  driv = colList[0]
  lst1, lst3 = [], []
  for line in FF3xOt("modinfo %s" % driv):
   if ":" in line:
    subj, _, val = line.partition(":")
    subj, val = subj.strip().capitalize(), val.strip()
    if not val.startswith("ERROR"):
     tLst = lst1 if subj in ("Filename", "Version", "Author", "Description", "License", "Srcversion", "Depends", "Vermagic") else lst3
     tLst.append((subj, val))
  def VVZwiy(p1, bg=""):
   tLst =  []
   for line in FF3xOt("find '%s' -maxdepth 1 -type f | sort" % p1):
    vals = FFL19l(os.path.join(p1, line))
    if vals:
     tLst.append((bg + FFxtW5(line).strip().capitalize(), vals[0].strip()))
   return sorted(tLst, key=lambda x: x[0].lower())
  path = "/sys/module/%s" % driv
  lst2 = [("#b#0a220000#" + a, b) for (a,b) in VVZwiy(path) if (a,b) not in lst1]
  lst4 = VVZwiy(os.path.join(path, "parameters"), "#b#0a221133#")
  lst1 = [("#b#11000a0f#" + a,b) for a,b in lst1]
  lst3 = [("#b#0a003344#" + a,b) for a,b in lst3]
  VVGape = lst1 + lst2 + lst3 + lst4
  bg, title = "#11001122", "Driver : %s" % driv
  if VVGape: FFUQ0v(self, None, title=title, VVGape=VVGape, VV3cHe=(40, 60), VVKDPJ=1, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00883300", VVbcr0="#0a444444")
  else  : FFdw58(self, "No Driver Info !", title=title)
 def VVyUAC(self):
  cmd  = "RES=$(uname -m | awk '{print toupper($0)}');"
  cmd += "if [ -z \"$RES\" ] ; then RES=$(uname -a | awk '{print toupper($12)}'); fi;"
  cmd += "if [ -z \"$RES\" ] ; then echo 'Could not read Info.!'; else echo $RES; fi"
  FFZQVC(self, cmd)
 def VViKIV(self):
  FFZQVC(self, "uname -a")
 def VVft8B(self):
  cmd = FFoY7E(VVZDGE, "| grep secondstage")
  if cmd : FFZQVC(self, 'output=$(%s); if [ -z "$output" ] ; then echo "Not found for this receiver."; else echo $output; fi' % cmd)
  else : FFfone(self)
 def VVetBc(self):
  c1, c2, c3 = "#b#11000a0f#", "#b#0a220000#", "#b#0a003344#"
  VVGape = []
  VVGape.append((c1 + "Box Type"  , self.VVOq0L("boxtype").upper() ))
  VVGape.append((c1 + "Board Version" , self.VVOq0L("board_revision") ))
  VVGape.append((c1 + "Chipset"  , self.VVOq0L("chipset")   ))
  VVGape.append((c1 + "S/N"   , self.VVOq0L("sn")    ))
  VVGape.append((c1 + "Version"  , self.VVOq0L("version")   ))
  VVvZXX   = []
  VVSBVq = ""
  try:
   from Components.SystemInfo import SystemInfo
   keysList = list(SystemInfo)
   if keysList:
    for key in keysList:
     if key == "canMultiBoot":
      VVSBVq = SystemInfo[key]
     else:
      VVvZXX.append((c3 + str(key), str(SystemInfo[key])))
  except:
   pass
  if VVSBVq:
   VVbnnF = self.VVUG40(VVSBVq, c2)
   if VVbnnF:
    VVbnnF.sort(key=lambda x: x[0].lower())
    VVGape += VVbnnF
  if VVvZXX:
   VVvZXX.sort(key=lambda x: x[0].lower())
   VVGape += VVvZXX
  if VVGape:
   header  = ("Subject" , "Value")
   widths  = (40    , 60)
   FFUQ0v(self, None, header=header, VVGape=VVGape, VV3cHe=widths, VVwdmN=28, VVKDPJ=1, VVoRat="#00ffff00", VVJKqd="#0a884400")
  else:
   FF4lCP(self, "Could not read info!")
 def VVOq0L(self, fileName):
  fileName = "/proc/stb/info/" + fileName
  if FFCyVu(fileName):
   try:
    txt = FFL19l(fileName)[0]
    if txt:
     return txt
   except:
    pass
  return "-"
 def VVUG40(self, mbDict, bg):
  try:
   mbList = list(mbDict)
   VVGape = []
   for key in mbList:
    bootDict = mbDict[key]
    device  = bootDict.get("device"  , "")
    rootsubdir = bootDict.get("rootsubdir" , "")
    startupfile = bootDict.get("startupfile", "")
    subject  = "Multiboot-" + str(key)
    value  = ""
    if startupfile : subject += " ... "      + startupfile
    if rootsubdir : value  += "Root-Sub-Dir = %s  ...  " % rootsubdir
    if device  : value  += "Device = "     + device
    if not value:
     value  = str(bootDict)
    VVGape.append((bg + subject, value))
  except:
   pass
  return VVGape
 def VVtK13(self):
  title = "Tuners"
  c1 = "#f#00ffff88#"
  sName = [c1 + "Slot Name"]
  Type = [c1 + "Type"]
  Descr = [c1 + "Description"]
  conn = [c1 + "Connectable to"]
  fId  = [c1 + "Frontend ID"]
  sId  = [c1 + "Slot ID"]
  mType = [c1 + "Multi-Type"]
  mStream = [c1 + "Multi-Stream"]
  FCB  = [c1 + "FCB"]
  bScan = [c1 + "Supports Blind-Scan"]
  tot = 0
  for ndx, slot in enumerate(nimmanager.nim_slots):
   if slot.frontend_id is not None:
    tot += 1
    sName.append(slot.getSlotName())
    Type.append(slot.getType())
    Descr.append(slot.getFriendlyFullDescription())
    conn.append(" , ".join(slot.connectableTo()))
    fId.append(str(slot.frontend_id))
    sId.append(slot.getSlotID())
    mType.append("Yes" if slot.isMultiType() else "No")
    try:  mStream.append("Yes" if slot.isMultistream() else "No")
    except:  mStream.append("?")
    try:  FCB.append("Yes" if slot.isFBCTuner() else "No")
    except:  FCB.append("?")
    try:  bScan.append("Yes" if slot.supportsBlindScan() else "No")
    except:  bScan.append("?")
  if tot:
   VVAkuK = []
   VVAkuK.append(sName)
   VVAkuK.append(Type)
   VVAkuK.append(Descr)
   VVAkuK.append(conn)
   VVAkuK.append(fId)
   VVAkuK.append(sId)
   VVAkuK.append(mType)
   VVAkuK.append(mStream)
   VVAkuK.append(FCB)
   VVAkuK.append(bScan)
   FFUQ0v(self, None, title="%s (Total = %s)" % (title, tot), VVGape=VVAkuK, width=1700, height=1000, VVKDPJ=1)
  else:
   FFdw58(self, "No Tuner Info.", title=title)
 def VVUKRb(self):
  major   = pyVersion[0]
  minor   = pyVersion[1]
  micro   = pyVersion[2]
  releaselevel = pyVersion[3]
  serial   = pyVersion[4]
  txt = "Version\t: %d.%d.%d\n" % (major, minor, micro)
  txt += "Release\t: %s\n"  % releaselevel
  txt += "Serial\t: %d\n"   % serial
  FF4lCP(self, txt)
 def VVluJ6(self):
  if CCYrUm.VVWp6i():
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt = tab("Stream Relay", "Supported")
   host, port = CCYrUm.VVbfMb()
   txt += tab("Hosts List", host or "?")
   txt += tab("Port", port or "?")
   txt += tab("Total Services", len(CCYrUm.VVtXqQ()))
   FF4lCP(self, txt, width=900)
  else:
   FFdw58(self, "Patch not found.")
 @staticmethod
 def VVSwko():
  def VVJi7Q(v, ndx):
   lst = v.split(";")[ndx].split(",")
   return {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
  v = "openbox,OpenBox,openpli,OpenPLI,openvision,OpenVision;areadeltasat,ArEaDeltaSat,cobralibero,Cobralibero,opentr,OpenTR,peter,PeterPan,Gemini,Gemini;italysat,ItalySat,oozoon,OoZooN,openatv,openATV,openeight,OpenEight,openmips,OpenMips,opennfr,OpenNFR,openplus,OpenPlus,openspa,OpenSPA,pure2,Pure2,rudream,ruDream,teamblue,teamBlue,titannit,OpenAFF_Titan"
  v = {"/etc/issue": VVJi7Q(v,0), "/etc/issue.net": VVJi7Q(v,1), "/etc/image-version": VVJi7Q(v,2)}
  for p1, d in v.items():
   img = CC674y.VVyFLu(p1, d)
   if img: return img
  v = "Blackhole,Blackhole,DE,Dream-Elite,EGAMI,Egami,LT,LT,MediaSat,MediaSat,OPENDROID,OpenDroid,Bp/geminimain,GP3;Domica,Domica,DreamElite,Dream-Elite,GP4,GP4,SatLodge,Satlodge,Satdreamgr,SatdreamGr,TSimage,OpenTS_Ts,newnigma2,newnigma2;DemonisatManager,DDD-Demoni,VTIPanel,VTI,ViX,OpenVIX;AddOnManager,Merlin3,DreamOSatcamManager,DreamOSat CamManager,ExtraAddonss,OpenESI,HDF-Toolbox,OpenHDF,HDMUCenter,HDMU,LDteam,OpenLD,NssPanel,NonSoloSat,PKT,PKT,PowerboardCenter,PBNigma-VX,TDW,TDW"
  p = "/usr/lib/enigma2/python/"
  v = {p: VVJi7Q(v,0), p + "Plugins/": VVJi7Q(v,1), VVhDOZ: VVJi7Q(v,2), VVUytA: VVJi7Q(v,3)}
  for p1, d in v.items():
   img = CC674y.VVdVCf(p1, d)
   if img: return img
  return "OpenBlackhole" if iGlob("%sScreens/BpBlue.p*" % p) else ""
 @staticmethod
 def VVyFLu(path, d):
  if FFCyVu(path):
   txt = FFYVq0(path).lower()
   for key, val in d.items():
    if key.lower() in txt: return val
  return ""
 @staticmethod
 def VVdVCf(path, d):
  for key, val in d.items():
   if VVmJwX(path + key): return val
  return ""
 @staticmethod
 def VV1LWx():
  return VVmJwX(VVhDOZ + "VTIPanel")
class CCUImU(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 700, 630, 50, 40, 30, "#22003300", "#22001100", 32)
  self.session  = session
  VV3wat = []
  VV3wat.append(("Settings (All)"   , "all" ))
  VV3wat.append(("Settings (Hot Keys)"  , "hk" ))
  VV3wat.append(("Settings (Tuner/DiSEqC)" , "tun" ))
  VV3wat.append(("Settings (Plugins)"  , "plug"))
  VV3wat.append(("Settings (Usage)"   , "usg" ))
  VV3wat.append(("Settings (Time Zone)"  , "tz" ))
  VV3wat.append(("Settings (Skin)"   , "sk" ))
  FFZMxC(self, VV3wat=VV3wat)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "all" : g = ""
   elif item == "hk" : g = ("config.misc.ButtonSetup." if CCxSED.VVdBQ3() else "config.misc.hotkey.")
   elif item == "tun" : g = "config.Nims."
   elif item == "plug" : g = ".plugins."
   elif item == "usg" : g = ".usage."
   elif item == "tz" : g = ".timezone."
   elif item == "sk" : g = ".skin."
   title = self["myMenu"].l.getCurrentSelection()[0]
   lst = []
   for line in FF3xOt("cat %s%s" % (VVfBVj, (" | grep %s" % g) if g else "")):
    k, _, v = line.partition("=")
    k, v = k.strip(), v.strip() or "-"
    if not g or g in line:
     lst.append((k.strip() or "-", v.strip() or "-"))
   if lst : FFUQ0v(self, None, title=title, header=("Key", "Value"), VVGape=lst, VVwdmN=28, VVpCEu=True)
   else : FFdw58(self, "No settings changes found.", title=title)
class CCid3A(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 950, 800, 50, 40, 30, "#22003300", "#22001100", 30)
  self.VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
  self.session  = session
  self.VV4gQd  = VV4gQd
  self.camInfo_cmd = camCommand + " -V 2> /dev/null"
  camName = "SoftCam"
  nC = oC = c = ""
  if VV4gQd:
   c = VVJEMb if VVmNNN else VVZtfx
   if   "oscam" in VV4gQd : camName, oC = "OSCam", c
   elif "ncam"  in VV4gQd : camName, nC = "NCam" , c
  VV3wat = []
  VV3wat.append(("OSCam Files" , "OSCamFiles" ))
  VV3wat.append(("NCam Files" , "NCamFiles" ))
  VV3wat.append(("CCcam Files" , "CCcamFiles" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((VVFuwR + 'Convert "/etc/CCcam.cfg" to OSCam/NCam Readers', "VVAyqf"))
  VV3wat.append(VVAL3j)
  VV3wat.append((oC + "OSCam Readers" , "OSCamReaders"))
  VV3wat.append((nC + "NCam Readers" , "NSCamReaders"))
  VV3wat.append(VVAL3j)
  camCmd = os.path.basename(camCommand)
  txt = "%s Settings%s" % (camName, "" if camCmd in ("oscam", "ncam") else " ( %s )" % camCmd)
  VV3wat.append(FFsLU5(txt, "camInfo", VV4gQd, c))
  VV3wat.append(VVAL3j)
  camLst = ((c + camName + " Live Status" , "camLiveStatus" )
    , (c + camName + " Live Log" , "camLiveLog"  ))
  if VV4gQd:
   for item in camLst: VV3wat.append(item)
  else:
   for item in camLst: VV3wat.append((item[0], ))
  FFZMxC(self, title="SoftCam Tools", VV3wat=CCid3A.VV2wVK(VV3wat, 5))
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "OSCamFiles"  : self.session.open(CC3v50, "oscam")
   elif item == "NCamFiles"  : self.session.open(CC3v50, "ncam")
   elif item == "CCcamFiles"  : self.session.open(CC3v50, "cccam")
   elif item == "VVAyqf" : self.VVAyqf()
   elif item == "VVgo8Z" : self.VVgo8Z()
   elif item == "OSCamReaders"  : self.VVL8Lp("os")
   elif item == "NSCamReaders"  : self.VVL8Lp("n")
   elif item == "camInfo"   : self.VVm7sR(self.camInfo_cmd)
   elif item == "camLiveStatus" : CCid3A.VVgHEe(self.session, True)
   elif item == "camLiveLog"  : CCid3A.VVgHEe(self.session, False)
   else       : self.close()
 def VVm7sR(self, cmd):
  lines = FF3xOt(cmd)
  VVAkuK = []
  for line in lines:
   line = line.strip()
   if ":" in line:
    parts = line.split(":")
    key  = parts[0].strip()
    val  = parts[1].strip()
    VVAkuK.append((key, val))
   elif line:
    VVAkuK.append((line, ""))
  if VVAkuK:
   header   = ("Parameter" , "Value" )
   widths   = (50    , 50  )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=28, VVpCEu=True)
  else:
   FFZQVC(self, cmd)
 def VVAyqf(self):
  path = CCid3A.VVWxDt()
  outFile = "%scccam_to_reader_%s.txt" % (FF0cqc(), FFjTQe())
  if FFCyVu(path):
   lines = FFL19l(path)
   lst = []
   for line in lines:
    line = line.strip()
    if line.startswith("C:"):
     while "  " in line: line = line.replace("  ", " ")
     parts = line.split(" ")
     if len(parts) == 5:
      CTxt, host, port, User, Pass = parts
      lst.append((host, port, User, Pass))
   newLine = []
   if lst:
    VVJi7Q = lambda txt, val: "%s= %s\n" % (txt.ljust(30), str(val))
    with open(outFile, "w") as f:
     for ndx, item in enumerate(lst, start=1):
      host, port, User, Pass = item
      f.write("[reader]\n")
      f.write(VVJi7Q("label"    , "CCcam-Line-%d" % ndx))
      f.write(VVJi7Q("description"  , "CCcam-Line-%d" % ndx))
      f.write(VVJi7Q("protocol"   , "cccam"))
      f.write(VVJi7Q("device"    , "%s,%s" % (host, port)))
      f.write(VVJi7Q("user"    , User))
      f.write(VVJi7Q("password"   , Pass))
      f.write(VVJi7Q("fallback"   , "1"))
      f.write(VVJi7Q("group"    , "64"))
      f.write(VVJi7Q("cccversion"   , "2.3.2"))
      f.write(VVJi7Q("audisabled"   , "1"))
      f.write(VVJi7Q("ccckeepalive"  , "1"))
      f.write("\n")
    tot = len(lst)
    FFipXT(self, "Output = %d Reader%s in:\n\n%s" % (tot, FFcacr(tot), outFile))
   else:
    FF28n1(self, "No valid CCcam lines", 1500)
  else:
   FF28n1(self, "%s not found" % path, 1500)
 def VVgo8Z(self):
  CCh3tv.VV7Nf4(self, VVixvy=self.VVs6qu, VVbYwR=self.VVOgyS)
 def VVs6qu(self, VVXyP6):
  ttl = "Processing ..."
  VVXyP6.VVNc18 = ("", "Not found")
  dic = CC6u6z.VVtAiS()
  if dic : VVXyP6.VVq8NF(len(dic[1]) + 4)
  else : return
  lst1 = []
  uErr = []
  uNoLn = []
  for uNum, u in enumerate(dic[1], start=1):
   u = FFqmPQ(u[1:-1])
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVaks5(u.partition("/")[0] if VVBvqf else ttl)
   VVXyP6.VVxtQs(1)
   res, err = CCHRcZ.VVcUJs("https://%s" % u, timeout=4)
   if res:
    span = iSearch(r"(C: \S+ \d+ \S+ [^\s<]+)", res.text, IGNORECASE)
    if span : lst1.append(str(span.group(1)).strip().replace("c:", "C:"))
    else : uNoLn.append(u)
   elif err:
    uErr.append(u)
  lst2 = []
  u = FFqmPQ(dic[2][1:-1])
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVaks5((u + " (P1)") if VVBvqf else ttl)
  VVXyP6.VVxtQs(1)
  res, err = CCHRcZ.VVcUJs("https://%s" % u, timeout=2)
  if res:
   span = iSearch(r'<a href="(.+)">%s<\/a>' % FFQqEJ("RnJlZSBDQ2NhbSBzZXJ2ZXJz"), res.text, IGNORECASE)
   if span:
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVaks5((u + " (P2)") if VVBvqf else ttl)
    VVXyP6.VVxtQs(1)
    res, err = CCHRcZ.VVcUJs(span.group(1), timeout=2)
    if res:
     lst2 = iFindall(r"(C:\s+.+)#", res.text) or []
     lst2 = list(map(str.strip, list(map(str, lst2))))
     lst2.sort()
    elif err: uErr.append(u)
  elif err: uErr.append(u)
  if not lst2: uNoLn.append(u)
  lst3 = []
  u = FFqmPQ(dic[3][1:-1])
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVaks5(u  if VVBvqf else ttl)
  VVXyP6.VVxtQs(1)
  res, err = CCHRcZ.VVcUJs("https://%s" % u, timeout=2)
  if res:
   lst3 = iFindall(r"(C:\s+.+)<\/a>", res.text) or []
   lst3 = list(map(str.strip, list(map(str, lst3))))
   lst3.sort()
  elif err: uErr.append(u)
  if not lst3: uNoLn.append(u)
  if not lst1 and not lst2 and not lst3:
   VVXyP6.VVNc18 = ("", "No lines found")
   return
  sep1 = "#" + " %s %s %s" % ("=" * 15, FFwjLg(), "=" * 15)
  sep2 = "#" + " " + "-" * 51
  lst = ["", sep1]
  lst.extend(lst1)
  if lst1 and lst2: lst.append(sep2)
  lst.extend(lst2)
  if lst1 or lst2: lst.append(sep2)
  lst.extend(lst3)
  totL = len(lst1) + len(lst2) + len(lst3)
  def VVONcs(p):
   patt = r"^#\s={10,}\s.+\s={10,}"
   fLines, totR  = [], 0
   oldLines = FFL19l(p)
   Max = len(oldLines) - 1
   for ndx, ln in enumerate(oldLines):
    ln = str(ln).strip()
    if ndx < Max:
     nextL = oldLines[ndx + 1].strip()
     if   iMatch(patt, ln) and (iMatch(patt, nextL) or not nextL or nextL.startswith("#")) : continue
     elif (ln == sep2) and (not nextL or nextL == sep2 or iMatch(patt, nextL))    : continue
    if not ln or ln.startswith("#"):
     fLines.append(ln)
    else:
     Code = ln.partition("#")[0].strip()
     if not Code in lst : fLines.append(ln)
     elif Code   : totR += 1
   return fLines, totR
  def VV9EHD(p, lines):
   fTxt = "\n".join(lines).strip()
   while "\n\n\n" in fTxt: fTxt = fTxt.replace("\n\n\n", "\n\n")
   with open(p, "w") as f: f.write("%s\n" % fTxt)
  f1 = CCid3A.VVWxDt()
  fLines, totR1 = VVONcs(f1)
  fLines.extend(lst)
  VV9EHD(f1, fLines)
  f2 = CCid3A.VVv8H6()
  totR2 = 0
  if FFCyVu(f2):
   fLines, totR2 = VVONcs(f2)
   fLines.extend(lst)
   VV9EHD(f2, fLines)
  c1 = VVFuwR
  ttl = lambda x: "%s:\n" % FFjt5L(x, c1)
  txt1  = ttl("Updated Files")
  txt1 += "  %s%s\n" % (f1, ("   (Replaced : %s)" % totR1) if totR1 else "")
  if FFCyVu(f2): txt1 += "  %s%s\n" % (f2, ("   (Replaced : %s)" % totR2) if totR2 else "")
  if VVBvqf:
   txt = txt1
   if uErr:
    txt += "\n" + ttl("With Errors")
    txt += "  %s\n" % "\n  ".join(uErr)
   if uNoLn:
    txt += "\n" + ttl("With no Lines")
    txt += "  %s\n" % "\n  ".join(uNoLn)
   txt += "\n%s" % FFGEAF("Added Lines (%s)" % totL, VVJEMb)
   txt += "\n".join(lst)
  else:
   txt  = ttl("Added Lines")
   txt += "  %s\n\n" % totL
   txt += txt1
  VVXyP6.VVNc18 = (txt, "")
 def VVOgyS(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVRI6P:
   txt, err = VVNc18
   if err  : FFdw58(self, err)
   elif not txt: FFdw58(self, "Not found")
   else:
    FF4lCP(self, txt)
    CCid3A.VVaomc(self.session)
 @FFOAKH()
 def VVL8Lp(self, VVX2Ni):
  VVAkuK = CCid3A.VVj372(self, VVX2Ni)
  if VVAkuK:
   VVAkuK.sort(key=lambda x: int(x[0]))
   if self.VV4gQd and self.VV4gQd.startswith(VVX2Ni):
    VVwWmA = ("Delete Reader" , BF(self.VV2zpk, VVX2Ni) , [])
    VVwSzI = ("Toggle State"  , self.VV6saL, [VVX2Ni]     , "Changing State ...")
    VVpCEu = False
   else:
    VVwWmA = VVwSzI = None
    VVpCEu = True
   bg = "#22000011"
   header   = ("No." , "State" , "Label" , "Description" , "Host", "Port", "Protocol", "User", "Password")
   widths   = (4  , 5    , 28    , 16   , 14 , 6   , 9   , 9  , 9   )
   VVLIqP  = (CENTER , CENTER , LEFT   , LEFT   , LEFT , CENTER, LEFT  , LEFT , LEFT  )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, height=1000, VVwdmN=24, VVpCEu=VVpCEu, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVHPI7=True
     , VVwltY="#22002030", VVkxBG=bg, VVemyB=bg, VVJKqd="#00664411", VVbcr0="#00444444", VVX9AA="#08442211")
 def VVqc5j(self, VV6A99, VVX2Ni):
  VVAkuK = CCid3A.VVj372(self, VVX2Ni)
  if VVAkuK : VV6A99.VVMqQ9(VVAkuK)
  else  : VV6A99.cancel()
 def VVj372(self, VVX2Ni):
  rFile = "%s%scam.server" % (self.VVtkkP, VVX2Ni)
  if FFCyVu(rFile):
   lst = CCid3A.VValww(rFile)
   if not lst: FFdw58(self, "No readers found !")
   return lst
  else:
   FF8Wsn(self, rFile)
   return []
 def VV2zpk(self, VVX2Ni, VV6A99, title, txt, colList):
  num, stt, lbl, dscr, hst, prt, prot, usr, pas = colList
  FFRMYv(self, BF(CCid3A.VVQGgp, VV6A99, lbl, cbFnc=BF(self.VVqc5j, VV6A99, VVX2Ni)), "%s\n\nDelete ?" % lbl, title="Delete Reader")
 def VV6saL(self, VV6A99, VVX2Ni):
  confFile = "%s%scam.conf" % (self.VVtkkP, VVX2Ni)
  readerState = VV6A99.VVeE40(1)
  readerLabel = VV6A99.VVeE40(2)
  if "off" in readerState.lower() : newState = "enable"
  else       : newState = "disable"
  urlAction = "&label=%s&action=%s" % (FFSiPR(readerLabel), newState)
  uReq = CCid3A.VVJssd(self, VVX2Ni, confFile, "readerlist", urlAction)
  if uReq:
   try:
    page = iUrlopen(uReq, timeout=4)
   except Exception as e:
    VV6A99.VVrmMb()
    FFdw58(self, "Cannot connect to SoftCAM !\n\nError = %s" % str(e))
    return
   self.VVqc5j(VV6A99, VVX2Ni)
  else:
   VV6A99.VVrmMb()
 @staticmethod
 def VVJssd(SELF, VVX2Ni, confFile, urlPart, urlAction, typ="html"):
  if FFCyVu(confFile):
   lines = FFL19l(confFile)
   user = "root"
   pwd  = port = ""
   if lines:
    webif = False
    for line in lines:
     line = line.strip().lower()
     if "[webif]" in line:
      webif = True
     if webif and "=" in line:
      if   line.startswith("httpuser"): user = line.split("=")[1].strip()
      elif line.startswith("httppwd") : pwd = line.split("=")[1].strip()
      elif line.startswith("httpport"): port = line.split("=")[1].strip()
   if not webif:
    FFdw58(SELF, "Cannot connect to SoftCAM Web Interface !")
    return None
   elif not port:
    FFdw58(SELF, "SoftCAM Web Port not found in file:\n\n%s" % confFile)
    return None
  else:
   FF8Wsn(SELF, confFile)
   return None
  if not iRequest:
   FFdw58(SELF, "Module not found\n\nurllib/urllib2")
   return None
  try:
   url = "http://127.0.0.1:%s/%scamapi.%s?part=%s%s" % (port, VVX2Ni, typ, urlPart, urlAction)
   acceccManager = HTTPPasswordMgrWithDefaultRealm()
   acceccManager.add_password(None, url, user, pwd)
   handlers= HTTPDigestAuthHandler(acceccManager)
   opener = build_opener(HTTPHandler, handlers)
   install_opener(opener)
   return iRequest(url)
  except Exception as e:
   FFdw58(SELF, "Error while preparing URL Request !\n\n %s" % str(e))
   return None
 @staticmethod
 def VVYmCL():
  VVtkkP = "/etc/tuxbox/config/"
  VV4gQd = None
  VVmNNN  = None
  camCommand = FFTKR0(r"lsof | grep 'oscam\|ncam' | tail -1 | awk '{print $2}'")
  if camCommand:
   camCmd = os.path.basename(camCommand).lower()
   if   camCmd.startswith("oscam") : VV4gQd = "oscam"
   elif camCmd.startswith("ncam") : VV4gQd = "ncam"
  if VV4gQd:
   tStr = os.path.basename(camCommand).lower()
   for path in iGlob("/etc/init.d/softcam.*"):
    _, _, camName = os.path.basename(path).lower().partition(".")
    if camName == tStr:
     fTxt = FFYVq0(path)
     span = iSearch(r"-config-dir\s(\/etc\/tuxbox.*?)\s", fTxt, IGNORECASE)
     if span:
      VVtkkP = FFoWxR(span.group(1))
      var = "$CAMNAME"
      if var in VVtkkP:
       span = iSearch(r'CAMNAME="(.+)"', fTxt, IGNORECASE)
       if span:
        VVtkkP = VVtkkP.replace(var, span.group(1))
      break
   else:
    path = FFTKR0(camCommand + " -V 2> /dev/null | grep -i configdir | awk '{print $2}'")
    path = FFoWxR(path)
    if VVmJwX(path):
     VVtkkP = path
   tFile = FFoWxR(VVtkkP) + VV4gQd + ".conf"
   tFile = FFTKR0("FILE='%s'; [ -f $FILE ] && cat $FILE | grep -i LOGFILE | awk '{print $3}'" % tFile)
   if FFCyVu(tFile):
    VVmNNN = tFile
  return VVtkkP, VV4gQd, VVmNNN, camCommand
 @staticmethod
 def VVw1zi(SELF=None):
  VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
  VVX2Ni = confFile = ""
  if VV4gQd:
   VVX2Ni = "os" if "oscam" in VV4gQd else "n"
   confFile = "%s%scam.conf" % (VVtkkP, VVX2Ni)
  elif SELF:
   FFdw58(SELF, message="No active OSCam/NCam")
  return VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile
 @staticmethod
 def VV6ows(SELF, part, act, typ="html"):
  VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile = CCid3A.VVw1zi(SELF)
  return CCid3A.VVJssd(SELF, VVX2Ni, confFile, part, act, typ=typ) if VV4gQd else None
 @staticmethod
 def VV27G2():
  VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile = CCid3A.VVw1zi()
  return "%s%scam.server" % (VVtkkP, VVX2Ni) if VV4gQd else ""
 @staticmethod
 def VVv8H6():
  VVtkkP, VV4gQd, VVmNNN, camCommand, VVX2Ni, confFile = CCid3A.VVw1zi()
  return ("%sCCcam.cfg" % VVtkkP) if VVtkkP else ""
 @staticmethod
 def VVWxDt():
  return "/etc/CCcam.cfg"
 @staticmethod
 def VVFzc8():
  return (CCid3A.VVWxDt(), CCid3A.VVv8H6())
 @staticmethod
 def VValww(rFile):
  lst  = []
  tag  = "[reader]"
  lines = FFL19l(rFile)
  tagFound= False
  enable = label = description = url = port = protocol = User = password = ""
  onStr = "#f#1100ff00#" + "ON"
  offStr = "OFF"
  for ndx, line in enumerate(lines):
   if tag in line.lower() or ndx >= len(lines) - 1:
    if enable or label or description or url or port or protocol or User or password:
     if enable == "": enable = onStr
     lst.append((str(len(lst) + 1), enable, label, description, url, port, protocol, User, password))
    enable = label = description = url = port = protocol = User = password = ""
   elif "=" in line:
    key, _, val = line.partition("=")
    key, val = key.strip().lower(), val.strip()
    if   key == "label"   : label   = val
    elif key == "description" : description = val
    elif key == "protocol"  : protocol  = val
    elif key == "user"   : User   = val
    elif key == "password"  : password  = val
    elif key == "enable"  : enable = offStr if val == "0" else onStr
    elif key == "device"  :
     url, _, port = val.partition(",")
     url, port = url.strip(), port.strip()
  return lst
 @staticmethod
 @FFOAKH("Deleting ...")
 def VVQGgp(SELF, lbl, delCC=True, cbFnc=None):
  if delCC: CCid3A.VV9mPr(lbl)
  uReq = CCid3A.VV6ows(SELF, "readerlist", "&label=%s&action=delete" % FFSiPR(lbl), typ="json")
  if uReq:
   try:
    res = iUrlopen(uReq, timeout=4)
    if cbFnc: cbFnc()
   except:
    FFjADj(SELF, "Cannot access SoftCam", 2000)
 @staticmethod
 def VV9mPr(dLbl):
  relatedReaders = []
  rFile = CCid3A.VV27G2()
  rLst = [(hst, prt, usr, pas) for num, stt, lbl, dscr, hst, prt, prot, usr, pas in CCid3A.VValww(rFile) if lbl==dLbl]
  for f in CCid3A.VVFzc8():
   c, lines = 0, []
   for ln in FFL19l(f):
    span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)\s+(\S+)", ln.strip())
    if span and span.groups() in rLst:
     ln = "#" + ln
     c += 1
    lines.append(ln)
   if c > 0:
    with open(f, "w") as f:
     f.write("%s\n" % "\n".join(lines))
 @staticmethod
 def VVaomc(session):
  cmd, name = CCid3A.VVAAze()
  if cmd:
   def VVZwiy(*args): CCYrUm.VV0iSP(session)
   CCaTk8().VVtIZD("%s restart" % cmd, VVZwiy)
 @staticmethod
 def VVAAze():
  try:
   c = os.path.realpath("/etc/init.d/softcam")
   if not c.endswith(".None"): return c, os.path.split(c)[1].partition(".")[2]
  except:
   pass
  return "", ""
 @staticmethod
 def VVgHEe(session, VVpLzn):
  VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
  if VV4gQd: session.open(CC6dXO, VVtkkP=VVtkkP, VV4gQd=VV4gQd, VVmNNN=VVmNNN, VVpLzn=VVpLzn)
  else  : FFzcnp(session, message="No active OSCam/NCam", title="Live Log")
 @staticmethod
 def VVAilv(SELF):
  if iElem:
   return True
  else:
   FFdw58(SELF, "Module not found:\n\nxml.etree")
   return False
 @staticmethod
 def VV2wVK(lst, i):
  t = CC6u6z.VVZxjK(900)
  if t and VVBvqf: lst.insert(i, (VVFuwR + t, "VVgo8Z"))
  return lst
class CC3v50(Screen):
 def __init__(self, session, VVqTGx):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 700, 650, 50, 40, 30, "#22003300", "#22001100", 30)
  self.session  = session
  self.VVtkkP, VV4gQd, VVmNNN, camCommand = CCid3A.VVYmCL()
  if   VVqTGx == "ncam" : self.prefix = "n"
  elif VVqTGx == "oscam" : self.prefix = "os"
  else     : self.prefix = ""
  VV3wat = []
  if self.prefix == "":
   VV3wat.append(("CCcam.cfg"         , "c_CCcam_cfg"  ))
   VV3wat.append(("ecm.info"          , "c_ecm_info"  ))
  else:
   VV3wat.append(("AutoRoll.Key"         , "x_AutoRoll_Key" ))
   VV3wat.append(("constant.cw"         , "x_constant_cw" ))
   VV3wat.append((self.prefix + "cam.ccache"      , "x_cam_ccache" ))
   VV3wat.append((self.prefix + "cam.conf"      , "x_cam_conf"  ))
   VV3wat.append((self.prefix + "cam.dvbapi"      , "x_cam_dvbapi" ))
   VV3wat.append((self.prefix + "cam.provid"      , "x_cam_provid" ))
   VV3wat.append((self.prefix + "cam.server"      , "x_cam_server" ))
   VV3wat.append((self.prefix + "cam.services"     , "x_cam_services" ))
   VV3wat.append((self.prefix + "cam.srvid2"      , "x_cam_srvid2" ))
   VV3wat.append((self.prefix + "cam.user"      , "x_cam_user"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("SoftCam.Key / SoftCam.key"     , "x_SoftCam_Key" ))
   VV3wat.append(("CCcam.cfg"         , "x_CCcam_cfg"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append((self.prefix + "cam.log (last 100 lines)"  , "x_cam_log"  ))
   VV3wat.append((self.prefix + "cam.log-prev (last 100 lines)" , "x_cam_log_prev" ))
   VV3wat.append((self.prefix + "cam.pid"      , "x_cam_pid"  ))
  FFZMxC(self, VV3wat=VV3wat)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  pathTmp = "/tmp/"
  if item is not None:
   if   item == "c_CCcam_cfg"  : FFaOUK(self, "/var/etc/CCcam.cfg")
   elif item == "c_ecm_info"  : FFaOUK(self, "/tmp/ecm.info")
   elif item == "x_AutoRoll_Key" : FFaOUK(self, self.VVtkkP + "AutoRoll.Key")
   elif item == "x_constant_cw" : FFaOUK(self, self.VVtkkP + "constant.cw")
   elif item == "x_cam_ccache"  : self.VVaJjM("cam.ccache")
   elif item == "x_cam_conf"  : self.VVaJjM("cam.conf")
   elif item == "x_cam_dvbapi"  : self.VVaJjM("cam.dvbapi")
   elif item == "x_cam_provid"  : self.VVaJjM("cam.provid")
   elif item == "x_cam_server"  : self.VVaJjM("cam.server")
   elif item == "x_cam_services" : self.VVaJjM("cam.services")
   elif item == "x_cam_srvid2"  : self.VVaJjM("cam.srvid2")
   elif item == "x_cam_user"  : self.VVaJjM("cam.user")
   elif item == "x_SEP"   : pass
   elif item == "x_SoftCam_Key" : self.VVEmlc()
   elif item == "x_CCcam_cfg"  : FFaOUK(self, self.VVtkkP + "CCcam.cfg")
   elif item == "x_SEP"   : pass
   elif item == "x_cam_log"  : FFaOUK(self, pathTmp + self.prefix + "cam.log")
   elif item == "x_cam_log_prev" : FFaOUK(self, pathTmp + self.prefix + "cam.log-prev")
   elif item == "x_cam_pid"  : FFaOUK(self, pathTmp + self.prefix + "cam.pid")
   else       : self.close()
 def VVaJjM(self, fileName):
  FFaOUK(self, self.VVtkkP + self.prefix + fileName)
 def VVEmlc(self):
  path = self.VVtkkP + "SoftCam.Key"
  if FFCyVu(path) : FFaOUK(self, path)
  else    : FFaOUK(self, path.replace(".Key", ".key"))
class CC6dXO(Screen):
 def __init__(self, session, VVtkkP="", VV4gQd="", VVmNNN="", VVpLzn=False):
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1700, 950, 50, 30, 20, "#22002030", "#33000011", 25, VVeFSs=40)
  self.session   = session
  self.VVmNNN   = VVmNNN
  self.VVpLzn   = VVpLzn
  self.timer    = eTimer()
  self.VV3o4m  = False
  self.Title    = "Live Log"
  self.elementTree  = None
  self.VVCbxX   = None
  self.VVNiEs  = False
  self.user    = "root"
  self.pwd    = ""
  self.port    = ""
  self.VV6A99  = None
  self.period    = 3000
  if "oscam" in VV4gQd : titleTxt, self.VVX2Ni = "OSCam", "os"
  else     : titleTxt, self.VVX2Ni = "NCam" , "n"
  self.confFile   = "%s%scam.conf" % (VVtkkP, self.VVX2Ni)
  if self.VVpLzn: self.Title = "  %s Status" % titleTxt
  else   : self.Title = "  %s Live Log" % titleTxt
  FFZMxC(self, self.Title, addScrollLabel=True)
  FFRLNq(self["keyRed"], "Stop")
  FFBep1(self, {"red": self.VVKNev})
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH(VV7u0U=False)
  FFWgBS(self)
  self["myBar"].instance.setHAlign(1)
  self.VVKNev()
 def onExit(self):
  self.timer.stop()
 def VVTZ90(self):
  try: self.timer_conn = self.timer.timeout.connect(self.VV0HkJ)
  except: self.timer.callback.append(self.VV0HkJ)
  self.timer.start(self.period, False)
  self.VV3o4m = True
  self.VV5jvY(True)
 def VVOZOa(self):
  self.timer.stop()
  self.VV3o4m = False
  try:
   self.timer.callback.remove(self.VV0HkJ)
  except:
   pass
  self.VV5jvY(False)
 def VV5jvY(self, isOn):
  if isOn : title, redTxt, barTxt, txt = " (Running)" , "Stop" , "Waiting for update ..." , "Started"
  else : title, redTxt, barTxt, txt = ""   , "Start", ""      , "Stopped"
  if self.VV6A99:
   self.VV6A99.VV0ZtI(self.Title + title)
   self.VV6A99["keyRed"].setText(redTxt)
   FF28n1(self.VV6A99, txt, 800)
  else:
   self["myTitle"].setText(self.Title + title)
   self["keyRed"].setText(redTxt)
   FF28n1(self, txt, 1000)
 def VVKNev(self):
  if self.VV3o4m:
   self.VVOZOa()
  else:
   self.VVTZ90()
   uReq = CCid3A.VVJssd(self, self.VVX2Ni, self.confFile, "status", "")
   if uReq and CCid3A.VVAilv(self):
    self.VVCbxX, self.elementTree = uReq, iElem
    if self.VVNiEs:
     self.VVNiEs = False
     self["myLabel"].setText("Reading from SoftCAM Interface ...")
    FFIElK(self.VV7wNh)
   else:
    self.close()
 def VV0HkJ(self):
  if self.VV3o4m:
   self.VV6Qml()
 def VV7wNh(self):
  self.VV6Qml()
 def VV6Qml(self):
  try:
   page = iUrlopen(self.VVCbxX, timeout=1).read()
   err = ""
  except iURLError as e:
   err = FFWVTk(e)
  except Exception as e:
   err = str(e)
  if err:
   self["myLabel"].setText(FFjt5L("Cannot read from SoftCAM Interface !\n\nError = %s\n\nPlease activate Softcam." % err, VVz22H))
   self.VVNiEs = True
   self.VVOZOa()
   return
  camTxt = page.decode("UTF-8")
  lines = list(map(str, camTxt.splitlines()))
  if self.VVpLzn: ok = self.VVim5j(lines)
  else   : ok = self.VVEBkn(lines)
  txt = "Last Update : %s" % FFIPdt()
  if self.VV6A99: self.VV6A99["myBar"].setText(txt)
  else     : self["myBar"].setText(txt)
  if not ok:
   FFdw58(self, "No date from SoftCam.")
   self.VVOZOa()
   if self.VV6A99: self.VV6A99.cancel()
   self.close()
 def VVim5j(self, lines):
  xmlTxt = '<?xml version="1.0" encoding="UTF-8"?>\n'
  tags = ("<status", "<client", "<request", "<times", "<connection", "</client", "</status")
  for line in lines:
   line = line.strip()
   if line.startswith(tags):
    xmlTxt += line
  parseError = False
  try:
   root = self.elementTree.fromstring(xmlTxt)
  except Exception as e:
   parseError = FFjt5L("Error while parsing data elements !\n\nError = %s" % str(e), VVYjI5)
   self.VVNiEs = True
   self.VVOZOa()
  txt = ""
  if not parseError is False:
   txt = parseError
   self["myLabel"].setText(txt, VV47Xm=VVYAtm)
  else:
   VVAkuK = []
   for client in root.findall("client"):
    name  = client.get("name", "-")
    desc  = client.get("desc", "-")
    protocol = client.get("protocol", "-")
    conn  = client.find("connection")
    if not conn is None:
     ip  = conn.get("ip", "-")
     port = conn.get("port", "-")
     status = conn.text
    else:
     ip = port = status = "-"
    stCode, fg = self.VV87ey(status)
    VVAkuK.append((name, ip, port, protocol, desc, "%s%s" % (fg, status)))
   if VVAkuK:
    VVAkuK.sort(key=lambda x: x[0].lower())
    if self.VV6A99:
     self.VV6A99.VVMqQ9(VVAkuK, VV5YRVMsg=False)
    else:
     bg = "#22000011"
     title = self.Title.strip() + " (Running)" if self.VV3o4m else ""
     VVu8qI = self.VVltJU
     VVCOpO = (""  , self.VVchAN , [])
     VVwWmA  = ("Stop"  , self.VVr2sK , [])
     VV4QTJ = ("Options" , self.VVG1TP, [])
     header = ("Label" , "Host", "Port", "Protocol", "Description" , "State" )
     widths = (32  ,  15 , 8  , 17  , 16   , 12  )
     align = (LEFT  ,  LEFT , CENTER, CENTER , LEFT   , CENTER )
     self.VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=align, VV3cHe=widths, VVwdmN=24, width=1700, height=950, VVu8qI=VVu8qI, VVCOpO=VVCOpO, VVwWmA=VVwWmA, VV4QTJ=VV4QTJ
            , VVwltY="#22002030", VVkxBG=bg, VVemyB=bg, VVJKqd="#00664411", VVbcr0="#00444444", VVX9AA="#08442211")
    return True
   else:
    return False
 def VVltJU(self, VV6A99):
  VV6A99.cancel()
  self.close()
 def VVchAN(self, VV6A99, title, txt, colList):
  VV6A99["myBar"].instance.setHAlign(1)
 def VVr2sK(self, VV6A99, title, txt, colList):
  self.VVKNev()
 def VV87ey(self, st):
  st = st.upper()
  if   st in ["OK", "CONNECTED", "CARDOK"] or st.startswith(("ON")) : c = 0
  elif any(x in st for x in ("ERROR", "UNDEF", "UNKNOWN", "OFFLINE")) : c = 1
  elif st == "OFF"             : c = 2
  else                : c = 3
  return c, {0:"#f#0055ff55#", 1:"#f#00ff8000#", 2:"#f#00aa88ff#"}.get(c, "")
 def VVG1TP(self, VV6A99, title, txt, colList):
  delLst, lblLst = [], []
  for lbl, hst, prt, Prot, Dsc, stt in VV6A99.VVrrm9():
   if not Prot in ("http", "server", "dvbapi"): lblLst.append(lbl)
   stCode, fg = self.VV87ey(stt)
   if stCode == 1: delLst.append(lbl)
  tmp = {x: lblLst.count(x) for x in lblLst}
  duplLst = []
  for lbl, cnt in tmp.items():
   if cnt > 1: duplLst.extend([lbl] * (cnt - 1))
  curLbl, hst, prt, curProt, Dsc, stt = colList
  c1, c2 = VVyFI2 , VVZtfx
  VV3wat = []
  VV3wat.append(("Delete Selected Reader", "delCur"))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Delete Inactive Readers" , "badRdr", delLst))
  VV3wat.append(FFsLU5("Delete Duplicate Readers" , "dupRdr", duplLst))
  if VVBvqf:
   VV3wat.append(VVAL3j)
   VV3wat.append(FFsLU5("Delete Inactive Lines (from CCcam.cfg Files)" , "badCc", delLst))
  FFLFTC(self, BF(self.VVDoj8, VV6A99, duplLst, delLst, curLbl, curProt), VV3wat=VV3wat, width=1000, title="Options", VVU8mZ=True)
 def VVDoj8(self, VV6A99, duplLst, delLst, curLbl, curProt, item=None):
  if item:
   title, ref, ndx = item
   if   ref == "delCur": self.VVALnL(VV6A99, delLst, curLbl, curProt)
   elif ref == "badRdr": self.VV0UE1(VV6A99, title, delLst, True)
   elif ref == "dupRdr": self.VV0UE1(VV6A99, title, duplLst, False)
   elif ref == "badCc" : self.VVIvec(delLst, title)
 def VVIvec(self, delLst, title=""):
  def VVZwiy(fil):
   lines = []
   c = 0
   for ln in FFL19l(fil):
    span = iSearch(r"^(?:C|N):\s+(\S+)\s+(\d+)\s+(\S+)", ln)
    if span and "_".join(span.groups()) in delLst:
     c += 1
     continue
    else:
     lines.append(ln)
   if c > 0:
    with open(fil, "w") as f:
     f.write("%s\n" % "\n".join(lines))
   return c
  txt = ""
  for f in CCid3A.VVFzc8():
   if FFCyVu(f):
    tot = VVZwiy(f)
    if tot: txt += "File\t: %s\nDeleted\t: %s\n\n" % (f, tot)
  if title:
   if txt:
    FF4lCP(self, txt, title)
    CCid3A.VVaomc(self.session)
   else:
    FFipXT(self, "No related lines in CCcam.cfg files.", title)
 def VV0UE1(self, VV6A99, title, delLst, delC):
  if delC: self.VVIvec(delLst)
  CCh3tv.VV7Nf4(self, VVixvy=BF(self.VVKM5K, delLst), VVbYwR=BF(self.VV6SFd, title))
 def VVKM5K(self, delLst, VVXyP6):
  totDel = totErr = 0
  VVXyP6.VVq8NF(len(delLst))
  VVXyP6.VVNc18 = (totDel, totErr)
  for lbl in delLst:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVaks5(lbl)
   VVXyP6.VVxtQs(1)
   page = None
   uReq = CCid3A.VVJssd(self, self.VVX2Ni, self.confFile, "readerlist", "&label=%s&action=delete" % FFSiPR(lbl), typ="json")
   if uReq:
    try: page = iUrlopen(uReq, timeout=4)
    except: pass
   if page : totDel += 1
   else : totErr += 1
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVNc18 = (totDel, totErr)
 def VV6SFd(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  totDel, totErr = VVNc18
  txt = "Deleted : %s" % totDel
  if totErr: txt += "\n\nFailed : %s" % totErr
  if totDel: self.VV6Qml()
  FFipXT(self, txt, title)
 def VVALnL(self, VV6A99, delLst, curLbl, curProt):
  fnc = BF(CCid3A.VVQGgp, VV6A99, curLbl, cbFnc=self.VV6Qml)
  if curProt in ("http", "server", "dvbapi") : FF28n1(VV6A99, "Cannot delete protocol=%s" % curProt, 2000)
  elif curLbl in delLst      : fnc()
  else          : FFRMYv(self, fnc, "%s\n\nDelete ?" % curLbl, title="Delete Active Reader")
 def VVEBkn(self, lines):
  txt = ""
  for line in lines:
   line = line.strip()
   span = iSearch(r"^[0-9]{4}[-\/][0-9]{2}[-\/][0-9]{2}\s+", line, IGNORECASE)
   if span:
    line = "\n" + VVIH76 + line[:19] + VVA4XU + line[19:]
    for preTxt in (" connecting to ", " from server ", " by ", "reader ", "server ", "(reader) "):
     if preTxt in line:
      if preTxt == " by " and " by WebIf" in line:
       line = line.replace("WebIf", VV9nWG + "WebIf" + VVA4XU)
      else:
       t1, t2, t3 = line.partition(preTxt)
       if t2:
        h1, h2, h3 = t3.partition(" ")
        line = t1 + t2 + VVGCYL + h1 + h2 + VVA4XU + h3
    span = iSearch(r"(.+:\s*)(found\s*)(\(\d+\s*ms\))(.+)", line, IGNORECASE)
    if span:
     line = "\n" + span.group(1) + VVSGsk + span.group(2) + VVFuwR + span.group(3) + VVA4XU + span.group(4)
    line = self.VVcAvB(line, VVFuwR, ("(webif)", ))
    line = self.VVcAvB(line, VVFuwR, ("(anticasc)", "(anticasc)", "(cache)", "(cccam)", "(chk)", "(client)", "(config)", "(dvbapi)", "(ecm)", "(emm)", "(emmcache)", "(emu)", "(main)", "(net)", "(newcamd)", "(reader)", "(stat)"))
    line = self.VVcAvB(line, VVSGsk, ("OSCam", "NCam", "log switched"))
    line = self.VVcAvB(line, VVyFI2, (": not found", "failed", "rejected group", "usr/pwd invalid", "timeout", "no matching reader", "disconnected"))
    ndx = line.find(") - ")
    if ndx > -1:
     line = line[:ndx + 3] + VV1fx4 + line[ndx + 3:] + VVA4XU
    txt += line + "\n"
  self["myLabel"].setText(txt, VV47Xm=VVYAtm)
  return bool(txt.strip())
 def VVcAvB(self, line, color, lst):
  for txt in lst:
   if txt in line:
    t1, t2, t3 = line.partition(txt)
    if t2:
     return t1 + color + t2 + VVA4XU + t3
  return line
class CCxSED(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 750, 1000, 50, 60, 30, "#10104060", "#10001A1F", 30)
  self.session  = session
  VV3wat = []
  VV3wat.append(("Backup Channels"    , "VVWyWy"   ))
  VV3wat.append(("Restore Channels"    , "VVgcOH"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Backup SoftCAM Files"   , "VVmuRi" ))
  VV3wat.append(("Restore SoftCAM Files"  , "VVrIlm" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Backup Tuner Settings"  , "bkupTuner"    ))
  VV3wat.append(("Restore Tuner Settings"  , "restTuner"    ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Backup HotKeys Settings"  , "bkupHKeys"    ))
  VV3wat.append(("Restore HotKeys Settings"  , "restHKeys"    ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Backup Enigma2 Settings File" , "VV31XB"   ))
  VV3wat.append(("Restore Enigma2 Settings File", "VV2kBT"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Backup Network Settings"  , "VVWN2f"   ))
  VV3wat.append(("Restore Network Settings"  , "VVf1ql"   ))
  if VVBvqf:
   VV3wat.append(VVAL3j)
   VV3wat.append(("Backup FHD-Glass17 Skin" , "bkupFhdg17"    ))
   VV3wat.append(("Restore FHD-Glass17 Skin" , "restFhdg17"    ))
  for i in range(0, len(VV3wat), 3):
   VV3wat[i] = (VVJEMb + VV3wat[i][0], VV3wat[i][1])
  if VVBvqf:
   c1, c2, c3, c4, c5 =VVz22H, VVSGsk, VVJEMb , VVGCYL, VVFuwR
   VV3wat.append(VVAL3j)
   VV3wat.append((c1 + "Fix Data (%s)" % VVPAan , "VVZ7sM"   ))
   VV3wat.append((c2 + "1- Create IPK"    , "VVAQWI1"  ))
   VV3wat.append((c2 + "2- Create DEB"    , "VVAQWI2"  ))
   VV3wat.append((c3 + "3- Create IPK (No Restart)" , "VVAQWI3"  ))
   VV3wat.append((c3 + "4- Create DEB (No Restart)" , "VVAQWI4"  ))
   VV3wat.append((c3 + "5- Create IPK (No Depend)" , "VVAQWI5"  ))
   VV3wat.append((c3 + "6- Create DEB (No Depend)" , "VVAQWI6"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append((c4 + "Decode Crash Report"   , "VVE342" ))
   VV3wat.append((c4 + "Show Windows Stats"   , "VVUwoK" ))
   VV3wat.append((c5 + "%s Simple Portal" % ("Disable" if CFG.simplePortal.getValue() else "Enable") , "VVjFUg" ))
  FFZMxC(self, title="Backup & Restore", VV3wat=VV3wat)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "VVWyWy"  : self.VVWyWy()
   elif item == "VVgcOH"  : self.VV7nlV("channels_backup*.tar.gz", self.VVgcOH, isChan=True)
   elif item == "VVmuRi" : self.VVmuRi()
   elif item == "VVrIlm": self.VV7nlV("softcam_backup*.tar.gz", self.VVrIlm)
   elif item == "bkupTuner"   : self.VV5ISt("tuner_backup", ["config.Nims."])
   elif item == "restTuner"   : self.VV7nlV("tuner_backup*.backup", BF(self.VVJVKe, "tuner"), isTuner=True)
   elif item == "bkupHKeys"   : self.VV5ISt("hotkey_backup", ["config.misc.hotkey.", "config.misc.ButtonSetup."])
   elif item == "restHKeys"   : self.VV7nlV("hotkey_backup*.backup", BF(self.VVJVKe, "hotk"))
   elif item == "VV31XB"  : self.VV31XB()
   elif item == "VV2kBT"  : self.VV7nlV("settings_backup*.tar.gz", self.VV2kBT)
   elif item == "VVWN2f"  : self.VVWN2f()
   elif item == "VVf1ql"  : self.VV7nlV("network_backup*.tar.gz", self.VVf1ql)
   elif item == "bkupFhdg17"   : self.VV5ISt("fhdg17_skin_backup", ["config.plugins.setupGlass17."])
   elif item == "restFhdg17"   : self.VV7nlV("fhdg17_skin_backup*.backup", BF(self.VVJVKe, "fhdg17"))
   elif item == "VVZ7sM"   : FFRMYv(self, BF(FF2JFr, self.session, BF(CCxSED.VVZ7sM, self)), "Erase previous obf ?")
   elif item.startswith("VVAQWI") : self.VVAQWI(int(item[-1]))
   elif item == "VVE342" : self.VVE342()
   elif item == "VVUwoK"  : CCxSED.VVUwoK(self)
   elif item == "VVjFUg" : self.VVjFUg()
 def VVjFUg(self):
  FFjt1c(CFG.simplePortal, not CFG.simplePortal.getValue())
  self.close()
 @staticmethod
 def VVA6y8(SELF):
  OBF_Path = VV231J + "OBF/"
  if FFCyVu(OBF_Path + "obf.py"):
   from sys import path as iPath
   iPath.append(OBF_Path)
   try: from imp import reload
   except: from importlib import reload
   try: from .OBF import obf
   except: import obf
   reload(obf)
   return obf
  else:
   FF8Wsn(SELF, OBF_Path)
   return None
 @staticmethod
 def VVUwoK(SELF):
  obf = CCxSED.VVA6y8(SELF)
  if obf:
   txt, title = obf.windowsStats()
   FF4lCP(SELF, txt, title=title, VVRhqH="WinStat")
 @staticmethod
 def VVZ7sM(SELF):
  obf = CCxSED.VVA6y8(SELF)
  if obf:
   txt, err = obf.fixCode(VV231J, VVJ6zn, VVPAan)
   if err : FFdw58(SELF, err)
   else : FF4lCP(SELF, txt, height=1050)
 def VVAQWI(self, mode):
  OBF_Path = VV231J + "OBF/"
  files = iGlob("%s*main_final.py" % OBF_Path)
  if not files:
   FFdw58(self, "Final File .py not found in:\n\n%s" % OBF_Path)
   return
  FFpwZS("rm -f %s__pycache__/" % VV231J)
  self.session.open(CCxz86, path=VV231J, VVyCS0=mode in (2, 4, 6), VVKTL7=mode in (3, 4), VVc8YP=mode not in (5, 6))
 def VVE342(self):
  path = "/tmp/OBF/"
  if not VVmJwX(path):
   FFdw58(self, "Path not found:\n%s" % path)
   return
  files = iGlob("%s*.log" % path)
  if not files:
   FFdw58(self, "No log files in:\n\n%s" % path)
   return
  codF, err = self.VVwsxh("%s*.list" % path)
  if err:
   FF8Wsn(self, path + "*.list")
   return
  srcF, err = self.VVwsxh("%s*main_final.py" % path)
  if err:
   FF8Wsn(self, path + "*.final.py")
   return
  VVGape = []
  for f in files:
   f = os.path.basename(f)
   VVGape.append((f, f))
  FFLFTC(self, BF(self.VVnARS, path, codF, srcF), VV3wat=VVGape)
 def VVnARS(self, path, codF, srcF, item=None):
  if item:
   logF = path + item
   if not FFCyVu(logF) : FF8Wsn(self, logF)
   else     : self.VVVXq5(logF, codF, srcF)
 @FFOAKH()
 def VVVXq5(self, logF, codF, srcF):
  lst  = []
  lines = FFL19l(codF)
  for line in lines:
   line = line.split(":")[1]
   parts = line.split("->")
   lst.append((parts[1].strip(), parts[0].strip()))
  if not lst:
   FFdw58(self, "No codes in : %s" % codF)
   return
  newLogF = logF.replace(".log", ".NEW.log")
  totLog  = self.VVCoa9(lst, logF, newLogF)
  if totLog == 0:
   FFdw58(self, "No match found in this version for:\n\n%s" % os.path.basename(logF))
   return
  newSrcF = srcF.replace(".py" , ".DBG.py")
  totSrc  = self.VVCoa9(lst, srcF, newSrcF)
  txt = "Found\t: %s\nIn\t: %s\n\nFound\t: %s\nIn\t: %s\n\nNew Files\t:\n" % (totLog, logF, totSrc, srcF)
  if not totLog and not totSrc:
   txt += "None"
  else:
   if totLog: txt += "    %s\n" % newLogF
   if totSrc: txt += "    %s\n" % newSrcF
  FF4lCP(self, txt)
 def VVwsxh(self, patt):
  tFiles = iGlob(patt)
  if not tFiles:
   return "", "*.list"
  f = tFiles[0]
  if not FFCyVu(f):
   return "", "Not found:\n\n"
  return f, ""
 def VVCoa9(self, lst, f1, f2):
  txt = FFYVq0(f1)
  tot = 0
  for item in lst:
   if item[0] in txt:
    tot += 1
   txt = txt.replace(item[0], item[1])
  if tot > 0:
   with open(f2, "w") as f:
    f.write(txt)
  return tot
 def VVWyWy(self):
  path1 = VVQe79
  path2 = "/etc/tuxbox/"
  VVGape = []
  VVGape.append("%s%s" % (path1, "*.tv"))
  VVGape.append("%s%s" % (path1, "*.radio"))
  VVGape.append("%s%s" % (path1, "*list"))
  VVGape.append("%s%s" % (path1, "*list_*"))
  VVGape.append("%s%s" % (path1, "lamedb*"))
  VVGape.append("%s%s" % (path2, "*.xml"))
  CCxSED.VVU6pR(self, VVGape, self.VVt2Ml("channels_backup"), addTimeStamp=True)
 def VVmuRi(self):
  VVGape = []
  VVGape.append("/etc/tuxbox/config/")
  VVGape.append("/etc/tuxbox/scce/")
  VVGape.append("/etc/CCcam.*")
  VVGape.append("/usr/keys/")
  VVGape.append("/usr/scam/")
  VVGape.append("/etc/tuxbox/*cam*")
  VVGape.append("/etc/tuxbox/*Cam*")
  VVGape.append("/usr/local/etc/oscam*.*")
  VVGape.append("/usr/local/etc/ncam*.*")
  VVGape.append("/etc/oscam*.*")
  VVGape.append("/etc/ncam*.*")
  VVGape.append("/etc/uniqid")
  CCxSED.VVU6pR(self, VVGape, self.VVt2Ml("softcam_backup"), addTimeStamp=True)
 def VVWN2f(self):
  VVGape = []
  VVGape.append("/etc/hostname")
  VVGape.append("/etc/default_gw")
  VVGape.append("/etc/resolv.conf")
  VVGape.append("/etc/wpa_supplicant*.conf")
  VVGape.append("/etc/network/interfaces")
  VVGape.append("%snameserversdns.conf" % VVQe79)
  CCxSED.VVU6pR(self, VVGape, self.VVt2Ml("network_backup"), addTimeStamp=True)
 def VV31XB(self):
  CCxSED.VVU6pR(self, [VVfBVj], self.VVt2Ml("settings_backup"), addTimeStamp=True)
 def VV2kBT(self, path=None):
  if path:
   ques = "Overwrite %s File (and restart) ?" % VVfBVj
   img = CC674y.VVSwko()
   if img:
    if not img.lower() in path.lower():
     ques = "This file is not labeled with your image name (%s)\n\n%s" % (FFjt5L(img, VV1fx4), ques)
   FFRMYv(self, BF(self.VVUymq, path), ques)
 def VVUymq(self, path):
  path = FF0cqc() + path
  pathInTar = VVfBVj.lstrip("/")
  res = FFTKR0("tar -tf '%s' '%s'" % (path, pathInTar))
  if not res == pathInTar:
   FFdw58(self, "Cannot read settings file from:\n\n%s" % path)
   return
  if not FFpwZS("cp -rf '%s' '%s.bak'" % (VVfBVj, VVfBVj)):
   FFdw58(self, "Cannot backup the file:\n\n%s" % VVfBVj)
   return
  if not FFpwZS("tar -C / -xf '%s' '%s'" % (path, pathInTar)):
   FFdw58(self, "Cannot read settings file from:\n\n%s" % path)
   return
  if FFpwZS("tar -C / -xzf '%s%s'" % (FF0cqc(), path)):
   FFdw58(self, "Cannot restore the file:\n\n%s" % VVfBVj)
   return
  FF28Zd(self, "echo 'Applying new settings ...'")
 def VVt2Ml(self, fName):
  img = CC674y.VVSwko()
  if img: fName = "%s_%s" % (fName, img)
  return fName
 def VVgcOH(self, fileName=None):
  if fileName:
   FFRMYv(self, BF(self.VVymb6, fileName), "Overwrite current channels ?")
 @FFOAKH("Restoring ...")
 def VVymb6(self, fileName):
  path = FF0cqc() + fileName
  if FFCyVu(path):
   if CClYaF.VVJ1XA(path):
    VVkMso , VVEuxL = CCYrUm.VVBN5t()
    VVOVzS, VVb8I6 = CCYrUm.VVmPK0()
    cmd  = FFb2oQ("cd %s" % VVQe79)
    cmd += FFb2oQ("rm -f *.tv *.radio *.del lamedb* whitelist blacklist satellites.xml %s %s" % (VVEuxL, VVb8I6))
    cmd += "tar -C / -xzf '%s'" % path
    ok = FFpwZS(cmd)
    FFfpyJ()
    if ok: FFipXT(self, "Channels Restored.")
    else : FFdw58(self, "Error while restoring:\n\n%s" % fileName)
   else:
    FFdw58(self, "Invalid tar file:\n\n%s" % path)
  else:
   FF8Wsn(self, path)
 def VVrIlm(self, fileName=None):
  if fileName:
   FFRMYv(self, BF(self.VVvxOt, fileName), "Overwrite SoftCAM files ?")
 def VVvxOt(self, fileName):
  fileName = FF0cqc() + fileName
  txt = FFQ45w("tar -C / -xzf '%s'" % fileName)
  if txt : FF4lCP(self, "Error while restoring SoftCam files from:\n\n%s\n\n%s\n\nError:\n\n%s" % (fileName, SEP, txt), isErr=True)
  else : FFipXT(self, "SoftCam Files Restored.\n\n( You may need to restart your SoftCAM )")
 def VVf1ql(self, fileName=None):
  if fileName:
   FFRMYv(self, BF(self.VVeo9P, fileName), "Overwrite Network Settings (and REBOOT) ?")
 def VVeo9P(self, fileName):
  fileName = FF0cqc() + fileName
  if FFCyVu(fileName):
   cmd = "tar -C / -xzvf '%s';" % fileName
   cmd += "echo ''; echo 'REBOOTING ...';"
   cmd += "sleep 3; reboot"
   FFbi5l(self,  cmd)
  else:
   FF8Wsn(self, fileName)
 def VV7nlV(self, pattern, callBackFunction, isTuner=False, isChan=False):
  title = FFGNZA()
  if VVmJwX(FF0cqc()):
   myFiles = FFkzic(FF0cqc(), pattern)
   if len(myFiles) > 0:
    myFiles.sort(key=os.path.getmtime, reverse=True)
    VVGape = []
    for myFile in myFiles:
     fileName = os.path.basename(myFile)
     VVGape.append((fileName, fileName))
    if len(myFiles) > 1:
     title = title + " (Sorted by time)"
    if   isTuner  : VVwJOl = ("Sat. List", self.VVg19U)
    elif isChan and iTar: VVwJOl = ("Bouquets Importer", CC9xd9.VVhvea)
    else    : VVwJOl = None
    VVaTeF = ("Rename ", self.VV6KMC)
    VVJbOd = self.VVog33
    FFLFTC(self, callBackFunction, title=title, width=1200, VV3wat=VVGape, VVJbOd=VVJbOd, VVwJOl=VVwJOl, VVaTeF=VVaTeF, VVtboQ=FF0cqc())
   else:
    FFdw58(self, "No files found in:\n\n%s" % FF0cqc(), title)
  else:
   FFdw58(self, "Path not found:\n\n%s" % FF0cqc(), title)
 def VVog33(self, VV7tND, txt, ref, ndx):
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), y)
  txt  = ttl("File", txt)
  txt += ttl("Path", FF0cqc())
  txt += ttl("Note", FFjt5L("%s can restore this file on any image." % VVh9hj, VVJEMb))
  FF4lCP(self, txt)
 def VV6KMC(self, VV7tND, fName):
  left = name = right = ""
  for prefix in ("channels_backup_", "softcam_backup_", "settings_backup_", "network_backup_"):
   ext = ".tar.gz"
   if fName.startswith(prefix) and fName.endswith(ext):
    left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
    break
  if not name:
   for prefix in ("tuner_backup_", "hotkey_backup_", "fhdg17_skin_backup_"):
    ext = ".backup"
    if fName.startswith(prefix) and fName.endswith(ext):
     left, name, right, = prefix, fName[len(prefix):-len(ext)], ext
     break
  if not name:
   name = fName
  FF4z45(self, BF(self.VVLWkQ, VV7tND, fName, left, name, right), defaultText=name, title="Rename: %s .. %s" % (left, right), message="New name:")
 def VVLWkQ(self, VV7tND, fName, left, name, right, nName):
  if nName is not None:
   if not nName: left = left.rstrip("_")
   nName = left + nName + right
   bPath = FF0cqc()
   if   fName == nName    : FF28n1(VV7tND, "No change", 800)
   elif FFCyVu(bPath + nName) : FFdw58(self, "Name already exists:\n\n%s" % nName)
   else       : FFRMYv(self, BF(self.VVlISN, VV7tND, bPath, fName, nName), "Rename to:\n\n%s" % nName, title=fName)
 def VVlISN(self, VV7tND, bPath, fName, nName):
  fPath = bPath + fName
  nPath = bPath + nName
  try:
   stat = os.stat(fPath)
   os.rename(fPath, nPath)
   os.utime(nPath, (stat.st_atime, stat.st_mtime))
   VV7tND.VVKjBW((nName, nName))
   FF1mVE(VV7tND, "Renamed", 800)
  except Exception as e:
   FFdw58(self, str(e), title="Rename")
 def VV5ISt(self, filePrefix, grepLst):
  if not FFCyVu(VVfBVj):
   FFdw58(self, "Cannot read settings file")
   return
  grep = r"\|".join(grepLst)
  lines = FF3xOt("cat '%s' | grep '%s'" % (VVfBVj, grep))
  if not lines:
   FFdw58(self, "No settings found")
  for line in lines:
   if not any(x in line for x in grepLst):
    FFdw58(self, "\n".join(lines))
    return
  else:
   path = "%s%s%s_%s.backup" % (FF0cqc(), filePrefix, self.VVt2Ml(""), FFjTQe())
   try:
    with open(path, "w") as f:
     f.write("%s\n" % "\n".join(lines))
    FFipXT(self, "Result File:\n\n%s" % path)
   except Exception as e:
    FFdw58(self, str(e))
 def VVJVKe(self, mode, path=None):
  if not path:
   return
  path = FF0cqc() + path
  if not FFCyVu(path):
   FF8Wsn(self, path)
   return
  elif not FFCyVu(VVfBVj):
   FF8Wsn(self, VVfBVj)
   return
  if   mode == "tuner" : subj, grepLst = "Tuner"  , [".Nims."]
  elif mode == "hotk"  : subj, grepLst = "Hotkeys" , [".hotkey.", ".ButtonSetup."]
  elif mode == "fhdg17": subj, grepLst = "FHDG17-Skin", [".setupGlass17."]
  lines = FFL19l(path)
  lst1 = []
  for line in lines:
   if line.strip() and not line in lst1 and any(x in line for x in grepLst):
    lst1.append(line)
  if not lst1:
   FFdw58(self, "Nothing to restore from:\n\n%s" % path)
   return
  lst2 = []
  if mode == "tuner":
   atvL = ("dvbs.", "dvbc.", "dvbt.", "atsc.")
   for line in lst1:
    span = iSearch(r"(\w+\.Nims\.\d+\.)(.+)", line)
    if span:
     if span.group(2).startswith(atvL): line = span.group(1) + span.group(2)[5:]
     else        : line = span.group(1) + "dvbs." + span.group(2)
     if not line in lst2:
      lst2.append(line)
   lst = lst1 + lst2
   if nimmanager.nim_slots:
    if "dvbs" in config.Nims[0].dict() : lst = [x for x in lst if any("." + y in x for y in atvL)]
    else        : lst = [x for x in lst if not any("." + y in x for y in atvL)]
  elif mode == "hotk":
   pli, atv = ".hotkey.", ".ButtonSetup."
   for line in lst1:
    if   atv in line: line = line.replace(atv, pli)
    elif pli in line: line = line.replace(pli, atv)
    if not line in lst2:
     lst2.append(line)
   lst = lst1 + lst2
   if CCxSED.VVdBQ3() : lst = [x for x in lst if atv in x]
   else          : lst = [x for x in lst if atv not in x]
  FFRMYv(self, BF(self.VVMVEU, lst, grepLst), "Overwrite %s settings (and restart) ?" % subj)
 def VVMVEU(self, lines, grepLst):
  tFile = "/tmp/ajp_tmp"
  try:
   with open(tFile, "w") as f:
    for line in FFL19l(VVfBVj):
     if line.strip() and not any(x in line for x in grepLst):
      f.write("%s\n" % line)
    for ndx, line in enumerate(lines):
     f.write("%s%s" % (line, "" if ndx == len(lines) - 1 else "\n"))
  except Exception as e:
   FFdw58(self, str(e))
   return
  cmd  = "echo 'Applying new settings ...';"
  cmd += "mv -f '%s' '%s'" % (tFile, VVfBVj)
  FF28Zd(self, cmd)
 @staticmethod
 def VVdBQ3():
  from sys import modules
  return "Screens.ButtonSetup" in modules
 def VVg19U(self, selectionObj, path):
  if not path:
   return
  path = FF0cqc() + path
  if not FFCyVu(path):
   FF8Wsn(self, path)
   return
  txt = FFYVq0(path)
  satList = []
  lst = iFindall(r".+[.](diseqc.?)[=](\d+)", txt, IGNORECASE)
  for sat in lst:
   diseqc = sat[0].upper()
   satNum = sat[1]
   satList.append((diseqc.replace("DISEQC", "DiSEqC-"), satNum))
  lst = iFindall(r".+[.]sat[.](\d+)[.](lnb[=].+)", txt, IGNORECASE)
  for sat in lst:
   satNum = sat[0]
   lnb  = sat[1].upper()
   satList.append((lnb.replace("LNB=", "LNB-"), satNum))
  if satList:
   satList = list(set(satList))
   satList.sort(key=lambda x: x[0])
   txt = ""
   for item in satList:
    txt += "%s\t%s\n" % (item[0], FFycBE(item[1]))
   FF4lCP(self, txt, title="Satellites List")
  else:
   FFdw58(self, "Incorrect Tuner Backup file !\n\n(or missing info.)", title="  Satellites List")
 @staticmethod
 def VVU6pR(SELF, pathList, tarFileName, addTimeStamp=True):
  VVGape = []
  t = ""
  for path in pathList:
   if os.path.isfile(path):
    if FFCyVu(path):
     VVGape.append(path)
   elif os.path.isdir(path):
    if os.listdir(path):
     VVGape.append(path)
   else:
    VVuPkC  = os.path.dirname(path)
    fileName = os.path.basename(path)
    fileName = fileName.replace("*", ".*")
    if CCxSED.VVfwDD(VVuPkC, fileName):
     VVGape.append(path)
  if not VVGape:
   FFdw58(SELF, "Files not found!")
  elif not VVmJwX(FF0cqc()):
   FFdw58(SELF, "Path not found!\n\n%s" % FF0cqc())
  else:
   tarFileName = "%s%s" % (FF0cqc(), tarFileName)
   if addTimeStamp:
    tarFileName = "%s_%s" % (tarFileName, FFjTQe())
   tarFileName += ".tar.gz"
   filesLine = ""
   for f in VVGape:
    filesLine += "%s " % f
   failed = "Process failed !"
   cmd  = "echo 'Collecting files ...';"
   cmd += "tar -czf '%s' %s 2> /dev/null;" % (tarFileName, filesLine)
   cmd += "if [ -f '%s' ]; then "   % tarFileName
   cmd += " chmod 644 '%s';"    % tarFileName
   cmd += " echo -e '\nDONE\n';"
   cmd += " echo -e '\nResult File:\n%s\n' %s;" % (tarFileName, FFSPDv(tarFileName, VVSGsk))
   cmd += " echo '';"
   cmd += "else"
   cmd += " echo -e '\n%s\n' %s;"   % (failed, FFSPDv(failed, VVSGsk))
   cmd += "fi;"
   FFiOUV(SELF, cmd, VVgoZo=True)
 @staticmethod
 def VVfwDD(Dir, patt):
  lst = []
  if Dir:
   exp = iCompile(patt)
   for root, dirs, files in os.walk(Dir):
    for f in files:
     if exp.match(f) is not None:
      lst.append((root, f))
  return lst
class CC9xd9():
 def __init__(self, SELF):
  self.SELF   = SELF
  self.Title   = "Bouquets Importer"
  self.fileName  = ""
  self.filePath  = ""
  self.instance  = None
  self.isZip   = False
  self.cbFnc   = None
 @staticmethod
 def VVhvea(SELF, fName):
  bi = CC9xd9(SELF)
  bi.instance = bi
  bi.VVJgMK(fName)
 @staticmethod
 def VVtXW3(SELF, cbFnc=None):
  bi = CC9xd9(SELF)
  bi.instance = bi
  bi.cbFnc = cbFnc
  bi.VVjjw4()
 def VVJgMK(self, fName):
  self.fileName = fName
  self.filePath = FF0cqc() + fName
  self.isZip   = fName.endswith(".zip")
  if FFCyVu(self.filePath): self.VVFgaQ()
  else      : self.VVRCp0(self.filePath)
 def VVQ5VQ(self, txt) : FFdw58(self.SELF, txt, title=self.Title)
 def VVwb7n(self, txt)  : FF28n1(self, txt, 1500)
 def VVRCp0(self, path) : FF8Wsn(self.SELF, path, title=self.Title)
 def VVjjw4(self):
  if VVmJwX(FF0cqc()):
   lst = FFkzic(FF0cqc(), "channels_backup*.tar.gz")
   if iZip: lst.extend(self.VVEGpI())
   if len(lst) > 0:
    VV3wat = []
    for item in lst:
     item = os.path.basename(item)
     txt = FFjt5L(item, VVFuwR) if item.endswith(".zip") else item
     VV3wat.append((txt, item))
    VV3wat.sort(key=lambda x: x[1].lower())
    FFLFTC(self.SELF, self.VVk9Z6, VVyRCy=3, title=self.Title, width=1200, VV3wat=VV3wat, VVtboQ=FF0cqc(), VVwltY="#22111111", VVkxBG="#22111111")
   else:
    self.VVQ5VQ("No valid backup files found in:\n\n%s" % FF0cqc())
  else:
   self.VVQ5VQ("Backup Directory not found:\n\n%s" % FF0cqc())
 def VVk9Z6(self, fName=None):
  if fName:
   self.VVJgMK(fName)
  else:
   if self.instance: del self.instance
 def VVEGpI(self):
  files = FFkzic(FF0cqc(), "*.zip")
  lst = []
  try:
   for path in files:
    bakFile = os.path.basename(path)
    with iZip.ZipFile(path) as zipF:
     dbFound = bFound = False
     for zipInfo in zipF.infolist():
      fName = os.path.basename(zipInfo.filename)
      if fName == "lamedb" : dbFound = True
      if fName.endswith(".tv"): bFound = True
      if dbFound and bFound:
       lst.append(bakFile)
       break
  except:
   pass
  return lst
 def VVnQfA(self, lines):
  lst = []
  for line in lines:
   span = iSearch(r".+(userbouquet\..+\.(tv|radio))", line, IGNORECASE)
   if span:
    lst.append(span.group(1))
  return lst
 def VVFgaQ(self):
  CCh3tv.VV7Nf4(self.SELF, VVLL7M="Reading Bouquets ...", titleBg="#22003344", bodyBg="#22001122"
      , VVixvy  = self.VVQPt7
      , VVbYwR = self.VV6Jtz)
 def VVQPt7(self, VVXyP6):
  lines, err = CC9xd9.VVbsHS(self.filePath, "bouquets.tv")
  if err:
   self.VVQ5VQ(err)
   return
  bTvSortLst  = self.VVnQfA(lines)
  lines, err = CC9xd9.VVbsHS(self.filePath, "bouquets.radio")
  if err:
   self.VVQ5VQ(err)
   return
  bRadSortLst = self.VVnQfA(lines)
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  self.VVAkuK = []
  self.subBouquets = {}
  if self.filePath.endswith(".zip"):
   with iZip.ZipFile(self.filePath) as zipF:
    zInfLst = zipF.infolist()
    VVXyP6.VVq8NF(len(zInfLst))
    for zipInfo in zInfLst:
     fName = os.path.basename(zipInfo.filename)
     if not VVXyP6 or VVXyP6.isCancelled: return
     VVXyP6.VVaks5(fName)
     VVXyP6.VVxtQs(1)
     span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
     if span:
      mode = span.group(1)
      with zipF.open(zipInfo.filename) as f:
       row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), zipInfo.filename, "-", False)
       if err:
        return
       tName = os.path.basename(row[11])
       parenB = row[1]
       if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
       elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
       self.VVAkuK.append(row)
       lst = []
       for fPath in bnbLst:
        for zipInfo in zipF.infolist():
         if fPath == os.path.basename(zipInfo.filename):
          with zipF.open(zipInfo.filename) as f:
           row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), zipInfo.filename, parenB, True)
           if err:
            return
           lst.append(row)
       if lst:
        self.subBouquets[tName] = lst
  else:
   with iTar.open(self.filePath) as tar:
    members = tar.getmembers()
    VVXyP6.VVq8NF(len(members))
    for mem in members:
     fName = os.path.basename(mem.name)
     if not VVXyP6 or VVXyP6.isCancelled: return
     VVXyP6.VVaks5(fName)
     VVXyP6.VVxtQs(1)
     span = iSearch(r"userbouquet\..+\.(tv|radio)$", fName, IGNORECASE)
     if span:
      mode = span.group(1)
      f = tar.extractfile(mem)
      row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), mem.name, "-", False)
      if err:
       return
      tName = os.path.basename(row[11])
      parenB = row[1]
      if   tName in bTvSortLst : row[0] = str(bTvSortLst.index(tName))
      elif tName in bRadSortLst: row[0] = str(1000000 + bRadSortLst.index(tName))
      self.VVAkuK.append(row)
      lst = []
      for fPath in bnbLst:
       for mem in tar.getmembers():
        if fPath == os.path.basename(mem.name):
         f = tar.extractfile(mem.name)
         row, bnbLst, err = self.VVsM21(f, mode, len(self.VVAkuK), mem.name, parenB, True)
         if err:
          return
         lst.append(row)
      if lst:
       self.subBouquets[tName] = lst
 def VV6Jtz(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if self.VVAkuK:
   self.VVAkuK.sort(key=lambda x: int(x[0]))
   for ndx, item in enumerate(self.VVAkuK): self.VVAkuK[ndx][0] = str(ndx + 1)
   for key, lst in self.subBouquets.items():
    for ndx, row in enumerate(self.VVAkuK):
     if key == os.path.basename(row[11]):
      self.VVAkuK = self.VVAkuK[:ndx+1] + lst + self.VVAkuK[ndx+1:]
      break
   for ndx, item in enumerate(self.VVAkuK): self.VVAkuK[ndx][0] = str(ndx + 1)
   VVemyB = "#11000600"
   VVlJfJ = self.VVlmMg
   VVu1YM  = ("Show Services"  , self.VVQnzP  , [])
   VV2ytr = (""     , self.VVEE0O, [])
   VVwSzI = ("Import to System" , self.VV3Jty  , [])
   VVScQz = ("Multi-Select"  , self.VVWIaF, [])
   header   = ("Num" , "Bouquet Name", "Parent Bouquet" , "Mode", "Items" , "DVB" , "IPTV", "S.Relay" , "Local" , "Marker" , "Bouquet" , "File")
   widths   = (7  ,  36   , 0.01    , 7  , 7   , 7  , 7  , 7   , 7   , 7   , 8   ,  0.01 )
   VVLIqP  = (CENTER ,  LEFT   , LEFT    , CENTER, CENTER , CENTER, CENTER, CENTER , CENTER , CENTER , CENTER ,  LEFT )
   tbl = FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=self.VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=24, height=1000, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVlJfJ=VVlJfJ, VVwSzI=VVwSzI, VVScQz=VVScQz, VVMfsO=1, VVSLOq=CFG.lastFindServers, VVwltY=VVemyB, VVkxBG=VVemyB, VVemyB=VVemyB, VVJKqd="#00004455", VVbcr0="#0a282828")
   tbl.VVIOX6(BF(self.VVlmMg, tbl))
  else:
   self.VVQ5VQ("No valid bouquets in:\n\n%s" % os.path.basename(self.filePath))
 def VV3Jty(self, VV6A99, title, txt, colList):
  if VV6A99["keyGreen"].getVisible():
   cnt = 0
   if VV6A99.VVXWPu:
    rows = VV6A99.VVbF9W()
    for ndx, totBnb in enumerate(VV6A99.VVf3uT(10)):
     if VV6A99.VVvlf4(ndx) and totBnb.isdigit() and int(totBnb) > 0:
      VV6A99.VVTQDs(ndx, mode=0, movDn=False)
      cnt += 1
   if cnt == 0:
    if VV6A99.VVXWPu:
     tot = VV6A99.VVc5NH()
     ques = "Import %s Bouquet%s" % (FFjt5L(tot, VVSGsk), FFcacr(tot))
    else:
     bName = VV6A99.VV5crm()[1]
     ques = "Import Bouquet ?\n\n%s" % bName
    FFRMYv(self.SELF, BF(self.VVEzy6, VV6A99, self.filePath), ques, title=self.Title)
   else:
    FFjADj(VV6A99, "Fixed Selections : %s" % cnt, 2000)
 def VVlmMg(self, VV6A99):
  VV6A99["keyGreen"].hide()
  if VV6A99.VVXWPu:
   if VV6A99.VVc5NH() > 0:
    VV6A99["keyGreen"].show()
  else:
   totBnb = VV6A99.VV5crm()[10]
   if not (totBnb.isdigit() and int(totBnb) > 0):
    VV6A99["keyGreen"].show()
 def VVEE0O(self, VV6A99, title, txt, colList):
  totBnb = VV6A99.VV5crm()[10]
  if totBnb.isdigit() and int(totBnb) > 0:
   c1, c2 = VVz22H, VVFuwR
   txt += "\n%sNote:\n" % c1
   txt += "%s- This bouquet includes %s%s%s Sub-Bouquet%s.\n" % (c2, c1, totBnb, c2, FFcacr(int(totBnb)))
   txt += "- Its-Sub-Bouquets will follow it in the list (in yellow) if exist in the backup file."
  FF4lCP(self.SELF, txt, title=title)
 def VVWIaF(self, VV6A99, title, txt, colList):
  CCzSCo(self.SELF, VV6A99, addSep=False, setsOk=True).VV9VR2(None, None, width=700)
 def VVQnzP(self, VV6A99, title, txt, colList):
  if FFCyVu(self.filePath):
   num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName = VV6A99.VV5crm()
   CCh3tv.VV7Nf4(self.SELF, VVLL7M= "Reading Services ...", titleBg="#22003344", bodyBg="#22001122"
       , VVixvy  = BF(self.VVX7RM, bName, fName)
       , VVbYwR = BF(self.VVTuhA, VV6A99, bName))
  else:
   FF28n1(VV6A99, "Cannot open file !", 1500)
 def VVX7RM(self, bName, fName, VVXyP6):
  lines, err = CC9xd9.VVbsHS(self.filePath, "lamedb")
  if err:
   self.VVQ5VQ(err)
   return
  dbServLst = CCYrUm.VVBshb(lines, mode=10)
  lines, err = CC9xd9.VVbsHS(self.filePath, os.path.basename(fName))
  if err:
   self.VVQ5VQ(err)
   return
  if not VVXyP6 or VVXyP6.isCancelled: return
  patt = iCompile(r"1:64:(?:[a-f0-9]+:){8}:(.+)"
      r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
      r"|(?:[a-f0-9]+:){10}http.+:(.+)"
      r"|(?:[a-f0-9]+:){10}(\/.+)"
      r'|.+1:7:.+FROM BOUQUET\s+"(.+)"'
      r"|((?:[a-f0-9]+:){10})(?:$|:.+)"
      , IGNORECASE)
  VVXyP6.VVq8NF(len(lines))
  VVAkuK = []
  bnbFound = False
  for line in lines:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
   iSleep(0.0005)
   if line.startswith("#SERVICE "):
    span = patt.search(line)
    if span:
     g1, g2, g3, g4, g5, g6 = span.groups()
     if   g1: VVAkuK.append((g1.strip(), "Marker"))
     elif g2: VVAkuK.append((g2 or "-", "Sub-Bouquet"))
     elif g3: VVAkuK.append((g3.strip() or "-", "Stream Relay" if FFHgaY(line) else "IPTV"))
     elif g4: VVAkuK.append((os.path.basename(g4.strip() or "-"), "Local Media"))
     elif g5: VVAkuK.append((g5 or "-", "Sub-Bouquet"))
     elif g6:
      dbCode = CCYrUm.VVlPsR(g6)
      for dbCode1, name, prov in dbServLst:
       if dbCode1.upper() in dbCode:
        VVAkuK.append((name.strip() or "-", FFec0y(g6, False)))
        break
     if any((g2, g5)):
      bnbFound = True
     if not VVXyP6 or VVXyP6.isCancelled: return
     if VVAkuK:
      VVXyP6.VVaks5(VVAkuK[len(VVAkuK) - 1][0])
  if bnbFound:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVq8NF(len(VVAkuK))
   VVXyP6.VV78Id(0)
   for ndx, item in enumerate(VVAkuK):
    name, descr = item
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVaks5(name)
    VVXyP6.VVxtQs(1)
    if iMatch(r".+\.tv", name, IGNORECASE):
     lines, err = CC9xd9.VVbsHS(self.filePath, os.path.basename(name))
     if lines and not err:
      span = iSearch(r"#NAME\s+(.+)", lines[0], IGNORECASE)
      if span:
       bName = span.group(1).strip()
       if bName:
        VVAkuK[ndx] = (bName, descr)
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVNc18 = VVAkuK
 def VVTuhA(self, VV6A99, bName, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18:
   VVemyB = "#11001122"
   bName = iSub(r"\s{4,}" ," .. " , bName)
   header  = ("Service", "Type")
   widths  = (80  , 20 )
   VVLIqP = (LEFT  , CENTER)
   FFUQ0v(self.SELF, None, title="Services in : %s" % bName, header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVwltY=VVemyB, VVkxBG=VVemyB, VVemyB=VVemyB, VVJKqd="#11550033", VVSLOq=CFG.lastFindServers)
  elif not VVRI6P:
   pass
  else:
   FF28n1(VV6A99, "No valid services !", 1500)
 def VVsM21(self, f, mode, sequence, fPath, parentB, isSubB):
  bName = ""
  totItem = totDVB = totMrk = totBnb = totIptv = totSRelay = totLoc = 0
  bnbLst = []
  for line in f:
   try:
    line = str(line.decode()).strip()
   except:
    self.VVQ5VQ("Encoding Error in the archived file:\n\n%s" % fPath)
    return [], [], "File Encoding Error"
   if line.startswith("#SERVICE "):
    totItem +=1
    if   iMatch(r".+1:64:(?:[A-Fa-f0-9]+:){8}:.+", line)    : totMrk += 1
    elif FFHgaY(line)           : totSRelay += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}http.+:.+", line, IGNORECASE) : totIptv += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}\/.+", line)     : totLoc += 1
    elif iMatch(r".+(?:[A-Fa-f0-9]+:){10}(?:$|:.+)", line)    : totDVB += 1
    else:
     span = iSearch(r'.+1:7:.+FROM BOUQUET\s+"(.+)".+', line, IGNORECASE)
     if span:
      totBnb += 1
      bnbLst.append(span.group(1))
   elif line.startswith("#NAME "):
    bName = line[6:]
  chColor = lambda x: str(x) if x else "#f#00666666#" + str(x)
  bMode = "TV" if mode == "tv" else "Radio"
  if   totBnb : fg, totBnb  = "#f#00ff5522#" , str(totBnb)
  elif isSubB : fg, totBnb  = "#f#00ffffbb#" , "Sub-B."
  else  : fg, totBnb = ""    , chColor(totBnb)
  row = [str(2000001 + sequence), fg + bName, parentB, fg + bMode, "#f#00ff88ff#" + str(totItem), chColor(totDVB), chColor(totIptv), chColor(totSRelay), chColor(totLoc), chColor(totMrk), fg + totBnb, fPath]
  return row, bnbLst, ""
 def VVEzy6(self, VV6A99, archPath):
  title = "Import Bouquets"
  tvBouquetFile  = VVQe79 + "bouquets.tv"
  radBouquetFile = VVQe79 + "bouquets.radio"
  for f in (tvBouquetFile, radBouquetFile):
   if not FFCyVu(f):
    FF8Wsn(self.SELF, f, title=title)
    return
  isMulti = VV6A99.VVXWPu
  if isMulti : rows = VV6A99.VVbF9W()
  else  : rows = [VV6A99.VV5crm()]
  CCh3tv.VV7Nf4(self.SELF, VVLL7M=title, titleBg="#22003344", bodyBg="#22001122", totBars=2
      , VVixvy  = BF(self.VVlZ6h, VV6A99, rows, archPath, tvBouquetFile, radBouquetFile, title)
      , VVbYwR = BF(self.VV0n7h, title) )
 def VVlZ6h(self, VV6A99, rows, archPath, tvBouquetFile, radBouquetFile, title, VVXyP6):
  totTP = totServ = totTv = totRad = totMissTP = totMissServ = totMissSRelay = totAllServ = 0
  totBouq = len(rows)
  VVXyP6.VVq8NF(totBouq)
  VVXyP6.VVUIH1(totBouq)
  VVXyP6.VVNc18 = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
  bList = []
  totAllServ = 0
  if FFCyVu(archPath):
   for num, bName, parentB, bMode, totItem, totDVB, totIptv, totSRelay, totLoc, totMrk, totBnb, fName in rows:
    if not VVXyP6 or VVXyP6.isCancelled:
     return
    VVXyP6.VVaks5(bName)
    VVXyP6.VVxtQs(1)
    totAllServ += int(totItem)
    newFile = os.path.basename(fName)
    span = iSearch(r".+\.(.+)\.(tv|radio)", newFile, IGNORECASE)
    if span : fNamePart, fNameExt = span.group(1), span.group(2)
    else : fNamePart, fNameExt = "bouquet", "tv"
    newFile = "userbouquet.%s.%s" % (fNamePart, fNameExt)
    bPath = VVQe79 + newFile
    num  = 0
    while FFCyVu(bPath):
     num += 1
     newFile = "userbouquet.%s_%d.%s" % (fNamePart, num, fNameExt)
     bPath = VVQe79 + newFile
    CC9xd9.VV9cx5(archPath, fName, VVQe79, newFile)
    if FFCyVu(bPath):
     bList.append(newFile)
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  if bList:
   FFJvhj(tvBouquetFile)
   FFJvhj(radBouquetFile)
   for bFile in bList:
    if bFile.endswith("tv") : mainBFile, totTv = tvBouquetFile , totTv  + 1
    else     : mainBFile, totRad = radBouquetFile, totRad + 1
    with open(mainBFile, "a") as f:
     f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   VVXyP6.VVNc18 = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
   totTP, totServ, totMissTP, totMissServ, totMissSRelay = self.VVUNqO(archPath, bList, VVXyP6)
   VVXyP6.VVNc18 = (totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay)
 def VV0n7h(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  FFfpyJ()
  totBouq, totAllServ, totTP, totServ, totTv, totRad, totMissTP, totMissServ, totMissSRelay = VVNc18
  c1, c2 = VVFuwR, VVz22H
  txt  = FFjt5L("Added:\n", VVFuwR)
  txt += "Bouquets\t: %d     (%d TV , %d Radio)\n" % (totBouq, totTv, totRad)
  txt += "Services\t: %d\n" % totAllServ
  if totTP or totServ:
   txt += "\n"
   txt += FFjt5L("Imported to lamedab:\n", VVFuwR)
   if totTP : txt += "Transponders\t: %d\n" % totTP
   if totServ : txt += "Services\t: %d\n"  % totServ
  if any((totMissTP, totMissServ, totMissSRelay)):
   txt += "\n"
   txt += FFjt5L("Missing from archived lamedb:\n", VVz22H)
   if totMissTP : txt += "Transponders\t: %d\n" % totMissTP
   if totMissServ : txt += "Services\t: %d"  % totMissServ
   if totMissSRelay : txt += "Stream Relay\t: %d" % totMissSRelay
  FF4lCP(self.SELF, txt, title=title, width=1000)
  if self.cbFnc:
   self.cbFnc()
 def VVUNqO(self, archPath, bList, VVXyP6):
  VVkMso, err = CCYrUm.VVQwcg(self.SELF, VV49Lf=False)
  if err:
   return 0, 0, 0, 0
  dbServIDs = CCYrUm.VVaZcW(VVkMso, mode=11)
  if not dbServIDs:
   return 0, 0, 0, 0
  newDbServIDs = set()
  newDbTpIDs  = set()
  newStreamRelayChNames = set()
  for bFile in bList:
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   VVXyP6.VVaks5(bFile)
   VVXyP6.VVg2Dw(1)
   lines = FFL19l(VVQe79 + bFile)
   for line in lines:
    span = iSearch(r"((?:[A-Fa-f0-9]+:){10}$)", line, IGNORECASE)
    if span:
     VVPxk5 = span.group(1)
     dbCode = CCYrUm.VVlPsR(VVPxk5)
     if not dbCode in dbServIDs:
      newDbServIDs.add(dbCode)
      newDbTpIDs.add(CCYrUm.VVIoyj(VVPxk5))
    else:
     span = iSearch(r"(?:[A-Fa-f0-9]+:){10}https?(?::|%3a)\/\/(?:(?:127|0)\.\d+\.\d+\.\d+|localhost)(?::|%3a)\d+\/(.+)\/pid(\d+):", line, IGNORECASE)
     if span:
      newStreamRelayChNames.add(" PID ".join(span.groups()))
  dbServIDs = None
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVaks5("Updating lamedb (Stage-1) ...")
  tFile = ""
  if any((newDbServIDs, newDbTpIDs, newStreamRelayChNames)) and FFCyVu(archPath):
   dbName = "lamedb"
   tFile = "/tmp/%s.tmp" % dbName
   fName = CC9xd9.VVcVZU(archPath, dbName)
   CC9xd9.VV9cx5(archPath, fName, "/tmp/", dbName + ".tmp")
  newTPLines = set()
  newServLines= set()
  dbTpData = CCYrUm.VVaZcW(VVkMso, mode=0)
  dbServData = CCYrUm.VVaZcW(VVkMso, mode=10)
  if newDbTpIDs:
   for item in CCYrUm.VVaZcW(tFile, mode=0):
    if item[0].upper() in newDbTpIDs and not item in dbTpData:
     newTPLines.add(item)
  if newDbServIDs:
   for item in CCYrUm.VVaZcW(tFile, mode=10):
    if item[0].upper() in newDbServIDs and not item in dbServData:
     newServLines.add(item)
  totMissSRelay = len(newStreamRelayChNames)
  if newStreamRelayChNames:
   for item in CCYrUm.VVaZcW(tFile, mode=14):
    for VV1wIO in newStreamRelayChNames:
     if VV1wIO.lower() == item[1].lower():
      totMissSRelay = 0
      if not item in dbServData:
       newServLines.add(item)
       tp = CCYrUm.VVwhja(item[0])
       if not tp in dbTpData:
        newTPLines.add(tp)
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVaks5("Updating lamedb (Stage-2) ...")
  totMissTP = 0
  totMissServ = 0
  lst = CCYrUm.VVaZcW(tFile, mode=1)
  for dbCode in newDbTpIDs:
   if not lst or not dbCode in lst:
    totMissTP += 1
  lst = CCYrUm.VVaZcW(tFile, mode=11)
  for dbCode in newDbServIDs:
   if not lst or not dbCode in lst:
    totMissServ += 1
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVaks5("Updating lamedb (Stage-3) ...")
  FFwgGB(tFile)
  totServ = totTP = 0
  if newTPLines or newServLines:
   isServ = isTP = False
   tmpDbFile = VVkMso + ".tmp"
   lines   = FFL19l(VVkMso)
   with open(tmpDbFile, "w") as f:
    for line in lines:
     sLine = line.strip()
     if   sLine == "transponders": isTP, isServ = True, False
     elif sLine == "services" : isTP, isServ = False, True
     elif sLine == "end":
      if isTP:
       for item in (newTPLines):
        totTP += 1
        for L in item:
         f.write(L + "\n")
      elif isServ:
       for item in (newServLines):
        totServ += 1
        for L in item:
         f.write(L + "\n")
     f.write(line + "\n")
   FFpwZS("mv -f '%s' '%s'" % (tmpDbFile, VVkMso))
  return totTP, totServ, totMissTP, totMissServ, totMissSRelay
 @staticmethod
 def VVcVZU(path, fName):
  if path.endswith(".zip"):
   with iZip.ZipFile(path) as zipF:
    for zipInfo in zipF.infolist():
     if os.path.basename(zipInfo.filename) == fName:
      return zipInfo.filename
  else:
   with iTar.open(path) as tar:
    for mem in tar.getmembers():
     if os.path.basename(mem.name) == fName:
      return mem.name
  return ""
 @staticmethod
 def VV9cx5(path, fName, newPath, newFile):
  if path.endswith(".zip"):
   with iZip.ZipFile(path) as zipF:
    zipInfo = zipF.getinfo(fName)
    zipInfo.filename = newFile
    zipF.extract(zipInfo, newPath)
  else:
   with iTar.open(path) as tar:
    mem = tar.getmember(fName)
    mem.name = newFile
    tar.extract(mem, path=newPath)
 @staticmethod
 def VVbsHS(path, subFile):
  lines = []
  try:
   if path.endswith(".zip"):
    with iZip.ZipFile(path) as zipF:
     for zipInfo in zipF.infolist():
      fName = os.path.basename(zipInfo.filename)
      if fName == subFile:
       with zipF.open(zipInfo.filename) as f:
        lines = f.read().decode().splitlines()
       break
     else:
      return [], "Archived file not found:\n\n%s" % subFile
   else:
    with iTar.open(path) as tar:
     for mem in tar.getmembers():
      fName = os.path.basename(mem.name)
      if fName == subFile:
       f = tar.extractfile(mem)
       lines = f.read().decode().splitlines()
       break
     else:
      return [], "Archived file not found:\n\n%s" % subFile
   return [str(x.strip()) for x in lines], ""
  except:
   return [], "Error while reading the archived file:\n\n%s" % subFile
class CCEzue():
 def __init__(self):
  self.VVcHUa   = "Package Creator"
  self.VVrVbw   = "ajpanel_package_"
  self.VVvHW8  = FF0cqc()
  self.VVwdtN   = ""
  self.VVNvsj   = ""
  self.VVHCVG   = ""
  self.VVkzdr   = None
  self.VVIHf1   = None
  self.VVs3Gr = ""
  self.VVEvFg  = ""
  self.VVJorQ = ""
  self.VVQBGg = ""
  self.VVuB9m = ""
  self.VVj1mD = ""
  self.VVhQ0X()
 def VVhQ0X(self):
  self.projPkg   = ""
  self.projVer   = ""
  self.projArch   = ""
  self.VVHCVGsSize  = 0
  self.projTotalDirs  = 0
  self.projTotalFiles  = 0
  self.projAct_postInst = 0
  self.projAct_postRm  = 0
 @FFOAKH()
 def VV37Fz(self):
  FFHQjU()
  self.VVvHW8 = FFoUor()
  lst = FFkES0(self.VVvHW8)
  VV3wat = []
  if lst:
   for path in lst:
    if path.startswith(self.VVrVbw):
     prName = os.path.basename(path)
     VV3wat.append((prName, prName))
  if VV3wat:
   VV3wat.sort(key=lambda x: x[1].lower())
   VVOa1G = self.VVBAJe
   VVwJOl = ("Add new project", self.VVtfY4)
   VVB4pu= ("Delete Project" , self.VVLvWJ)
   self.VVkzdr = FFLFTC(self, None, VV3wat=VV3wat, width=1100, VVOa1G=VVOa1G, VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVyRCy=5, VVwltY="#22111133", VVkxBG="#22111133")
  else:
   FFRMYv(self, self.VVGrGJ, "No projects found !\n\n Create new project ?", title=self.VVcHUa)
 def VVGrGJ(self)    : FFimQ3(self, BF(self.VVQTlD))
 def VVtfY4(self, VV7tND, item) : FFimQ3(self.VVkzdr, BF(self.VVQTlD))
 def VVQTlD(self):
  err, _ = self.VVWetn(0)
  if err:
   self.VVwTG2(err)
  else:
   c = 0
   while True:
    c += 1
    name = "project_%d" % (c)
    if not VVmJwX("%s%s%s" % (self.VVvHW8, self.VVrVbw, name)):
     break
   self.VVmNbG(name)
 def VVmNbG(self, name, cbFnc=None):
  FF4z45(self, cbFnc or self.VVaqC7, defaultText=name, title="New Project Name", message="Enter project name")
 def VVaqC7(self, name):
  if name and name.strip():
   path = "%s%s%s" % (self.VVvHW8, self.VVrVbw, name)
   if VVmJwX(path):
    FFRMYv(self, BF(self.VVmNbG, name), "Project directory already exists !\n\n Change name ?", title=self.VVcHUa)
   else:
    err = FFENxa(path)
    if err:
     self.VVwTG2("Cannot create project directory !\n\n %s" % err)
    else:
     item = os.path.basename(path)
     if self.VVkzdr: self.VVkzdr.VV5HD3((item, item), isSort=True)
     else   : self.VV37Fz()
 def VVLvWJ(self, VV7tND, path):
  if path:
   path = self.VVvHW8 + path
   if VVmJwX(path):
    totDir, totFile, totLink = FFK6he(path)
    FFRMYv(self, BF(self.VVbRTn, path), "Project directory contains %d items.\n\n%s\n\nDelete ?" %(totDir + totFile + totLink, path), title=self.VVcHUa)
 def VVbRTn(self, path):
  if FFpwZS("rm -rf '%s'" % path):
   self.VVkzdr.VV478W()
 def VVBAJe(self, item=None):
  if item:
   VV7tND, txt, Dir, ndx = item
   self.VVhQ0X()
   self.VVwdtN = os.path.basename(Dir)[len(self.VVrVbw):]
   self.VVNvsj = "%s%s/" % (self.VVvHW8, Dir)
   self.VVHCVG = "%s%s.cfg"  % (self.VVNvsj, self.VVwdtN)
   self.VVs3Gr = self.VVNvsj + "control"
   self.VVEvFg  = self.VVNvsj + "prerm"
   self.VVJorQ = self.VVNvsj + "postrm"
   self.VVQBGg = self.VVNvsj + "preinst"
   self.VVuB9m = self.VVNvsj + "postinst"
   if not FFCyVu(self.VVs3Gr):
    err, lst = self.VVWetn(2)
    if err:
     self.VVwTG2(err)
     return
    pkg = FFWEt2(self.VVwdtN, r"_").lower()
    with open(self.VVs3Gr, "w") as f:
     for line in lst:
      f.write("%s\n" % (line[1].replace("xx1", pkg).replace("xx2", self.VVwdtN)))
   if not FFCyVu(self.VVHCVG):
    with open(self.VVHCVG, "w") as f:
     sep = "#" * 80
     f.write("%s\n" % sep)
     f.write("%s Project\t: %s\n" % ("#", self.VVwdtN))
     f.write("%s Started\t: %s\n" % ("#", FFIPdt()))
     f.write("%s\n" % sep)
   if FFCyVu(self.VVHCVG): self.VVEB1h(VV7tND)
   else      : self.VVwTG2("Cannot create project file:\n\n%s" % self.VVHCVG)
 def VVEB1h(self, VV7tND=None, jmpDict=None):
  FFimQ3(VV7tND or self.VVIHf1 or self, BF(self.VV1Ovp, jmpDict))
 def VV1Ovp(self, jmpDict):
  self.VVhQ0X()
  pkgRows, ctrlRows, actnRows, fileRows, unknRows = [], [], [], [], []
  tLst = []
  if FFCyVu(self.VVs3Gr):
   for lineNdx, line in enumerate(FFL19l(self.VVs3Gr)):
    line = line.strip()
    if ":" in line:
     subj, val, rem = self.VVEhxm(line)
     if   subj in tLst: rem = FFjt5L("Duplicate Field", VVz22H)
     elif val == ""  : rem = FFjt5L("No Value", VVz22H)
     tLst.append(subj)
     pkgRows.append((str(lineNdx), "Control", subj, val, "", rem, ""))
  if not pkgRows:
   self.VVwTG2('Invalid "control" file:\n\n%s' % self.VVs3Gr)
   return
  for path in (self.VVQBGg, self.VVuB9m, self.VVEvFg, self.VVJorQ):
   size = val = ""
   if FFCyVu(path):
    val = path
    sz = FFXhoc(path)
    if sz > -1: size = CClYaF.VV99gM(sz, mode=4)
    else   : size = FFjt5L("Size error", VVz22H)
   ctrlRows.append(("", "Script", os.path.basename(path), val, size, "", ""))
  lines = list(map(str.strip, FFL19l(self.VVHCVG)))
  pathsLst = []
  for line in lines:
   if line.startswith("/"):
    pathsLst.append(line)
  pathsAnalysis = CCts4c.VVm09O(pathsLst)
  for lineNdx, line in enumerate(lines):
   lineNdx = str(lineNdx)
   if line and not line.startswith("#"):
    validF = size = rem = ""
    if line.startswith("/"):
     path, fName, typ, size, rem, validF = self.VVF6iU(line, fileRows, pathsAnalysis)
     fileRows.append((lineNdx, "Resource", typ or "Unknown", path, size, rem, validF))
    else:
     Title, val = self.VV2ukf(line)
     if Title: actnRows.append((lineNdx, "Action", Title, val, size, rem, validF))
     else : unknRows.append((lineNdx, "?", "-", line, size, FFjt5L("Unknown value", VVz22H), validF))
  for ndx, row in enumerate(actnRows):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   rem = ""
   if   FFCyVu(self.VVuB9m) and Title == "postinst" : rem = "Ignored (if custom postinst)"
   elif FFCyVu(self.VVJorQ  ) and Title == "postrm" : rem = "Ignored (if custom postrm)"
   if rem:
    actnRows[ndx] = (lineNdx, Section, Title, Value, Size, FFjt5L(rem, VVz22H), ValidF)
  actnRows.sort(key=lambda x: x[2].lower())
  fileRows.sort(key=lambda x: (x[2].lower(), x[3].lower()))
  unknRows.sort(key=lambda x: x[3].lower())
  VVAkuK = pkgRows
  VVAkuK.extend(actnRows)
  VVAkuK.extend(ctrlRows)
  VVAkuK.extend(fileRows)
  VVAkuK.extend(unknRows)
  cDict = {"Control":"", "Action":"0c302636", "Script":"0a28281a", "Resource":"1100385a", "?":"11550000"}
  for ndx, row in enumerate(VVAkuK):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   color = cDict.get(Section, "")
   if color:
    if ValidF: Remarks = "%s%s" % (FFjt5L("Valid", VVSGsk), " ... " + Remarks if Remarks else "")
    VVAkuK[ndx] = (lineNdx, "#b#%s#" % color + Section, Title, Value, Size, "#b#0a0b0b1b#" + Remarks, ValidF)
  if self.VVIHf1:
   self.VVIHf1.VVMqQ9(VVAkuK, VVDpzd=BF(self.VVagnj, jmpDict) if jmpDict else None, isSort=False)
  else:
   bg = "#15000000"
   title = "%s : %s" % (self.VVcHUa, self.VVwdtN)
   VV2ytr = (""     , self.VVA984   , [])
   VVdHJK = (""     , self.VVV9gg   , [])
   VVwWmA = ("Create Package"  , self.VV1QUT , [])
   VVScQz = ("Post Install Action", self.VVKEHB, [])
   VV4QTJ = ("Edit File"   , self.VVc4kr  , [])
   header  = ("lineNdx", "Section" , "Title" , "Value / Path", "Size", "Remarks" , "ValidF")
   widths  = (0  , 9   , 11  , 48   , 10 , 22  , 0   )
   VVLIqP = (CENTER , CENTER , LEFT  , LEFT   , CENTER, LEFT  , CENTER )
   self.VVIHf1 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1850, height=1040, VVwdmN=26, VV2ytr=VV2ytr, VVdHJK=VVdHJK, VVwWmA=VVwWmA, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVMfsO=2
         , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00664411", VVbcr0="#00444444", VVX9AA="#08442211")
   self.VVIHf1.VVIOX6(self.VVp6TV)
 def VVagnj(self, jmpDict, VV6A99, title, txt, colList):
  self.VVIHf1.VVPkdw(jmpDict)
 def VVp6TV(self):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVIHf1.VV5crm()
  if Section == "Control":
   txt = '"control" File'
  elif Section == "Script" :
   txt = "Script File"
   if Value.startswith("/") and FFCyVu(Value):
    txt = "Script File"
   else:
    self.VVIHf1["keyBlue"].hide()
    return
  else:
   txt = "Project File"
  self.VVIHf1["keyBlue"].show()
  self.VVIHf1["keyBlue"].setText("Edit %s" % txt)
 def VVEhxm(self, line):
  def VVZwiy(patt, val, Len):
   if len(val) < Len   : return FFjt5L("Length error" , VVz22H)
   elif not iMatch(patt, val) : return FFjt5L("Invalid format" , VVz22H)
   else      : return ""
  subj, _, val = line.partition(":")
  val, rem = val.strip(), ""
  if   not self.projPkg  and subj == "Package"  : self.projPkg, rem = val, VVZwiy(r"^[a-z]+[a-z0-9+-_.]+$", val, 2)
  elif not self.projVer  and subj == "Version"  : self.projVer, rem = val, VVZwiy(r"^[a-zA-Z0-9_+-.~]*$" , val, 1)
  elif not self.projArch and subj == "Architecture": self.projArch = val
  return subj, val, rem
 def VVF6iU(self, path, fileRows, pathsAnalysis):
  cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = pathsAnalysis
  rem = note = validF = targetType = ""
  size = "-"
  isCtrl = False
  fName = os.path.basename(path)
  typ = FFTWKU(path)
  path = FFVc4H(path)
  c1 = VVz22H
  if   typ == "Mount"     : rem = "Not allowed"
  elif not typ      : rem = "Cannot be accessed"
  elif FFoWxR(path) in rmDirLst: rem = "Ignored (child exists)"
  else:
   for item in fileRows:
    if item[3].strip() == path:
     rem = "Duplicate"
     break
  if rem:
   rem = FFjt5L(rem, c1)
   return path, fName, typ, size, rem, validF
  sz = -1
  skipSz = False
  if typ == "Directory":
   sz = FF4oMa(path)
  elif typ == "SymLink":
   targetPath = os.path.realpath(path)
   targetType = FFTWKU(targetPath)
   if  targetType == "Mount"  : skipSz, rem = True, FFjt5L("Not allowed", c1)
   elif targetType == "Directory" : sz = FF4oMa(targetPath)
   elif targetType == "File"  : sz = FFXhoc(targetPath)
   else       : sz, rem = FFXhoc(path), FFjt5L("Invalid", c1)
   note = "%s%s%s" % (note, " ... " if note else "", "Linked to : %s" % targetPath)
  elif typ == "File":
   sz = FFXhoc(path)
  if not skipSz:
   if sz > -1:
    validF = "" if rem else "1"
    if validF:
     if "Directory" in (typ, targetType) : self.projTotalDirs  += 1
     if "File" in (typ, targetType)  : self.projTotalFiles += 1
     self.VVHCVGsSize += sz
    size = CClYaF.VV99gM(sz, mode=4)
   else:
    size = FFjt5L("Size error", c1)
  rem = "%s%s%s" % (rem, " ... " if rem else "", note)
  return path, fName, typ, size, rem, validF
 def VV2ukf(self, line):
  Title = val = ""
  actDict = {"restart":1, "reboot":2 }
  span = iSearch(r"postinst\s*=\s*(.+)", line, IGNORECASE)
  if span:
   act = span.group(1).lower()
   self.projAct_postInst = actDict.get(act, 0)
   Title, val = "postinst", "%s after the package is installed" % act.capitalize()
  else:
   span = iSearch(r"postrm\s*=\s*(.+)", line, IGNORECASE)
   if span:
    act = span.group(1).lower()
    self.projAct_postRm = actDict.get(act, 0)
    Title, val = "postrm", "%s after the package is removed" % act.capitalize()
  return Title, val
 def VVc4kr(self, VV6A99, title, txt, colList):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
  if   Section == "Control": path, lineNdx = self.VVs3Gr, int(lineNdx)
  elif Section == "Script" : path, lineNdx = Value, 0
  else      : path, lineNdx = self.VVHCVG, int(lineNdx)
  if FFCyVu(path) : CCyMCP(self, path, VVbYwR=self.VVsV9F, VVPhQC=lineNdx)
  else    : FF8Wsn(self, path)
 def VVsV9F(self, fileChanged):
  if fileChanged:
   self.VVEB1h()
 def VVwTG2(self, txt):
  FFdw58(self, txt, title=self.VVcHUa)
 def VVA984(self, VV6A99, title, txt, colList):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  c = VVFuwR
  s  = FFGEAF("Current Row", c)
  s += title + "\n"
  s += txt + "\n"
  s += FFGEAF("Project", c)
  s += tab("File Name", self.VVHCVG)
  s += tab("Valid Dirs", self.projTotalDirs)
  s += tab("Valid Files", self.projTotalFiles)
  s += tab("Total Size", CClYaF.VV99gM(self.VVHCVGsSize))
  FF4lCP(self, s, title="Project Info", width=1600)
 def VVV9gg(self, VV6A99, title, txt, colList):
  c1, c2, c3, c4, c5 = VVJEMb, VVZtfx, VVFuwR, VVz22H, VVSGsk
  allRes, invRes, unkRes = self.VV0sEJ()
  totAll = len(allRes)
  totInv = len(invRes)
  totAllTxt = ("(Total=%d)" % totAll) if allRes else ""
  totInvTxt = ("(Total=%d)" % totInv) if invRes else ""
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = colList
  canDel = False
  if Section != "Script" and Title not in ("Package", "Version", "Description", "Maintainer", "Architecture"):
   canDel = True
  canAddPkg, depTitle = False, ""
  if Section == "Control" and Title in ("Breaks", "Built-Using", "Conflicts", "Depends", "Enhances", "Pre-Depends", "Provides", "Recommends", "Replaces", "Suggests"):
   canAddPkg, depTitle = True , VVA4XU + '\tFor : "%s"' % Title
  VV3wat = []
  VV3wat.append((c1 + "Add Resource Files/Dirs"       , "addFiles"))
  VV3wat.append((c1 + "Import Files/Dirs List from an Installed Package", "pkgFiles"))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Import Control File (control/preinst/prerm/postinst/postrm)" , "ctrlFMan" ))
  VV3wat.append((c3 + "Import Control Data from an Installed Package"    , "ctrlImprt" ))
  VV3wat.append((c3 + "Add Control Field"           , "ctrlField" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Add Binary Package%s"  % depTitle  , "addDep" , canAddPkg, c2 ))
  VV3wat.append(FFsLU5("Remove Binary Package%s" % depTitle  , "delDep" , canAddPkg, c2 ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Change Package Name"  , "pkgNam" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Delete All Resources %s"  % totAllTxt , "delAllRes" , totAll > 0, c4))
  VV3wat.append(FFsLU5("Delete Invalid Resources %s" % totInvTxt , "delInval" , totInv > 0, c4))
  VV3wat.append(FFsLU5("Delete Current Row"      , "delRow"  , canDel , c4))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5('Undo Last "control" File Changes'   , "ctrlUndo" , FFCyVu(self.VVs3Gr + ".bak"), c5))
  VV3wat.append(FFsLU5("Undo Last Project File Changes"   , "projUndo" , FFCyVu(self.VVHCVG + ".bak")  , c5))
  FFLFTC(self, BF(self.VVml7A, Title), VV3wat=VV3wat, width=1050, height=1000, title="Options", VVwltY="#11001122", VVkxBG="#11001122", VVU8mZ=True)
 def VVml7A(self, fldTitle, item=None):
  if item:
   ques, item, ndx = item
   ques = FFzBfi(ques)
   if   item == "addFiles" : self.VV4RT4()
   elif item == "pkgFiles" : self.VVcm7J(self.VVIHf1, "Import Files/Dirs", self.VVusXB)
   elif item == "ctrlFMan" : self.VVuApU()
   elif item == "ctrlImprt": self.VVcm7J(self.VVIHf1, "Import 'control' data", self.VVuDfE)
   elif item == "ctrlField": self.VVC6AO()
   elif item == "addDep" : self.VV9kEP(self.VVIHf1, fldTitle)
   elif item == "delDep" : self.VVpbtA(fldTitle)
   elif item == "pkgNam" : self.VVlbnM()
   elif item == "delAllRes": self.VVLpXB(ques, 1)
   elif item == "delInval" : self.VVLpXB(ques, 2)
   elif item == "delRow" : self.VVJIGU()
   elif item == "ctrlUndo" : self.VV22s9(self.VVs3Gr)
   elif item == "projUndo" : self.VV22s9(self.VVHCVG)
 def VV4RT4(self):
  Dir = CFG.lastPkgProjDir.getValue()
  self.session.openWithCallback(self.VVA4iB, BF(CClYaF, mode=CClYaF.VVR977, VV1pbK=Dir, VVIC7J=True))
 def VVA4iB(self, path):
  if path:
   if isinstance(path, list):
    lines = "\n".join(path)
    path = path[0]
   else:
    lines = path
   FFjt1c(CFG.lastPkgProjDir, FFx9pN(path, True))
   self.VVLKxu(lines, 2)
 @FFOAKH(par=1)
 def VVusXB(self, VV6A99, title, txt, colList):
  pkg = colList[0]
  lst = FF3xOt(r"%s | grep -E '^\/'" % (FF5sZa(VVjZ1L, pkg)))
  if lst : FFRMYv(self, BF(self.VVTJmT, VV6A99, lst), "Add %s Files/Dirs to project ?" % len(lst), title="Import Control Fields")
  else : self.VVwTG2("No files/dirs found in package:\n\n%s" % pkg)
 def VVTJmT(self, VV6A99, lst):
  VV6A99.cancel()
  self.VVLKxu("\n".join(lst), 2)
 def VVuApU(self):
  Dir = FFx9pN(CFG.lastPkgProjDir.getValue(), False)
  self.session.openWithCallback(self.VVmcFt, BF(CClYaF, VV1gDA="pkgCtrl", VV1pbK=Dir))
 def VVmcFt(self, path):
  if path:
   FFjt1c(CFG.lastPkgProjDir, path)
   fName = os.path.basename(path)
   FFj2hO(self.VVs3Gr)
   if FFpwZS("cp -f '%s' '%s'" % (path, self.VVNvsj + fName)):
    self.VVEB1h()
    self.VVIHf1.VVPkdw({1:"Script", 2:fName})
 def VV22s9(self, File):
  if FFpwZS("mv -f '%s.bak' '%s'" % (File, File)):
   self.VVEB1h()
  else:
   self.VVwTG2("Process Failed !")
 @FFOAKH(par=1)
 def VVuDfE(self, VV6A99, title, txt, colList):
  pkg = colList[0]
  lines = []
  for line in FF3xOt(FF5sZa(VVaS8u, pkg)):
   span = iSearch(r"^([A-Z].+):\s*.+", line)
   if span and span.group(1) in ("Package", "Version", "Depends", "Section", "Architecture", "Maintainer", "Source", "Description"):
    lines.append(line)
  if lines: FFRMYv(self, BF(self.VVoueF, VV6A99, lines), "Replace current fields ?", title="Import Control Fields")
  else : self.VVwTG2("Cannot import from this package:\n\n%s" % pkg)
 def VVoueF(self, VV6A99, lines):
  VV6A99.cancel()
  FFj2hO(self.VVs3Gr)
  with open(self.VVs3Gr, "w") as f:
   for line in lines:
    f.write(line.strip() + "\n")
  self.VVEB1h(jmpDict={1:"Control", 2:"Package"})
 def VV0sEJ(self):
  allRes, invRes, unkRes = [], [], []
  for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if lineNdx.isdigit():
    if Section == "Resource":
     allRes.append(int(lineNdx))
     if not ValidF: invRes.append(int(lineNdx))
    if Section == "?": unkRes.append(int(lineNdx))
  allRes.extend(unkRes)
  invRes.extend(unkRes)
  return sorted(allRes), sorted(invRes), sorted(unkRes)
 def VVLpXB(self, ques, mode):
  allRes, invRes, unkRes = self.VV0sEJ()
  if   mode == 1: lst = allRes
  elif mode == 2: lst = invRes
  if lst : FFRMYv(self, BF(self.VV0On5, lst), "%s ?" % ques, title=self.VVcHUa)
  else : FF28n1(self.VVIHf1, "Nothing to delete", 2000)
 def VV0On5(self, ndxLst):
  if FFCyVu(self.VVHCVG):
   lines = FFL19l(self.VVHCVG)
   FFj2hO(self.VVHCVG)
   with open(self.VVHCVG, "w") as f:
    for ndx, line in enumerate(lines):
     if not ndx in ndxLst:
      f.write("%s\n" % line)
   self.VVEB1h()
  else:
   FF8Wsn(self, self.VVHCVG, title=self.VVcHUa)
 def VVJIGU(self):
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVIHf1.VV5crm()
  if    Section == "Control" : file = self.VVs3Gr
  else      : file = self.VVHCVG
  if Section == "Control" : FFj2hO(self.VVs3Gr)
  else     : FFj2hO(self.VVHCVG)
  lineNum = int(self.VVIHf1.VV5crm()[0]) + 1
  FFpwZS("sed -i .bak -e '%dd' '%s'" % (lineNum, file))
  self.VVEB1h()
 def VVLKxu(self, line, jmp):
  if FFCyVu(self.VVHCVG):
   FFj2hO(self.VVHCVG)
   FFJvhj(self.VVHCVG)
   with open(self.VVHCVG, "a") as f:
    f.write("%s\n" % line)
   if   jmp == 1: jmpDict = {1:"Action" , 2:line.split("=")[0]}
   elif jmp == 2: jmpDict = {1:"Resource" , 3:line.strip().rstrip("/")}
   else   : jmpDict = None
   self.VVEB1h(jmpDict=jmpDict)
  else:
   FF8Wsn(self, self.VVHCVG, title=self.VVcHUa)
 def VVKEHB(self, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(FFsLU5("No-Action after installation" , "instNon", self.projAct_postInst != 0))
  VV3wat.append(FFsLU5("Restart after installation" , "instRes", self.projAct_postInst != 1))
  VV3wat.append(FFsLU5("Reboot after installation"  , "instReb", self.projAct_postInst != 2))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("No-Action after removal" , "rmNon", self.projAct_postRm != 0))
  VV3wat.append(FFsLU5("Restart after removal" , "rmRes", self.projAct_postRm != 1))
  VV3wat.append(FFsLU5("Reboot after removal"  , "rmReb", self.projAct_postRm != 2))
  FFLFTC(self, self.VVYw4S, VV3wat=VV3wat, title="Action (after the package is installed/removed)")
 def VVYw4S(self, item=None):
  if item:
   if   item == "instNon" : self.VVmBmf("postinst", 0)
   elif item == "instRes" : self.VVmBmf("postinst", 1)
   elif item == "instReb" : self.VVmBmf("postinst", 2)
   elif item == "rmNon" : self.VVmBmf("postrm", 0)
   elif item == "rmRes" : self.VVmBmf("postrm", 1)
   elif item == "rmReb" : self.VVmBmf("postrm", 2)
 def VVmBmf(self, subj, val):
  if FFCyVu(self.VVHCVG):
   lines = FFL19l(self.VVHCVG)
   FFj2hO(self.VVHCVG)
  else:
   lines = []
  inFile = False
  with open(self.VVHCVG, "w") as f:
   for ndx, line in enumerate(lines):
    line = line.strip()
    if not iMatch(r"%s\s*=.+" % subj, line, IGNORECASE) : f.write(line + "\n")
    else            : inFile = True
  if val > 0: self.VVLKxu("%s=%s" % (subj, {1:"restart", 2:"reboot"}.get(val, "")), 1)
  elif inFile: self.VVEB1h()
 def VVlbnM(self):
  pkg = FFWEt2(self.VVwdtN, r"_").lower()
  VV3wat = []
  VV3wat.append((pkg, pkg))
  VV3wat.append(VVAL3j)
  for s in ("extensions", "systemplugins", "", "skins", "picons", "softcams", "", "drivers", "security", "settings"):
   if s:
    name = "enigma2-plugin-%s-%s" % (s, pkg)
    c = VVFuwR if name == self.projPkg else ""
    VV3wat.append((c + name, name))
   else:
    VV3wat.append(VVAL3j)
  FFLFTC(self, self.VVfrko, VV3wat=VV3wat, title="Package Name")
 def VVfrko(self, item=None):
  if item:
   self.VVALN2("Package", item)
 @FFOAKH(par=1)
 def VV9kEP(self, VVIHf1, fldTitle):
  lst = set()
  for path in CCeSkW.VVrmJV():
   if FFCyVu(path):
    with open(path, "r") as f:
     for line in f:
      if line.startswith(("Package")):
       lst.add(line.split(":", 1)[1].strip())
  if lst:
   VV3wat = []
   for item in lst: VV3wat.append((item, item))
   VV3wat.sort(key=lambda x: x[0].lower())
   VV7tND = FFLFTC(self, BF(self.VVaSIb, fldTitle), VV3wat=VV3wat, width=1100, title="Add Binary Package")
   if self.VVj1mD:
    VV7tND.VVyQ6Y(self.VVj1mD)
  else:
   self.VVwTG2("Cannot read dependencies list !")
 def VVaSIb(self, fldTitle, item=None):
  if item:
   lst = []
   self.VVj1mD = item
   if FFCyVu(self.VVs3Gr):
    for line in FFL19l(self.VVs3Gr):
     line = line.strip()
     if line.startswith("%s:" % fldTitle):
      pkgs = line[len(fldTitle) + 1:].strip()
      if pkgs:
       lst = list(map(str.strip, pkgs.split(",")))
      break
   if not item in lst:
    lst.append(item)
    self.VVALN2("%s" % fldTitle, ", ".join(lst))
   else:
    FF28n1(self.VVIHf1, "Already added", 1500)
 def VVpbtA(self, fldTitle):
  lst = []
  lineNdx, Section, Title, Value, Size, Remarks, ValidF = self.VVIHf1.VV5crm()
  lst = list(map(str.strip, Value.split(",")))
  if lst:
   VV3wat = []
   for item in lst: VV3wat.append((item, item))
   FFLFTC(self, BF(self.VVGDdK, fldTitle, lst), VV3wat=VV3wat, title="Remove Dependency")
  else:
   self.VVwTG2("No dependencies to remove !")
 def VVGDdK(self, fldTitle, lst, item=None):
  if item:
   for ndx, dep in enumerate(lst):
    if dep == item:
     del lst[ndx]
     break
   if lst:
    self.VVALN2(fldTitle, ", ".join(lst))
   else:
    FFj2hO(self.VVs3Gr)
    FFpwZS("sed -i '/%s:*/d' '%s'" % (fldTitle, self.VVs3Gr))
    self.VVEB1h(jmpDict={1:"Control", 2:fldTitle})
 def VVALN2(self, subj, val):
  lines = FFL19l(self.VVs3Gr) if FFCyVu(self.VVs3Gr) else []
  inFile = False
  FFj2hO(self.VVs3Gr)
  with open(self.VVs3Gr, "w") as f:
   for ndx, line in enumerate(lines):
    line = line.strip()
    if line.startswith(subj + ":"):
     line = "%s: %s" % (subj, val)
     inFile = True
    f.write(line + "\n")
   if not inFile:
    f.write("%s: %s\n" % (subj, val))
  self.VVEB1h(jmpDict={1:"Control", 2:subj})
 def VVC6AO(self):
  err, lst = self.VVWetn(3, onlyName=True)
  if err:
   self.VVwTG2(err)
  else:
   curFields = []
   for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
    lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
    if Section == "Control":
     curFields.append(Title)
   lst.sort(key=lambda x: x[0].lower())
   VV3wat = []
   for item in lst:
    if not item[0] in curFields:
     VV3wat.append((item[0], item[1]))
   if VV3wat : FFLFTC(self, self.VVzUQ0, VV3wat=VV3wat, title="Control Fields", VVU8mZ=True)
   else  : self.VVwTG2("All fields are added.")
 def VVzUQ0(self, item=None):
  if item:
   if FFCyVu(self.VVs3Gr):
    txt, line, ndx = item
    FFj2hO(self.VVs3Gr)
    FFJvhj(self.VVs3Gr)
    with open(self.VVs3Gr, "a") as f:
     f.write("%s\n" % line)
    self.VVEB1h(jmpDict={1:"Control", 2:txt})
   else:
    FF8Wsn(self, self.VVs3Gr, title=self.VVcHUa)
 def VVWetn(self, mode, excl="", onlyName=False):
  path = "%sajpanel_pkg" % VVIp2p
  if not FFCyVu(path) : return "Missing 'control' Template File !", []
  elif mode == 0   : return "", []
  reqLst1, optLst1 , optLst2 = [], [], []
  for line in FFL19l(path):
   line = line.strip()
   if line and not line.startswith("#"):
    span = iSearch(r"(.{3})(\d):(.+):\s*(.*)", line)
    if span:
     typ, seq, name, val = span.group(1), span.group(2), span.group(3), span.group(4)
     if not excl or excl.startswith("%s:", fld):
      item = ((name, "%s: %s" %(name, val)))
      if   typ == "REQ" and seq == "1": reqLst1.append(item)
      elif typ == "OPT" and seq == "1": optLst1.append(item)
      elif typ == "OPT" and seq == "2": optLst2.append(item)
  if   mode == 1: lst = reqLst1
  elif mode == 2: lst = reqLst1 + optLst1
  else    : lst = reqLst1 + optLst1 + optLst2
  return "", lst
 def VV1QUT(self, VV6A99, title, txt, colList):
  for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if Section == "Control" and Remarks:
    self.VVIHf1.VVrqBw(ndx)
    FF28n1(self.VVIHf1, "Check %s\n( %s )" % (Title, FFzBfi(Remarks)), 1500)
    return
  VV3wat = []
  VV3wat.append(("Create .ipk", "ipk"))
  VV3wat.append(("Create .deb", "deb"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Create .tar.gz  (ignore control files)", "tar"))
  FFLFTC(self, self.VV41ZX, VV3wat=VV3wat, width=700, title=self.VVcHUa)
 def VV41ZX(self, typ=None):
  if typ:
   fnc = BF(self.VVyMDW, self.VVIHf1, typ)
   if self.projTotalDirs + self.projTotalFiles > 0:
    fnc()
   elif typ == "tar":
    self.VVwTG2("No Dirs/Files found !\n\nYou need to add at least 1 directory or 1 file to the project !")
    return
   else:
    FFRMYv(self, fnc, "No directories/files included in this package.\n\nContinue ?", title=self.VVcHUa)
 @FFOAKH(par=1)
 def VVyMDW(self, VVIHf1, typ):
  if   not self.projPkg : err = "Package"
  elif not self.projVer : err = "Version"
  elif not self.projArch : err = "Architecture"
  else     : err = ""
  if err:
   self.VVwTG2('Parameter "%s" not found !' % err)
   return
  pyTxt = ""
  if typ == "tar":
   tName, ext, arch = self.VVwdtN, "tar.gz" , ""
  else:
   tName, ext, arch = self.projPkg , typ  , "_" + self.projArch
   if   "py2" in self.VVwdtN.lower() : pyTxt = "_py2"
   elif "py3" in self.VVwdtN.lower() : pyTxt = "_py3"
  outFile = "%s%s_%s%s%s.%s" % (FFoUor(), tName, self.projVer, arch, pyTxt, ext)
  projDir = "/tmp/__%s/" % VVh9hj
  FFpwZS("rm -rf '%s'"  % projDir)
  if not typ == "tar":
   if not FFpwZS("mkdir -p '%s'" % projDir):
    self.VVwTG2("Cannot create tmp files:\n\n%s" % projDir)
    return
  ctrlLst = []
  resFiles = []
  for ndx, row in enumerate(self.VVIHf1.VVrrm9()):
   lineNdx, Section, Title, Value, Size, Remarks, ValidF = row
   if   Section == "Control": ctrlLst.append("%s: %s" % (Title, Value))
   elif ValidF     : resFiles.append(Value)
  if typ == "tar":
   CCts4c.VVyKy5(self, pType=typ, pName=self.VVwdtN, outFile=outFile, resFiles=resFiles)
   return
  cFile = "%scontrol" % projDir
  try:
   with open(cFile, "w") as f:
    for line in ctrlLst:
     f.write("%s\n" % line)
  except:
   self.VVwTG2("Cannot create 'control' file:\n\n%s" % cFile)
   return
  fName = ("prerm"     ,"preinst"      ,"postrm"     , "postinst"     )
  srcF  = (self.VVEvFg  , self.VVQBGg   , self.VVJorQ  , self.VVuB9m  )
  line  = ("Removing package : xx ...", "Installing Package : xx ..." , "Package removed (xx)." , "Installation completed (xx)" )
  act   = (0       , 0        , self.projAct_postRm  , self.projAct_postInst   )
  def VVZwiy(act):
   if   act == 1: return "echo 'RESTARTING GUI ...'\n%s\n" % CCp90q.VV0los()
   elif act == 2: return "echo 'REBOOTING DEVICE ...'\nsleep 3; reboot\n"
   else   : return "echo 'You may need to Restart GUI.'\n"
  cntrlFiles = [cFile]
  for fName, srcF, line, act in zip(fName, srcF, line, act):
   dstF = os.path.join(projDir, fName)
   cntrlFiles.append(dstF)
   if FFCyVu(srcF):
    FFpwZS("cp -f '%s' '%s'" % (srcF, dstF))
   else:
    with open(dstF, "w") as f:
     f.write("#!/bin/bash\n")
     f.write("echo '%s'\n" % line.replace("xx", self.projPkg))
     f.write(VVZwiy(act) if srcF in (self.VVuB9m, self.VVJorQ) else "")
     f.write("exit 0\n")
  CCts4c.VVyKy5(self, pType=typ, pName=self.VVwdtN, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, cbFnc=BF(self.VVfP9s, projDir))
 def VVfP9s(self, projDir):
  FFpwZS("rm -rf '%s'"  % projDir)
class CCxz86(Screen):
 def __init__(self, session, path, VVyCS0, VVKTL7=False, VVc8YP=False):
  self.skin, self.VVfOli = FFiNEe(VVlrZA, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVU4ws=False)
  self.session    = session
  self.Path     = FFoWxR(path)
  self.VVuolg   = path
  self.VV6hPq   = ""
  self.VVZI3n   = ""
  self.VVyCS0    = VVyCS0
  self.VVKTL7   = VVKTL7
  self.VVc8YP   = VVc8YP
  self.VVHfwN    = ""
  self.VVcMkC  = ""
  self.VVXMAG    = False
  self.VVpnvE  = False
  self.origPackageName  = ""
  self.VVdTT5   = 0
  self.VVW8yV  = "enigma2-plugin-extensions-"
  self.VVy1b0  = "enigma2-plugin-systemplugins-"
  self.VVmbMf = "enigma2-"
  self.VVvd6z  = 0
  self.VVUbo0  = 1
  self.VVcz78  = 2
  self.tbl     = None
  self.allOk     = False
  self.grnBtn     = True
  if VVmJwX(self.Path + "DEBIAN") or VVyCS0 : self.VVtdm0 = "DEBIAN"
  else           : self.VVtdm0 = "CONTROL"
  self.controlPath = self.Path + self.VVtdm0
  self.controlFile = self.controlPath + "/control"
  self.preinstFile = self.controlPath + "/preinst"
  self.postinstFile = self.controlPath + "/postinst"
  self.prermFile  = self.controlPath + "/prerm"
  self.postrmFile  = self.controlPath + "/postrm"
  self.newControlPath = ""
  if VVyCS0 : self.packageExt = ".deb"
  else  : self.packageExt = ".ipk"
  self.Title = "Create Package (%s)" % self.packageExt
  FFZMxC(self)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVlHAi()
 @FFOAKH()
 def VVlHAi(self):
  self.VVTNjW(True)
  self.VVYJMU(True)
 def VVqL2C(self, state):
  if self.tbl:
   if self.grnBtn : self.tbl["keyGreen"].show()
   else   : self.tbl["keyGreen"].hide()
 def VVYJMU(self, VVpQCY=False):
  cLst, pkgName, ok = self.VVFIaW(self.controlFile)
  self.allOk = ok
  if not cLst:
   FFdw58(self, "Cannot read control file:\n\n%s" % self.controlFile, title=self.Title)
   self.cancel()
   return
  if pkgName:
   txt = ""
   if self.VVXMAG:
    if   self.VVKTL7  : txt = "_no_restart"
    elif not self.VVc8YP : txt = "_no_depends"
   pkgName = "%s%s%s" % (pkgName, txt, self.packageExt)
   self.VVZI3n = self.VV6hPq + pkgName
   self.VVpnvE = True
   errTxt = ""
  else:
   self.VVZI3n  = ""
   self.VVpnvE = False
  if VVpQCY:
   if   pkgName.startswith(self.VVW8yV) : self.VVuolg = VVUytA + self.VVHfwN + "/"
   elif pkgName.startswith(self.VVy1b0) : self.VVuolg = VVhDOZ + self.VVHfwN + "/"
   else            : self.VVuolg = self.Path
  lst = []
  if self.VVXMAG : fg = "#f#00ff80ff#"
  else    : fg = ""
  bg = "#b#00000000#"
  lst.append((bg + "Source Path" , fg + self.Path      , ""))
  lst.append((bg + "Installation" , fg + "#f#00ffff88#" + self.VVuolg, ""))
  lst.append((bg + "Package File" , "#f#0000ff00#" + self.VVZI3n  , ""))
  lst.append((bg + "Control File" , "#f#00777777#" + self.controlFile  , ""))
  if self.grnBtn:
   if   self.VVdTT5 == 1: act = "Add commands to %s after installation." % FFjt5L("Restart GUI" , VVz22H)
   elif self.VVdTT5 == 2: act = "Add commands to %s after installation." % FFjt5L("Reboot Device", VVz22H)
   else      : act = "No action."
   lst.append((bg + "Post Install" , bg + act, ""))
  lst.extend(cLst)
  if self.tbl:
   self.tbl.VVMqQ9(lst, isSort=False)
  elif lst:
   if self.VVyCS0: bg, typ = "#0a002a3a", "DEB"
   else   : bg, typ = "#0a002a2a", "IPK"
   VVu8qI = self.VVWIEE
   VVwWmA = ("Create %s" % typ , self.VVHhAo , [])
   VVwSzI = ("Post Install"  , self.VVTj6Y , [])
   VVScQz = ("Installation Path" , self.VV2HEG  , [])
   VV4QTJ = ("Change Version"  , self.VVOMxR  , [])
   header  = ("Field" , "Value" , "Remarks" )
   widths  = (15  , 67  , 18  )
   self.tbl = FFUQ0v(self, None, title=self.Title, header=header, VVGape=lst, width=1800, height=1000, VV3cHe=widths, VVwdmN=30, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVKDPJ=2
        , VVwltY=bg, VVkxBG=bg, VVemyB=bg
        , VVbcr0="#00333333", VVJKqd="#06443333", VVX9AA="#0a332244")
   self.VV168u()
 def VV168u(self):
  for ndx, (field, val, rem) in enumerate(self.tbl.VVrrm9()):
   if rem:
    self.tbl.VVrqBw(ndx)
    break
 def cancel(self):
  if self.tbl: self.tbl.cancel()
  self.close()
 def VVWIEE(self, VV6A99):
  if self.newControlPath:
   if self.VVXMAG:
    self.VVrzU0()
   else:
    txt  = "Control Files were created in:\n%s\n\n" % FFjt5L(self.newControlPath, VVA4XU)
    txt += FFjt5L("Keep these files ?", VV1fx4)
    FFRMYv(self, self.cancel, txt, callBack_No=self.VVrzU0, title="Create Package", VVAgUy=True)
  else:
   self.cancel()
 def VVrzU0(self):
  FFpwZS("rm -rf '%s'" % self.newControlPath)
  self.cancel()
 def VVFIaW(self, cPath):
  pkg, ver, dsc, arc = "Package", "Version", "Description", "Architecture"
  dic = {}
  for line in FFL19l(cPath):
   if ":" in line:
    subj, _, val = line.partition(":")
    subj, val = subj.strip(), val.strip()
    if subj: dic[subj] = val
   elif iMatch(r"^\s+\S", line):
    line = line.strip()
    if line and dsc in dic:
     dic[dsc] = " - ".join((dic[dsc], line))
  pkgPatt = r"^[a-z]+[a-z0-9+-_.]+$"
  verPatt = r"^[a-zA-Z0-9_+-.~]*$"
  lenErr = "Must be > 1 char"
  frmErr = "Format error"
  lst = []
  pName =  pVer = pArc = ""
  ok = True
  for subj in (pkg, ver, dsc, arc):
   val = dic.get(subj, "")
   err = ""
   if val:
    if subj == pkg:
     pName = val
     if   len(val) < 2    : err = lenErr
     elif not iMatch(pkgPatt, val): err = frmErr
    elif subj == ver:
     pVer = val
     if   len(val) < 2    : err = lenErr
     elif not iMatch(verPatt, val): err = frmErr
    elif subj == arc:
     pArc = val
   else:
    err = "Missing value"
   lst.append((subj, val, ("#f#00ff8000#" if err else "") + err))
   if ok and err:
    ok = False
  for k, v in dic.items():
   if not k in (pkg, ver, dsc, arc):
    lst.append((k, v, ""))
  pkgName = ""
  if all((pName, pVer, pArc)):
   pkgName = "%s_%s_%s" % (pName, pVer, pArc)
   pkgName = pkgName.replace(" ", "")
  return lst, pkgName, ok
 def VVTNjW(self, VVpQCY):
  self.VVHfwN   = FFxtW5(self.Path)
  self.VVHfwN   = "_".join(self.VVHfwN.split())
  self.VVcMkC = self.VVHfwN.lower()
  self.VVXMAG = FFlpqQ(self.VVHfwN, self.Path)
  if self.VVXMAG and self.VVcMkC.endswith(VVXRGG.lower()):
   self.VVcMkC += "el"
  if self.VVXMAG : self.VV6hPq = FF0cqc()
  else    : self.VV6hPq = FFoUor()
  self.VV6hPq = FFoWxR(self.VV6hPq)
  if not VVmJwX(self.controlPath):
   FFpwZS("mkdir '%s'" % self.controlPath)
   self.newControlPath = self.controlPath
  else:
   self.newControlPath = ""
  mode = self.VVQWPv()
  if FFCyVu(self.controlFile):
   lines = FFL19l(self.controlFile)
   for line in lines:
    if line.strip().startswith("Package") and line.count(":") == 1:
     self.origPackageName = line.split(":")[1].strip()
     break
  else:
   if self.VVXMAG : version, description, maintainer = VVJ6zn , VVzOp7, "AMAJamry - " + CCJaSw.VVCcoN()
   else    : version, description, maintainer = "v1.0"   , self.VVHfwN , self.VVHfwN
   txt = ""
   txt += "Package: %s\n"  % self.VVSZM1(mode)
   txt += "Version: %s\n"  % version
   txt += "Description: %s\n" % description
   txt += "Maintainer: %s\n" % maintainer
   txt += "Architecture: all\n"
   txt += "Priority: optional\n"
   txt += "Section: base\n"
   txt += ("Homepage: %s\n" % CCJaSw.VVCcoN()) if self.VVXMAG else ""
   if self.VVXMAG and self.VVc8YP:
    txt += "Recommends: xz (>= 5), zip, p7zip, unrar, bzip2, ffmpeg, python-requests | python3-requests, python-imaging | python3-pillow, ar (>= 2) | enigma2-plugin-extensions-opkg-tools | binutils\n"
   with open(self.controlFile, "w") as f:
    f.write(txt)
  if self.VVXMAG : t = VVh9hj
  else    : t = self.VVHfwN
  self.VVIJmH(self.prermFile, "echo 'Removing package : %s ...'\n" % t)
  if self.VVXMAG : txt = (r'find %s \( -name "*.pyo" -o -name "*.pyc" \) -type f -delete' % self.Path) + "\n"
  else    : txt = ""
  self.VVIJmH(self.postrmFile, txt + "echo 'Package removed.'\n")
  if self.VVXMAG : self.VVIJmH(self.preinstFile, "echo 'Installing %s (%s) ...'\n" % (VVh9hj, VVJ6zn))
  else    : self.VVIJmH(self.preinstFile, "echo 'Installing Package : %s ...'\n" % self.VVHfwN)
  if VVpQCY and not mode == self.VVvd6z:
   self.VVdTT5 = 1
  txt = self.VV7CfH(0 if self.VVKTL7 else self.VVdTT5)
  canChange = True
  self.grnBtn = True
  if FFCyVu(self.postinstFile):
   fText = FFYVq0(self.postinstFile).strip()
   if txt.strip() == fText:
    canChange = False
   else:
    for action in range(3):
     if fText.strip() == self.VV7CfH(action).strip():
      break
    else:
     canChange = False
     self.grnBtn = False
  if canChange:
   with open(self.postinstFile, "w") as f:
    f.write(txt)
  FFpwZS("chmod 755 '%s' '%s' '%s' '%s' " % (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile))
 def VVIJmH(self, path, lines):
  if not FFCyVu(path):
   with open(path, "w") as f:
    f.write("#!/bin/bash\n")
    f.write(lines)
    f.write("exit 0\n")
 def VV7CfH(self, action):
  sep  = "echo '%s'\n" % SEP
  txt = "#!/bin/bash\n" + sep
  if action == 0:
   txt += "echo '--- FINISHED ---'\n"
   txt += sep
   txt += "echo 'You may need to Restart GUI.'\n"
  elif action == 1:
   txt += "echo 'RESTARTING GUI ...'\n"
   txt += sep
   txt += "%s\n" % CCp90q.VV0los()
  elif action == 2:
   txt += "echo 'REBOOTING DEVICE ...'\n"
   txt += sep
   txt += "sleep 3; reboot\n"
  else:
   return ""
  txt += "exit 0\n"
  return txt
 def VVTj6Y(self, VV6A99, title, txt, colList):
  if self.tbl["keyGreen"].getVisible():
   VV3wat = []
   VV3wat.append(("No Action" , "noAction" ))
   VV3wat.append(("Restart GUI" , "VV9qqT" ))
   VV3wat.append(("Reboot Device", "rebootDev" ))
   FFLFTC(self, self.VVJNdj, title="Package Installation Option (after completing installation)", VV3wat=VV3wat)
 def VVJNdj(self, item=None):
  if item is not None:
   if   item == "noAction"  : self.VVdTT5 = 0
   elif item == "VV9qqT" : self.VVdTT5 = 1
   elif item == "rebootDev" : self.VVdTT5 = 2
   self.VVTNjW(False)
   self.VVYJMU()
 def VV2HEG(self, VV6A99, title, txt, colList):
  rootPath = FFjt5L("/%s/" % self.VVHfwN, VVFuwR)
  VV3wat = []
  VV3wat.append(("Current Path"       , "toCurrent"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Extension Path"   , "toExtensions" , not self.VVuolg.startswith(VVUytA)))
  VV3wat.append(FFsLU5("System Plugins Path"  , "toSystemPlugins" , not self.VVuolg.startswith(VVhDOZ)))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Package Name in Root : %s" % rootPath , "toRootPath"  ))
  VV3wat.append(('Root "/"'        , "toRoot"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Pick Path with File Manager ..."  , "toOthers"  ))
  FFLFTC(self, self.VVjWlA, title="Installation Path", VV3wat=VV3wat)
 def VVjWlA(self, item=None):
  if item is not None:
   if   item == "toCurrent"  : self.VVO0Ka(FFx9pN(self.Path, True))
   elif item == "toExtensions"  : self.VVO0Ka(VVUytA)
   elif item == "toSystemPlugins" : self.VVO0Ka(VVhDOZ)
   elif item == "toRootPath"  : self.VVO0Ka("/")
   elif item == "toRoot"   : self.VVO0Ka("/", False)
   elif item == "toOthers"   : self.session.openWithCallback(self.VV67SG, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=FF0cqc()))
 def VV67SG(self, path):
  if len(path) > 0:
   self.VVO0Ka(path)
 def VVO0Ka(self, parent, withPackageName=True):
  if withPackageName : self.VVuolg = parent + self.VVHfwN + "/"
  else    : self.VVuolg = "/"
  mode = self.VVQWPv()
  FFpwZS(r"sed -i '/Package/c\Package: %s' %s" % (self.VVSZM1(mode), self.controlFile))
  self.VVYJMU()
 def VVOMxR(self, VV6A99, title, txt, colList):
  if FFCyVu(self.controlFile):
   lines = FFL19l(self.controlFile)
   version = ""
   for line in lines:
    if ":" in line:
     parts = line.split(":")
     key  = parts[0].strip()
     val  = parts[1].strip()
     if key == "Version":
      version = val
      break
   if version : FF4z45(self, self.VV1vpN, title="Change Package Version", defaultText=version, message="Enter Version:")
   else  : FFdw58(self, "Version not found or incorrectly set !")
  else:
   FF8Wsn(self, self.controlFile)
 def VV1vpN(self, VVRD20):
  if VVRD20:
   version, color = self.VVIuvk(VVRD20, False)
   if color == VVGCYL:
    FFpwZS(r"sed -i '/Version:/c\Version: %s' %s" % (VVRD20, self.controlFile))
    self.VVYJMU()
   else:
    FFdw58(self, "Incorrect Version Syntax !\n\nAllowed characters : letter, digits and _+-.~")
 def VVSZM1(self, mode):
  prefix, name = "", ""
  package = self.origPackageName or self.VVcMkC
  if package.startswith(self.VVmbMf):
   span = iSearch(r"(.+-)(.+)", package)
   if span:
    prefix, name = span.group(1).strip(), span.group(2)
  if not name:
   prefix, name = self.VVmbMf, package
  prefix = iSub(r"([^a-z0-9+-.]+)", r"-", prefix)
  name = iSub(r"([^a-z0-9+-.]+)", r"-", name)
  if   mode == self.VVUbo0 : prefix = self.VVW8yV
  elif mode == self.VVcz78 : prefix = self.VVy1b0
  return (prefix + name).lower()
 def VVQWPv(self):
  if   self.VVuolg.startswith(VVUytA) : return self.VVUbo0
  elif self.VVuolg.startswith(VVhDOZ) : return self.VVcz78
  else            : return self.VVvd6z
 def VVIuvk(self, val, isPackage):
  if   isPackage : pattern = r"^[a-z]+[a-z0-9+-_.]+$"
  else   : pattern = r"^[a-zA-Z0-9_+-.~]*$"
  if iMatch(pattern, val) and len(val) >= 2 : return val, VVGCYL
  else          : return val, VVYjI5
 def VVHhAo(self, VV6A99, title, txt, colList):
  if not self.VVpnvE:
   FFdw58(self, "Please fix Control File errors first.")
   return
  obfVars = obfErr = None
  if self.VVXMAG:
   obfVars, obfErr = self.VVcs8G()
  parent  = FFx9pN(self.VVuolg, True)
  newPath  = parent[1:]
  symlink  = parent[1:] + self.VVHfwN
  symlinkTo = FFVc4H(self.Path)
  instPathInfo=  (self.VVuolg, parent, newPath, symlink, symlinkTo)
  pType  = "deb" if self.VVyCS0 else "ipk"
  pName  = self.VVHfwN
  outFile  = self.VVZI3n
  resFiles = [self.Path]
  cntrlFiles = [self.controlFile]
  for f in (self.preinstFile, self.postinstFile, self.prermFile, self.postrmFile):
   if FFCyVu(f):
    cntrlFiles.append(f)
  CCts4c.VVyKy5(self, pType=pType, pName=pName, outFile=outFile, cntrlFiles=cntrlFiles, resFiles=resFiles, instPathInfo=instPathInfo, cbFnc=BF(self.VVvwIL, obfVars, obfErr))
 def VVvwIL(self, obfVars, obfErr):
  if obfVars:
   err = obfErr
   if not err:
    myP, obfP = obfVars
    if not FFpwZS("mv -f '%splugin.py' '%s'" % (obfP, myP)): err = "Cannot restore plug"
    if not FFpwZS("mv -f '%smain.py' '%s'" % (obfP, myP)): err = "Cannot restore main"
   if err:
    FFdw58(self, err, title="OBF Error")
 def VVcs8G(self):
  myP  = VV231J
  obfP = "%sOBF/" % VV231J
  plug = "%splugin.py" % myP
  main = "%smain.py" % myP
  lst  = iGlob("%s*main_final.py" % obfP)
  obfVars = (myP, obfP)
  if not VVmJwX(obfP) : return obfVars, "No OBF Dir"
  if not len(lst) == 1 : return obfVars, "No OBF File"
  if not FFCyVu(plug) : return obfVars, "No plug File"
  if not FFCyVu(main) : return obfVars, "No main File"
  if not FFpwZS("cp -f '%s' '%s' '%s'" % (plug, main, obfP)) : return obfVars, "Cannot copy to OBF"
  if not FFpwZS("cp -f %s*main_final.py '%s'" % (obfP, plug)): return obfVars, "Cannot OBF to main"
  if not FFpwZS("rm -f '%s'" % main)       : return obfVars, "Cannot del main"
  return obfVars, ""
class CCts4c(Screen):
 def __init__(self, session, title="", pType="", pName="", outFile="", cntrlFiles="", resFiles=None, instPathInfo="", cbFnc=None):
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1400, 900, 50, 30, 20, "#11302020", "#0a001010", 30)
  self.session   = session
  self.Title    = title or "Package Maker (%s)" % pName
  self.pType    = pType
  self.pName    = pName
  self.outFile   = outFile
  self.cntrlFiles   = cntrlFiles
  self.resFiles   = resFiles
  self.instPathInfo  = instPathInfo
  self.cbFnc    = cbFnc
  if pType == "deb": self.tarParam, self.tarExt = "-cJf", ".tar.xz"
  else    : self.tarParam, self.tarExt = "-czf", ".tar.gz"
  self.isTar    = pType == "tar"
  self.totalObj   = len(resFiles)
  self.VVRhqH = "packaging_result"
  self.tmpDir    = "/tmp/_%s/" % VVh9hj
  self.dataDir   = self.tmpDir + "DATA/"
  self.controlDir   = self.tmpDir + "CONTROL/"
  self.debBinFile   = self.tmpDir + "debian-binary"
  self.controlFile  = self.tmpDir + "control" + self.tarExt
  self.resLstFile   = self.tmpDir + "resLst"
  self.allInRoot   = False
  self.VVuolg  = ""
  FFZMxC(self, self.Title, addScrollLabel=True)
  FFBep1(self, { "ok": self.VV0awf })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH(VVRhqH=self.VVRhqH)
  self["myLabel"].appendText("Process started ...")
  FFIElK(self.VVv7Ck)
 def VV0awf(self):
  pass
 def VVDiQh(self, txt):
  self["myLabel"].appendText(txt + "\n")
 def VVq36d(self, txt="FAILED"):
  self.VVDiQh(FFjt5L("\n%s\n\nProcess Stopped !" % txt, VVz22H))
  self.VVBB9M()
 def VVBB9M(self):
  self.VVcECy()
  if self.cbFnc:
   self.cbFnc()
 def VVcECy(self, txt="FAILED"):
  FFpwZS("rm -rf '%s'"  % self.tmpDir)
 def VVv7Ck(self):
  self.VVDiQh("Checking Resources ...")
  if self.totalObj > 1:
   self.resFiles, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil = CCts4c.VVm09O(self.resFiles)
   txt = ".. Valid Resources List\t: %s\n" % len(self.resFiles)
   if errLst  : txt += ".. Invalid Files/Dirs\t: %s\n... %s\n" % (len(errLst), FFjt5L("\n... ".join(errLst), VVo7S9, VVA4XU))
   if totDuplDir : txt += ".. Removed Duplicate Dirs\t: %s\n"  % totDuplDir
   if totDuplFil : txt += ".. Removed Duplicate File\t: %s\n"  % totDuplFil
   if mntLst  : txt += ".. Removed Mount Paths\t: %s\n"   % len(mntLst)
   if rmDirLst  : txt += ".. Ignored dirs (child listed)\t: %s" % len(rmDirLst)
   self.VVDiQh(FFjt5L(txt.rstrip("\n"), VVA4XU))
   if not self.resFiles:
    self.VVq36d("No valid resources")
    return
  elif self.totalObj == 1 and not FFCyVu(self.resFiles[0]):
   self.VVq36d("Invalid or unreachable file/dir:\n%s" % self.resFiles[0])
   return
  self.VVcECy()
  FFwgGB(self.outFile)
  self.VVDiQh("Creating working dirs ...")
  if not FFpwZS("mkdir -p '%s'"  % self.tmpDir):
   self.VVq36d("Cannot create working dir.")
   return
  if not self.isTar:
   if not FFpwZS("mkdir -p '%s'" % self.controlDir):
    self.VVq36d("Cannot create /tmp/ dir.")
    return
   if self.instPathInfo:
    VVuolg, parent, newPath, symlink, symlinkTo = self.instPathInfo
    newPath  = self.dataDir + newPath
    symlink  = self.dataDir + symlink
    symlinkTo = symlinkTo
    self.allInRoot = VVuolg == "/"
    self.VVuolg = VVuolg.rstrip("/")
    if not FFpwZS("mkdir -p '%s'" % newPath):
     self.VVq36d("Cannot create full path.")
     return
    if not FFpwZS("ln -sf '%s' '%s';" % (symlinkTo, symlink)):
     self.VVq36d("Cannot create resources link.")
     return
   self.VVDiQh("Creating debian-binary file ...")
   if not FF7ymp("echo '2.0' > '%s'" % self.debBinFile):
    self.VVq36d("Cannot create bin file.")
    return
   lst = self.cntrlFiles
   for f in lst:
    if not FFpwZS("cp -f '%s' '%s'" % (f, self.controlDir)):
     self.VVq36d("Cannot read file:\n%s" % f)
     return
    newF = os.path.join(self.controlDir, os.path.basename(f))
    FFJvhj(newF)
    if not FFpwZS("chmod 755 '%s'" % newF):
     self.VVq36d("Cannot chmod file:\n%s" % newF)
     return
   self.VVDiQh("Archiving control files ...")
   cmd  = "cd '%s';" % self.controlDir
   cmd += "tar %s '%s' ./*;" % (self.tarParam, self.controlFile)
   if not FFpwZS(cmd):
    self.VVq36d("Cannot archive control files.")
    return
  self.VVDiQh("Archiving data files ...")
  if self.totalObj > 1:
   self.resFiles.sort(key=lambda x: x[0].lower())
   with open(self.resLstFile, "w") as resF:
    for item in self.resFiles:
     item = item.lstrip("/")
     if item:
      resF.write("%s\n" % item)
  FFIElK(self.VVze04)
 def VVze04(self):
  if self.isTar: dataFile = self.outFile
  else   : dataFile = self.tmpDir + "data" + self.tarExt
  tarExclude = "--exclude CONTROL --exclude DEBIAN --exclude __pycache__"
  if FFlpqQ(self.pName, self.outFile):
   tarExclude += " --exclude OBF --exclude *.pyo --exclude *.pyc"
  if self.instPathInfo:
   self.tarParam = self.tarParam.replace("-c", "-ch")
   cmd = "cd '%s';" % self.dataDir
   if self.allInRoot:
    cmd += "tar -C '%s' %s %s '%s' ./" % (self.resFiles[0], tarExclude, self.tarParam, dataFile)
   else:
    cmd += "tar %s %s '%s' '.%s'" % (tarExclude, self.tarParam, dataFile, self.VVuolg)
  else:
   if self.totalObj > 1:
    cmd = "tar -C / %s %s '%s' -T '%s'" % (tarExclude, self.tarParam, dataFile, self.resLstFile)
   elif self.totalObj == 1:
    cmd = "tar -C / %s %s '%s' '%s'" % (tarExclude, self.tarParam, dataFile, self.resFiles[0].lstrip("/"))
   else:
    cmd = ""
  if cmd:
   resp = FF3xOt(cmd)
   if resp:
    self.VVq36d(FFjt5L("\n".join(resp), VVyFI2, VVz22H))
    return
  else:
   if not FFpwZS("cp -f '%sdata%s' '%s'" % (VVIp2p, self.tarExt, self.tmpDir)):
    self.VVq36d("Cannot copy temporary data.%s" % self.tarExt)
    return
  if not self.isTar:
   self.VVDiQh("Creating %s ..." % self.pType.upper())
   arResp = FF3xOt("ar -r '%s' '%s' '%s' '%s';" % (self.outFile, self.debBinFile, self.controlFile, dataFile))
   if len(arResp) > 1 or not FFCyVu(self.outFile):
    self.VVq36d(FFjt5L("\n".join(arResp), VVyFI2, VVz22H))
    return
  self.VVBB9M()
  self.VVDiQh("Done.\n\nResult:\n%s\n" % FFjt5L(self.outFile, VVSGsk))
 @staticmethod
 def VVm09O(lst):
  lines = list(map(str.strip, lst))
  cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst = [], [], [], [], [], []
  for item in lst:
   item = item.strip()
   if   os.path.ismount(item) : mntLst.append(item)
   elif os.path.isdir(item) : dirLst.append(FFoWxR(item))
   elif os.path.isfile(item) : filLst.append(item)
   else       : errLst.append(item)
  totDir = len(dirLst)
  dirLst = list(set(dirLst))
  totDuplDir = totDir - len(dirLst)
  totFil = len(filLst)
  filLst = list(set(filLst))
  totDuplFil = totFil - len(filLst)
  cleanLst.extend(list(set(filLst)))
  for tDir in dirLst:
   for fil in cleanLst:
    if fil.startswith(tDir):
     rmDirLst.append(tDir)
     break
   else:
    cleanLst.append(tDir)
  cleanLst.sort(key=lambda x: x.lower())
  return cleanLst, dirLst, filLst, errLst, mntLst, rmDirLst, totDuplDir, totDuplFil
 @staticmethod
 def VVyKy5(SELF, **kwargs):
  if CCeSkW.VVq71e(SELF):
   SELF.session.open(CCts4c, **kwargs)
class CCeSkW(Screen, CCEzue):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 850, 900, 50, 40, 30, "#221a001a", "#22110011", 30)
  self.session   = session
  self.lastListAllRow  = -1
  self.lastRemoveAllRow = -1
  self.lastRemoveExtRow = -1
  self.lastPickedRow  = -1
  self.holdPkgColor  = "#f#00ff8800#"
  self.instPkgColor  = "#f#0000ff00#"
  CCEzue.__init__(self)
  c1, c2, c3, c4 = VVJEMb, VVZtfx, VVIH76, VVFuwR
  VV3wat = []
  VV3wat.append((c1 + "Plugins Browser"        , "pluginsBrowser"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Download/Install Packages (from feeds)"  , "downloadInstallPackages" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Remove Packages (show all)"     , "VVlXsDsAll"  ))
  VV3wat.append((c3 + "Remove Packages (Plugins/SoftCams/Skins)" , "removePluginSkinSoftCAM" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Update Packages List from Feeds"    , "VV3sSc"  ))
  VV3wat.append((c2 + "Upgradable Packages"       , "VVgIEp" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c4 + "Package Creator (ipk/deb/tar)"    , "packageCreator"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c4 + "Generate Packages.gz (from ipk/deb directory)", "VVtB0a"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Packaging Tool"         , "VV5EzU"   ))
  VV3wat.append(("Active Feeds"          , "VV4p0x"   ))
  FFZMxC(self, title="Plugins Tools", VV3wat=VV3wat)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "pluginsBrowser"    : CCFZr4.VVsCNi(self.session)
   elif item == "downloadInstallPackages"  : FFimQ3(self, BF(self.VV3v9Q, 0))
   elif item == "VVlXsDsAll"   : FFimQ3(self, BF(self.VV3v9Q, 1))
   elif item == "removePluginSkinSoftCAM"    : FFimQ3(self, BF(self.VV3v9Q, 2))
   elif item == "VV3sSc"   : CCeSkW.VV3sSc(self)
   elif item == "VVgIEp"  : self.VVgIEp()
   elif item == "packageCreator"    : self.VV37Fz()
   elif item == "VVtB0a"   : self.VVtB0a()
   elif item == "VV5EzU"    : self.VV5EzU()
   elif item == "VV4p0x"    : self.VV4p0x()
   else          : self.close()
 @FFOAKH()
 def VV4p0x(self):
  VVAkuK = []
  totAll = 0
  for path in CCeSkW.VVrmJV():
   tot = 0
   with open(path, "r") as f:
    for line in f:
     if line.startswith("Package"):
      tot += 1
      totAll += 1
   if tot:
    VVAkuK.append((os.path.basename(path), str(tot)))
  if VVAkuK:
   VVW5y5 = "Total Packages = %s" % totAll
   VVAkuK.sort(key=lambda x: x[0].lower())
   header  = ("Feed","Packages")
   widths  = (82  , 18  )
   VVLIqP = (LEFT  , CENTER )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1000, VVwdmN=26, VVW5y5=VVW5y5, VVKDPJ=2)
  else:
   self.VVwTG2("Cannot read packages list !")
 def VVgIEp(self, VV6A99=None):
  FFimQ3(VV6A99 or self, BF(self.VVaCeD, VV6A99))
 def VVaCeD(self, VV6A99):
  fLst, feedDic, instDic = self.VVLY1Q()
  lst = set()
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if pkg in feedDic:
    ver1, dsc1, inst1, hold1 = feedDic[pkg]
    if CCeSkW.VVohK9(ver, ver1) < 0:
     if hold : hold, c1 = "Yes", self.holdPkgColor
     else : hold = c1 = ""
     lst.add((c1 + pkg, c1 + ver, c1 + ver1, c1 + hold))
  if lst:
   VVAkuK = list(lst)
   VVAkuK.sort(key=lambda x: FFd1WZ(x[0]).lower())
   if VV6A99:
    VV6A99.VVMqQ9(VVAkuK, isSort=False)
   else:
    bg = "#20110011"
    VVwSzI = ("Upgrade"  , self.VVGNBx   , [])
    VVScQz = ("Package Info." , self.VVU1Iy    , [])
    VV4QTJ = ("Hold Update" , self.VVv7u0 , [])
    header  = ("Package", "Current Version" , "New Version" , "Hold Upd." )
    widths  = ( 40  , 25    , 25   , 10   )
    VVLIqP = ( LEFT , LEFT    , LEFT   , CENTER  )
    tbl = FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1700, VVwdmN=26, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindPackages, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00114455")
    tbl.VVIOX6(BF(self.VVhLnz, tbl))
  else:
   FFjADj(self, "Nothing to upgrade", 1500)
   if VV6A99: VV6A99.cancel()
 def VVGNBx(self, VV6A99, title, txt, colList):
  pkg, curV, newVer, holdState = VV6A99.VV5crm()
  if holdState:
   FF28n1(VV6A99, "Change Hold State first", 1000)
  else:
   cmd = FF5sZa(VVwFAi, pkg)
   FFbi5l(self, cmd, title="Installing : %s" % pkg, VVoasw=BF(self.VVgIEp, VV6A99))
 @FFOAKH(par=1)
 def VVv7u0(self, VV6A99, title, txt, colList):
  pkg, curV, newVer, holdState = VV6A99.VV5crm()
  cmd = FF5sZa(VVw6qo if holdState else VVofV3, pkg)
  FFpwZS(cmd)
  holdLst = self.VVhDfd(pkg)
  holdState = c1 = ""
  if len(holdLst) == 1 and holdLst[0][0] == pkg:
   holdState, c1 = "Yes", self.holdPkgColor
  VV6A99.VViSLW((c1 + pkg, c1 + curV, c1 + newVer, c1 + holdState))
  self.VVhLnz(VV6A99)
 def VVhLnz(self, VV6A99):
  pkg, curV, newVer, holdState = VV6A99.VV5crm()
  VV6A99["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 def VVtB0a(self):
  if CCeSkW.VVq71e(self):
   self.session.openWithCallback(self.VVKCPV, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=CFG.lastFeedPkgsDir.getValue()))
 @FFOAKH()
 def VVKCPV(self, path):
  title = "Feed Packages.gz Creator"
  if len(path) > 0:
   FFjt1c(CFG.lastFeedPkgsDir, path)
   files = []
   lst = iGlob(path + "*.ipk")
   totIpk = len(lst)
   for f in lst:
    files.append(os.path.basename(f))
   lst = iGlob(path + "*.deb")
   totDeb = len(lst)
   for f in lst:
    files.append(os.path.basename(f))
   lst = None
   if len(files) > 0:
    files.sort(key=lambda x: x[0].lower())
   else:
    FFdw58(self, "No ipk/deb files found in:\n\n%s" % path)
    return
   pFile = os.path.join(path, "Packages")
   gFile = "%s.gz" % pFile
   tFile = os.path.join(path, "Packages.stamps")
   with open(pFile, "w") as pF:
    with open(tFile, "w") as tF:
     for fName in files:
      fPath = os.path.join(path, fName)
      txt, mTime = CCeSkW.VVy0xB(fPath)
      pF.write("%s\n" % txt)
      tF.write("%s\n" % mTime)
   FFwgGB(gFile)
   os.system("gzip -k '%s'" % pFile)
   c = VVJEMb
   txt  = "%s: %s\n" % (FFjt5L("Processed Files:", c), len(files))
   txt += "  ipk   : %s\n" % totIpk
   txt += "  deb  : %s\n" % totDeb
   txt += "\n%s\n" % FFjt5L("Output Files:", c)
   txt += "  %s\n" % pFile
   txt += "  %s\n" % gFile
   txt += "  %s" % tFile
   FF4lCP(self, txt)
 def VV5EzU(self):
  pkg = FFUaC8()
  aptT = "apt - Advanced Package Tool" if FFayeZ("apt") else ""
  txt = {"ipkg": "Itsy", "opkg": "Open", "dpkg": "Debian"}.get(pkg, "")
  txt = "%s - %s Package Management System" % (pkg, txt) if txt else ""
  txt += "%s%s" % ("\n\nand\n\n" if txt and aptT else "", aptT)
  FFipXT(self, txt or "No packaging tools found!")
 def VV3v9Q(self, mode, Filter="", VV6A99=None):
  fdPath = Filter[5:] if Filter.startswith("feed=") else ""
  fLst, feedDic, instDic = self.VVLY1Q(fdPath)
  if fdPath and not feedDic:
   FFjADj(VV6A99, "No packages !", 1200)
   return
  if mode == 0: dic = feedDic.copy()
  else  : dic = instDic.copy()
  feedDic = instDic = None
  if mode == 2:
   words = ("extensions", "systemplugins", "softcams", "skin")
   for pkg in list(dic):
    if not pkg.startswith("enigma2-plugin-") and not any(x in pkg for x in words):
     del dic[pkg]
  if mode == 0 and Filter and not fdPath:
   word = Filter.lower()
   if word.endswith("s"): word = word[:-1]
   for pkg in list(dic):
    if not word in pkg:
     del dic[pkg]
   if not dic:
    FFjADj(VV6A99, "Not found", 1500)
    return
  VVGape = []
  for pkg, (ver, dsc, inst, hold) in dic.items():
   holdT = instT = c1 = ""
   if   hold    : c1, holdT = self.holdPkgColor, "Yes"
   elif inst and mode == 0 : c1, instT = self.instPkgColor, "Yes"
   VVGape.append((c1+ pkg, c1 + ver, c1 + dsc, c1 + instT, c1 + holdT))
  if VVGape:
   VVGape.sort(key=lambda x: FFd1WZ(x[0]).lower())
  else:
   FFdw58(self, "No packages found!")
   return
  if mode == 0:
   c1 = VVZtfx
   if Filter and not Filter == "All":
    if fdPath: title = "Feed = %s" % os.path.basename(fdPath)
    else  : title = "Filter = %s" % Filter
    title = "Download/Install ... %s" % FFjt5L(title, c1)
   else:
    title = FFjt5L("Download/Install Packages (from feeds)", c1)
  if VV6A99:
   VV6A99.VVMqQ9(VVGape, title, VV5YRVMsg=False, isSort=False)
   self.VVYtzC(mode, VV6A99)
  else:
   if mode == 0:
    VVC51D = self.lastListAllRow
    VVu8qI = self.VVxsZe
    VVwWmA = ("Install" , self.VVVcWW     , [])
    VVwSzI = ("Download" , self.VVyZYM     , [])
    VV4QTJ = ("Filter"  , BF(self.VVHZMd, fLst) , [])
    width = 1800
    widths = (43, 18, 32, 7, 0)
   else:
    if mode == 1:
     VVC51D  = self.lastRemoveAllRow
     VVu8qI = self.VVpRSq
    else:
     VVC51D  = self.lastRemoveExtRow
     VVu8qI = self.VVYcPT
    VVwWmA = ("Uninstall" , self.VVlXsD        , [])
    VVwSzI = None
    VV4QTJ = ("Hold Update", BF(self.VVyBrK, mode), [])
    width = 1550
    widths = (55, 35, 0, 0, 10)
   bg = "#11191111"
   VVScQz = ("Package Info." , self.VVU1Iy  , [])
   header   = ("Package", "Version" , "Description" , "Inst." , "Hold Upd." )
   VVLIqP  = (LEFT  , LEFT  , LEFT   , CENTER , CENTER  )
   tbl = FFUQ0v(self, None, header=header, VVGape=VVGape, VV3cHe=widths, VVLIqP=VVLIqP, width=width, height=1000, VVwdmN=26, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVC51D=VVC51D, VVSLOq=CFG.lastFindPackages
      , VVwltY="#22110011", VVkxBG=bg, VVemyB=bg, VVJKqd="#00004444", VVbcr0="#00333333")
   if mode != 0:
    tbl.VVIOX6(BF(self.VVYtzC, mode, tbl))
 def VVHZMd(self, fLst, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("All Packages", "All"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Feed ...", "fdPath"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("enigma2-plugin-extensions" , "enigma2-plugin-extensions" ))
  VV3wat.append(("enigma2-plugin-systemplugins" , "enigma2-plugin-systemplugins"))
  VV3wat.append(VVAL3j)
  for word in ("Alsa", "Dream", "Drivers", "Enigma", "Extensions", "Feeds", "Firmware", "Fonts", "GLibc", "GStreamer", "Kernel", "Lib", "Linux", "Locale", "Modules", "Network", "Octagon", "PIcons", "Perl", "Pkg", "Plugin", "Python", "Samba", "Settings", "Skin", "SoftCam", "SystemPlugins", "Tools", "Util", "Zip"):
   VV3wat.append((word, word))
  FFLFTC(self, BF(self.VVheDx, fLst, VV6A99), VV3wat=VV3wat, title="Select Filter")
 def VVheDx(self, fLst, VV6A99, item=None):
  if item:
   def VVZwiy(txt):
    if txt: FFimQ3(VV6A99, BF(self.VV3v9Q, 0, Filter=txt, VV6A99=VV6A99), title="Filtering ...")
   if item == "fdPath":
    lst = [(os.path.basename(f), "feed=%s" % f) for f in fLst]
    if lst : FFLFTC(self, VVZwiy, VV3wat=lst, title="Select Feed")
    else : FF28n1(VV6A99, "Not feed list", 2000)
   else:
    VVZwiy(item)
 def VVLY1Q(self, fdPath=""):
  fLst, feedDic = CCeSkW.VVPNlD(fdPath)
  instDic = CCeSkW.VVuPwl()
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if not dsc:
    if pkg in feedDic: newDsc = feedDic[pkg][1]
    else    : newDsc = self.VVcRZW(pkg)
    if newDsc:
     instDic[pkg] = (ver, newDsc, inst, hold)
  for pkg, (ver, dsc, inst, hold) in instDic.items():
   if pkg in feedDic:
    ver1, dsc1, inst1, hold1 = feedDic[pkg]
    if ver == ver1:
     feedDic[pkg] = (ver1, dsc1, inst, hold)
  return fLst, feedDic, instDic
 @staticmethod
 def VVPNlD(fdPath):
  if fdPath: fLst = [fdPath]
  else  : fLst = CCeSkW.VVrmJV()
  return fLst, CCeSkW.VVLR8b(fLst)
 @staticmethod
 def VVuPwl():
  fLst = [CCeSkW.VVqSoq()]
  return CCeSkW.VVLR8b(fLst)
 def VVhDfd(self, toFind=""):
  dic = CCeSkW.VVuPwl()
  lst = set()
  for pkg, (ver, dsc, inst, hold) in dic.items():
   if hold:
    if toFind:
     if pkg == toFind:
      return [(pkg, ver)]
    else:
     lst.add((pkg, ver))
  return lst
 @staticmethod
 def VVLR8b(fLst):
  dic = {}
  tab = lambda line: line.partition(":")[2].strip()
  for path in fLst:
   try:
    with open(path, "r") as f:
     pkg = ver = dsc = sta = ""
     for line in f:
      if ":" in line:
       line = line.strip()
       if   line.startswith("Package")  : pkg = tab(line)
       elif line.startswith("Version")  : ver = tab(line)
       elif line.startswith("Status")   : sta = tab(line)
       elif line.startswith("Description") : dsc = tab(line)
      elif iMatch(r"^\s+\S", line):
       dsc = " - ".join((dsc, line.strip()))
      elif not line.strip():
       staL = sta.lower()
       hold = "hold" in staL
       inst = "installed" in staL and not "not-installed" in staL
       if pkg: dic[pkg] = (ver, dsc, inst, hold)
       pkg = ver = dsc = sta = ""
   except:
    pass
  return dic
 @staticmethod
 def VVrmJV():
  dirs = set()
  span = iSearch(r"option\s+lists_dir\s+(\/.+\/.+)", FFYVq0("/etc/opkg/opkg.conf"))
  if span and VVmJwX(span.group(1)): dirs.add(span.group(1))
  for s in ("apt", "opkg", "ipkg"):
   path = "/var/lib/%s/lists" % s
   if VVmJwX(path): dirs.add(path)
  files = []
  for d in dirs: files.extend(iGlob(FFoWxR(d) + "*"))
  files = [f for f in files if os.path.isfile(f) and not f.endswith("/status")]
  files.sort()
  return files
 @staticmethod
 def VVqSoq():
  for p in ("lib", "lib64"):
   p = "/var/%s/dpkg/status" % p
   if FFCyVu(p):
    return p
  span = iSearch(r"option\s+status_file\s+(\/.+\/.+)", FFYVq0("/etc/opkg/opkg.conf"))
  if span and VVmJwX(span.group(1)):
   return span.group(1)
  else:
   for s in ("opkg", "ipkg"):
    path = "/var/lib/%s/status" % s
    if FFCyVu(path):
     return path
  return ""
 def VVcRZW(self, pkg):
  dsc = ""
  for s in ("opkg", "ipkg"):
   fil = "/var/lib/%s/info/%s.control" % (s, pkg)
   if FFCyVu(fil):
    for line in FFL19l(fil):
     if ":" in line:
      line = line.strip()
      if   line.startswith("Description") : dsc = line.partition(":")[2].strip()
      elif line and line.startswith(" ") : dsc += " - " + line.strip()
  return dsc
 def VVxsZe(self, VV6A99):
  self.lastListAllRow = VV6A99.VVGTqU()
  VV6A99.cancel()
 def VVpRSq(self, VV6A99):
  self.lastRemoveAllRow = VV6A99.VVGTqU()
  VV6A99.cancel()
 def VVYcPT(self, VV6A99):
  self.lastRemoveExtRow = VV6A99.VVGTqU()
  VV6A99.cancel()
 def VVbOv6(self, VV6A99):
  self.lastPickedRow  = VV6A99.VVGTqU()
  VV6A99.cancel()
 @FFOAKH(par=2)
 def VVyBrK(self, mode, VV6A99, title, txt, colList):
  pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
  cmd = FF5sZa(VVw6qo if holdState else VVofV3, pkg)
  FFpwZS(cmd)
  holdLst = self.VVhDfd(pkg)
  holdState = c1 = ""
  if len(holdLst) == 1 and holdLst[0][0] == pkg:
   holdState, c1 = "Yes", self.holdPkgColor
  VV6A99.VViSLW((c1 + pkg, c1 + ver, c1 + desc, c1 + inst, c1 + holdState))
  self.VVYtzC(mode, VV6A99)
 def VVYtzC(self, mode, VV6A99):
  if mode in (1, 2):
   pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
   VV6A99["keyBlue"].setText("%s Update" % ("Allow" if holdState else "Hold"))
 @FFOAKH(par=1)
 def VVcm7J(self, VVIHf1, grnTxt, grnFnc):
  instDic = CCeSkW.VVuPwl()
  VVGape = [(pkg, ver) for pkg, (ver, dsc, inst, hold) in instDic.items()]
  if not VVGape:
   self.VVwTG2("Cannot read installed packages !")
   return
  VVGape.sort(key=lambda x: x[0].lower())
  VVu8qI = self.VVbOv6
  VVwSzI = (grnTxt   , grnFnc     , [])
  VVScQz = ("Package Info." , self.VVU1Iy , [])
  header = ("Package", "Version" )
  widths = (65  , 35  )
  FFUQ0v(self, None, title=grnTxt, header=header, VVGape=VVGape, VV3cHe=widths, VVwdmN=30, VVu8qI=VVu8qI, VVwSzI=VVwSzI, VVScQz=VVScQz, VVC51D=self.lastPickedRow, VVSLOq=CFG.lastFindPackages
    , VVwltY="#22110011", VVkxBG="#22191111", VVemyB="#22191111", VVJKqd="#00003030", VVbcr0="#00333333")
 def VVU1Iy(self, VV6A99, title, txt, colList):
  FFimQ3(VV6A99, BF(CCeSkW.VVLFsP, self, colList[0]))
 def VVlXsD(self, VV6A99, title, txt, colList):
  pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
  if holdState: FF28n1(VV6A99, "Change Hold State first", 1000)
  else  : self.VVsxwI(VV6A99)
 def VVsxwI(self, VV6A99):
  VV3wat = []
  VV3wat.append(("Remove Package"        , "remove_ExistingPackage" ))
  VV3wat.append(("Remove Package (force remove)"    , "remove_ForceRemove"  ))
  VV3wat.append(("Remove Package (ignore failed dependencies)" , "remove_IgnoreDepends" ))
  FFLFTC(self, BF(self.VVGeqK, VV6A99)  , VV3wat=VV3wat)
 def VVGeqK(self, VV6A99, item):
  if item:
   pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
   if   item == "remove_ExistingPackage" : cmdOpt = VVAdjB
   elif item == "remove_ForceRemove"  : cmdOpt = VV9Fg4
   elif item == "remove_IgnoreDepends"  : cmdOpt = VVYJEp
   FFRMYv(self, BF(self.VVt1Qf, VV6A99, cmdOpt, pkg), "Remove Package ?\n\n%s" % pkg)
 def VVt1Qf(self, VV6A99, cmdOpt, pkg):
  cmd = FF5sZa(cmdOpt, pkg)
  if cmd : FFbi5l(self, cmd, VVoasw=BF(self.VVipSj, VV6A99, pkg))
  else : FFfone(self)
 def VVipSj(self, VV6A99, pkg):
  if not CCeSkW.VVvDqA(pkg):
   VV6A99.VVtM2v()
   if VV6A99.VVn1uo() == 0:
    VV6A99.cancel()
  FF2Wqb()
 def VVVcWW(self, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("Install Package"        , "install_CheckVersion" ))
  VV3wat.append(("Install Package (force reinstall)"   , "install_ForceReinstall" ))
  VV3wat.append(("Install Package (force overwrite)"   , "install_ForceOverwrite" ))
  VV3wat.append(("Install Package (force downgrade)"   , "install_ForceDowngrade" ))
  VV3wat.append(("Install Package (ignore failed dependencies)" , "install_IgnoreDepends" ))
  FFLFTC(self, BF(self.VV2pyB, VV6A99), VV3wat=VV3wat)
 def VV2pyB(self, VV6A99, item):
  if item:
   pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
   if   item == "install_CheckVersion"  : cmdOpt = VVwFAi
   elif item == "install_ForceReinstall" : cmdOpt = VVj9MD
   elif item == "install_ForceOverwrite" : cmdOpt = VVD9EU
   elif item == "install_ForceDowngrade" : cmdOpt = VVRA2G
   elif item == "install_IgnoreDepends" : cmdOpt = VVA8Es
   FFRMYv(self, BF(self.VVtlTi, pkg, VV6A99, cmdOpt), "Install Package ?\n\n%s" % pkg)
 def VVtlTi(self, pkg, VV6A99, cmdOpt):
  cmd = FF5sZa(cmdOpt, pkg)
  if cmd : FFbi5l(self, cmd, VVoasw=BF(self.VVMrFd, pkg, VV6A99), VV62hm=True)
  else : FFfone(self)
 def VVMrFd(self, pkg, VV6A99):
  FF2Wqb()
  if CCeSkW.VVvDqA(pkg):
   c1 = self.instPkgColor
   pkg, ver, desc, inst, holdState = VV6A99.VV5crm()
   row = (c1 + pkg.strip(), c1 + ver.strip(), c1 + desc.strip(), c1 + "Yes", c1 + holdState)
   VV6A99.VViSLW(row)
 def VVyZYM(self, VV6A99, title, txt, colList):
  pkg = colList[0]
  FFRMYv(self, BF(self.VVe60B, pkg), "Download Package ?\n\n%s" % pkg)
 def VVe60B(self, pkg):
  if CCuqoc.VVSuvZ():
   iCmd = FF5sZa(VVaS8u, pkg)
   dCmd = FF5sZa(VVUty9, pkg)
   dest = FFzQP1()
   if iCmd and dCmd:
    cTxt = lambda x, fg: " echo -e '\n%s' %s;" % (x, FFSPDv(x, fg))
    cmd  = "echo -e 'Downloading : %s';" % pkg
    cmd += "FILE1=$(%s '%s' | grep Filename | awk '{print $2}');" % (iCmd, pkg)
    cmd += 'if [ -z "$FILE1" ]; then'
    cmd += " echo -e '\nPackage : %s\n';" % pkg
    cmd += " echo -e $FILE1"
    cmd +=    cTxt("Not available on feed (update packages list and try again.)", VVYjI5)
    cmd += "else"
    cmd += " cd '%s';" % dest
    cmd +=   FFb2oQ(' rm -f "$FILE1"')
    cmd += " %s;" % dCmd
    cmd += ' if [ -f "%s$FILE1" ]; then' % dest
    cmd +=    cTxt("Downloaded to:", VVSGsk)
    cmd += '  echo "%s$FILE1";' % dest
    cmd += ' fi;'
    cmd += 'fi;'
    FFZQVC(self, cmd, VV26L0=[VVYjI5, "error:", "collected errors:", "failed", "not found"], VV62hm=True)
   else:
    FFfone(self)
  else:
   FFdw58(self, "No internet connection !")
 @staticmethod
 def VV3sSc(SELF):
  cmd = FFoY7E(VVaNvq)
  if cmd : FFbi5l(SELF, cmd, VV62hm=True, title="Available Packages List Upadate")
  else : FFfone(SELF)
 @staticmethod
 def VVV8mM(path):
  pkg = err = ""
  if VVmJwX(path):
   for line in FF3xOt(FF5sZa(VV0RRE, "*%s*" % path)):
    span = iSearch(r"(.+) - |(.+):", line)
    if span:
     pkg = span.group(1) or span.group(2)
     break
   if not pkg:
    err = "No package info !"
  else:
   err = "Path not found !"
  return pkg, err
 @staticmethod
 def VVLFsP(SELF, package, title=""):
  title = title or package
  fileExt = ""
  txt = instTime = ""
  c1 = VVcPtB
  info1 = []
  info2 = []
  infoCmd = FF5sZa(VVaS8u, package)
  if not infoCmd:
   FFfone(SELF, title=title)
   return
  info0 = FF3xOt(infoCmd, trim=False)
  if package.startswith("/") and info0:
   title = os.path.basename(package)
   info1 = info0
   for line in info0:
    line = line.strip()
    fld, _, val = line.partition(":")
    if fld == "Package" and val:
     fileExt = os.path.splitext(package)[1].strip(".").upper()
     package = val.strip()
     if CCeSkW.VVvDqA(package):
      info2 = FF3xOt(FF5sZa(VVaS8u, package), trim=False)
     break
  else:
   info2 = info0
  if info1:
   txt += FFGEAF("%s File Info" % (fileExt or "Package"), c1)
   txt += CCeSkW.VV2yzc(info1)[2] + "\n"
  if info2:
   txt1, txt2, txt3, instTime = CCeSkW.VV2yzc(info2)
   if txt1 and txt2:
    txt += FFGEAF("Package Version", c1)
    txt += txt1 + "\n"
    txt += FFGEAF("Installed Version", c1) + "\n"
    txt += txt2 + "\n"
   else:
    txt += FFGEAF("System Info", c1)
    txt += txt3 + "\n"
  if not info1 and not info2:
   txt += FFGEAF("Package Info", c1)
   txt += "No package information !\n\n"
  isInst = CCeSkW.VVvDqA(package)
  txt += FFGEAF("Package State", c1)
  txt += "  %s" % (FFjt5L("Installed", VVJEMb) if isInst else FFjt5L("Not Installed", VVz22H))
  txt += "\t%s\n\n" % instTime
  if isInst:
   files = FF3xOt(FF5sZa(VVjZ1L, package) + " | grep -e '^/'")
   files.sort()
   txt += FFGEAF("Resources", c1)
   if files: txt += "\n".join(files)
   else : txt += "  None"
  FF4lCP(SELF, txt, title=title, width=1700, height=1000, VVwdmN=28, VVllEU=30, titleBg="#11000022", VVemyB="#11000a11", VVRhqH=package)
 @staticmethod
 def VV2yzc(info):
  instTime = lastFld  = ""
  pkgCount = 0
  lines1 = []
  lines2 = []
  lines = lines1
  color = VVFuwR
  for line in info:
   fld, sep, val = line.partition(":")
   if sep:
    fld, val = fld.strip(), val.strip()
    if fld == "Package":
     pkgCount += 1
     if pkgCount > 1:
      lines = lines2
      color = VVJEMb
    elif fld == "Installed-Time":
     tm = val.strip()
     if tm.isdigit():
      instTime = FFTS4w(float(tm), wDay=True)
    lastFld = fld
   else:
    if lastFld == "Conffiles":
     val = fld.strip()
     Len = len(lines)
     last = Len - 1
     if Len > 0 and lines[last] == (lines[last][0], ""):
      lines[last] = (lines[last][0], val)
      continue
    else:
     val = fld
    fld = ""
   fld = fld.strip()
   if fld or val.strip():
    if fld: fld = FFjt5L(fld, color)
    lines.append((fld, val))
  txt1 = ""
  for fld, val in lines1:
   txt1 += "%s\t: %s\n" % (fld, val)
  txt2 = ""
  for fld, val in lines2:
   txt2 += "%s\t: %s\n" % (fld, val)
  txt3 = txt1
  if txt2:
   txt3 += "\n%s\n" % SEP + txt2
  return txt1, txt2, txt3, instTime
 @staticmethod
 def VVgrug():
  return FFpwZS("if [[ \"$(ar -V 2> /dev/null | grep 'GNU ar')\" ]]; then exit 0; else exit 1; fi")
 @staticmethod
 def VVvDqA(pkg):
  instDic = CCeSkW.VVuPwl()
  return pkg in instDic
 @staticmethod
 def VVq71e(SELF):
  if not CCeSkW.VVgrug():
   FFRMYv(SELF, BF(FFbi5l, SELF, FFvQ9y(), title="Installing 'ar'"), "'ar' package is required.\n\nInstall ?")
   return False
  else:
   pFound, pBBox = FFmCnY("xz")
   if not pFound   : title, ques = "Install 'xz'", "'xz' package is required.\n\nInstall ?"
   elif pFound and pBBox : title, ques = "Upgrade 'xz'", "Found BusyBox xz. A higher version is required.\n\nUpgrade ?"
   else     : return True
   FFRMYv(SELF, BF(FFbi5l, SELF, FFKbNE(), title=title), ques, title=title)
   return False
 @staticmethod
 def VVy0xB(path):
  txt = mTime = ""
  if FFCyVu(path):
   fName = os.path.basename(path)
   isDeb = os.path.splitext(fName)[1] == ".deb"
   if isDeb: ext, tarP = "xz", "J"
   else : ext, tarP = "gz", "z"
   txt += FFQ45w("ar -p '%s' control.tar.%s | tar %sxO ./control" % (path, ext, tarP))
   txt += "\n"
   txt += "Size: %s\n" % FFXhoc(path)
   txt += "Filename: %s\n" % fName
   txt += "MD5sum: %s\n" % FFTKR0("md5sum '%s' | cut -b-32" % path)
   txt += "SHA256sum: %s\n" % FFTKR0("sha256sum '%s' | cut -b-64"  % path)
   mTime = "%s %s" % (FFTKR0("stat -c%%Y '%s'" % path), fName)
  return txt, mTime
 @staticmethod
 def VVohK9(ver1, ver2):
  def VVZwiy(x):
   if   x == '~' : return -1
   elif x.isdigit(): return 0
   elif not x  : return 0
   elif x.isalpha(): return ord(x)
   else   : return ord(x) + 256
  def VVjX9E(val, ref):
   while val or ref:
    first_diff = 0
    while (val and not val[0].isdigit()) or (ref and not ref[0].isdigit()):
     vc = VVZwiy(val[0]) if val else 0
     rc = VVZwiy(ref[0]) if ref else 0
     if vc != rc:
      return vc - rc
     val = val[1:]
     ref = ref[1:]
    val = val.lstrip('0')
    ref = ref.lstrip('0')
    while val and ref and val[0].isdigit() and ref[0].isdigit():
     if not first_diff:
      first_diff = ord(val[0]) - ord(ref[0])
     val = val[1:]
     ref = ref[1:]
    if val and val[0].isdigit() : return 1
    if ref and ref[0].isdigit() : return -1
    if first_diff    : return first_diff
   return 0
  return VVjX9E(ver1, ver2)
 @staticmethod
 def VV2PRQ(curVer, webVer):
  webVer = webVer.strip().replace("version=", "")
  tab = lambda x: iSub(r"[^\d\.]", "", x.replace("_", "."))
  cur, web = tab(curVer), tab(webVer)
  upd = CCeSkW.VVohK9(cur, web) < 0
  return curVer.replace("v", ""), webVer, upd
class CCwnHL():
 def VVNXsZ(self, isRef, onlyEpg=False):
  self.shareIsRef   = isRef
  self.onlyEpg   = onlyEpg
  self.shareFilePrefix = "ajpanel_share_%s_" % ("ref" if self.shareIsRef else "data")
  self.shareFilePath  = ""
  FFb0NN()
  self.VVvxPw()
 def VVvxPw(self):
  files = FFkzic(FF7TOv(), self.shareFilePrefix + "*.xml")
  if files:
   files.sort()
   VV3wat = []
   for fil in files:
    VV3wat.append((os.path.basename(fil), fil))
   if self.shareIsRef : VVwltY, VVkxBG = "#22221133", "#22221133"
   else    : VVwltY, VVkxBG = "#22003344", "#22002233"
   VVwJOl  = ("Add new File", self.VVNwnz)
   FFLFTC(self, self.VVPQD2, VV3wat=VV3wat, width=1100, VVwJOl=VVwJOl, VVtboQ="", VVyRCy=4, VVwltY=VVwltY, VVkxBG=VVkxBG)
  else:
   FFRMYv(self, self.VVhT9v, "No files found.\n\nCreate a new file ?")
 def VVhT9v(self):
  path = self.VV8dIQ()
  if FFCyVu(path) : self.VVvxPw()
  else    : FF28n1(self, "Cannot create file", 1500)
 def VVNwnz(self, VV7tND, path):
  path = self.VV8dIQ()
  VV7tND.VV5HD3((os.path.basename(path), path), isSort=True)
 def VV8dIQ(self):
  path = "%s%s%s.xml" % (FF7TOv(), self.shareFilePrefix, FFjTQe())
  with open(path, "w") as f:
   f.write('<?xml version="1.0" encoding="utf-8"?>\n<share>\n\n\t<ch>\n\t\t<name1>Channel-1</name1>  <ref1>5001:0:1:22:22:22:22:0:0:0</ref1>\n\t\t<name2>Channel-2</name2>  <ref2>4097:0:1:22:22:22:22:0:0:0</ref2>\n\t</ch>\n\n</share>')
  return path
 @FFOAKH()
 def VVPQD2(self, path=None):
  if not path: return
  if not FFCyVu(path):
   FF8Wsn(self, path)
   return
  elif not CClYaF.VVSOog(self, path, FFGNZA()):
   return
  else:
   self.shareFilePath = path
  if not CCid3A.VVAilv(self):
   return
  tree = CCYrUm.VVkotG(self, self.shareFilePath)
  if not tree:
   return
  refLst = CCMvE7.VVit2n()
  def VVJi7Q(VVPxk5):
   if   FF4qbN(VVPxk5): return FFjt5L("DVB", VVJEMb)
   elif VVPxk5 in refLst     : return FFjt5L("IPTV", VVJEMb)
   else         : return ""
  VVAkuK= []
  errColor= "#f#00ffaa55#"
  num  = 1
  dupl = 0
  for ch in tree.getroot():
   ok, srcName, srcRef, dstName, dstRef = self.VVLTjY(ch)
   if ok:
    srcTxt = VVJi7Q(srcRef)
    dstTxt = VVJi7Q(dstRef)
    srcName, dstName = srcName.strip(), dstName.strip()
    skip = False
    for num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1 in VVAkuK:
     if (srcRef, dstRef, dstName) == (srcRef1, dstRef1, dstName1):
      dupl += 1
      break
    else:
     if  srcRef == dstRef : remark, c1, c2 = "4", errColor, errColor
     elif srcTxt and dstTxt : remark, c1, c2 = "0", ""  , ""
     elif dstTxt    : remark, c1, c2 = "1", errColor, ""
     elif srcTxt    : remark, c1, c2 = "2", ""  , errColor
     else     : remark, c1, c2 = "3", errColor, errColor
     c3 = "#f#0000ff00#" if remark == "0" else errColor
     VVAkuK.append((c3 + str(num), c1 + srcName, c1 + srcRef, c1 + srcTxt, c2 + dstName, c2 + dstRef, c2 + dstTxt, remark))
     num += 1
  refLst = None
  if VVAkuK:
   if self.shareIsRef : VVwltY, VVkxBG, optTxt = "#1a221133", "#1a221133", "Share Reference"
   else    : VVwltY, VVkxBG, optTxt = "#1a003344", "#1a002233", "Copy EPG" if self.onlyEpg else "Copy EPG/PIcons"
   VVCOpO = (""    , BF(self.VVAJyn, dupl) , [])
   VV2ytr = (""    , self.VVpKs1    , [])
   VVwWmA = ("Delete Entry" , self.VVSkmM   , [])
   VVwSzI = ("Add Entry"  , self.VVm5jD , [])
   VVScQz = (optTxt   , self.VVXUtT  , [])
   header  = ("Num" , "Source" , "Source Ref." ,"Type" , "Destination" , "Dest. Ref." , "Type", "Remark" )
   widths  = (8  , 25  , 15   , 6  , 25   , 15   , 6  , 0   )
   VVLIqP = (CENTER , LEFT  , LEFT   ,CENTER , LEFT   , LEFT   , CENTER, CENTER )
   VV6A99 = FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=24, VVCOpO=VVCOpO, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VVHPI7=True, VVMfsO=1, VVSLOq=CFG.lastFindServices
         , VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVkxBG, VVJKqd="#0a000000")
  else:
   FFdw58(self, "No valid sharing data found in:\n\n%s" % self.shareFilePath)
 def VVAJyn(self, dupl, VV6A99, title, txt, colList):
  if dupl:
   VV6A99.VV6fGE("Skipped %d duplicate%s" % (dupl, FFcacr(dupl)), 2000)
 def VVpKs1(self, VV6A99, title, txt, colList):
  def VVJi7Q(key, val): return "%s\t: %s\n" % (key, val or FFjt5L("?", VVyFI2))
  Keys = VV6A99.VVeVZB()
  Vals = VV6A99.VV5crm()
  txt = ""
  for i in range(len(Keys) - 1):
   txt += VVJi7Q(Keys[i], Vals[i])
   if i in (0, 3, 6):
    txt += "\n"
  remark = colList[7]
  txt1 = "Remarks\t: "
  c1, c2 = VVSGsk, VVyFI2
  if   remark == "0": txt1 += c1 + "Valid"
  elif remark == "1": txt1 += c2 + "Source channel is not in system"
  elif remark == "2": txt1 += c2 + "Destination channel is not in system"
  elif remark == "3": txt1 += c2 + "Both channels are not in system"
  elif remark == "4": txt1 += c2 + "Both channels have same Reference"
  FF4lCP(self, txt + txt1, title=title)
 def VVLTjY(self, chElem):
  srcName = chElem.find("name1")
  srcRef  = chElem.find("ref1")
  dstName = chElem.find("name2")
  dstRef  = chElem.find("ref2")
  patt = r"((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))"
  if srcName is not None and srcRef is not None and dstName is not None and dstRef is not None:
   lst = [srcName.text or "", srcRef.text or "", dstName.text or "", dstRef.text or ""]
   for i, text in enumerate(lst):
    lst[i] = str(text.encode("UTF-8").decode())
   srcName, srcRef, dstName, dstRef = lst
   span = iSearch(patt, srcRef)
   if span:
    srcRef = span.group(1).upper()
    span = iSearch(patt, dstRef)
    if span:
     dstRef = span.group(1).upper()
     return True, srcName.strip(), srcRef.strip(":"), dstName.strip(), dstRef.strip(":")
  return False, "", "", "", ""
 def VVSkmM(self, VV6A99, title, txt, colList):
  if VV6A99.VVGTqU() == 0 and VV6A99.VVn1uo() == 1:
   isLast, ques = True, "This is the last entry.\n\nDelete File ?"
  else:
   isLast, ques = False, "Delete current row ?"
  FFRMYv(self, BF(self.VVsDPB, isLast, VV6A99), ques)
 def VVsDPB(self, isLast, VV6A99):
  if isLast:
   FFwgGB(self.shareFilePath)
   VV6A99.cancel()
  else:
   num, srcName, srcRef, srcType, dstName, dstRef, dstType, remark = VV6A99.VV5crm()
   if self.VVzEs4(srcName, srcRef, dstName, dstRef):
    VV6A99.VVtM2v()
    VV6A99.VV8IgX()
    FF1mVE(VV6A99, "Deleted", 500)
   else:
    FF28n1(VV6A99, "Cannot delete from file", 2000)
 def VVm5jD(self, VV6A99, title, txt, colList):
  if self.shareIsRef : self.VVHGxg(VV6A99)
  else    : FFLFTC(self, BF(self.VVFHpo, VV6A99), VV3wat=[("DVB to IPTV", "iptv"), ("DVB to DVB", "dvb")], width=600, title="Source and Destination")
 def VVFHpo(self, VV6A99, item):
  if item:
   if   item == "iptv" : fnc = self.VVHGxg(VV6A99)
   elif item == "dvb" : fnc = self.VV85rZ(VV6A99)
 @FFOAKH("Loading Services ...", par=1)
 def VV85rZ(self, VV6A99):
  lst, err = CCYrUm.VVJud0(self, CCYrUm.VVp2Ed)
  if not lst:
   FFdw58(self, "No DVB Services !")
   return
  lst = [(VV1wIO, VVPxk5 + ":", sat) for VV1wIO, chProv, sat, VVPxk5 in lst]
  lst.sort(key=lambda x: x[0].lower())
  chkLst = [(srcRef + ":", dstRef + ":", dstName) for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9()]
  VVfaDBLst = []
  try:
   bg = "#11001100"
   self.session.open(CCjS4V, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
       , title="Chain DVB to DVB Channel", mnuTitle2="Destination Channel", mnuTitle3="Source", blueTitle="Add Entry"
       , blueFnc=BF(self.VVqlLf, VV6A99, VVfaDBLst), delFnc=None
       , widths2=(70, 0, 30), aligns2=(LEFT, LEFT, CENTER), tBg=bg, bBg=bg, bg1=bg, bg2=bg)
  except:
   pass
 @FFOAKH("Loading Services ...", par=1)
 def VVHGxg(self, VV6A99):
  lst = CCwnHL.VVcON6()
  if not lst:
   FFdw58(self, "No IPTV Services !")
   return
  lst = [(name, ref + ":") for name, bouquet, url, ref in lst]
  chkLst = [(srcRef + ":", dstRef + ":", dstName) for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9()]
  VVfaDBLst = [r + ":" for r in CCMvE7.VVit2n()]
  try:
   self.session.open(CCjS4V, lst, chkLst=chkLst, srcPath=self.shareFilePath, dstPath=self.shareFilePath
       , title="Chain DVB to IPTV Channel", mnuTitle2="IPTV Chan Name", mnuTitle3="IPTV Reference", blueTitle="Add Entry"
       , blueFnc=BF(self.VVqlLf, VV6A99, VVfaDBLst), delFnc=None
       , widths2=(60, 40), fonts2=(0, 1))
  except:
   pass
 @FFOAKH(par=3)
 def VVqlLf(self, VV6A99, VVfaDBLst, bindCls):
  c1  = VVJEMb
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVzYMA()
  srcName, srcRef, srcTxt = d["name"]  , d["VVPxk510"].rstrip(":"), ""
  dstName, dstRef, dstTxt = d["mnuTxt"], d["mnuRef"].rstrip(":")  , ""
  if   FF4qbN(srcRef)  : srcTxt = FFjt5L("DVB", c1)
  elif srcRef.rstrip(":") + ":" in VVfaDBLst : srcTxt = FFjt5L("IPTV", c1)
  if   FF4qbN(dstRef)  : dstTxt = FFjt5L("DVB", c1)
  elif dstRef.rstrip(":") + ":" in VVfaDBLst : dstTxt = FFjt5L("IPTV", c1)
  if srcRef == dstRef:
   FFjADj(bindCls, "Cannot add (same Reference)", 2000)
  else:
   for ndx, (num1, srcName1, srcRef1, srcTxt1, dstName1, dstRef1, dstTxt1, remark1) in enumerate(VV6A99.VVrrm9()):
    if (srcRef, dstRef, dstName) == (srcRef1, dstRef1, dstName1):
     FFdw58(self, "Already added in row Num-%d" % (ndx + 1))
     break
   else:
    if self.VVAHBa(srcName, srcRef, dstName, dstRef):
     VV6A99.VV1MqZ((str(VV6A99.VVn1uo() + 1), srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, "0"))
     FFG2sB(bindCls, "Saved", 800)
     bindCls.VVfC5O((d["VVPxk510"], d["mnuRef"], d["mnuTxt"]))
    else:
     FFjADj(bindCls, "Cannot edit XML File", 2000)
 @staticmethod
 def VVcON6():
  VVAkuK = []
  files  = CCkEI5.VVjMS6()
  patt  = r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8})(http.+)\n#DESCRIPTION\s+(.+)"
  if files:
   for path in files:
    txt = FFYVq0(path)
    span = iSearch(r"#NAME\s(.+)", txt, IGNORECASE)
    if span : VVY5Mx = span.group(1)
    else : VVY5Mx = ""
    VVY5Mx_lCase = VVY5Mx.lower()
    for match in iFinditer(patt, txt, IGNORECASE):
     VVPxk5 = match.group(1).upper().strip(":")
     url  = match.group(2).strip()
     VV1wIO = match.group(3).strip()
     VVAkuK.append((VV1wIO, VVY5Mx, url, VVPxk5))
  return VVAkuK
 def VVAHBa(self, srcName, srcRef, dstName, dstRef):
  tree = CCYrUm.VVkotG(self, self.shareFilePath)
  if not tree:
   return False
  root = tree.getroot()
  ch = iElem.Element("ch")
  root.append(ch)
  name  = iElem.SubElement(ch, "name1")
  ref   = iElem.SubElement(ch, "ref1")
  name.text = srcName
  ref.text = srcRef
  name  = iElem.SubElement(ch, "name2")
  ref   = iElem.SubElement(ch, "ref2")
  name.text = dstName
  ref.text = dstRef
  self.VVuOoS(tree, root)
  return True
 def VVzEs4(self, srcName1, srcRef1, dstName1, dstRef1):
  tree = CCYrUm.VVkotG(self, self.shareFilePath)
  if not tree:
   return False
  tableLst = [srcName1, srcRef1, dstName1, dstRef1]
  found = False
  root = tree.getroot()
  for ch in root:
   ok, srcName, srcRef, dstName, dstRef = self.VVLTjY(ch)
   if ok and [srcName, srcRef, dstName, dstRef] == tableLst:
    root.remove(ch)
    found = True
  if found:
   self.VVuOoS(tree, root)
  return found
 def VVuOoS(self, tree, root, withComments=True):
  xmlTxt = iElem.tostring(root)
  txt  = CCYrUm.VVRyHN(xmlTxt)
  parser = CCYrUm.CC9usG()
  if withComments : parser = iElem.XMLParser(target=parser)
  else   : parser = None
  root = iElem.fromstring(txt, parser=parser)
  tree._setroot(root)
  tree.write(self.shareFilePath, encoding="UTF-8")
 def VVXUtT(self, VV6A99, title, txt, colList):
  if self.onlyEpg:
   self.VV38cQ(VV6A99, "epg")
  else:
   if self.shareIsRef:
    FFRMYv(self, BF(self.VVQPvJ, VV6A99), "Copy all References from Source to Destination ?")
   else:
    VV3wat = []
    VV3wat.append(("Copy EPG\t (All List)" , "epg"  ))
    VV3wat.append(("Copy Picons\t (All List)" , "picon" ))
    FFLFTC(self, BF(self.VV38cQ, VV6A99), VV3wat=VV3wat, width=1000)
 def VV38cQ(self, VV6A99, item=None):
  if item:
   if   item == "epg" : fnc, txt = self.VV7fpu  , "EPG"
   elif item == "picon": fnc, txt = self.VVTlsd , "PIcons"
   title = "Copy %s" % txt
   tot   = VV6A99.VVn1uo()
   FFRMYv(self, BF(fnc, VV6A99, title), "Overwrite %s for %d Service%s ?" % (FFjt5L(txt, VV1fx4), tot, FFcacr(tot)), title=title)
 @FFOAKH(par=1)
 def VVQPvJ(self, VV6A99):
  files = CCkEI5.VVjMS6()
  totChange = 0
  if files:
   for path in files:
    txt = FFYVq0(path)
    toSave = False
    for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9():
     if remark == "0":
      srcPart = ":".join(srcRef.split(":")[1:]) + ":"
      dstPart = ":".join(dstRef.split(":")[1:]) + ":"
      txt, tot = iSubn(r"(#SERVICE\s+(?:[A-Fa-f0-9]+[:]))%s(.+\/\/.+:%s\s?\n#DESCRIPTION.+\n)" % (dstPart, dstName), r"\g<1>%s\2" % srcPart, txt, IGNORECASE)
      if tot:
       toSave = True
       totChange += tot
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
  if totChange > 0:
   FFfpyJ()
  tot = VV6A99.VVn1uo()
  skp = tot - totChange
  txt  = "Processed\t: %d\n" % tot
  txt += "Changed\t: %d\n"  % totChange
  if skp > 0: txt += "Skipped\t: %d\n"  % skp
  FF4lCP(self, txt)
 @FFOAKH(par=1)
 def VVTlsd(self, VV6A99, title):
  if not iCopyfile:
   FFdw58(self, "Module not found:\n\nshutil", title=title)
   return
  pPath = CCafIt.VVjkKT()
  totFound = totDone = totSame = totErr = 0
  for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9():
   srcPng = pPath + srcRef.replace(":", "_") + ".png"
   dstPng = pPath + dstRef.replace(":", "_") + ".png"
   if FFCyVu(srcPng):
    totFound += 1
    if srcPng == dstPng:
     totSame += 1
    else:
     try:
      iCopyfile(srcPng, dstPng)
      totDone += 1
     except:
      totErr += 1
  txt  = "Services\t: %d\n" % VV6A99.VVn1uo()
  txt += "Found\t: %d\n" % totFound
  txt += "Copied\t: %d"  % totDone
  if totSame: txt += "\nSame Ref.\t: %d" % totSame
  if totErr : txt += "\nErrors\t: %d"  % totErr
  FF4lCP(self, txt, title=title)
 @FFOAKH(par=1)
 def VV7fpu(self, VV6A99, title):
  txt, err = CC5TsO.VVDL6A(VV6A99, title)
  if err : FFdw58(self, err, title=title)
  else : FF4lCP(self, txt, title=title)
 class CC9usG(iElem.TreeBuilder):
  def comment(self, data):
   self.start(iElem.Comment, {})
   self.data(data)
   self.end(iElem.Comment)
 @staticmethod
 def VVkotG(SELF, path, withComments=True, title=""):
  try:
   if withComments:
    try:
     return iElem.parse(path, parser=iElem.XMLParser(target=CCYrUm.CC9usG()))
    except:
     return iElem.parse(path)
  except Exception as e:
   CCwnHL.VVBfGR(SELF, path, str(e), title)
   return None
 @staticmethod
 def VVBfGR(SELF, path, err, title=None):
  txt  = "%s\n%s\n\n" % (FFjt5L("XML Parse Error in:", VVyFI2), path)
  txt += "%s\n%s\n\n" % (FFjt5L("Error:", VVyFI2), str(err))
  FF4lCP(SELF, txt, VVemyB="#11220000", titleBg="#11330000", title=title or FFGNZA().strip())
 @staticmethod
 def VVRyHN(xmlTxt):
  txt = iSub(r">[\n\s]*", ">" , xmlTxt.decode("UTF-8"))
  txt = iSub(r"([^12])>\s*<" , r"\1>\n<", txt)
  txt = iSub(r"ref1>\s*<name2", r"ref1>\n<name2", txt)
  txt = iSub(r"</ref2></ch>" , r"</ref2>\n</ch>\n", txt)
  txt = iSub(r"<ch>"   , r"\t<ch>", txt)
  txt = iSub(r"</ch>"   , r"\t</ch>", txt)
  txt = iSub(r"<name1>"  , r"\t\t<name1>", txt)
  txt = iSub(r"<name2>"  , r"\t\t<name2>", txt)
  txt = iSub(r"(<!-- .+ -->)" , r"\t\1\n", txt)
  txt = iSub(r"<share>"  , r"<share>\n", txt)
  return txt
class CCiEqS(Screen):
 def __init__(self, session, title):
  self.skin, self.VVfOli = FFiNEe(VVDEl1, 600, 300, 30, 0, 0, "#22112211", "#0a223322", 35, VVeFSs=40)
  self.session  = session
  self.index   = 1
  self.totSec   = 0
  FFZMxC(self, title=title)
  FFRLNq(self["keyYellow"], "Reset")
  self["signTitle"] = Label("+/-")
  self["hourTitle"] = Label("Hour")
  self["minTitle"] = Label("Min")
  self["sign"]  = Label("+")
  self["hour"]  = Label("00")
  self["min"]   = Label("00")
  self.list   = [self["sign"], self["hour"], self["min"]]
  FFHlAU(self,
  {
   "ok" : self.VVQi42 ,
   "green" : self.VVQi42 ,
   "yellow": self.VVPzLw ,
   "up" : self.VVx0di  ,
   "down" : self.VVDBsZ ,
   "left" : self.VVziFC ,
   "right" : self.VVLe1s ,
   "cancel": self.close
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FFWgBS(self)
  self.VVwhvR()
 def VVQi42(self):
  sign = self["sign"].getText()
  hour = self["hour"].getText()
  min  = self["min"].getText()
  seconds = int(hour) * 3600 + int(min) * 60
  seconds *= 1 if sign == "+" else -1
  self.close(seconds)
 def VVPzLw(self):
  self["sign"].setText("+")
  self["hour"].setText("00")
  self["min"].setText("00")
 def VVx0di(self)  : self.VVtR6o(1)
 def VVDBsZ(self) : self.VVtR6o(-1)
 def VVziFC(self) : self.VVwhvR(-1)
 def VVLe1s(self) : self.VVwhvR(1)
 def VVwhvR(self, box=0):
  self.index += box
  if   self.index < 0     : self.index = len(self.list) - 1
  elif self.index > len(self.list) - 1: self.index = 0
  for obj in self.list: FFZ0AC(obj, "#06405040")
  FFZ0AC(self.list[self.index], "#0a225577")
 def VVtR6o(self, increment):
  if self.index == 0:
   sign = self.list[0].getText()
   if   sign == "+": sign = "-"
   elif sign == "-": sign = "+"
   self.list[0].setText(sign)
  else:
   if self.index == 1 : min, max, step = 0, 23, 1
   else    : min, max, step = 0, 45, 15
   val = int(self.list[self.index].getText()) + increment * step
   if val < min: val = max
   if val > max: val = min
   self.list[self.index].setText("%02d" % val)
class CCDJgl():
 def __init__(self, SELF, mode=0):
  self.SELF   = SELF
  self.Title   = "XML-TV Tools"
  self.xmltv_path  = FF0cqc() + "epg/"
  self.VVVvc0  = ""
  self.curChName  = ""
  self.curChTitle  = ""
  self.curPath  = ""
  self.curTotTags  = 0
  self.displayName = ""
  self.adjustedTime = 0
  self.curChanRefFile = self.xmltv_path + CFG.xmlTvChannelRefFile.getValue()
  self.skipLst  = ("hd+", "hd", "fhd+", "fhd", "4k", "tv", "hd_en", "beinsports.com", "elcienma", "elifeon", "jawwy", "ooredoo", "shahid", "sattv", "switch", "tod", "whatson")
  self.blackStar  = b"\xe2\x9c\xa6".decode("UTF-8")
  if mode == 0:
   CCDJgl.VVT11L()
   self.VVa96Z(self.SELF)
  else:
   self.tbl = SELF
   if   mode == 1: CCDJgl.VVuIyO(SELF, cbf=self.VVnlje, toTable=True)
   elif mode == 2: CCDJgl.VVuIyO(SELF)
   elif mode == 3: CCDJgl.VVJavA(SELF)
 @FFOAKH("Collecting Files ...", par=1)
 def VVa96Z(self, SELF, goToFile=None):
  lst = self.VV9Gev()
  if lst:
   wTxt = "Reading names ..."
   bg = "#11001020"
   VV2ytr = (""      , self.VVQ7kk    , [])
   VVwWmA = ("Delete File"   , self.VVF3D7   , [])
   VVwSzI = ("XML File Channels"  , BF(self.VVFnPM, False), [], wTxt)
   VVScQz = ("More Options"   , self.VVdbe3   , [])
   VV4QTJ = ("EPG for Current Chan" , BF(self.VVFnPM, True) , [], wTxt)
   header  = ("File" , "Size", "Type")
   widths  = (64  , 14 , 22 )
   VVLIqP = (LEFT  , CENTER, LEFT )
   self.tbl = FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1600, VVwdmN=28, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ
        , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06554455", VVbcr0="#00333333")
  else:
   FFRMYv(self.SELF, BF(CCi3sj, self.SELF, BF(self.VVa96Z, self.SELF)), "No xml Files in:\n\n%s\n\nDownload ?" % self.xmltv_path, title=self.Title)
 def VV572m(self, newPath=None):
  if newPath:
   lst = self.VV9Gev()
   if lst:
    self.tbl.VVMqQ9(lst, VVDpzd=BF(self.VVpXyS, newPath), VV5YRVMsg=True)
 def VVpXyS(self, newPath, VV6A99, title, txt, colList):
  if newPath:
   self.tbl.VVn5CC(0, os.path.basename(newPath))
 def VV9Gev(self):
  lst = []
  for f in iGlob("%s*.xml" % self.xmltv_path):
   sz, typ = self.VVduuJ(f)
   if sz > -1:
    if   sz > 200000000 : c1 = "#f#00ff4000#"
    elif sz > 10000000 : c1 = "#f#00ff8033#"
    else    : c1 = "#f#00aaffaa#"
    lst.append((os.path.basename(f), c1 + CClYaF.VV99gM(sz, mode=4), typ))
  if lst : return sorted(lst, key=lambda x: x[0].lower())
  else : return []
 def VVduuJ(self, path):
  sz = FFXhoc(path)
  orng =   "#f#00ff8033#"
  if sz == -1:
   return sz, orng + "Not found"
  else:
   defF = CFG.xmlTvChannelRefFile.getValue()
   c1 = "#f#0055ff55#" if defF == os.path.basename(path) else "#f#00cccccc#"
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0:
      if   elem.tag == "tv"  : return sz, "#f#00888888#" + "Events"
      elif elem.tag == "channels" : return sz, c1 + "Reference"
      else      : return sz, orng + 'Unknown tag "%s"' % elem.tag
   except Exception as e:
    return sz, orng + str(e)[:50]
 def VVQ7kk(self, VV6A99, title, txt, colList):
  fName, szTxt, Type = VV6A99.VV5crm()
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVZtfx), y)
  txt  = ttl("File", fName)
  txt += ttl("Size", szTxt)
  txt += ttl("Type", Type)
  path = self.xmltv_path + fName
  if 1 < FFXhoc(path) < 500:
   txt += ttl("File Contents", FFYVq0(path).strip())
  FF4lCP(self.tbl, txt, title=title)
 def VVdbe3(self, VV6A99, title, txt, colList):
  fName, szTxt, Type = VV6A99.VV5crm()
  defF = CFG.xmlTvChannelRefFile.getValue()
  canView = defF and FFCyVu(self.xmltv_path + defF)
  self.curPath = self.xmltv_path + colList[0].strip()
  c1, c2, c3, c4 = VVJEMb, VVFuwR, VVZtfx, VV1fx4
  VV3wat = []
  VV3wat.append((c1 + "Change Current Channel"   , "zap"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Read Current Channel EPG"  , "curEv" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
  VV3wat.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Download XML-TV File"   , "dlnd" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c1 + "Analyze Selected XML File Tags" , "chk" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("View Channel-Reference Table" , "refTable", canView, c4))
  VV3wat.append((    "Set Channel-Reference File" , "refPick" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Chain References to File Channels", "bind" , "Events" in Type , c1))
  FFLFTC(self.tbl, self.VVKU4F, VV3wat=VV3wat, width=950, VVyRCy=3, title="XML File Options", VVwltY="#11110022", VVkxBG="#11110022", VVoCB2="#08663300")
 def VVKU4F(self, item):
  if   item == "zap"  : CCYrUm.VVGvmp()
  elif item == "curEv" : CCDJgl.VVuIyO(self.tbl, cbf=self.VVnlje, toTable=True)
  elif item == "saveCur" : CCDJgl.VVuIyO(self.tbl, cbf=self.VV572m)
  elif item == "saveGrp" : CCDJgl.VVJavA(self.tbl, cbf=self.VV572m)
  elif item == "dlnd"  : CCi3sj(self.tbl, self.VV572m)
  elif item == "chk"  : self.VVmSkv(self.curPath)
  elif item == "refTable" : self.VVlVPK(self.tbl)
  elif item == "refPick" : self.VVcEfE()
  elif item == "bind"  : CCDJgl.VV8f7q(self.tbl, self.curPath)
 @FFOAKH(par=1)
 def VVlVPK(self, tbl):
  title = "Channel-Reference File (Error)"
  refLst, err = self.VVQhlB(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
  if err:
   FFRMYv(self.tbl, self.VVcEfE, "%s\n\nOpen a new file ?" % (err), title=title)
   return
  elif not refLst:
   FFRMYv(self.tbl, self.VVcEfE, "No records in:\n%s\n\nOpen a new file ?" % (os.path.basename(self.curChanRefFile)), title=title)
   return
  refLst = [(nm, rf, CCYrUm.VVMJTa(rf, unknown="")) for nm, rf in refLst]
  bg = "#0a202020"
  refLst.sort(key=lambda x: x[0].lower())
  header   = ("Channel Name", "Reference" , "Source" )
  widths   = (46    , 42   , 12  )
  VVLIqP  = (LEFT    , LEFT   , CENTER )
  FFUQ0v(self.tbl, None, title=CFG.xmlTvChannelRefFile.getValue(), header=header, VVGape=refLst, VVLIqP=VVLIqP, VV3cHe=widths, width=1600, VVwdmN=28, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a805000", VVbcr0="#00333333")
 def VVcEfE(self):
  title = "Channel-Reference File"
  defF = CFG.xmlTvChannelRefFile.getValue()
  lst = []
  for fName, szTxt, Type in self.tbl.VVrrm9():
   if "Reference" in Type:
    lst.append((FFjt5L(fName, VVSGsk) if fName == defF else fName, fName))
  if lst : FFLFTC(self.tbl, self.VVYU1b, VV3wat=sorted(lst, key=lambda x: x[1].lower()), title=title, width=1400)
  else : self.VVQ5VQ("No Channel-Reference files in:\n\n%s" % self.xmltv_path, title=title)
 def VVYU1b(self, fName):
  if fName:
   if self.xmltv_path + fName == self.xmltv_path + CFG.xmlTvChannelRefFile.getValue():
    FFjADj(self.tbl, "No change", 1000)
   else:
    FFjt1c(CFG.xmlTvChannelRefFile, fName)
    FFjADj(self.tbl, "Saved", 800, isGrn=True)
    defF = CFG.xmlTvChannelRefFile.getValue()
    for ndx, (fName, szTxt, Type) in enumerate(self.tbl.VVrrm9()):
     if "Reference" in Type:
      if fName == defF: color = "#0055ff55"
      else   : color = "#00cccccc"
      self.tbl.VVmMYI(ndx, 2, 8, FFRUST(color))
      self.tbl.VVmMYI(ndx, 2, 9, FFRUST(color))
 def VVRDQa(self):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self.tbl)
  if VV1wIO and VVPxk5:
   self.VVVvc0 = VVPxk5
   self.curChName = VV1wIO
   self.curChTitle = "Current Ch. : %s" % FFjt5L(self.curChName, VVGCYL)
   return True
  else:
   self.VVQ5VQ("Cannot get current channel data.")
   return False
 def VVF3D7(self, VV6A99, title, txt, colList):
  fName = colList[0].strip()
  FFRMYv(self.tbl, BF(self.VVaLYo, VV6A99, self.xmltv_path + fName), "Delete:\n\n%s" % fName, title=self.Title)
 def VVaLYo(self, VV6A99, path):
  FFwgGB(path)
  if FFCyVu(path):
   FF28n1(self.tbl, "Not deleted", 1000)
  else:
   VV6A99.VVtM2v()
   if VV6A99.VVn1uo() == 0:
    VV6A99.cancel()
 def VVFnPM(self, isCurChan, VV6A99, title, txt, colList):
  self.curPath = self.xmltv_path + colList[0].strip()
  if isCurChan and not self.VVRDQa():
   return
  self.VVAGJR(self.curPath)
  if self.curTotTags == -1:
   return
  chLst, err = self.VV3o1S(self.curPath)
  if not err:
   if isCurChan: self.VVAiqL(chLst)
   else  : self.VVN50a(chLst)
  VV6A99.VVrmMb()
 def VVAiqL(self, chLst):
  if self.VVRDQa():
   CCJaSw.VV5YpJ(self.tbl, CFG.xmlTvNameCompRatio, "Name Similarity Ratio (%)", cbFnc=BF(self.VVbGHQ, self.tbl, chLst), isSave=True)
 @FFOAKH("Filtering names ...", par=1)
 def VVbGHQ(self, tbl, chLst):
  mRatio  = CFG.xmlTvNameCompRatio.getValue()
  VVVvc0 = self.VVVvc0.rstrip(":").upper()
  curName  = self.curChName.lower()
  lst   = []
  for name, chId, VVPxk5, iconUrl, isIcon, isRef in chLst:
   if VVPxk5 == VVVvc0:
    lst.append((name, chId, "100", iconUrl, isIcon))
   else:
    tName = name.lower().replace(self.blackStar, "")
    span = iSearch(r".+[|:]\s*(.+)", tName)
    if span:
     tName = span.group(1) or name
    tName = " ".join([x for x in tName.split() if x not in self.skipLst])
    ratio = CCafIt.VV8e0X(curName, tName)
    if ratio > mRatio:
     lst.append((name, chId, str(ratio), iconUrl, isIcon))
  if lst:
   bg = "#0a102020"
   tName = "Closest Name ( > %s%% )" % mRatio
   lst.sort(key=lambda x: int(x[2]), reverse=True)
   VV2ytr = ("", self.VV6CHS  , [])
   VVu1YM  = ("", self.VVJGp2 , [], "Checking file ...")
   VVW5y5   = "OK = Filter New Events"
   header  = (tName, "ID" , "Ratio" , "iconUrl" , "PIcon" )
   widths  = (88 , 0  , 0   , 0   , 12  )
   VVLIqP = (LEFT , LEFT , CENTER , CENTER , CENTER )
   FFUQ0v(self.tbl, None, title=self.curChTitle, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, VVwdmN=30, VV2ytr=VV2ytr, VVu1YM=VVu1YM, VVW5y5=VVW5y5, VVKDPJ=2
     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a805000", VVbcr0="#00333333")
  else:
   self.VVQ5VQ("No %s%% similar name in:\n\n%s" % (mRatio, os.path.basename(self.curPath)), title=self.curChName)
  self.tbl.VVrmMb()
 def VV6CHS(self, VV6A99, title, txt, colList):
  name, chId, ratio, iconUrl, isIcon = VV6A99.VV5crm()
  CCvjVs.VV0Xds(self.tbl, VV7VUc=CCvjVs.VVbSwV, title=title, params=(txt, iconUrl))
 def VVN50a(self, chLst):
  refLst, err = self.VVQhlB(self.xmltv_path + CFG.xmlTvChannelRefFile.getValue())
  if err:
   FFRMYv(self.tbl, self.VVcEfE, "%s\n\nOpen a new file ?" % (err), title="Channel-Reference File (error)")
   return
  refDict = dict(refLst)
  lst = []
  for name, chId, VVPxk5, iconUrl, isIcon, isRef in chLst:
   if not VVPxk5 and chId in refDict:
    VVPxk5, isRef = refDict[chId], "Yes"
   lst.append((name, chId, VVPxk5, iconUrl, isIcon, isRef))
  bg = "#0a302a20"
  lst.sort(key=lambda x: x[0].lower())
  VVlJfJ = self.VVfCDC
  VV2ytr = (""      , self.VVOmdx    , [])
  VVwSzI = ("Import EPG (Auto)"  , self.VVjpzD , [])
  VVScQz = ("Multi-Select"   , self.VV0uk9   , [])
  VV4QTJ = ("Filter EPG to File"  , self.VVzwHR  , [])
  header   = ("Channel", "ID" , "VVPxk5" , "iconUrl" , "PIcon" , "Ref.")
  widths   = (80  , 0  , 0   , 0   , 10  , 10 )
  VVLIqP  = (LEFT  , CENTER, CENTER , CENTER , CENTER , CENTER)
  FFUQ0v(self.tbl, None, title=os.path.basename(self.curPath), header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1300, VVwdmN=30, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVlJfJ=VVlJfJ
    , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#00005566", VVbcr0="#00333333")
 def VVOmdx(self, VV6A99, title, txt, colList):
  name, chId, VVPxk5, iconUrl, isIcon, isRef = VV6A99.VV5crm()
  sat = CCYrUm.VVMJTa(VVPxk5, unknown="")
  txt  = "Channel\t: %s\n" % name
  if VVPxk5 : txt += "Reference\t: %s\n" % VVPxk5
  if sat  : txt += "Source\t: %s\n" % sat
  if iconUrl : txt += "\n%s:\n%s" % (FFjt5L("Icon URL", VVFuwR), iconUrl)
  CCvjVs.VV0Xds(self.tbl, VV7VUc=CCvjVs.VVbSwV, title=title, params=(txt, iconUrl))
 def VV0uk9(self, VV6A99, title, txt, colList):
  CCzSCo(self.SELF, VV6A99, addSep=False).VV9VR2(None, None, width=700)
 def VVfCDC(self, VV6A99):
  VV6A99.VVucBj()
  VV6A99.VVuDSc()
  if VV6A99.VVXWPu:
   VV6A99.VVO1tN("OK = Select")
   if VV6A99.VVc5NH():
    VV6A99.VVsd6P()
    VV6A99.VVbpCf()
  else:
   VV6A99.VVO1tN("")
   VV6A99.VVsd6P()
   VV6A99.VVbpCf()
 def VVzwHR(self, VV6A99, title, txt, colList):
  if VV6A99["keyBlue"].getVisible():
   if VV6A99.VVXWPu : tot = VV6A99.VVc5NH()
   else        : tot = 1
   FFRMYv(self.tbl, BF(self.VVSsBP, VV6A99), "Save data for %s selected channel%s to file ?" % (FFjt5L(tot, VVSGsk), FFcacr(tot)), title=self.curChTitle)
 def VVSsBP(self, VV6A99):
  CCh3tv.VV7Nf4(self.tbl, VVLL7M="Reading events ...", VVIZBP=CCh3tv.VVgJkc
      , VVixvy  = BF(self.VV0cfX, VV6A99)
      , VVbYwR = self.VVmEyX )
 def VV0cfX(self, VV6A99, VVXyP6):
  self.tmpPath = ""
  totTags = self.VVvoni(self.curPath, VVXyP6)
  if totTags == -1:
   return
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVq8NF(totTags)
  self.tmpTitle = "Filter EPG to File"
  self.tmpTotCh = self.tmpTotEv = self.tmpTotValid = self.tmpTotRep = 0
  if VV6A99.VVXWPu : rows = VV6A99.VVbF9W()
  else        : rows = [VV6A99.VV5crm()]
  idLst = [x[1] for x in rows]
  if not CCDJgl.VVyHvM(self.tbl, self.Title):
   return
  tName = FFfCtV(rows[0][0], r"-").replace(" ", "_")
  totCh = len(rows)
  if totCh > 1:
   tName += "_(+%s_other%s)" % (totCh - 1, FFcacr(totCh - 1))
  self.tmpPath = "%s_%s_%s.xml" % (self.curPath[:-4], tName, FFjTQe())
  self.tmpFileFooter = "</tv>\n"
  progLst = set()
  with open(self.tmpPath, "w") as f:
   f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
   f.write('<tv generator-info-name="%s-%s-EPG-Filter">\n' % (VVh9hj, VVJ6zn))
   try:
    for event, elem in iElem.iterparse(self.curPath, events=("end", )):
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     VVXyP6.VVxtQs(1)
     if elem.tag == "programme":
      prId = FFwW5m(elem, "channel")
      if prId in idLst:
       self.tmpTotEv += 1
       start = FFwW5m(elem, "start")
       stop  = FFwW5m(elem, "stop")
       if start and stop:
        tmpId = (start, stop, prId)
        if tmpId in progLst:
         self.tmpTotRep +=1
        else:
         self.tmpTotValid += 1
         progLst.add(tmpId)
         f.write(FFT8ma(elem)+ "\n")
      elem.clear()
     elif elem.tag == "channel":
      if FFwW5m(elem, "id") in idLst:
       self.tmpTotCh += 1
       f.write(FFT8ma(elem) + "\n")
      elem.clear()
     if self.tmpTotCh:
      totValid = FFjt5L(self.tmpTotValid, VVSGsk if self.tmpTotValid else VVYjI5)
      if not VVXyP6 or VVXyP6.isCancelled:
       return
      VVXyP6.VVaks5("Channels: %s        Events: %s     Valid: %s" % (self.tmpTotCh, self.tmpTotEv, totValid))
   except Exception as e:
    self.VVre5F(str(e), title=self.tmpTitle)
    VVXyP6.VVlmol()
    return
   f.write(self.tmpFileFooter)
   self.tmpFileFooter = ""
 def VVmEyX(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if threadErr or self.tmpTotEv == 0:
   FFwgGB(self.tmpPath)
   if self.tmpTotEv == 0:
    FFdw58(self.tbl, "No valid events.", title=self.tmpTitle)
  else:
   note = ""
   if self.tmpFileFooter:
    note = FFjt5L("\n\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVz22H)
    with open(self.tmpPath, "a") as f:
     f.write(self.tmpFileFooter)
   repTxt = FFjt5L("   ( Repeated Event Time : %s )" % self.tmpTotRep, VVz22H) if self.tmpTotRep else ""
   txt  = "Channels\t: %s\n" % self.tmpTotCh
   txt += "Found Events\t: %s%s\n" % (self.tmpTotEv, repTxt)
   txt += "Filtered Events\t: %s\n\n" % self.tmpTotValid
   txt += "%s\n%s" % (FFjt5L("Output File:", VVSGsk), self.tmpPath)
   txt += note
   FF4lCP(self.tbl, txt, title=self.tmpTitle)
   self.VV572m(self.tmpPath)
 def VVmSkv(self, path):
  CCh3tv.VV7Nf4(self.tbl, VVIZBP=CCh3tv.VVgJkc
      , VVixvy  = self.VVTPh3
      , VVbYwR = self.VVHwU4)
 def VVTPh3(self, VVXyP6):
  VVXyP6.VVNc18 = {}
  totTags = self.VVvoni(self.curPath, VVXyP6)
  if totTags == -1:
   return
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVaks5("Validating XML Tags ...")
  VVXyP6.VVq8NF(totTags)
  tDict = {}
  try:
   for event, elem in iElem.iterparse(self.curPath, events=("end", )):
    if not VVXyP6 or VVXyP6.isCancelled:
     return
    VVXyP6.VVxtQs(1)
    tDict[elem.tag] = tDict.get(elem.tag, 0) + 1
    elem.clear()
  except Exception as e:
   VVXyP6.VVNc18["xErr"] = str(e)
   return
  if tDict:
   lst = [(key, val) for key, val in tDict.items()]
   lst.sort(key=lambda x: x[0].lower())
   c1 = VVFuwR
   txt  = FFjt5L("File:\n", c1)
   txt += "%s\n\n" % self.curPath
   txt += FFjt5L("XML Tags (total = %s):\n" % totTags, c1)
   for key, val in lst:
    txt += "%s\t: %s\n" % (key, val)
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVNc18["txt"] = txt
   VVXyP6.VVNc18["ttl"] = "XML Tags Validation : %sOK" % VVSGsk
  else:
   VVXyP6.VVNc18["err"] = "No xml tags in:\n\n%s" % self.curPath
 def VVHwU4(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if   "err"  in VVNc18 : self.VVQ5VQ(VVNc18["err"])
  elif "xErr" in VVNc18 : self.VVre5F(VVNc18["xErr"])
  elif "txt"  in VVNc18 : FF4lCP(self.tbl, VVNc18["txt"], height=1050, title=VVNc18["ttl"])
 def VVAGJR(self, path):
  fName = os.path.basename(path)
  sz = FFXhoc(path)
  if sz > -1:
   return True
  else:
   FF8Wsn(self.tbl, path, title=self.Title)
   return False
 def VVvoni(self, path, VVXyP6):
  infPath = path + ".tot_tags"
  try: sz, mTm = FFXhoc(path), os.path.getmtime(path)
  except: sz, mTm = -1, 0
  if not self.VVAGJR(path):
   FFwgGB(infPath)
   return -1
  try:
   tot = self.VV4Jmq(path, infPath, sz, mTm)
   if tot:
    return tot
   else:
    tot = 0
    with ioOpen(path, "r", encoding="UTF-8") as f:
     for line in f:
      tot += line.count("</") + line.count("/>")
      if not VVXyP6 or VVXyP6.isCancelled:
       return -1
      VVXyP6.VVaks5("Counting Tags : %s" % tot)
     self.VVu262(path, infPath, tot, sz, mTm)
     return tot
  except Exception as e:
   self.VVre5F(str(e))
   FFwgGB(infPath)
   return -1
 def VVu262(self, path, infPath, tot, sz, mTm):
  try:
   with open(infPath, "w") as f:
    f.write("%s,%s,%s" % (int(sz), mTm, tot))
  except:
   pass
 def VV4Jmq(self, path, infPath, sz, mTm):
  try:
   sz1, mTm1, tot = FFYVq0(infPath).strip().split(",")
   if (str(sz), str(mTm)) == (sz1, mTm1):
    return int(tot)
  except:
   pass
  FFwgGB(infPath)
  return 0
 @staticmethod
 def VVQhlB(path):
  if not CFG.xmlTvChannelRefFile.getValue(): return [], "This requires Channel-Reference File."
  elif not FFCyVu(path)     : return [], ("File not found:\n%s" % path)
  else          : return CCDJgl.VVQiv6(path)
 @staticmethod
 def VVQiv6(path):
  lst = set()
  err = ""
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "channels":
     err = "Invalid Channel-Reference File !"
     break
    elif elem.tag == "channel":
     chId = FFwW5m(elem, "id")
     if chId:
      VVPxk5 = FFax4p(elem)
      span = iSearch(r"^((?:[A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+))", VVPxk5)
      if span:
       lst.add((chId, span.group(1).upper()))
    elem.clear()
  except Exception as e:
   err = str(e)
  return list(lst), err
 def VV3o1S(self, path, VVwb7n=True):
  lst = set()
  err = err1 = ""
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "tv":
     err = "Not XML-TV Format:\n\n%s" % path
     break
    elif elem.tag == "channel":
     chId = FFwW5m(elem, "id")
     if chId:
      name = FF6Tbq(elem, "display-name")
      if name:
       VVPxk5 = FF6Tbq(elem, "reference").rstrip(":").upper()
       iconUrl = FFaJfl(elem, "icon", "src")
       isIcon = "Yes" if iconUrl else ""
       isRef = "Yes" if VVPxk5 else ""
       lst.add((name, chId, VVPxk5, iconUrl, isIcon, isRef))
     elem.clear()
    elif elem.tag == "programme":
     elem.clear()
     break
  except Exception as e:
   err1 = str(e)
  if not lst:
   err = "No channel names in:\n\n%s" % os.path.basename(self.curPath)
  if VVwb7n:
   if   err : self.VVQ5VQ(err)
   elif err1: self.VVre5F(err1)
  return lst, err or err1
 def VVl2nN(self, chIdSet, VVXyP6):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  tabLst = lambda x, y: tab(x, " , ".join(y))
  now  = int(iTime())
  try:
   chan = ""
   for event, elem in iElem.iterparse(self.curPath, events=("start", )):
    if not VVXyP6 or VVXyP6.isCancelled:
     return
    VVXyP6.VVxtQs(1)
    if elem.tag == "programme":
     self.tmpTotEv += 1
     chan = FFwW5m(elem, "channel")
     if chan in chIdSet:
      startTS = self.VVpWUX(FFwW5m(elem, "start"))
      stopTS  = self.VVpWUX(FFwW5m(elem, "stop"))
      if startTS and stopTS and stopTS > startTS:
       dur = stopTS - startTS
       if startTS > now or now < startTS + dur:
        self.tmpTotNew += 1
        director = writer = producer = actor = rating = ""
        Title = FF6Tbq(elem, "title")
        descSh = FF6Tbq(elem, "sub-title")
        descLng = FF6Tbq(elem, "desc")
        Date = FF6Tbq(elem, "date")
        country = FF6Tbq(elem, "country")
        cat  = FFFE2m(elem, "category")
        episode = FFFE2m(elem, "episode-num")
        iconUrl = FFaJfl(elem, "icon", "src")
        cred = elem.find("credits")
        if not cred is None:
         director= FFFE2m(cred, "director")
         writer = FFFE2m(cred, "writer")
         producer= FFFE2m(cred, "producer")
         actor = FFFE2m(cred, "actor")
        rate = elem.find("rating")
        if not rate is None:
         rSys = FFaJfl(elem, "rating", "system")
         rating = FF6Tbq(rate, "value") + ((" (%s)" % rSys) if rSys else "")
        desc = ""
        if Date  : desc += tab("Date", Date)
        if country : desc += tab("Country", country)
        if rating : desc += tab("Rating", rating)
        if cat  : desc += tabLst("Category", cat)
        if episode : desc += tabLst("Episode", episode)
        if director : desc += tabLst("Director", director)
        if writer : desc += tabLst("Writer", writer)
        if producer : desc += tabLst("Producer", producer)
        if actor : desc += tabLst("Actors", actor)
        if desc  : descLng = "%s\n\n%s" % (desc.rstrip(), descLng)
        startTxt= FFTS4w(startTS).replace(" ", "   ")
        startTS = str(int(startTS))
        durTxt = FFFHEC(dur)
        dur  = str(int(dur))
        isDesc = "Yes" if desc else ""
        isIcon = "Yes" if iconUrl else ""
        yield chan, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon)
       else:
        self.tmpTotOld += 1
        yield None, None
    elif elem.tag == "channel":
     pass
    if elem.tag != "tv":
     elem.clear()
  except Exception as e:
   self.tmpTotErr = str(e)
   yield chan, None
 def VVJGp2(self, VV6A99, title, txt, colList):
  name, chId, ratio, iconUrl, isIcon = VV6A99.VV5crm()
  self.displayName = name
  CCh3tv.VV7Nf4(self.tbl, VVIZBP=CCh3tv.VVgJkc
      , VVixvy  = BF(self.VV2SYm, {chId})
      , VVbYwR = self.VVKr2D )
  VV6A99.VVrmMb()
 def VV2SYm(self, chIdSet, VVXyP6):
  self.curTotTags = self.VVvoni(self.curPath, VVXyP6)
  if self.curTotTags == -1:
   return
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVaks5("Reading Events ...")
  VVXyP6.VVq8NF(self.curTotTags)
  VVXyP6.VVNc18 = set()
  self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = 0
  self.tmpTotErr = ""
  for retChId, row in self.VVl2nN(chIdSet, VVXyP6):
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   if self.tmpTotErr:
    self.VVre5F(self.tmpTotErr)
    VVXyP6.VVlmol()
    return
   elif row:
    VVXyP6.VVNc18.add(row)
   txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFjt5L(self.tmpTotNew, VVSGsk if self.tmpTotNew else VVYjI5))
   VVXyP6.VVaks5(txt)
 def VVKr2D(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if threadErr:
   pass
  elif VVNc18:
   self.VVnlje(FFjt5L(self.displayName, VV1fx4), VVNc18)
  elif VVRI6P:
   if self.tmpTotOld: txt = "No new event.\n\nFound %s expired event%s." % (self.tmpTotOld, FFcacr(self.tmpTotOld))
   else     : txt = "No valid events data !"
   self.VVQ5VQ(txt, title=self.curChName)
 def VVnlje(self, VV1wIO, evLst):
  if not self.VVRDQa():
   return
  title = "EPG for : %s" % VV1wIO
  evLst = sorted(list(evLst), key=lambda x: int(x[1]))
  VV2ytr = (""      , self.VVembo    , [])
  VVwSzI = ("Import All Events"  , self.VVUVPi , [])
  VVScQz = ("Reset Times"   , self.VV5BI8   , [])
  VV4QTJ = ("Adjust All Start Time" , self.VV3b1s  , [])
  header  = ("Start Time" , "start" ,"Duration" , "dur" , "Title" , "Summary" , "desc", "iconUrl" , "Descr." , "Poster" )
  widths  = (20   , 0   , 10  , 0  , 30  , 26  , 0  , 0   , 7   , 7   )
  VVLIqP = (CENTER  , CENTER ,CENTER  , CENTER, LEFT  , LEFT  , LEFT , LEFT  , CENTER , CENTER )
  tbl = FFUQ0v(self.tbl, None, title=title, header=header, VVGape=evLst, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, VVwdmN=24, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ)
  tbl.VVAHUl()
 def VVembo(self, VV6A99, title, txt, colList):
  startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = VV6A99.VV5crm()
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), y)
  txt  = "Start Time\t: %s\n" % startTxt
  txt += "Duration\t: %s\n\n" % durTxt
  txt += ttl("Title", Title)
  if descSh : txt += ttl("Summary", descSh)
  if descLng: txt += ttl("Description", descLng)
  CCvjVs.VV0Xds(self.tbl, VV7VUc=CCvjVs.VVbSwV, title=title, params=(txt, iconUrl))
 def VVUVPi(self, VV6A99, title, txt, colList):
  tot  = VV6A99.VVn1uo()
  ques = "Add %s event%s to current channel from:\n\n%s" % (tot, FFcacr(tot), FFjt5L(self.displayName, VV1fx4))
  FFRMYv(self.tbl, BF(self.VVFzpn, VV6A99), ques, title=self.curChTitle)
 @FFOAKH(par=1)
 def VVFzpn(self, VV6A99):
  lst = []
  for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in VV6A99.VVrrm9():
   lst.append((int(startTS), int(dur), Title, descSh, descLng, 1))
  totEv, totOK = CC5TsO.VV8M7K(self.VVVvc0, lst)
  if totOK > 0:
   CC5TsO.VVYLja()
   CCYrUm.VV0iSP(self.tbl.session)
  txt = "Total Events\t: %s\n" % totEv
  txt += "Total Added\t: %s\n" % totOK
  FF4lCP(self.tbl, txt, title=self.curChName)
 def VVjpzD(self, VV6A99, title, txt, colList):
  title = "Import EPG (Auto)"
  if VV6A99.VVXWPu : rows = VV6A99.VVbF9W()
  else        : rows = [VV6A99.VV5crm()]
  totRef = 0
  for name, chId, VVPxk5, iconUrl, isIcon, isRef in rows:
   if VVPxk5: totRef += 1
  totSel = len(rows)
  if totRef:
   ques = "Selected channels = %s ( %s with Reference )\n\nImport events for %s channel%s ?" % (totSel, totRef, totRef, FFcacr(totRef))
   FFRMYv(self.tbl, BF(self.VVUWSc, title, rows), ques, title=title)
  else:
   s = FFcacr(totSel)
   self.VVQ5VQ("No Reference%s for the selected channel%s in:\n\n%s" % (s, s, CFG.xmlTvChannelRefFile.getValue()), title=title)
 def VVUWSc(self, title, rows):
  CCh3tv.VV7Nf4(self.tbl, VVLL7M="Reading events ...", VVIZBP=CCh3tv.VVgJkc
      , VVixvy  = BF(self.VVfz01, title, rows)
      , VVbYwR = BF(self.VVWr3M, title) )
 def VVfz01(self, title, rows, VVXyP6):
  totTags = self.VVvoni(self.curPath, VVXyP6)
  if totTags == -1:
   return
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVq8NF(totTags)
  self.tmpTotEv = self.tmpTotNew = self.tmpTotOld = self.tmpTotAdd = self.tmpTotNoRef = self.tmpTotCh = self.tmpTotChDone = 0
  self.tmpTotErr = ""
  chIdSet = set()
  refDict = {}
  for name, chId, VVPxk5, iconUrl, isIcon, isRef in rows:
   if iMatch(r"^([A-Fa-f0-9]+:){9}(?:[A-Fa-f0-9]+)", VVPxk5):
    chIdSet.add(chId)
    refDict[chId] = VVPxk5
    self.tmpTotCh += 1
   else:
    self.tmpTotNoRef += 1
  if not chIdSet:
   self.VVQ5VQ("Channel Reference not found in file.", title=title)
   return
  lst = []
  doneCh = set()
  oldChId = newChId = ""
  for retChId, row in self.VVl2nN(chIdSet, VVXyP6):
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   if self.tmpTotErr:
    self.VVre5F(self.tmpTotErr)
    VVXyP6.VVlmol()
    return
   elif row:
    if not VVXyP6 or VVXyP6.isCancelled:
     return
    doneCh.add(retChId)
    self.tmpTotChDone = len(doneCh)
    VVPxk5 = refDict.get(retChId, "")
    startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon = row
    lst = [(int(startTS), int(dur), Title, descSh, descLng, 1)]
    totEv, totOK = CC5TsO.VV8M7K(VVPxk5, lst)
    self.tmpTotAdd += totOK
   txt = "Events: %d   (%s new)" % (self.tmpTotEv, FFjt5L(self.tmpTotNew, VVSGsk if self.tmpTotNew else VVYjI5))
   VVXyP6.VVaks5(txt)
 def VVWr3M(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if threadCounter > 0:
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt  = ""
   txt += tab("Channels", self.tmpTotCh)
   txt += tab("Processed", self.tmpTotChDone)
   txt += "\n"
   if self.tmpTotNoRef: txt += tab("No Reference", self.tmpTotNoRef)
   txt += tab("Total Events", self.tmpTotNew + self.tmpTotOld)
   txt += tab("Added Events", self.tmpTotAdd)
   if self.tmpTotOld: txt += tab("Old Events", self.tmpTotOld)
   if not threadCounter == threadTotal:
    txt += FFjt5L("\n  ... Cancelled at %s %%" % int(threadCounter * 100 / threadTotal), VVz22H)
   FF4lCP(self.tbl, txt, title=title, width=1500)
   if self.tmpTotAdd > 0:
    CC5TsO.VVYLja()
    CCYrUm.VV0iSP(self.tbl.session)
 def VV3b1s(self, VV6A99, title, txt, colList):
  self.tbl.session.openWithCallback(BF(self.VV3mYS, VV6A99), CCiEqS, "Adjust Event Start Time")
 @FFOAKH(par=1)
 def VV3mYS(self, VV6A99, sec=None):
  if sec is not None:
   if sec == 0:
    newSec = -self.adjustedTime
    self.adjustedTime = 0
   else:
    newSec = sec
    self.adjustedTime += sec
   lst = []
   for ndx, (startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon) in enumerate(VV6A99.VVrrm9()):
    startTS = int(startTS) + newSec
    startTxt =  FFTS4w(startTS).replace(" ", "   ")
    lst.append((startTxt, str(startTS), durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon))
   VV6A99.VVMqQ9(lst)
   if self.adjustedTime:
    VV6A99.VVQ7id()
    VV6A99["keyYellow"].setText("Reset Times ( %s %s )" % ("-" if self.adjustedTime < 0 else "+", FFFHEC(abs(self.adjustedTime))))
   else:
    VV6A99.VVAHUl()
 def VV5BI8(self, VV6A99, title, txt, colList):
  self.VV3mYS(VV6A99, 0)
 def VVpWUX(self, tm):
  try:
   span = iSearch(r"(\d{14})(?:\s+([+-])(\d\d)(\d\d))*", tm)
   if span:
    dateTime, sign, hh,mm = span.groups()
    tStamp = mktime(datetime.strptime(dateTime, "%Y%m%d%H%M%S").timetuple())
    if sign and hh and mm:
     gmt = (int(hh) * 3600 + int(mm) * 60)
     if sign == "-":
      gmt *= -1
     tStamp -= gmt
    return tStamp - iTimezone
  except:
   pass
  return 0
 def VVQ5VQ(self, err, title=""):
  FFdw58(self.tbl, err, title=title or self.Title)
 def VVre5F(self, err, title=""):
  CCwnHL.VVBfGR(self.tbl, os.path.basename(self.curPath), str(err), title=title or self.Title)
 @staticmethod
 def VVLnhF(timeStamp):
  return datetime.fromtimestamp(timeStamp + iTimezone).strftime("%Y%m%d%H%M%S +0000")
 @staticmethod
 def VVX583(txt):
  return txt.replace("&", "&#38;")
 @staticmethod
 def VVZwxs(txt):
  d = { "&lt;" : "<" , "&#60;": "<"
   , "&gt;" : ">" , "&#62;": ">"
   , "&apos;" : "'" , "&#39;": "'", "&#x27;": "'"
   , "&quot;" : '"' , "&#34;": '"'
   , "&amp;" : "&" , "&#38;": "&"
   , "&nbsp;" : " "
   , "&#09;" : "\t"
   , "&#10;" : "\n"
   , "&#13;" : "\n"
   , "&#91;" : "["
   , "&#93;" : "]"
   , "&#124;" : "|"
   }
  for key, val in d.items():
   if key in txt:
    txt = txt.replace(key, val)
  return txt
 @staticmethod
 def VVyHvM(SELF, title=""):
  path = FF0cqc() + "epg/"
  if FFpwZS("mkdir -p '%s'" % path):
   return path
  else:
   FFdw58(SELF, "Cannot create EPG directory:\n\n%s" % path, title=title or FFGNZA().strip())
   return ""
 @staticmethod
 def VVT11L():
  path = FF0cqc() + "epg/"
  fName = "ajpanel_channels.xml"
  refF = path + fName
  if not FFCyVu(refF) and FFpwZS("mkdir -p '%s'" % path):
   with open(refF, "w") as f:
    f.write('<?xml version="1.0" encoding="utf-8"?>\n<channels>\n</channels>\n')
 @staticmethod
 @FFOAKH()
 def VVuIyO(SELF, cbf=None, toTable=False):
  title = "Read Current Channel EPG" if toTable else "Seve Current Channel Events"
  VVwb7n = lambda x: FFdw58(SELF, x, title=title)
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
  if not VV1wIO or not VVPxk5:
   VVwb7n("Cannot get current channel data.")
   return
  ec, inst = CC5TsO.VVo0fG()
  if not inst:
   VVwb7n("Cannot access EPG Cache !")
   return
  try:
   evList = inst.lookupEvent([CC5TsO.VVhAdK, (VVPxk5.rstrip(":"), 0, -1, -1)])
  except:
   evList = []
  if not evList:
   FFdw58(SELF, "No EPG.", title=VV1wIO)
   return
  lst = []
  for start, dur, Title, descrS, descrL, pc, genre in evList:
   startTxt= FFTS4w(start).replace(" ", "   ")
   startTS = str(int(start))
   durTxt = FFFHEC(dur)
   if descrS == "Not Applicable":
    descrS = ""
   more = ""
   if pc:
    for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
   if genre:
    for g in genre: more += "Genre : %s\n" % str(g)
   if more:
    descrL = more.rstrip() + ("\n" + descrL if descrL else "")
   lst.append((startTxt, startTS, FFFHEC(dur), str(int(dur)), Title, descrS, descrL, "", "Yes" if descrL else "", ""))
  if toTable:
   cbf(FFjt5L(VV1wIO, VVSGsk), lst)
   return
  epgDir = CCDJgl.VVyHvM(SELF, title)
  if not epgDir:
   return
  tName = FFfCtV(VV1wIO, r"-").replace(" ", "_")
  path = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, tName, FFjTQe())
  with open(path, "w") as f:
   if not VVPxk5.endswith(":"): VVPxk5 += ":"
   f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
   f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (VVh9hj, VVJ6zn))
   f.write('<channel id="%s"><display-name lang="en">%s</display-name></channel>\n' % (VV1wIO, VV1wIO))
   f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VV1wIO, VV1wIO, VVPxk5))
   for startTxt, startTS, durTxt, dur, Title, descSh, descLng, iconUrl, isDesc, isIcon in lst:
    end = int(startTS) + int(dur)
    start = CCDJgl.VVLnhF(int(startTS))
    stop  = CCDJgl.VVLnhF(end)
    f.write('<programme start="%s" stop="%s" channel="%s">\n'   % (start, stop, VV1wIO))
    f.write('\t<title lang="en">%s</title>\n'      % CCDJgl.VVX583(Title))
    if descSh: f.write('\t<sub-title lang="en">%s</sub-title>\n' % CCDJgl.VVX583(descSh))
    f.write('\t<desc lang="en">%s</desc>\n'       % CCDJgl.VVX583(descLng))
    f.write('</programme>\n')
   f.write("</tv>\n")
  tot = len(evList)
  FFipXT(SELF, "Saved %d event%s to:\n\n%s\n%s" % (tot, FFcacr(tot), epgDir, os.path.basename(path)), title=VV1wIO)
  if cbf: cbf(path)
 @staticmethod
 @FFOAKH()
 def VVJavA(SELF, cbf=None):
  title = "Save EPG to File"
  VVwb7n = lambda x: FFdw58(SELF, x, title=title)
  ec, inst = CC5TsO.VVo0fG()
  if not inst:
   VVwb7n("Cannot access EPG Cache !")
   return
  srvLst = CCMvE7.VVqZTI()
  if not srvLst:
   VVwb7n("No services found in:\n\n%s" % rootSrc)
   return
  srvLst.sort(key=lambda x: x[1].lower())
  srvLst = [[VV1wIO, VVPxk5.rstrip(":"), 0] for x, (VVPxk5, VV1wIO) in enumerate(srvLst)]
  epgDir = CCDJgl.VVyHvM(SELF, title)
  if not epgDir:
   return
  VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc = CCjThi.VVZhZh()
  path  = "%sajpanel_xmltv_%s_%s.xml" % (epgDir, FFfCtV(rootName or rootSrc, r"_"), FFjTQe())
  tPath = "/tmp/ajp_xmltv"
  totChk = totCh = totEv = totPc = totGenre = 0
  with open(tPath, "w") as f:
   for ndx, (VV1wIO, VVPxk5, flag) in enumerate(srvLst):
    totChk += 1
    try:
     evList = inst.lookupEvent([CC5TsO.VVhAdK, (VVPxk5.rstrip(":"), 0, -1, -1)])
    except:
     evList = []
    if evList:
     srvLst[ndx][2] = 1
     totCh += 1
     totEv += len(evList)
     for start, dur, Title, descrS, descrL, pc, genre in evList:
      end = start + dur
      start = CCDJgl.VVLnhF(start)
      stop  = CCDJgl.VVLnhF(end)
      f.write('<programme start="%s" stop="%s" channel="%s">\n' % (start, stop, VV1wIO))
      f.write('\t<title lang="en">%s</title>\n'    % CCDJgl.VVX583(Title))
      if descrS and not "Not Applicable" in descrS:
       f.write('\t<sub-title lang="en">%s</sub-title>\n' % CCDJgl.VVX583(descrS))
      f.write('\t<desc lang="en">%s</desc>\n'     % CCDJgl.VVX583(descrL))
      if pc:
       for Sys, val in pc:
        totPc += 1
        f.write('\t<rating system="%s"><value>%s</value></rating>\n' % (Sys.strip(), val))
      if genre:
       for item in genre:
        totGenre += 1
        f.write('\t<category lang="en">%s</category>\n' % str(item))
      f.write('</programme>\n')
  if totEv:
   err = ""
   try:
    with open(path, "w") as f:
     f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
     f.write('<tv generator-info-name="%s-%s-EPG-Export">\n' % (VVh9hj, VVJ6zn))
     for VV1wIO, VVPxk5, flag in srvLst:
      if flag:
       if not VVPxk5.endswith(":"): VVPxk5 += ":"
       f.write('<channel id="%s"><display-name lang="en">%s</display-name><reference>%s</reference></channel>\n' % (VV1wIO, VV1wIO, VVPxk5))
     with open(tPath, "r") as tmpf:
      for line in tmpf.readlines():
       f.write(line)
     f.write("</tv>\n")
    tab = lambda x, y: "%s\t: %s\n" % (x, y)
    txt  = ""
    txt += tab("Group", rootSrc)
    txt += tab("Name", rootName or rootSrc)
    txt += "\n"
    txt += tab("Channels", totCh)
    txt += tab("Events", totEv)
    if totGenre : txt += tab("Category", totGenre)
    if totPc : txt += tab("P. Control", totPc)
    txt += "\n%s\n%s" % (FFjt5L("Output File:", VVSGsk), path)
    FF4lCP(SELF, txt, title=title, width=1500)
    if cbf: cbf(path)
   except Exception as e:
    FFwgGB(path)
    VVwb7n("Error during data export:\n\n%s" % str(e))
  else:
   FFdw58(SELF, "No EPG from %s channel%s in:\n\n%s" % (totChk, FFcacr(totChk), rootName or rootSrc), title=VV1wIO)
  FFwgGB(tPath)
 @staticmethod
 def VVtrWY(path):
  lst = set()
  try:
   for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
    if ndx == 0 and elem.tag != "tv":
     return [], "File is not XML-TV Format:\n%s" % FFjt5L(path, VVYjI5)
     break
    elif elem.tag == "channel":
     chId = FFwW5m(elem, "id")
     name = FF6Tbq(elem, "display-name")
     if chId and name:
      lst.add((name, chId))
     elem.clear()
    elif elem.tag == "programme":
     elem.clear()
     break
  except Exception as e:
   return [], str(e)
  return sorted(list(lst)), ""
 @staticmethod
 @FFOAKH("Validating Files ...")
 def VV8f7q(SELF, epgF):
  title = "Chain Channel Reference to XML-TV Channel Name"
  epgDir = CCDJgl.VVyHvM(SELF, title)
  if epgDir: outF = epgDir + "ajpanel_channels.xml"
  else  : return
  if FFCyVu(outF):
   chkLst, err = CCDJgl.VVQiv6(outF)
   if err:
    CCwnHL.VVBfGR(SELF, outF, err, title=title)
    return
   else:
    chkLst = [(ref + ":", id, id) for id, ref in chkLst]
  else:
   chkLst = []
  lst, err = CCDJgl.VVtrWY(epgF)
  if err:
   CCwnHL.VVBfGR(SELF, outF, err, title=title)
  else:
   try:
    SELF.session.open(CCjS4V, lst, chkLst=chkLst, srcPath=epgF, dstPath=outF
        , title=title, mnuTitle2="XMLTV Display Name", mnuTitle3="XMLTV Channel ID", blueTitle="Add Entry"
        , blueFnc=CCDJgl.VV0sVM, delFnc=CCDJgl.VVPrBx)
   except:
    pass
 @staticmethod
 @FFOAKH()
 def VV0sVM(bindCls):
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVzYMA()
  if not d["VVPxk510"]:
   FFjADj(bindCls, "Invalid Reference !", 800)
   return
  line = '\t<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (d["source"], d["mnuRef"], d["VVPxk510"], d["name"])
  try:
   if FFCyVu(outF):
    txt = FFYVq0(outF)
    with open(outF, "w") as f:
     f.write(txt.replace("</channels>", "").strip() + "\n%s\n</channels>\n" % line)
   else:
    with open(outF, "w") as f:
     f.write('<?xml version="1.0" encoding="utf-8"?>\n')
     f.write('<channels>\n\n')
     f.write(line)
     f.write('\n</channels>\n')
   FFG2sB(bindCls, "Saved", 800)
   bindCls.VVfC5O((d["VVPxk510"], d["mnuRef"], d["mnuTxt"]))
  except Exception as e:
   CCwnHL.VVBfGR(bindCls, outF, e, title=title)
 @staticmethod
 @FFOAKH()
 def VVPrBx(bindCls):
  title= bindCls.Title
  outF = bindCls.dstPath
  d  = bindCls.VVzYMA()
  try:
   lines = FFL19l(outF, keepends=True)
   with open(outF, "w") as f:
    for line in lines:
     if not d["mnuRef"] in line and not d["VVPxk510"] in line:
      f.write(line)
   FFG2sB(bindCls, "Deleted", 800)
   bindCls.VVNA0C((d["VVPxk510"], d["mnuRef"], d["mnuTxt"]))
  except Exception as e:
   CCwnHL.VVBfGR(bindCls, outF, e, title=title)
class CCjS4V(ChannelSelectionBase):
 def __init__(self, session, VV3wat, chkLst=None, srcPath="", dstPath="", pickMode=0, perc1=50, aligns2=None, widths2=None, fonts2=None, title="", mnuTitle1="", mnuTitle2="", mnuTitle3="", blueTitle="", blueFnc=None, delFnc=None, tBg="#11001122", bBg="#11001122", tBg1="#11220000", tBg2="#11220000", bg1="#11001122", bg2="#11001122"):
  self.skin, self.VVfOli = FFiNEe(VVkFCt, 1800, 1000, 30, 10, 10, tBg, bBg, 30, VVeFSs=40, VV0Ay7=2, VVUuJZ={"perc1": perc1, "perc2": widths2[0] if widths2 else 50, "tbg1": tBg1, "tbg2": tBg2, "bg1": bg1, "bg2": bg2})
  self.session  = session
  self.VV3wat  = VV3wat
  self.chkLst   = chkLst or []
  self.srcPath  = srcPath
  self.dstPath  = dstPath
  self.pickMode  = pickMode
  self.aligns2  = aligns2
  self.widths2  = widths2
  self.fonts2   = fonts2
  self.Title   = title or "Chain Channel Reference"
  self.mnuTitle1  = mnuTitle1 or "Source Channels"
  self.mnuTitle2  = mnuTitle2
  self.mnuTitle3  = mnuTitle3
  self.blueTitle  = blueTitle or "Add Selection to file"
  self.blueFnc  = blueFnc
  self.delFnc   = delFnc
  self.bg2   = bg2
  self.totRows  = 18
  self.VV8c7y  = 40
  self.curMenu  = 1
  self.VVwdmN  = int(self.VV8c7y * 0.82)
  self.cursCur  = "#08885500"
  self.cursNorm  = "#08223333"
  self.curRef   = ""
  self.cancelTime  = 0
  self.added   = False
  self.lastChannel = self.VVtpQU()
  self.tpData   = CC3Z54()
  self.isVti   = CC674y.VV1LWx()
  FFZMxC(self, title=self.Title)
  self["myMenu"]  = MenuList([], True, eListboxPythonMultiContent)
  self["myTitle1"] = Label(self.mnuTitle1)
  self["myTitle2"] = Label(self.mnuTitle2)
  self["myTitle3"] = Label(self.mnuTitle3)
  self["myFrm1"]  = Label()
  self["myFrm2"]  = Label()
  FFRLNq(self["keyRed"] , "Group = Favourite")
  FFRLNq(self["keyGreen"] , "Show Chains")
  FFRLNq(self["keyYellow"], "Find Close Name")
  FFRLNq(self["keyBlue"] , self.blueTitle)
  if self.pickMode == 0: self["keyBlue"].hide()
  self["keyGreen"].hide()
  try:
   from difflib import get_close_matches as iClosest
   self.iClosest = iClosest
  except:
   self.iClosest = None
  ChannelSelectionBase.__init__(self, session)
  self.bouquet_mark_edit = 0
  FFHlAU(self,
  {
   "ok"  : self.VVPr1F  ,
   "cancel" : self.cancel  ,
   "info"  : self.VVauE3 ,
   "menu"  : self.VVEzGg ,
   "tv"  : self.VVQVyP,
   "red"  : self.VVp5CU ,
   "green"  : self.VVgd7n,
   "yellow" : self.VVSXdh,
   "blue"  : self.VVsL1P ,
   "down"  : self.VVDBsZ  ,
   "up"  : self.VVx0di   ,
   "left"  : self.VVziFC  ,
   "right"  : self.VVLe1s  ,
   "pageUp" : self.VVLlE3  ,
   "chanUp" : self.VVLlE3  ,
   "pageDown" : self.VVSYHQ ,
   "chanDown" : self.VVSYHQ ,
   "next"  : self.VVylpm  ,
   "last"  : self.VVGc2k
  }, name="ChannelSelectBaseActions", prio=-2)
  FFHlAU(self, {})
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  FFWgBS(self)
  obj  = self["myMenu"]
  objL = obj.l
  self.VV64T6()
  FF4IPF(obj, bg=self.cursNorm)
  objL.setFont(0, gFont(VVNhAq, self.VVwdmN))
  objL.setFont(1, gFont(VVNhAq, int(self.VVwdmN * 0.7)))
  objL.setItemHeight(self.VV8c7y)
  obj.setList(self.VV23Cq())
  obj.setList(obj.list)
  obj  = self["list"]
  objL = obj.l
  self.setTvMode()
  self.showFavourites()
  obj.setMode(1)
  self.VV3sWT()
  FF4IPF(obj, bg=self.cursCur)
  obj.onSelectionChanged.append(self.VVFA1G)
  objL.setItemHeight(self.VV8c7y)
  try:
   objL.setColor(objL.eventForeground, parseColor("#00ffffaa"))
   objL.setItemsDistances(15)
  except:
   pass
  objL.setColor(objL.serviceEventProgressbarColor, parseColor("#0000ff00"))
  objL.setColor(objL.serviceEventProgressbarColorSelected, parseColor("#0000ff00"))
  objL.setColor(objL.serviceEventProgressbarBorderColor, parseColor("#00ffffff"))
  self.VVvDEf()
  self.VVRUZw()
 def onExit(self):
  self["list"].onSelectionChanged = []
 def VVEzGg(self):
  VV3wat = []
  VV3wat.append(("Go to Current Playing Channel" , "cur" ))
  VV3wat.append(("Go to Original Playing Channel" , "orig"))
  if self.chkLst:
   VV3wat.append(VVAL3j)
   VV3wat.append(("Next Chained Service"  , "chain0"))
   VV3wat.append(("Previous Chained Service" , "chain1"))
  if self.delFnc:
   VV3wat.append(VVAL3j)
   VV3wat.append(FFsLU5("Delete Selected Chain", "del" , self.VVuUsf(), VVz22H))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Exit  (or double-Cancel)", "exit"))
  FFLFTC(self, self.VVeDfm, title="Options", VV3wat=VV3wat)
 def VVeDfm(self, item):
  if item:
   if   item == "cur"  : self.VVqfeT(False)
   elif item == "orig"  : self.VVqfeT(True)
   elif item == "chain0" : self.VVUSFL()
   elif item == "chain1" : self.VVSefD()
   elif item == "del"  : self.VVN1I2()
   elif item == "exit"  : self.close()
 def VVPr1F(self):
  if self.curMenu == 1:
   serv = self.getCurrentSelection()
   if serv.flags & 7 == 7:
    self.enterPath(serv)
    if not len(self.servicelist.getList()):
     self.keyGoUp()
     FF28n1(self, "No Services", 500)
    self.VV3sWT()
    serv = self.session.nav.getCurrentlyPlayingServiceReference()
    if serv:
     try: self.setCurrentSelectionAlternative(serv)
     except: self.setCurrentSelection(serv)
   elif serv.flags == 0:
    FFnfiC(self.session, self.curRef)
    FFSqRh(self, "Cancel to go back to table")
  self.VVRUZw()
 def VVN1I2(self):
  self.delFnc(self)
  self.VVRUZw()
 def cancel(self):
  serv = self.getCurrentSelection()
  if iTime() - self.cancelTime < 0.6:
   self.close()
  elif self.curMenu == 2:
   self.VVziFC()
  elif len(self.servicePath) <= 1:
   FF28n1(self, "Double Cancel to exit", 500)
   self.cancelTime = iTime()
  else:
   self.keyGoUp()
   self.VV3sWT()
   self.VVRUZw()
   self.cancelTime = iTime()
 def VVauE3(self):
  lst= []
  d  = self.VVzYMA()
  def VVZwiy(x, y):
   if y: lst.append((c + x, y))
  c, s = "#b#11440044#", "Source Channel - "
  VVZwiy(s + "Name"  , d["name"])
  VVZwiy(s + "Reference" , "" if "ORDER BY" in d["noPhpRef"] else d["noPhpRef"])
  VVZwiy(s + "Source" , d["source"] + (" (%s)" % d["satLong"]) if d["satLong"] else "")
  VVZwiy(s + "Path"  , d["path"])
  VVZwiy(s + "Parent" , d["rootName"])
  VVZwiy(s + "ParentPath", d["rootPath"])
  c, s = "#b#11001122#", "Destination Channel - "
  VVZwiy(s + "Row Number", "%d of %d" % (d["mnuRowNum"], len(self.VV3wat)))
  VVZwiy(s + self.mnuTitle2, d["mnuTxt"])
  VVZwiy(s + self.mnuTitle3, d["mnuRef"])
  VVZwiy(s + "Source File", self.srcPath)
  VVZwiy(s + "Output File", self.dstPath)
  FFUQ0v(self, None, title=self.Title, VVGape=lst, VV3cHe=(40, 60), width=1700, VVwdmN=28, VVJKqd="#0a333333", VVbcr0="#00333333", VVKDPJ=1)
 def VVgd7n(self):
  if self["keyGreen"].getVisible():
   self.VVGCzn()
 def VVsL1P(self):
  if self["keyBlue"].getVisible():
   if self.added:
    FFjADj(self, "Already Added.", 1000)
   else:
    self.blueFnc(self)
    self.VVFA1G()
 def VVx0di(self):
  if self.curMenu == 1: self.moveUp()
  else    : self["myMenu"].up()
  self.VVRUZw()
 def VVDBsZ(self):
  if self.curMenu == 1: self.moveDown()
  else    : self["myMenu"].down()
  self.VVRUZw()
 def VVLlE3(self):
  if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageUp)
  else    : self["myMenu"].pageUp()
  self.VVRUZw()
 def VVSYHQ(self):
  if self.curMenu == 1: self.servicelist.instance.moveSelection(self.servicelist.instance.pageDown)
  else    : self["myMenu"].pageDown()
  self.VVRUZw()
 def VVGc2k(self):
  if self.curMenu == 1: self["list"].moveToPrevMarker()
  else    : self["myMenu"].moveToIndex(0)
 def VVylpm(self):
  if self.curMenu == 1: self["list"].moveToNextMarker()
  else    : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 def VVziFC(self):
  if self.curMenu == 2:
   self.curMenu = 1
   self.VVRUZw()
 def VVLe1s(self):
  if self.curMenu == 1:
   self.curMenu = 2
   self.VVRUZw()
 def VVtpQU(self):
  root = None
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   root = InfoBar.instance.servicelist.getRoot()
  return serv, root
 def VVqfeT(self, isOrig):
  if isOrig: serv, root = self.lastChannel
  else  : serv, root = self.VVtpQU()
  if serv and root:
   try:
    self.enterPath(root)
    self.servicelist.setCurrent(serv)
   except:
    try:
     self.showAllServices()
     self.servicelist.setCurrent(serv)
    except:
     pass
   self.VV3sWT()
   self.VVziFC()
   d = self.VVzYMA()
   self["keyRed"].setText("Group = %s" % d["gName"])
  else:
   FF28n1(self, "Not found", 800)
 @FFOAKH()
 def VVSXdh(self):
  d = self.VVzYMA()
  lst = [item[0] for item in self.VV3wat]
  lst.extend([item[1] for item in self.VV3wat])
  bestLst = self.iClosest(d["name"], lst, 1, 0.6)
  if bestLst : self.VVyoOq(bestLst[0])
  else  : FFjADj(self, "Not found.", 500)
 def VVyoOq(self, id):
  for ndx, item in enumerate(self.VV3wat):
   txt = item[0]
   ref = item[1]
   if txt == id or ref == id:
    self["myMenu"].moveToIndex(ndx)
    self.VVRUZw()
    break
 def VVLlJi(self):
  return [item[0] for item in self.chkLst]
 @FFOAKH()
 def VVUSFL(self):
  refs = self.VVLlJi()
  cNdx = self.servicelist.getCurrentIndex()
  lst = self.servicelist.getList()
  for ndx, serv in enumerate(lst):
   if ndx > cNdx and serv and serv.toString() in refs:
    self.servicelist.moveToIndex(ndx)
    self.VVRUZw()
    break
  else:
   FFjADj(self, "Not found", 1000)
 @FFOAKH()
 def VVSefD(self):
  refs = self.VVLlJi()
  cNdx = self.servicelist.getCurrentIndex()
  if cNdx > 0:
   lst = self.servicelist.getList()
   for ndx in range(cNdx-1, -1, -1):
    serv = lst[ndx]
    if serv and serv.toString() in refs:
     self.servicelist.moveToIndex(ndx)
     self.VVRUZw()
     return
  FFjADj(self, "Not found", 1000)
 def VVGCzn(self):
  d = self.VVzYMA()
  lst = []
  lst2 = []
  for srcRef, dstRef, dstName in self.chkLst:
   if d["VVPxk510"] == srcRef:
    txt1 = FFjt5L(dstName, VVA4XU)
    for ndx, item in enumerate(self.VV3wat):
     mTxt = item[0]
     mRef = item[1]
     if (mTxt, mRef) == (dstName,  dstRef):
      txt1 = FFjt5L(item[0], VVJEMb) + FFjt5L("  (%s)" % item[1], VVo7S9)
      lst.append((txt1, (ndx, dstName)))
      break
    else:
     lst2.append((txt1, (-1, dstName)))
  if lst or lst2:
   lst.sort(key=lambda x: x[0].lower())
   lst2.sort(key=lambda x: x[0].lower())
   if lst and lst2 : lst.append(VVAL3j)
   if lst2   : lst.extend(lst2)
   title = "Item%s Linked to : %s" % (FFcacr(len(lst)), FFjt5L(d["name"], VVJEMb))
   FFLFTC(self, self.VVPUpF, VV3wat=lst, width=1300, VVyRCy=3, title=title, VVwltY="#11001122", VVkxBG="#11001122", VVoCB2="#11330000")
  else:
   FF28n1(self, "Not found", 800)
 def VVPUpF(self, item):
  if not item: return
  if item[0] == -1:
   FFdw58(self, "Not found in current list.\n\nProbably added from another list.", item[1])
  else:
   self["myMenu"].moveToIndex(item[0])
   self.VVLe1s()
   self.VVRUZw()
 def VVRUZw(self):
  if self.VVuUsf() : tBg, cBg, self.added = "#00ff8000", "#00ff0000", True
  else        : tBg, cBg, self.added = "#00ffffff", self.cursCur, False
  FFGUI5(self["myTitle1"], tBg)
  FFGUI5(self["myTitle2"], tBg)
  FFGUI5(self["myTitle3"], tBg)
  if self.curMenu == 1:
   CCKg9B(self, self["list"])
   FF4IPF(self["list"], bg=cBg)
   FF4IPF(self["myMenu"], bg=self.cursNorm)
  else:
   CCKg9B(self, self["myMenu"])
   FF4IPF(self["list"], bg=self.cursNorm)
   FF4IPF(self["myMenu"], bg=cBg)
  for obj in ("list", "myMenu"):
   inst = self[obj].instance
   inst.setSelectionEnable(0)
   inst.setSelectionEnable(1)
 def VVfC5O(self, item):
  self.chkLst.append(item)
  self.VVRUZw()
 def VVNA0C(self, item):
  self.chkLst.remove(item)
  self.VVRUZw()
 def VVuUsf(self):
  d = self.VVzYMA()
  return (d["VVPxk510"], d["mnuRef"], d["mnuTxt"]) in self.chkLst
 def VVzYMA(self):
  serv = self.getCurrentSelection()
  d = {"name": "", "rootName": "", "VVPxk5": "", "VVPxk510": "", "noPhpRef": "", "rootRef": "", "gName": "", "source": "", "satLong": "", "path": "", "rootPath": ""}
  ndx, txt, ref = self.VVYu3Y()
  d["mnuRowNum"], d["mnuTxt"], d["mnuRef"] = ndx + 1, txt, ref
  if serv:
   VVPxk5   = serv.toString()
   path   = CCLSIv.VVijn5(VVPxk5, mode=1)
   if "ORDER BY" in path: path = ""
   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", VVPxk5)
   if span  : d["VVPxk510"] = span.group(1)
   if not path : d["satLong"]   = FFec0y(VVPxk5, True)
   d["VVPxk5"] = VVPxk5
   d["name"]  = FFCjjv(VVPxk5)
   d["source"]  = CCYrUm.VVMJTa(VVPxk5, unknown="")
   d["noPhpRef"]= iSub(r"[&?]mode=.+end=", r"", VVPxk5, flags=IGNORECASE)
   d["path"]  = path
   rootRef   = self.getRoot().toString()
   rootPath  = CCLSIv.VVijn5(rootRef, mode=1)
   if "ORDER BY" in rootPath: rootPath = ""
   gNum, gName  = self.VVOlkd(rootRef)
   d["rootRef"] = rootRef
   d["rootName"]= FFCjjv(rootRef)
   d["gName"]  = gName
   d["rootPath"]= rootPath
  return d
 def VVYu3Y(self):
  ndx = self["myMenu"].l.getCurrentSelectionIndex()
  txt = self.VV3wat[ndx][0]
  ref = self.VV3wat[ndx][1]
  return ndx, txt, ref
 def VVQVyP(self):
  try:
   if   self.mode == 0: self.setRadioMode()
   elif self.mode == 1: self.setTvMode()
   serv = self.getCurrentSelection()
   if serv.flags & 7 == 7:
    self.enterPath(serv)
   rootRef = self["list"].getRoot().toString()
   gNum, gName = self.VVOlkd(rootRef)
   self.VVCiA3(gNum)
   self.VVRUZw()
  except:
   pass
  self.VVvDEf()
 def VVvDEf(self):
  self["myTitle"].setText("  %s \t\t %s" % (self.Title, FFjt5L("Radio" if self.mode == 1 else "TV", VVo7S9)))
 def VVOlkd(self, VVPxk5):
  if   "(satellitePosition == " in VVPxk5: return 2, "Satellite"
  elif "Current transponder" in VVPxk5 : return 2, "Transponder"
  elif "(provider == " in VVPxk5   : return 3, "Provider"
  elif "FROM BOUQUET" in VVPxk5   : return 4, "Favourite"
  else         : return 1, "ALL"
 def VVp5CU(self):
  FFLFTC(self, self.VVCiA3, width=500, VV3wat=[("All", 1), ("Satellites", 2), ("Provider", 3), ("Favourites", 4)], title="Channels Group")
 def VVCiA3(self, g):
  if g:
   if   g == 1: self.showAllServices()
   elif g == 2: self.showSatellites()
   elif g == 3: self.showProviders()
   elif g == 4: self.showFavourites()
   self.VV3sWT()
   self.VVRUZw()
   self["keyRed"].setText("Group = " + {1:"All", 2:"Satellites", 3:"Provider", 4:"Favourites", }.get(g, "?"))
 def VV23Cq(self):
  totCol = len(self.VV3wat[0])
  align = self.aligns2 or [LEFT] * totCol
  font = self.fonts2 or [0] * totCol
  fg  = [FFRUST("#00ffffff")] * totCol
  fg[1] = FFRUST("#00666666")
  bg  = FFRUST(self.bg2)
  sFg  = [FFRUST("#00ffffff")] * totCol
  sFg[1] = FFRUST("#00888888")
  w  = self["myMenu"].instance.size().width()
  if self.widths2 : widths = [w * r / 100 for r in self.widths2]
  else   : widths = [w  // totCol] * totCol
  rows  = []
  for rNdx, row in enumerate(self.VV3wat):
   cols = [rNdx]
   posX = 0
   for cNdx, txt in enumerate(row):
    gap = (0 if align[cNdx] == CENTER else 8)
    cols.append(CCnES5.VVNynG( posX + gap, 0
              , widths[cNdx] - gap, self.VV8c7y
              , font[cNdx]
              , align[cNdx] | RT_VALIGN_CENTER
              , txt
              , fg[cNdx]
              , bg
              , sFg[cNdx]
              , None
              , 0
              , None
              ))
    posX += widths[cNdx]
   rows.append(cols)
  return rows
 def VV64T6(self):
  inst = self["myMenu"].instance
  sz = inst.size()
  w, h = sz.width(), sz.height()
  self.VV8c7y = h // self.totRows
  diff = h % self.totRows
  if diff:
   for obj in ("list", "myMenu", "myFrm1", "myFrm2"):
    inst = self[obj].instance
    w, h = inst.size().width(), inst.size().height()
    inst.resize(eSize(*(w, h - diff)))
   inst = self.instance
   w, h = inst.size().width(), inst.size().height()
   inst.resize(eSize(*(w, h - diff)))
   screenSize = getDesktop(0).size()
   inst.move(ePoint((screenSize.width() - w) // 2, (screenSize.height() - h) // 2))
   for name in ("keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine"):
    obj = self[name]
    inst = obj.instance
    pos = obj.getPosition()
    obj.instance.move(ePoint(pos[0], pos[1] - diff))
 def VV3sWT(self):
  obj = self["list"]
  objL= obj.l
  objL.setItemHeight(self.VV8c7y)
  numFontSz = int(self.VV8c7y * 0.45)
  objL.setElementFont(objL.celServiceNumber, gFont(VVNhAq, numFontSz))
  objL.setElementFont(objL.celServiceName, gFont(VVNhAq, self.VVwdmN))
  objL.setElementFont(objL.celServiceInfo, gFont(VVNhAq, int(self.VV8c7y * 0.60)))
  if self.isVti:
   return
  try:
   inst = obj.instance
   numW = self.VVGhIc(inst, gFont(VVNhAq, numFontSz), inst.size(), "0000").width()
   rowW = inst.size().width() - 30
   nameW = rowW - (numW + obj.fieldMargins + obj.progressBarWidth + obj.fieldMargins)
   serv = self.getCurrentSelection()
   objL.setElementPosition(objL.celServiceNumber, eRect(0, 0, numW, self.VV8c7y))
   if serv and serv.flags == 0 : left = numW + obj.fieldMargins
   else      : left = 10
   objL.setElementPosition(objL.celServiceName, eRect(left, 0, nameW, self.VV8c7y))
   objL.setElementPosition(objL.celServiceEventProgressbar, eRect(rowW - obj.progressBarWidth, 0, obj.progressBarWidth, self.VV8c7y))
  except:
   pass
 def VVGhIc(self, instance, font, targetSize, txt):
  from enigma import eLabel
  return eLabel.calculateTextSize(font, txt, targetSize)
 def VVFA1G(self):
  self["keyBlue"].hide()
  serv = self.getCurrentSelection()
  if serv and serv.flags == 0:
   self.curRef = serv.toString()
   txt = CCYrUm.VVMJTa(self.curRef, unknown="")
   tpTxt = self.tpData.VVNNi3(self.curRef)
   if tpTxt: txt += " (%s)" % tpTxt
   if txt : txt += " - "
   txt = (txt + self.curRef).strip()
   if len(txt) > 61: txt = txt[:61] + ".."
   if self.pickMode in (0, 2): self["keyBlue"].show()
  else:
   self.curRef = ""
   txt = self.mnuTitle1
   if self.pickMode in (1, 2): self["keyBlue"].show()
  self["myTitle1"].setText(txt)
  self.VVRUZw()
  if self.VVzYMA()["VVPxk510"] in self.VVLlJi():
   self["keyGreen"].show()
  else:
   self["keyGreen"].hide()
class CCi3sj():
 def __init__(self, SELF, cbf=None):
  self.SELF  = SELF
  self.cbf  = cbf
  self.Title  = "Download XML-TV File"
  self.urlsPath = FF0cqc() + "ajpanel_epg_source"
  self.dstPath = FF0cqc() + "epg/"
  self.tbl  = None
  self.lastPath = ""
  if not FFCyVu(self.urlsPath):
   FF8Wsn(self.SELF, self.urlsPath, title=self.Title)
   return
  self.epgDir = CCDJgl.VVyHvM(SELF, self.Title)
  if not self.epgDir:
   return
  lst = self.VVEP93()
  if lst:
   if self.tbl:
    self.tbl.VVMqQ9(lst)
   else:
    lst.sort(key=lambda x: x[0].lower())
    bg = "#11112233"
    VVu8qI = self.VVGDVP
    VVwSzI = ("Download", self.VVo3JE, [])
    header  = ("File", "URL", "Exists" )
    widths  = (28  , 64 , 8   )
    VVLIqP = (LEFT  , LEFT , CENTER )
    self.tbl = FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=lst, VV3cHe=widths, VVLIqP=VVLIqP, width=1700, VVwdmN=26, VVu8qI=VVu8qI, VVwSzI=VVwSzI, VVwltY="#00004455", VVkxBG=bg, VVemyB=bg, VVJKqd="#0a665533", VVbcr0="#00333333", VVX9AA="#00552222")
  else:
   FFdw58(self.SELF, "No valid URLs in:\n\n%s" % path, title=self.Title + " (xml/gz/xz)" )
 def VVGDVP(self, VV6A99):
  if self.lastPath and self.cbf:
   self.cbf(self.lastPath)
  VV6A99.cancel()
 def VVEP93(self):
  lst = []
  for url in FFL19l(self.urlsPath):
   url = url.strip()
   if not url.startswith("#") and url.endswith((".gz", ".xz", ".xml")) and not url.endswith((".tar.gz", ".tar.xz")):
    fName = os.path.basename(url)
    if fName.endswith((".gz", ".xz")) : fName = fName[:-3]
    if not fName.endswith(".xml")  : fName += ".xml"
    lst.append((fName, url, "Yes" if FFCyVu(self.dstPath + fName) else ""))
  return lst
 def VVo3JE(self, VV6A99, title, txt, colList):
  fName, url, exist = VV6A99.VV5crm()
  for ext, tool in {".gz": "gzip", ".xz":"xz"}.items():
   if url.endswith(ext) and not FFayeZ(tool):
    FFdw58(self.tbl, 'Please install "%s" to handle the "%s" files.' % (tool, ext), title=self.Title)
    return
  ques = "Download%s:\n\n%s" % (" (%s)" % FFjt5L("and overwrite", VVz22H) if FFCyVu(self.epgDir + fName) else "", fName)
  FFRMYv(self.tbl, BF(self.VVObj8, self.tbl, url, fName), ques, title=self.Title)
 @FFOAKH("Downloading ...", par=1, clearMsg=False)
 def VVObj8(self, tbl, url, fName):
  path, err = FFx9uM(url, os.path.basename(url), timeout=3, tmpPath=self.epgDir)
  if path:
   self.VVBhun(self.tbl, path)
  else:
   FFdw58(self.tbl, "Download Error:\n\n%s" % err, title=self.Title)
   FF28n1(self.tbl)
 @FFOAKH("Extracting ...", par=1)
 def VVBhun(self, tbl, path):
  if path.endswith((".gz", ".xz")):
   txt = FFQ45w("%s -fd '%s'" % ("gzip" if path.endswith("gz") else "xz", path))
   if not txt:
    src = path[:-3]
    path = src
    if not path.endswith(".xml"):
     path = src + ".xml"
    if not FFpwZS("mv -f '%s' '%s'" % (src, path)):
     FFdw58(self.tbl, "Cannot rename the downloaded file:\n\n%s" % src, title=self.Title)
     return
   else:
    FFdw58(self.tbl, "Cannot extract:\n%s\n\n( %s )" % (path, txt), title=self.Title)
    return
  self.lastPath = path
  FF1mVE(self.tbl, "Downloaded")
  try:
   fName, url, exist = self.tbl.VV5crm()
   self.tbl.VViSLW((fName, url, FFjt5L("New", VVSGsk)))
  except:
   pass
class CC5TsO(Screen, CCwnHL):
 VV9Ht1  = "BDTSE"
 VVhAdK  = "BDTSEPW"
 VVEj5l   = "save"
 VVss6k   = "load"
 VVctP1  = "flushEPG"
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 1000, 1000, 50, 40, 30, "#22110011", "#22110022", 30)
  self.session  = session
  c1, c2, c3, c4, c5 = VVJEMb, VVFuwR, VVJEMb, VVGCYL, VVz22H
  valid, path, sz, szTxt, modTm = CC5TsO.VV0Zhh()
  qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
  VV3wat = []
  VV3wat.append((c1 + "XML-TV Tools", "xmltvTools"))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Read Current Channel EPG"  , "curEv" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Save Current Channel EPG"  , "saveCur" ))
  VV3wat.append((c2 + "Save Current Channel-Group EPG" , "saveGrp" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "EPG Events Counter"    , "evCount" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c4 + "Cache File Info.", "inf"))
  VV3wat.append(VVAL3j)
  fTxt = " (%s)" % os.path.basename(path) if valid else ""
  VV3wat.append(FFsLU5("Save EPG to File%s" % fTxt , self.VVEj5l, valid))
  VV3wat.append(FFsLU5("Load EPG from File%s" % fTxt , self.VVss6k, valid))
  VV3wat.append(VVAL3j)
  VV3wat.append((c5 + "Delete EPG (from RAM only)", self.VVctP1))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVFT2F", qUrl or "chCode" in VVfaDB))
  VV3wat.append(("Copy EPG between Channels (from xml file)", "copyEpg" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Translate Current Channel EPG", "VVwBbY"))
  FFZMxC(self, title="EPG Tools", VV3wat=VV3wat)
  self.onShown.append(self.VV7OzD)
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "xmltvTools"   : CCDJgl(self)
   elif item == "curEv"    : CCDJgl(self, mode=1)
   elif item == "saveCur"    : CCDJgl(self, mode=2)
   elif item == "saveGrp"    : CCDJgl(self, mode=3)
   elif item == "evCount"    : self.VVv148()
   elif item == "inf"     : self.VVdXJt()
   elif item in (self.VVEj5l, self.VVss6k, self.VVctP1):
    reset = item == self.VVss6k
    FFRMYv(self, BF(self.VVvvRZ, item, reset), VVsWSA="Continue ?")
   elif item == "VVFT2F": CCkEI5.VVFT2F(self)
   elif item == "copyEpg"    : self.VVNXsZ(False, onlyEpg=True)
   elif item == "VVwBbY" : self.VVwBbY()
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 @FFOAKH()
 def VVvvRZ(self, act, reset=False):
  ok = CC5TsO.VVdThy(act)
  if ok:
   if reset:
    CCYrUm.VV0iSP(self.session)
   FFipXT(self, "Done")
  else:
   FFipXT(self, "Failed!")
 def VVdXJt(self):
  title = "EPG Cache File"
  valid, path, sz, szTxt, modTm = CC5TsO.VV0Zhh()
  if path:
   if valid: txt = "File Path\t: %s\n\nFile Size\t: %s\n\nModified\t: %s\n" % (path, szTxt or "?", modTm)
   else : txt = "System Settings: %s\n\n%s" % (path, FFjt5L("File not found (check System EPG settings).", VVz22H))
   FF4lCP(self, txt, title=title)
  else:
   FFdw58(self, "Cannot read Path Settings !", title=title)
 @FFOAKH()
 def VVv148(self):
  title = "EPG Events Counter"
  ec, inst = CC5TsO.VVo0fG()
  if not inst:
   FFdw58(self, "Cannot access EPG Cache !", title=title)
   return
  lst = CCYrUm.VV3FRU("1:7:")
  lst = [(n, r.rstrip(":"), FFec0y(r, False)) for r, n in lst]
  lst2 = CCMvE7.VVIjNS()
  lst.extend([(n, r.rstrip(":"), "IPTV") for r, n in lst2])
  lst2 = None
  VVAkuK = []
  totEv = 0
  for n, r, t in lst:
   evList = inst.lookupEvent([CC5TsO.VV9Ht1, (r.rstrip(":"), 0, -1, -1)])
   tot = len(evList)
   if tot:
    totEv += tot
    VVAkuK.append((n, r, t, str(tot)))
  if VVAkuK:
   title += FFjt5L("  ( Total Events = %s )" % totEv, VVA4XU)
   bg = "#0a112525"
   VVAkuK.sort(key=lambda x: x[0].lower())
   header  = ("Name" , "Reference" , "Source" , "EPG Events" )
   widths  = (40  , 40   , 8   , 12   )
   VVLIqP = (LEFT  , LEFT   , CENTER , CENTER )
   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VVpCEu=True, width=1800, height=950, VV3cHe=widths, VVwdmN=28
         , VVwltY=bg, VVkxBG=bg, VVemyB=bg)
  else:
   FFdw58(self, "No channels with cached EPG !", title=title)
 def VVwBbY(self):
  title = "Translate Current Channel EPG"
  bg = "#11101010"
  VVu1YM  = (""   , BF(self.VVqDKc, title, True) , [])
  VVwSzI = ("Start"  , BF(self.VVqDKc, title, False), [])
  VV4QTJ = ("Language" , self.VVmOvU         , [])
  widths  = (50 , 50 )
  VVLIqP = (LEFT , CENTER)
  FFUQ0v(self, None, title=title, VVGape=self.VVz1nR(), VVLIqP=VVLIqP, VV3cHe=widths, width=900, VVYUmm=20, VVwdmN=30, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVKDPJ=2
    , VVwltY="#11201010", VVkxBG=bg, VVemyB=bg, VVJKqd="#00004455", VVbcr0=bg)
 def VVz1nR(self):
  ch = dict(self.VVkQ4u())
  VVAkuK = []
  VVAkuK.append(("Event Name Language" , ch.get(CFG.epgLangTitle.getValue(), "")))
  VVAkuK.append(("Description Language", ch.get(CFG.epgLangDescr.getValue(), "")))
  return VVAkuK
 def VVmOvU(self, VV6A99, title, txt, colList):
  ndx = VV6A99.VVGTqU()
  title = colList[0]
  confItem = CFG.epgLangTitle if ndx == 0 else CFG.epgLangDescr
  CCJaSw.VV5YpJ(self, confItem, title, lst=self.VVkQ4u(), cbFnc=BF(self.VVS4PG, VV6A99), isSave=True)
 def VVS4PG(self, VV6A99):
  for ndx, row in enumerate(self.VVz1nR()):
   VV6A99.VVEOou(ndx, row)
  FF1mVE(VV6A99, "Saved", 600)
 def VVkQ4u(self):
  lst = [("", "DISABLED")]
  for line in FFL19l("%sajpanel_lang" % VVIp2p):
   span = iSearch(r"\s*(.+)\s*,\s*(.+)\s*", line)
   if span:
    lst.append((span.group(1), span.group(2)))
  return lst
 def VVqDKc(self, Title, isAsk, VV6A99, title, txt, colList):
  tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
  if not (tVal or dVal):
   FF28n1(VV6A99, "Change Language", 700)
  else:
   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
   VVPxk5, evList, err = CC5TsO.VVVHZD(VVPxk5)
   fnc = BF(self.VVyZ3o, Title, VVPxk5, evList, VV6A99)
   if   err : FFdw58(self, err, title=Title)
   elif isAsk : FFRMYv(self, fnc, "Start ?", title=Title)
   else  : fnc()
 def VVyZ3o(self, title, VVPxk5, evList, VV6A99):
  CCh3tv.VV7Nf4(self, VVLL7M=title, titleBg="#22003344", bodyBg="#22001122"
      , VVixvy  = BF(self.VV8Eiv, evList)
      , VVbYwR = BF(self.VVhb4S, VV6A99, title, VVPxk5))
 def VV8Eiv(self, evList, VVXyP6):
  totEv = len(evList)
  newLst = []
  totErrName = totErrShort = totErrLong = totSkip = 0
  VVXyP6.VVq8NF(totEv)
  VVXyP6.VVNc18 = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
  lang = CFG.epgLangDescr.getValue()
  for ev in evList:
   trName, trShort, trLong, errName, errShort, errLong = CC5TsO.VVZXHh(*ev[2:5])
   totErrName  += errName
   totErrShort += errShort
   totErrLong  += errLong
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   VVXyP6.VVxtQs(1)
   VVXyP6.VVYQKA(len(newLst), ev[2] if len(ev[2]) < 22 else ev[2][:22] + " ...")
   name1, short1, long1 = ev[2:5]
   if (name1, short1, long1) != (trName, trShort, trLong):
    item = list(ev)
    item[2], item[3], item[4] = trName, trShort, trLong
    item.append(1)
    newLst.append(tuple(item))
   else:
    totSkip += 1
   VVXyP6.VVNc18 = (newLst, totEv, totErrName, totErrShort, totErrLong, totSkip)
 def VVhb4S(self, VV6A99, title, VVPxk5, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  newLst, totEv, totErrName, totErrShort, totErrLong, totSkip = VVNc18
  if newLst: totEv, totOK = CC5TsO.VV8M7K(VVPxk5, newLst)
  else  : totOK = 0
  if totOK:
   CC5TsO.VVYLja()
   CCYrUm.VV0iSP(self.session)
  txt  = "Events\t: %d\n"  % totEv
  txt += "Processed\t: %d\n" % len(newLst)
  txt += "Changed\t: %d\n" % totOK
  if totSkip : txt += "Skipped\t: %d \t... Same language\n" % totSkip
  if any((totErrName, totErrShort, totErrLong)):
   txt += "\nErrors:\n"
   if totErrName : txt += "  Event Name\t: %d\n" % totErrName
   if totErrShort: txt += "  Description\t: %d\n" % totErrShort
   if totErrLong : txt += "  Description\t: %d\n" % totErrLong
  FF4lCP(self, txt, title=title)
  VV6A99.cancel()
 @staticmethod
 def VVZXHh(eName, eShort, eLong):
  eName, eShort, eLong = eName.strip(), eShort.strip(), eLong.strip()
  tVal, dVal = CFG.epgLangTitle.getValue(), CFG.epgLangDescr.getValue()
  lang, lst, resLst, errLst = (tVal, dVal, dVal), (eName, eShort, eLong), ["", "", ""], [0, 0, 0]
  def VVJi7Q(ndx):
   if lst[ndx] and lang[ndx]:
    txt, err = CC5TsO.VV6IMT(lst[ndx], lang[ndx])
    resLst[ndx], errLst[ndx] = txt, 1 if err else 0
  thLst = []
  for ndx in range(3):
   th = iThread(name="ajp_%d" % ndx, target=BF(VVJi7Q, ndx))
   th.start()
   thLst.append(th)
  for th in thLst: th.join()
  trName, trShort, trLong = resLst[0] or eName, resLst[1] or eShort, resLst[2] or eLong
  errName, errShort, errLong = errLst
  return trName, trShort, trLong, errName, errShort, errLong
 @staticmethod
 def VV6IMT(txt, toLang):
  txt = txt.strip()
  if txt:
   qUrl = "%s%s&q=%s" % ("=lt&otua=ls&?m/moc.elgoog.etalsnart//:sptth"[::-1], toLang, FFSiPR(txt))
   txt, err = CCkEI5.VVzVZL(qUrl, timeout=1, allowDocType=True)
   if err:
    return "", err
   else:
    txt = FFXarh(txt)
    ndx  = txt.find('<div class="result-container">')
    if ndx > -1:
     txt = txt[ndx + 30:]
     ndx  = txt.find("</div>")
     if ndx > -1:
      return str(CC5TsO.VV5Bjk(txt[:ndx])).strip(), ""
   return "", "Could not translate"
  else:
   return "", "Nothing to translate"
 @staticmethod
 def VV0Zhh():
  path = szTxt = modTm = ""
  valid = sz = 0
  try: path = config.misc.epgcache_filename.getValue()
  except: pass
  if FFCyVu(path):
   valid = 1
   sz = FFXhoc(path)
   szTxt = CClYaF.VV99gM(sz) if sz > -1 else ""
   modTm = FFTS4w(os.path.getmtime(path))
  return valid, path, sz, szTxt, modTm
 @staticmethod
 def VVo0fG():
  try:
   from enigma import eEPGCache
   return eEPGCache, eEPGCache.getInstance()
  except:
   return None, None
 @staticmethod
 def VVYLja():
  CC5TsO.VVdThy(CC5TsO.VVEj5l)
 @staticmethod
 def VVdThy(act):
  ec, inst = CC5TsO.VVo0fG()
  if inst and hasattr(ec, act):
   try:
    exec("inst.%s()" % act)
    return True
   except:
    pass
  return False
 @staticmethod
 def VVVHZD(VVPxk5):
  ec, inst = CC5TsO.VVo0fG()
  if inst:
   try:
    evList = inst.lookupEvent([CC5TsO.VV9Ht1, (VVPxk5.rstrip(":"), 0, -1, 20160)])
    if evList: return VVPxk5, evList, ""
    else  : return VVPxk5, [], "No System EPG"
   except:
    return VVPxk5, [], "EPG Read-Error !"
  else:
   return VVPxk5, [], "Cannot read EPG Cache !"
 @staticmethod
 def VV8M7K(VVPxk5, events, longDescDays=0):
  ec, inst = CC5TsO.VVo0fG()
  totEv, totOK, fnc = 0, 0, None
  if inst:
   if   hasattr(ec, "importEvents"): fnc = inst.importEvents
   elif hasattr(ec, "importEvent") : fnc = inst.importEvent
  if fnc:
   for data in events:
    totEv += 1
    try:
     if longDescDays and data[0] > iTime() + 86400 * longDescDays:
      data = data[:4] + ("",) + data[5:]
     fnc(VVPxk5, (data,))
     totOK += 1
    except:
     pass
  return totEv, totOK
 @staticmethod
 def VVgoJl(SELF):
  serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   ec, inst = CC5TsO.VVo0fG()
   if ec:
    event = inst.lookupEventTime(serv, -1, 0)
    if event:
     return CC5TsO.VVjO5v(event)
   try:
    info = eServiceCenter.getInstance().info(serv)
    event = info and info.getEvent(serv)
    if event:
     return CC5TsO.VVjO5v(event)
   except:
    pass
   VV1wIO = serv.getName()
   if VV1wIO:
    return [VV1wIO] + [""] * 6
  return [CC3rDi(SELF.session).VV1wIO] + [""] * 6
 @staticmethod
 def VVMZqx(SELF):
  fPath, fDir, fName = CClYaF.VV4zSS(SELF)
  if fName:
   return os.path.splitext(fName)[0]
  evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVgoJl(SELF)
  s = CC3rDi(SELF.session)
  if s.isDvb:
   return evName if any((evTime, evDur, evShort, evDesc, genre, PR)) else ""
  elif " >> " in s.VV1wIO:
   ev = s.VV1wIO.partition(" >> ")[2].strip()
   if ev: return ev
  return evName
 @staticmethod
 def VVjO5v(event):
  evName = event.getEventName().strip()    or ""
  evTime = event.getBeginTime()      or ""
  evDur = event.getDuration()      or ""
  evShort = event.getShortDescription().strip()  or ""
  evDesc = event.getExtendedDescription().strip() or ""
  genre, PR = CC5TsO.VVadPU(event)
  return evName, evTime, evDur, evShort, evDesc, genre, PR
 @staticmethod
 def VVj18Y(VVPxk5):
  service = eServiceReference(VVPxk5)
  evLst = []
  if service:
   ec, inst = CC5TsO.VVo0fG()
   try:
    if inst:
     for evNum in range(2):
      event = inst.lookupEventTime(service, -1, evNum)
      evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVjO5v(event)
      evEnd = evPos = evRem = evCom = 0
      evTimeTxt = evPosTxt = evDurTxt = evEndTxt = evRemTxt = evComTxt = ""
      if evTime and evDur:
       evEnd = evTime + evDur
       evTimeTxt = FFTS4w(evTime)
       evEndTxt  = FFTS4w(evEnd)
       evDurTxt  = FFFHEC(evDur)
       now = int(iTime())
       if now > evTime and now < evEnd:
        evPos = now - evTime
        evPosTxt = FFFHEC(evPos)
        evRem = evEnd - now
        evRemTxt = FFFHEC(evRem)
       elif now < evTime:
        evCom = evTime - now
        evComTxt = FFFHEC(evCom)
      evLst.append((evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt))
   except:
    pass
  return evLst
 @staticmethod
 def VVadPU(event):
  genre = PR = ""
  try:
   genre  = CC5TsO.VVB7eC(event.getGenreData().getLevel1(), event.getGenreData().getLevel2())
   age = event.getParentalData().getRating()
   PR  = CC5TsO.VV0aka(age)
  except:
   pass
  return genre, PR
 @staticmethod
 def VV0aka(age):
  if   age == 0 : return "Undefinded (all ages)"
  elif age > 15 : return "Rated by broadcaster (%d)" % age
  else   : return "Minimum Age = %d years" % (age + 3)
 @staticmethod
 def VVB7eC(L1, L2):
  if   L1 <= 0  : return "Undefined Content"
  elif L1 >= 15  : return "User Defined Genre"
  elif L1 > 12  : return "Unlisted Genre"
  else:
   MG, SG = CC5TsO.VVpfDV()
   if MG and SG:
    key = "%d,%d" % (L1, L2)
    if key in SG   : return SG[key].title()
    elif L1 - 1 < len(MG) : return MG[L1 - 1] .title()
    else     : return "Unknown Genre"
   else:
    return ""
 @staticmethod
 def VVpfDV():
  path = VVIp2p + "_sup_genre"
  MG = SG = ""
  if FFCyVu(path):
   MG = iFindall(r"\d,0;(\w+\s?\w+)", FFYVq0(path), IGNORECASE)
   SG = iFindall(r"(\d+,\d+);(.+)", FFYVq0(path), IGNORECASE)
   if SG: SG = dict(SG)
  return MG, SG
 @staticmethod
 def VVDL6A(VV6A99, title):
  ec, inst = CC5TsO.VVo0fG()
  if not inst:
   return "", "Cannot access EPG Cache !"
  totFound = totEvents = totSuccess = totInvalid = totEvErr = 0
  for num, srcName, srcRef, srcTxt, dstName, dstRef, dstTxt, remark in VV6A99.VVrrm9():
   if remark == "0":
    try:
     evList = inst.lookupEvent([CC5TsO.VV9Ht1, (srcRef.rstrip(":"), 0, -1, 20160)])
    except:
     totEvErr += 1
     evList = []
    if evList:
     totFound += 1
     lst = []
     for item in evList:
      lst.append((item[0], item[1], item[2], item[3], item[4], 1))
     totEv, totOK = CC5TsO.VV8M7K(dstRef, lst)
     totEvents += totEv
     totSuccess += totOK
   else:
    totInvalid += 1
  if totSuccess > 0:
   CC5TsO.VVYLja()
   CCYrUm.VV0iSP(VV6A99.session)
  txt  = "Services\t: %d\n"  % VV6A99.VVn1uo()
  txt += "Invalid Ref.\t: %s\n" % totInvalid
  txt += "With Events\t: %d\n\n" % totFound
  txt += "Found Events\t: %d\n" % totEvents
  txt += "Copied Events\t: %d\n" % totSuccess
  if totEvErr:
   txt += "EPG Errors\t: %d" % totEvErr
  return txt, ""
 @staticmethod
 def VVwlye(VVPxk5):
  ec, inst = CC5TsO.VVo0fG()
  if inst and VVPxk5:
   try:
    return inst.lookupEvent([CC5TsO.VVhAdK, (VVPxk5.rstrip(":"), 0, -1, -1)])
   except:
    pass
  return []
 @staticmethod
 def VVotRV(info, VVPxk5):
  evLst = []
  if info:
   for evNum in range(2):
    try:
     ev = info.getEvent(evNum)
     evLst.append(CC5TsO.VVjO5v(ev))
    except:
     pass
  if not evLst and VVPxk5:
   serv = eServiceReference(VVPxk5)
   ec, inst = CC5TsO.VVo0fG()
   if serv and inst:
    for evNum in range(2):
     try:
      ev = inst.lookupEventTime(serv, -1, evNum)
      evLst.append(CC5TsO.VVjO5v(ev))
     except:
      pass
  if not evLst and VVPxk5:
   try:
    serv = eServiceReference(VVPxk5)
    info = serv and eServiceCenter.getInstance().info(serv)
    if info:
     ev = info.getEvent(serv)
     evLst.append(CC5TsO.VVjO5v(ev))
   except:
    pass
  return evLst
 @staticmethod
 def VV73bj(evList, totTr=0):
  tab = lambda x, y: "%s\t: %s\n" % (x, y) if y else ""
  tab2= lambda x, y: "%s\t:\n%s\n" % (x, y) if y else ""
  sep = FFjt5L("_" * 33 + "\n", VVo7S9)
  now = iTime()
  epg = ""
  for evNum, (start, dur, Title, descrS, descrL, pc, genre)in enumerate(evList, start=1):
   startTxt = endTxt = durTxt = ""
   isCurEv = False
   try:
    startTxt= FFTS4w(start).replace(" ", "   ")
    endTxt = FFTS4w(start + dur).replace(" ", "   ")
    durTxt = FFFHEC(dur)
    isCurEv = start < now and (start + dur) > now
   except:
    pass
   descrS = str(descrS).strip()
   if descrS == "Not Applicable":
    descrS = ""
   descrL = str(descrL).strip()
   more = ""
   if pc:
    for Sys, val in pc: more += "Parental Control (%s) : %s\n" % (Sys.strip(), val)
   if genre:
    for g in genre: more += "Genre : %s\n" % str(g)
   if more:
    descrL = more.rstrip() + ("\n" + descrL if descrL else "")
   Title2 = lang = ""
   if totTr > 0 and evNum <= totTr:
    trName, trShort, trLong, errName, errShort, errLong = CC5TsO.VVZXHh(Title, descrS, descrL)
    descrS, descrL = trShort, trLong
    if Title and trName and Title != trName:
     Title2 = FFjt5L(trName, VVFuwR)
     lang = " (%s)" % CFG.epgLangDescr.getValue().upper()
   if isCurEv : evFg, descrFg, txt = VVz22H , VVZtfx, "     (CURRENT EVENT)"
   else  : evFg, descrFg, txt = VVwdUw , VVA4XU  , ""
   epg += sep
   epg += tab("Event"   , FFjt5L(str(evNum) + txt, evFg))
   epg += tab("Start"   , startTxt)
   epg += tab("Title"   , FFjt5L(Title, VVFuwR) if Title else "")
   epg += tab("Title" + lang , FFjt5L(Title2, VVFuwR) if Title2 else "")
   epg += tab("Start"   , startTxt)
   epg += tab("End"   , endTxt)
   epg += tab("Duration"  , durTxt)
   epg += tab2("Summary"  , FFjt5L(descrS, VVA4XU) if descrS else "")
   epg += tab2("Description" , FFjt5L(descrL, descrFg) if descrL else "")
  return epg
 @staticmethod
 def VV5Bjk(txt):
  try:
   from HTMLParser import HTMLParser
   return HTMLParser().unescape(txt)
  except:
   pass
  try:
   import html.parser
   return html.parser.HTMLParser().unescape(txt)
  except:
   pass
  try:
   import html
   return html.unescape(txt)
  except:
   pass
  return txt
class CCYrUm(Screen, CCwnHL):
 VVO0DT  = 0
 VVL3Ny = 1
 VV56GN  = 2
 VVbJ5s  = 3
 VVp2Ed = 4
 VVXNWJ = 5
 VVmjC7 = 6
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 1000, 1040, 50, 40, 30, "#22000033", "#22000011", 30)
  self.session   = session
  self.filterObj    = None
  self.VVAG2D = None
  self.lastfilterUsed  = None
  self.servFilterInFilter = False
  VV3wat = self.VVLywV()
  FFZMxC(self, VV3wat=VV3wat, title="Services/Channels")
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self["myMenu"].setList(self.VVLywV())
  FF4IPF(self["myMenu"])
  FF2GM8(self)
 def VVLywV(self):
  VV3wat = []
  c = VVJEMb
  VV3wat.append((c + "Open Player Bar"         , "openPlayer"   ))
  VV3wat.append((c + "Open Signal Monitor"        , "openSignal"   ))
  VV3wat.append((c + "Current Service Information"      , "currentServiceInfo" ))
  VV3wat.append(VVAL3j)
  c = VVFuwR
  VV3wat.append((c + "Services (Lock, Hide, Delete, Add to Fav)"  , "VVQexT" ))
  VV3wat.append((c + "Services (Transponders)"       , "VVEaAz"))
  VV3wat.append((VVyFI2 + "More tables ..."     , "VVRb4u"  ))
  c = VVZtfx
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Import Bouquets from Backup Files"  , "VVtXW3", iTar, c ))
  VV3wat.append((c + 'Export Services to "channels.xml"'    , "VVTcc4"       ))
  VV3wat.append((c + "Copy EPG/PIcons between Channels (from xml file)" , "copyEpgPicons"       ))
  c = VVIH76
  VV3wat.append(VVAL3j)
  VV3wat.append((c + "Satellites Services Cleaner"      , "VVX96j"  ))
  VV3wat.append((c + "Invalid Services Cleaner"       , "VVq2o6" ))
  c = VVIH76
  VV3wat.append(VVAL3j)
  VV3wat.append((c + "Delete Channels with no names"     , "VVHSqx" ))
  VV3wat.append((c + "Delete Empty Bouquets"       , "VVkTJd"  ))
  VV3wat.append(VVAL3j)
  VVkMso, VVEuxL = CCYrUm.VVBN5t()
  if FFCyVu(VVkMso):
   enab = FFCyVu(VVEuxL)
   if enab: VV3wat.append(("Enable Hidden Services List"    , "enableHiddenChannels" ))
   else   : VV3wat.append(("Disable Hidden Services List"   , "disableHiddenChannels" ))
  VV3wat.append(("Reset Parental Control Settings"      , "VV7C5D" ))
  VV3wat.append(("Reload Channels and Bouquets"       , "VV8d5Y" ))
  return VV3wat
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "openPlayer"      : CCqWM2.VVHc02(self.session)
   elif item == "openSignal"      : FFdXBl(self.session, reopen=True)
   elif item == "currentServiceInfo"    : CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY)
   elif item == "VVQexT"   : self.VVQexT()
   elif item == "VVEaAz"  : self.VVEaAz()
   elif item == "VVRb4u"    : self.VVRb4u()
   elif item == "VVtXW3" : CC9xd9.VVtXW3(self)
   elif item == "VVTcc4"     : self.VVTcc4()
   elif item == "copyEpgPicons"     : self.VVNXsZ(False)
   elif item == "VVX96j"    : self.VVX96j()
   elif item == "VVq2o6"   : self.VVq2o6()
   elif item == "VVHSqx"   : self.VVHSqx()
   elif item == "VVkTJd"    : self.VVkTJd(self)
   elif item == "enableHiddenChannels"    : self.VVm5xh(True)
   elif item == "disableHiddenChannels"   : self.VVm5xh(False)
   elif item == "VV7C5D"   : FFRMYv(self, self.VV7C5D, "Reset and Restart ?")
   elif item == "VV8d5Y"     : CCYrUm.VV8d5Y(self)
 def VVRb4u(self):
  VV3wat = []
  VV3wat.append(("Services (IDs)"       , "VV3eXE"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Services (Parental-Control List)"   , "VVreo3" ))
  VV3wat.append(("Services (Hidden List)"     , "VVXQWm"  ))
  VV3wat.append(("Services with PIcons for the System"  , "VVt2Rn1"  ))
  VV3wat.append(("Services without PIcons for the System" , "VVt2Rn2"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Transponders (Statistics)"    , "TranspondersStats"  ))
  VV3wat.append(("Satellites.xml (Statistics)"    , "VV0k8o"  ))
  FFLFTC(self, None, VV3wat=VV3wat, title="Service Information", VVOa1G=self.VVxAwA)
 def VVxAwA(self, item):
  if item:
   VV7tND, txt, ref, ndx = item
   if   ref == "VV3eXE" : self.VV3eXE(VV7tND, txt)
   elif ref == "VVreo3" : self.VVreo3(VV7tND, txt)
   elif ref == "VVXQWm"  : self.VVXQWm(VV7tND, txt)
   elif ref == "VVt2Rn1"  : self.VVt2Rn(VV7tND, txt, True)
   elif ref == "VVt2Rn2"  : self.VVt2Rn(VV7tND, txt, False)
   elif ref == "TranspondersStats"   : self.VVCPXM(VV7tND, txt)
   elif ref == "VV0k8o"  : self.VV0k8o(VV7tND, txt)
 def VVTcc4(self):
  VV3wat = []
  VV3wat.append(("All DVB-S/C/T Services", "all"))
  VV3wat.extend(CCMvE7.VVlHzq())
  FFLFTC(self, self.VVm3LS, VV3wat=VV3wat, title="", VVU8mZ=True)
 @FFOAKH()
 def VVm3LS(self, item=None):
  if item:
   txt, ref, ndx = item
   if ref == "all" : lst = CCYrUm.VV3FRU("1:7:")
   else   : lst = FFZcDI(eServiceReference(ref))
   if lst:
    tot = len(lst)
    if tot > 0:
     rows = []
     for r, n in lst:
      sat = CCYrUm.VVMJTa(r)
      rows.append('<!-- %s --><channel id="%s">%s</channel><!-- %s -->\n' % (sat, n, r, n))
     if rows:
      rows.sort()
      fPath = "%schannels_%s.xml" % (FFeAlZ(), FFjTQe())
      with open(fPath, "w") as f:
       f.write('<?xml version="1.0" encoding="utf-8"?>\n')
       f.write('<channels>\n\n')
       for row in rows: f.write(row)
       f.write('\n</channels>\n')
      FFipXT(self, "Saved %d service%s to:\n\n%s" % (tot, FFcacr(tot), fPath))
      return
   FF28n1(self, "No Services found !", 1500)
 @staticmethod
 @FFOAKH()
 def VV8d5Y(SELF):
  FFfpyJ()
  FFipXT(SELF, "Finished\n\nReloaded Channels and Bouquets")
 @FFOAKH()
 def VVQexT(self):
  self.VVAG2D = None
  self.lastfilterUsed  = None
  self.filterObj   = CCoErY(self)
  VVAkuK, err = CCYrUm.VVJud0(self, self.VVO0DT)
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   VVu1YM  = ("Zap"   , self.VVUJjB     , [])
   VV2ytr = (""    , self.VVuuEx , [])
   VVScQz = ("Options"  , self.VV3Uay , [])
   VVwSzI = ("Current Service", self.VVRyTu , [])
   VV4QTJ = ("Filter"   , self.VVFuTd  , [], "Loading Filters ...")
   header   = ("Name" , "Provider", "Sat.", "Reference" , "PC"  , "Hidden" )
   widths   = (24  , 20  , 9  , 34   , 6   , 7   )
   VVLIqP  = (LEFT  , LEFT  , CENTER, LEFT    , CENTER , CENTER )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
 @FFOAKH()
 def VVEaAz(self):
  self.VVAG2D = None
  self.lastfilterUsed  = None
  self.filterObj   = CCoErY(self)
  VVAkuK, err = CCYrUm.VVJud0(self, self.VVL3Ny)
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   VVu1YM  = ("Zap"   , self.VVUJjB      , [])
   VV2ytr = (""    , self.VVuuEx  , [])
   VVwSzI = ("Current Service", self.VVRyTu  , [])
   VVScQz = ("Options"  , self.VVucSu , [])
   VV4QTJ = ("Filter"   , self.VVsXuX  , [], "Loading Filters ...")
   header   = ("Name" , "Provider", "Type", "Ref.", "Sat.", "Transponder" , "Freq." , "Pol.", "FEC" , "SR" )
   widths   = (25  , 24  , 14 , 0.01 , 9  , 0.02   , 8   , 5  , 7  , 8  )
   VVLIqP  = (LEFT  , LEFT  , CENTER, CENTER, CENTER, CENTER   , CENTER , CENTER, CENTER, CENTER)
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
 def VV3Uay(self, VV6A99, title, txt, colList):
  servName = colList[0].strip()
  VVPxk5  = colList[3].strip()
  pcState  = colList[4].strip()
  hidState = colList[5].strip()
  mSel = CCzSCo(self, VV6A99, setsOk=True, setsBlue=True)
  VV3wat = []
  isMulti = VV6A99.VVXWPu
  c1 = VVyFI2
  if isMulti:
   VV6a8O = VV6A99.VVf3uT(3)
   tot = len(VV6a8O)
   if VV6a8O:
    VV3wat.append(("Add Selection to Parental Control"  , "VVfINz1" ))
    VV3wat.append(("Remove Selection from Parental Control" , "VVfINz2" ))
    VV3wat.append(VVAL3j)
    VV3wat.append(("Add Selection to Hidden Services"   , "VVszQY1" ))
    VV3wat.append(("Remove Selection from Hidden Services" , "VVszQY2" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c1 + "Delete %s service%s" % (tot, FFcacr(tot)), "VVwGwW"))
    VV3wat.append(VVAL3j)
  else:
   pc = pcState == "No"
   hid = hidState == "No"
   VV3wat.append(FFsLU5("Add to Parental Control"  , "VVtkcA1" , pc  ))
   VV3wat.append(FFsLU5("Remove from Parental Control" , "VVtkcA2" , not pc ))
   VV3wat.append(VVAL3j)
   VV3wat.append(FFsLU5("Add to Hidden Services"  , "VVUEX71" , hid  ))
   VV3wat.append(FFsLU5("Remove from Hidden Services" , "VVUEX72" , not hid ))
   VV3wat.append(VVAL3j)
   VV3wat.append((c1 + "Delete Selected Service"    , "VVwGwW"     ))
   VV3wat.append(VVAL3j)
  cbFncDict = { "VVtkcA1" : BF(self.VVtkcA, VV6A99, VVPxk5, True)
     , "VVtkcA2" : BF(self.VVtkcA, VV6A99, VVPxk5, False)
     , "VVUEX71" : BF(self.VVUEX7, VV6A99, VVPxk5, True)
     , "VVUEX72" : BF(self.VVUEX7, VV6A99, VVPxk5, False)
     , "VVfINz1" : BF(self.VVfINz, VV6A99, True)
     , "VVfINz2" : BF(self.VVfINz, VV6A99, False)
     , "VVszQY1" : BF(self.VVszQY, VV6A99, True)
     , "VVszQY2" : BF(self.VVszQY, VV6A99, False)
     , "VVwGwW"  : BF(self.VVwGwW, VV6A99, isMulti, servName, VVPxk5)
     }
  VV3wat1, cbFncDict1 = CCYrUm.VVuGRo(self, VV6A99, servName, 3)
  VV3wat.extend(VV3wat1)
  for key, val in cbFncDict1.items(): cbFncDict[key] = val
  mSel.VV9VR2(VV3wat, cbFncDict)
 def VVucSu(self, VV6A99, title, txt, colList):
  servName = colList[0]
  mSel = CCzSCo(self, VV6A99, setsOk=True, setsBlue=True)
  VV3wat, cbFncDict = CCYrUm.VVuGRo(self, VV6A99, servName, 3)
  mSel.VV9VR2(VV3wat, cbFncDict)
 @staticmethod
 def VVuGRo(SELF, VV6A99, servName, VVeVVi):
  tot = VV6A99.VVc5NH()
  if tot > 0:
   sTxt = FFjt5L("%d Service%s" % (tot, FFcacr(tot)), VVFuwR)
   VV3wat = [("Add %s to Bouquet ..." % sTxt   , "addToBouquet_multi" )]
  else:
   servName = FFzBfi(servName)
   if len(servName) > 20: servName = servName[:20] + ".."
   servName = FFjt5L(servName, VVFuwR)
   VV3wat = [('Add "%s" to Bouquet ...' % servName , "addToBouquet_one" )]
  cbFncDict = { "addToBouquet_multi" : BF(CCYrUm.VVfYKK, SELF, VV6A99, VVeVVi, True)
     , "addToBouquet_one" : BF(CCYrUm.VVfYKK, SELF, VV6A99, VVeVVi, False)
     }
  return VV3wat, cbFncDict
 @staticmethod
 def VVfYKK(SELF, VV6A99, VVeVVi, isMulti):
  picker = CCMvE7(SELF, VV6A99, "Add to Bouquet", BF(CCYrUm.VVx16i, VV6A99, VVeVVi, isMulti))
 @staticmethod
 def VVx16i(VV6A99, VVeVVi, isMulti):
  if isMulti : VV6a8O = VV6A99.VVf3uT(VVeVVi)
  else  : VV6a8O = [VV6A99.VV5crm()[VVeVVi]]
  chUrlLst = []
  for ref in VV6a8O:
   chUrlLst.append(ref)
  return chUrlLst
 def VVtkcA(self, VV6A99, VVPxk5, isAddToBlackList):
  self.VVQsvO(VV6A99, [VVPxk5], isAddToBlackList)
 def VVfINz(self, VV6A99, isAddToBlackList):
  VV6a8O = VV6A99.VVf3uT(3)
  if not VV6a8O:
   FFdw58(self, "Nothing selected", title="Change Parental-Control State")
   return
  self.VVQsvO(VV6A99, VV6a8O, isAddToBlackList)
 @FFOAKH(par=1, clearMsg=False)
 def VVQsvO(self, VV6A99, VV6a8O, isAddToBlackList):
  for ndx, VVPxk5 in enumerate(VV6a8O):
   VVPxk5 = VVPxk5.strip()
   if not VVPxk5.endswith(":"):
    VVPxk5 += ":"
    VV6a8O[ndx] = VVPxk5
  changed = False
  if isAddToBlackList:
   if isAddToBlackList:
    with open(VV3W4d, "a") as f:
     for VVPxk5 in VV6a8O:
      f.write(VVPxk5 + "\n")
      changed = True
  elif FFCyVu(VV3W4d):
   lines = FFL19l(VV3W4d)
   if lines:
    for VVPxk5 in VV6a8O:
     while VVPxk5 in lines:
      ndx = lines.index(VVPxk5)
      lines[ndx] = ""
      changed = True
    if changed:
     with open(VV3W4d, "w") as f:
      for line in lines:
       if line:
        f.write(line + "\n")
  if changed:
   from Components.ParentalControl import parentalControl
   parentalControl.open()
   isMulti = VV6A99.VVXWPu
   if isMulti:
    self.VVfqnU(VV6A99, len(VV6a8O))
   else:
    if VVPxk5.endswith(":"):
     VVPxk5 = VVPxk5[:-1]
    self.VVSMmQ(VV6A99, VVPxk5)
    VV6A99.VVrmMb()
  else:
   VV6A99.VV6fGE("No changes")
 @FFOAKH(par=1)
 def VVUEX7(self, VV6A99, VVPxk5, isHide):
  title = "Change Hidden State"
  if FF4qbN(VVPxk5):
   ret = FFz2bQ(VVPxk5, isHide)
   if ret : self.VVSMmQ(VV6A99, VVPxk5)
   else : FFdw58(self, "Cannot Hide/Unhide this channel.", title=title)
  else:
   FFdw58(self, "Cannot Hide/Unhide this channel.\n\n(Invalid transponder)", title=title)
 def VVSMmQ(self, VV6A99, VVPxk5):
  VVAkuK, err = CCYrUm.VVJud0(self, self.VVO0DT, VV2W2o=[3, [VVPxk5], False])
  done = False
  if VVAkuK:
   data = VVAkuK[0]
   if data[3] == VVPxk5:
    done = VV6A99.VViSLW(data)
  if not done:
   self.VVJz5e(VV6A99, VV6A99.VVpVUj(), self.VVO0DT)
 def VVfqnU(self, VV6A99, totRefCodes):
  VVAkuK, err = CCYrUm.VVJud0(self, self.VVO0DT, VV2W2o=self.VVAG2D)
  VV6A99.VVMqQ9(VVAkuK, VVDpzd=BF(self.VV881E, totRefCodes))
 def VV881E(self, totRefCodes, VV6A99, title, txt, colList):
  VV6A99.VVW3QY()
  FFG2sB(VV6A99, "%d Processed" % totRefCodes, 1000)
 @FFOAKH(par=1, clearMsg=False)
 def VVszQY(self, VV6A99, isHide):
  VV6a8O = VV6A99.VVf3uT(3)
  if not VV6a8O:
   FFdw58(self, "Nothing selected", title="Change Hidden State")
   return
  totChanges = 0
  for VVPxk5 in VV6a8O:
   ret = FFz2bQ(VVPxk5, isHide, skipReload=True)
   if ret:
    totChanges += 1
  if totChanges > 0:
   FFfpyJ(True)
   self.VVfqnU(VV6A99, len(VV6a8O))
  else:
   VV6A99.VV6fGE("No changes")
 def VVwGwW(self, VV6A99, isMulti, servName, VVPxk5):
  c1 = VVYjI5
  if isMulti:
   refLst = VV6A99.VVf3uT(3)
   tot = len(refLst)
   ques = "Delete %s service%s ?" % (FFjt5L(str(tot), c1), FFcacr(tot))
  else:
   refLst, ques = [VVPxk5], c1 + servName
  FFRMYv(self, BF(self.VV5Tsj, VV6A99, refLst), ques, title="Delete Services")
 @FFOAKH("Deleting ...", par=1, clearMsg=False)
 def VV5Tsj(self, VV6A99, refLst):
  totDb, totBouqF, totBouqLn, err = CCYrUm.VVa7Nz(self, refLst)
  if err:
   FFdw58(self, err, title="Delete Services")
  elif any((totDb, totBouqF, totBouqLn)):
   if len(refLst) == VV6A99.VVn1uo():
    self.VVAG2D = self.lastfilterUsed = None
    self.VVfqnU(VV6A99, len(refLst))
    VV6A99.VV0ZtI("Filter = All")
   else:
    self.VVfqnU(VV6A99, len(refLst))
  else:
   FF28n1(VV6A99, "No change", 1000)
 def VVFuTd(self, VV6A99, title, txt, colList):
  inFilterFnc = BF(self.VVLAGo, VV6A99) if self.VVAG2D else None
  self.filterObj.VVmRCa(1, VV6A99, 2, BF(self.VVzHVk, VV6A99), inFilterFnc=inFilterFnc)
 def VVzHVk(self, VV6A99, item):
  self.VVpYI4(VV6A99, False, item, 2, self.VVO0DT)
 def VVLAGo(self, VV6A99, VV7tND, item):
  self.VVpYI4(VV6A99, True, item, 2, self.VVO0DT)
 def VVsXuX(self, VV6A99, title, txt, colList):
  inFilterFnc = BF(self.VV2QJU, VV6A99) if self.VVAG2D else None
  self.filterObj.VVmRCa(2, VV6A99, 4, BF(self.VVKAml, VV6A99), inFilterFnc=inFilterFnc)
 def VVKAml(self, VV6A99, item):
  self.VVpYI4(VV6A99, False, item, 4, self.VVL3Ny)
 def VV2QJU(self, VV6A99, VV7tND, item):
  self.VVpYI4(VV6A99, True, item, 4, self.VVL3Ny)
 def VVadaM(self, VV6A99, title, txt, colList):
  inFilterFnc = BF(self.VVAAgP, VV6A99) if self.VVAG2D else None
  self.filterObj.VVmRCa(0, VV6A99, 4, BF(self.VVolPW, VV6A99), inFilterFnc=inFilterFnc)
 def VVolPW(self, VV6A99, item):
  self.VVpYI4(VV6A99, False, item, 4, self.VV56GN)
 def VVAAgP(self, VV6A99, VV7tND, item):
  self.VVpYI4(VV6A99, True, item, 4, self.VV56GN)
 def VVpYI4(self, VV6A99, isInFilter, item, satCol, mode):
  self.servFilterInFilter = isInFilter
  if self.lastfilterUsed and self.lastfilterUsed == [item, satCol, mode]:
   return
  self.lastfilterUsed = [item, satCol, mode]
  if   item.startswith("__s__") : col, words, title = satCol, item[5:] , item[5:]
  elif item.startswith("__w__") : col, words, title = 0  , item[5:] , item[5:]
  elif item == "parentalControl" : col, words, title = 4  , "Yes"  , "Parental Control"
  elif item == "hiddenServices" : col, words, title = 5  , "Yes"  , "Hidden Services"
  elif item == "selectedTP"  :
   tp = VV6A99.VVeE40(5)
   col, words, title = 5  , tp , tp
  elif item == "emptyTP"   : col, words, title = 6  , "-"  , "Channels with no Transponder"
  elif item == "radio"   : col, words, title = 3  , ""  , "Radio Services"
  elif item == "streamRelay"  : col, words, title = 3  , ""  , "Stream Relay Services"
  else       : col, words, title = None , "All"  , "All"
  title = "Filter = %s" % title
  if len(title) > 55:
   title = title[:55] + ".."
  if col is None:
   self.VVAG2D = None
  elif item == "radio":
   words = ["1:0:2:", "1:0:7:", "1:0:A:"]
   self.VVAG2D = [col, words, True]
  elif item == "streamRelay":
   words = CCYrUm.VVtXqQ()
   if not words:
    FF28n1(VV6A99, "Not found", 1000)
    self.lastfilterUsed = None
    return
   self.VVAG2D = [col, words, False]
  else:
   words, asPrefix = CCoErY.VVPBNm(words)
   self.VVAG2D = [col, words, asPrefix]
  if words: FFimQ3(VV6A99, BF(self.VVJz5e, VV6A99, title, mode), clearMsg=False)
  else : FF28n1(VV6A99, "Incorrect filter", 2000)
 def VVJz5e(self, VV6A99, title, mode):
  VVAkuK, err = CCYrUm.VVJud0(self, mode, VV2W2o=self.VVAG2D, VVXwzE=False)
  if self.servFilterInFilter:
   lst = []
   for row in VV6A99.VVrrm9():
    try:
     ndx = VVAkuK.index(tuple(list(map(str.strip, row))))
     lst.append(VVAkuK[ndx])
    except:
     pass
   VVAkuK = lst
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   VV6A99.VVMqQ9(VVAkuK, title)
  else:
   FF28n1(VV6A99, "Not found!", 1500)
   self.lastfilterUsed = None
 def VVM14T(self, title, VVGape, VVu1YM=None, VV2ytr=None, VVwWmA=None, VVwSzI=None, VVScQz=None, VV4QTJ=None):
  VVwSzI = ("Current Service", self.VVRyTu, [], )
  header  = ("Name" , "Provider", "Sat.", "Reference" )
  widths  = (29  , 27  , 9  , 35   )
  VVLIqP = (LEFT  , LEFT  , CENTER, LEFT    )
  FFUQ0v(self, None, title=title, header=header, VVGape=VVGape, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
 def VVRyTu(self, VV6A99, title, txt, colList):
  self.VVBe8O(VV6A99)
 def VVZRWy(self, VV6A99, title, txt, colList):
  self.VVBe8O(VV6A99, True)
 def VVBe8O(self, VV6A99, isFromDetails=False):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  if VVPxk5:
   if isFromDetails:
    VVPxk5  = VVPxk5.upper()
    parts  = VVPxk5.split(":")
    Namespace = parts[6].zfill(8)
    SID   = parts[3].zfill(4)
    TSID  = parts[4].zfill(4)
    ONID  = parts[5].zfill(4)
    colDict  = { 0:VV1wIO, 5:Namespace, 6:SID, 7:TSID, 8:ONID }
    VV6A99.VVPkdw(colDict, VVwb7n=True)
   else:
    VV6A99.VVn5CC(3, VVPxk5, True)
   return
  FFdw58(self, "Cannot read current Reference Code !")
 @FFOAKH(par=1)
 def VV3eXE(self, obj, title):
  self.VVAG2D = None
  self.lastfilterUsed  = None
  self.filterObj   = CCoErY(self)
  VVAkuK, err = CCYrUm.VVJud0(self, self.VV56GN)
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   VV2ytr = (""    , self.VVELXv , []      )
   VVwSzI = ("Current Service", self.VVZRWy  , []      )
   VV4QTJ = ("Filter"   , self.VVadaM   , [], "Loading Filters ..." )
   VVu1YM  = ("Zap"   , self.VVkxsz      , []      )
   header   = ("Name" , "Provider", "Type-Val", "Type" , "Sat.", "Namespace" ,"SID" , "TSID", "ONID" )
   widths   = (24  , 22  , 0   , 16  , 9  , 11   , 6  , 6  , 6    )
   VVLIqP  = (LEFT  , LEFT  , CENTER , CENTER , CENTER, CENTER  , CENTER, CENTER, CENTER )
   FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindServices)
 def VVELXv(self, VV6A99, title, txt, colList):
  VVPxk5 = self.VVcfmi(colList)
  self.VVXmmB(VV6A99, title, txt + "Reference\t: %s" % VVPxk5, colList[0], VVPxk5)
 def VVuuEx(self, VV6A99, title, txt, colList):
  self.VVXmmB(VV6A99, title, txt, colList[0], colList[3])
 def VVXmmB(self, VV6A99, title, txt, VV1wIO, VVPxk5):
  rowNum = "Row: %s/%s" % (VV6A99.VVGTqU() + 1, VV6A99.VVn1uo())
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVL8mi, params=(VVPxk5, VV1wIO, rowNum, txt))
 def VVUJjB(self, VV6A99, title, txt, colList):
  CCqWM2.VVHc02(self.session, VVaHNe=colList[3], zapFnc=BF(self.VVJl3U, VV6A99, 0))
 def VVkxsz(self, VV6A99, title, txt, colList):
  CCqWM2.VVHc02(self.session, VVaHNe=self.VVcfmi(colList), zapFnc=BF(self.VVJl3U, VV6A99, 1))
 def VVJl3U(self, VV6A99, mode, val):
  if val == 1 : VV6A99.VVIRjv()
  else  : VV6A99.VVgexy()
  colList = VV6A99.VV5crm()
  if mode == 1: VVPxk5 = self.VVcfmi(colList)
  else  : VVPxk5 = colList[3]
  return VVPxk5
 def VVcfmi(self, colList):
  VV1wIO, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID = colList
  VVPxk5 = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0"))
  VVPxk5 = VVPxk5.replace("::", ":0:")
  return VVPxk5
 @staticmethod
 def VVaZcW(VVkMso, mode=0):
  lines = FFL19l(VVkMso, encLst=["UTF-8"])
  return CCYrUm.VVBshb(lines, mode)
 @staticmethod
 def VVBshb(lines, mode):
  lst = []
  header = "transponders" if mode < 10 else "services"
  if header in lines:
   lines = lines[lines.index(header) + 1:]
   if "end" in lines:
    lines = lines[:lines.index("end")]
    if len(lines) % 3 == 0:
     for i in range(0, len(lines), 3):
      if   mode in (0, 10): lst.append((lines[i], lines[i + 1], lines[i + 2]))
      elif mode in (1, 11): lst.append(lines[i].upper())
      elif mode in (2, 12): lst.append(lines[i + 1])
      elif mode in (3, 13): lst.append(lines[i + 2])
      elif mode == 14:
       span = iSearch(r"(\S+)\s+(PID)\s+(\d+)", lines[i + 1], IGNORECASE)
       if span:
        lst.append((lines[i], " ".join(span.groups()), lines[i + 2]))
  return lst
 @staticmethod
 def VVPXMf(VVkMso):
  lines = FFL19l(VVkMso, encLst=["UTF-8"])
  topPart = []
  for ln in lines:
   if ln.strip() == "transponders": break
   topPart.append(ln)
  endPart = []
  for ln in lines[::-1]:
   if ln.strip() == "end": break
   endPart.insert(0, ln)
  tpLst = CCYrUm.VVBshb(lines, mode=0)
  srvLst = CCYrUm.VVBshb(lines, mode=10)
  return topPart, tpLst, srvLst, endPart
 @staticmethod
 def VVoYZY(VVkMso, topPart, tpLst, srvLst, endPart):
  with open(VVkMso, "w") as f:
   for ln in topPart: f.write("%s\n" % ln)
   f.write("transponders\n")
   for item in tpLst: f.write("%s\n%s\n%s\n" % item)
   f.write("end\n")
   f.write("services\n")
   for item in srvLst: f.write("%s\n%s\n%s\n" % item)
   f.write("end\n")
   for ln in endPart: f.write("%s\n" % ln)
 @staticmethod
 def VVJud0(SELF, mode, VV2W2o=None, VVXwzE=True, VV49Lf=True):
  VVkMso, err = CCYrUm.VVQwcg(SELF, VV49Lf)
  if err:
   return None, err
  asPrefix = False
  if VV2W2o:
   filterCol = VV2W2o[0]
   filterWords = VV2W2o[1]
   asPrefix = VV2W2o[2]
   filterWords = list(filterWords)
   for ndx, item in enumerate(filterWords):
    filterWords[ndx] = item.strip().lower()
  else:
   filterWords = None
  if mode == CCYrUm.VVO0DT:
   blackList = None
   if FFCyVu(VV3W4d):
    blackList = FFL19l(VV3W4d)
    if blackList:
     blackList = set(blackList)
  elif mode == CCYrUm.VVL3Ny:
   tp = CC3Z54()
  VVY1oT, VVvwHc = FF07Sg()
  if mode in (CCYrUm.VVXNWJ, CCYrUm.VVmjC7):
   VVAkuK = {}
  else:
   VVAkuK = []
  tagFound = False
  with ioOpen(VVkMso, "r", encoding="utf-8") as f:
   lines = []
   for line in f:
    line = str(line).strip()
    if tagFound:
     if line == "end":
      break
     lines.append(line)
     if len(lines) >= 3:
      chCode = lines[0].upper()
      VV1wIO = lines[1]
      chProv = lines[2]
      if chCode.count(":") > 4 and not "," in chCode:
       parts  = chCode.split(":")
       SID   = parts[0]
       NameSpace = parts[1]
       TSID  = parts[2]
       ONID  = parts[3]
       STYPE  = parts[4]
      else:
       SID = NameSpace = TSID = ONID = STYPE = SNUM = VVPxk5 = ""
      chProvOrig = chProv
      if ","  in chProv : chProv = chProv.split(",")[0].strip()
      if "p:" in chProv : chProv = chProv.split("p:")[1].strip()
      if len(VV1wIO) == 0 : VV1wIO = "-"
      if len(chProv) == 0 : chProv = "-"
      s = NameSpace.zfill(8)[:4]
      val = int(s, 16)
      sat = FFS0T2(val)
      try:
       sTypeInt = int(STYPE)
       servTypeHex = (hex(sTypeInt))[2:].upper()
      except:
       sTypeInt = 0
       servTypeHex = "0"
      if mode == CCYrUm.VV56GN:
       if sTypeInt in VVY1oT:
        STYPE = VVvwHc[sTypeInt]
       tRow = (VV1wIO, chProv, servTypeHex, STYPE, sat, NameSpace, SID, TSID, ONID)
       if filterWords:
        tmp = tRow[filterCol].lower()
        if asPrefix:
         if any(tmp.startswith(x) for x in filterWords) : VVAkuK.append(tRow)
        elif any(x in tmp for x in filterWords)    : VVAkuK.append(tRow)
       else:
        VVAkuK.append(tRow)
      else:
       VVPxk5 = "1:0:%s:%s:%s:%s:%s:0:0:0" % (servTypeHex, SID.lstrip("0"), TSID.lstrip("0"), ONID.lstrip("0"), NameSpace.lstrip("0") )
       VVPxk5 = VVPxk5.replace("::", ":0:")
       if mode == CCYrUm.VVXNWJ:
        VVAkuK[VVPxk5.replace(":", "_")] = (VV1wIO, sat, 1)
       elif mode == CCYrUm.VVmjC7:
        VVAkuK[VV1wIO] = VVPxk5
       elif mode == CCYrUm.VVO0DT:
        if blackList and VVPxk5 + ":" in blackList : isBlackList = "Yes"
        else          : isBlackList = "No"
        flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
        if flag and int(flag.group(1), 16) & 2 == 2 : hidStr = "Yes"
        else          : hidStr =  "No"
        tRow = (VV1wIO, chProv, sat, VVPxk5, isBlackList, hidStr)
        if filterWords:
         tmp = tRow[filterCol].lower()
         if asPrefix:
          if any(tmp.startswith(x) for x in filterWords) : VVAkuK.append(tRow)
         elif any(x in tmp for x in filterWords)    : VVAkuK.append(tRow)
        else:
         VVAkuK.append(tRow)
       elif mode == CCYrUm.VVL3Ny:
        if sTypeInt in VVY1oT:
         STYPE = VVvwHc[sTypeInt]
        freq, pol, fec, sr, syst = tp.VVFGvS(VVPxk5)
        if not "-S" in syst:
         sat = syst
        if freq == "-" : tpStr = "-"
        else   : tpStr = sat + " " + freq + " " + pol + " " + fec + " " + sr
        tRow = (VV1wIO, chProv, STYPE, VVPxk5, sat, tpStr, freq, pol, fec, sr)
        if filterWords:
         tmp = tRow[filterCol].lower()
         if asPrefix:
          if any(tmp.startswith(x) for x in filterWords) : VVAkuK.append(tRow)
         elif any(x in tmp for x in filterWords)    : VVAkuK.append(tRow)
        else:
         VVAkuK.append(tRow)
       elif mode == CCYrUm.VVbJ5s:
        flag = iSearch(r"f:([A-Fa-f0-9]+)", chProvOrig)
        if flag and int(flag.group(1), 16) & 2 == 2:
         VVAkuK.append((VV1wIO, chProv, sat, VVPxk5))
       elif mode == CCYrUm.VVp2Ed:
        VVAkuK.append((VV1wIO, chProv, sat, VVPxk5))
      lines = []
    elif line == "services":
     tagFound = True
  if not VVAkuK and VVXwzE:
   FFdw58(SELF, "No services found!")
  return VVAkuK, ""
 @staticmethod
 def VVa7Nz(SELF, refLst):
  VVkMso, err = CCYrUm.VVQwcg(None, VV49Lf=False)
  if err: return 0, 0, 0, err
  topPart, tpLst, srvLst, endPart = CCYrUm.VVPXMf(VVkMso)
  if not all((tpLst, srvLst)): return 0, 0, 0, "Lamedb List error"
  refLst = [x.rstrip(":").upper() for x in refLst]
  oldLen = len(srvLst)
  srvLst = [(chCd, chNm, chPr) for chCd, chNm, chPr in srvLst if CCYrUm.VVR51d(chCd) not in refLst]
  totDb = oldLen - len(srvLst)
  if totDb: CCYrUm.VVoYZY(VVkMso, topPart, tpLst, srvLst, endPart)
  totBouqF, totBouqLn = CCYrUm.VVQrWd(refLst)
  if any((totDb, totBouqF, totBouqLn)): FFfpyJ()
  return totDb, totBouqF, totBouqLn, ""
 @staticmethod
 def VVQrWd(refLst):
  totF = totDel = 0
  for path in CCMvE7.VVHtVA():
   lines1, lines2 = FFL19l(path), []
   if not lines1: continue
   for line in lines1:
    span = iSearch(r"#SERVICE\s+((?:[A-Fa-f0-9]+:){10})$", line)
    if span and span.group(1).rstrip(":").upper() in refLst:
     totDel += 1
    else:
     lines2.append(line)
   if lines1 != lines2:
    totF += 1
    with open(path, "w") as f:
     f.write("\n".join(lines2) + "\n")
  return totF, totDel
 @FFOAKH(par=1)
 def VVreo3(self, obj, title):
  if FFCyVu(VV3W4d):
   lines = FFL19l(VV3W4d)
   if lines:
    newRows = []
    VVAkuK, err = CCYrUm.VVJud0(self, self.VVp2Ed)
    if VVAkuK:
     lines = set(lines)
     for item in VVAkuK:
      VVPxk5 = item[3] + ":"
      if VVPxk5 in lines:
       newRows.append((item[0], item[1], item[2], VVPxk5))
     if newRows:
      VVAkuK = newRows
      VVAkuK.sort(key=lambda x: x[0].lower())
      VV2ytr = ("", self.VVuuEx, [])
      VVu1YM  = ("Zap", self.VVUJjB    , [])
      self.VVM14T(title, VVAkuK, VVu1YM=VVu1YM, VV2ytr=VV2ytr)
     else:
      FF4lCP(self, "No matching Reference Code found !\n\nPC Lines\t: %d\nLameDB\t: %d" % (len(lines), len(VVAkuK)))
   else:
    FFipXT(self, "No active Parental Control services.", FFGNZA())
  else:
   FF8Wsn(self, VV3W4d)
 @FFOAKH(par=1)
 def VVXQWm(self, obj, title):
  VVAkuK, err = CCYrUm.VVJud0(self, self.VVbJ5s)
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   VV2ytr = ("" , self.VVuuEx , [])
   VVu1YM  = ("Zap", self.VVUJjB     , [])
   self.VVM14T(title, VVAkuK, VVu1YM=VVu1YM, VV2ytr=VV2ytr)
  elif err:
   pass
  else:
   FFipXT(self, "No hidden services.", FFGNZA())
 @FFOAKH()
 def VVq2o6(self):
  title = "Services unused in Tuner Configuration"
  VVkMso, err = CCYrUm.VVQwcg(self, title=title)
  if err:
   return
  nsLst = set()
  usedSats = CCYrUm.VVOjKz()
  for tuner in usedSats:
   for item in tuner[1]:
    ns = self.VVUScr(str(item[0]))
    nsLst.add(ns)
  sysLst = CCYrUm.VV3FRU("1:7:")
  tpLst  = CCYrUm.VVaZcW(VVkMso, mode=1)
  VVAkuK = []
  for VVPxk5, VV1wIO in sysLst:
   servID = CCYrUm.VVlPsR(VVPxk5)
   tpID = CCYrUm.VVIoyj(VVPxk5)
   refNs = VVPxk5.split(":")[6].zfill(8)[:4]
   if not tpID in tpLst or not refNs in nsLst:
    VVAkuK.append((VV1wIO, FFec0y(VVPxk5, False), VVPxk5, servID))
  if VVAkuK:
   VVAkuK.sort(key=lambda x: x[0].lower())
   VVScQz = ("Options"   , BF(self.VVmXsf, title), [])
   header   = ("Name" , "Media" , "Reference" , '"lamedb" Code' )
   widths   = (55  , 10  , 0    , 35    )
   VVLIqP  = (LEFT  , CENTER , LEFT   , CENTER   )
   FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVScQz=VVScQz, VVwltY="#0a001122", VVkxBG="#0a001122", VVemyB="#0a001122", VVJKqd="#00004455", VVbcr0="#0a333333", VVX9AA="#11331100", VVSLOq=CFG.lastFindServices)
  else:
   FFipXT(self, "No invalid service found !", title=title)
 def VVmXsf(self, Title, VV6A99, title, txt, colList):
  mSel = CCzSCo(self, VV6A99)
  isMulti = VV6A99.VVXWPu
  if isMulti : txt = "Remove %s Services" % FFjt5L(VV6A99.VVc5NH(), VVyFI2)
  else  : txt = "Remove : %s" % FFjt5L(VV6A99.VV5crm()[0], VVyFI2)
  VV3wat = [(txt, "del")]
  cbFncDict = {"del": BF(self.VV7uds, VV6A99, Title)}
  mSel.VV9VR2(VV3wat, cbFncDict)
 @FFOAKH(par=1)
 def VV7uds(self, VV6A99, title):
  VVkMso, err = CCYrUm.VVQwcg(self, title=title)
  if err:
   return
  isMulti = VV6A99.VVXWPu
  skipLst = []
  if isMulti : skipLst = VV6A99.VVf3uT(3)
  else  : skipLst = [VV6A99.VV5crm()[3]]
  tpLst = CCYrUm.VVaZcW(VVkMso, mode=0)
  servLst = CCYrUm.VVaZcW(VVkMso, mode=10)
  tmpDbFile = VVkMso + ".tmp"
  lines   = FFL19l(VVkMso)
  skip = False
  with open(tmpDbFile, "w") as f:
   for line in lines:
    tLine = line.strip()
    if tLine == "services":
     skip = True
     f.write(line + "\n")
     for item in servLst:
      if not item[0].upper() in skipLst:
       for L in item:
        f.write(L + "\n")
    elif skip and tLine == "end":
     skip = False
    if not skip:
     f.write(line + "\n")
  FFpwZS("mv -f '%s' '%s'" % (tmpDbFile, VVkMso))
  VVAkuK = []
  for row in VV6A99.VVrrm9():
   if not row[3] in skipLst:
    VVAkuK.append(row)
  FFfpyJ()
  FF4lCP(self, "Removed Services : %d" % len(skipLst), title="Remove Services")
  if VVAkuK:
   VV6A99.VVMqQ9(VVAkuK, title)
   VV6A99.VVW3QY()
  else:
   VV6A99.cancel()
 @FFOAKH(par=1)
 def VVCPXM(self, obj, title):
  VVkMso, err = CCYrUm.VVQwcg(self)
  if err:
   return
  totT, totC, totA, totS, totS2, satList = self.VVbKoL(VVkMso)
  txt = FFjt5L("Total Transponders:\n\n", VVGCYL)
  txt += "   DVB-S    Satellite\t: %d \n"  % totS
  txt += "   DVB-S2  Satellite\t: %d\n"  % totS2
  txt += "   DVB-T    Terrestrial\t: %d\n" % totT
  txt += "   DVB-C    Cable\t: %d\n"   % totC
  txt += "   DVB-A    ATSC\t: %d\n"   % totA
  if satList and len(satList) > 0:
   txt += FFjt5L("\nSatellite Transponders (Total=%d):\n\n" % (totS + totS2), VVGCYL)
   uniqSat = []
   for sat in satList:
    if not sat in uniqSat:
     uniqSat.append(sat)
   uniqSat.sort(key=lambda x: int(x))
   for item in uniqSat:
    txt += "   %s\t: %d\n" % (FF2qmC(item), satList.count(item))
  FF4lCP(self, txt, title)
 def VVbKoL(self, VVkMso):
  totT = totC = totA = totS = totS2 = 0
  satList = []
  tagFound = False
  with ioOpen(VVkMso, "r", encoding="utf-8") as f:
   lines = []
   for line in f:
    line = str(line).strip()
    if tagFound:
     if line == "end"    : break
     elif line.startswith("t")  : totT += 1
     elif line.startswith("c")  : totC += 1
     elif line.startswith("a")  : totA += 1
     elif line.startswith("s"):
      c = line.count(":")
      if   c > 9: totS2 += 1
      elif c > 5: totS  += 1
      if c > 5:
       satList.append(line.split(":")[4])
    elif line == "transponders":
     tagFound = True
  return totT, totC, totA, totS, totS2, satList
 @FFOAKH(par=1)
 def VV0k8o(self, obj, title):
  p1 = "/etc/enigma2/satellites.xml"
  p2 = "/etc/tuxbox/satellites.xml"
  if   FFCyVu(p1) : path = p1
  elif FFCyVu(p2) : path = p2
  else    : path = ""
  if not path:
   FF8Wsn(self, "%s\n.. or ..\n%s" % (p1, p2), title=title)
   return
  elif not CClYaF.VVSOog(self, path, title):
   return
  if not CCid3A.VVAilv(self):
   return
  tree = CCYrUm.VVkotG(self, path, title=title)
  if not tree:
   return
  VVAkuK = []
  root  = tree.getroot()
  totTpColor = "#f#00FFFF55#"
  for sat in root.findall("sat"):
   name = str(sat.get("name", "").encode("UTF-8").decode())
   pos  = sat.get("position", "")
   totTp = len(sat)
   hor = ver = cirL = cirR = unk = 0
   dvbS = dvbS2 = dvbUnk = 0
   for tp in sat.findall("transponder"):
    pol = tp.get("polarization")
    if   pol == "0" : hor += 1
    elif pol == "1" : ver += 1
    elif pol == "2" : cirL += 1
    elif pol == "3" : cirR += 1
    Sys = tp.get("system")
    if   Sys == "0" : dvbS += 1
    elif Sys == "1" : dvbS2 += 1
   try:
    posNum = int(pos)
    if posNum == 1801:
     posCalc = "180.1E"
    else:
     if posNum < 0:
      posNum += 3600
     posCalc = FFS0T2(posNum)
   except:
    posCalc = "?"
    pos  = "-9999"
   if " " in name : posXml, name = name.split(" ", 1)
   else   : posXml = posCalc
   bg = "" if posCalc.endswith("W") else "#b#00003333#"
   VVAkuK.append((bg + name, pos, posXml, posCalc, totTpColor + str(totTp), str(hor), str(ver), str(cirL), str(cirR), str(dvbS), str(dvbS2)))
  if VVAkuK:
   VVAkuK.sort(key=lambda x: int(x[1]))
   VVwSzI = ("Current Satellite", BF(self.VVqKgU, 3), [])
   header   = ("Satellite" , "Pos #" , "xml Pos" , "Position", "TP" , "Hor" , "Ver" , "Circ-L" , "Circ-R" , "DVB-S" , "DVB-S2" )
   widths   = (36    , 8   , 0   , 10  , 6  , 5  , 5  , 7   , 7   , 8   , 8   )
   VVLIqP  = (LEFT   , CENTER , CENTER , CENTER , CENTER, CENTER, CENTER, CENTER , CENTER , CENTER , CENTER )
   FFUQ0v(self, None, title=path, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=25, VViZ3s=1, VVwSzI=VVwSzI, VVSLOq=CFG.lastFindSatName)
  else:
   FFdw58(self, "No data found !", title=title)
 def VVqKgU(self, satCol, VV6A99, title, txt, colList):
  sat = FFec0y(CC3rDi(self.session).VVPxk5, False)
  for ndx, row in enumerate(VV6A99.VVrrm9()):
   if sat == row[satCol].strip():
    VV6A99.VVrqBw(ndx)
    break
  else:
   FF28n1(VV6A99, "Not in list", 1500)
 @FFOAKH()
 def VVX96j(self):
  satLst = nimmanager.getSatList()
  if not satLst:
   FFdw58(self, "No Satellites found !")
   return
  usedSats = CCYrUm.VVOjKz()
  VVAkuK = []
  for sat in satLst:
   tunerLst = []
   for tuner, sats in usedSats:
    if sat in sats:
     tunerLst.append(tuner)
   tunerLst.sort()
   tuners = " , ".join(tunerLst) if tunerLst else ""
   posVal = sat[0]
   if posVal > 1800: posTxt = str(posVal - 3600)
   else   : posTxt = str(posVal)
   VVAkuK.append((sat[1], posTxt, FFS0T2(sat[0]), tuners, str(posVal)))
  if VVAkuK:
   VVemyB = "#11222222"
   VVAkuK.sort(key=lambda x: int(x[1]))
   VVwSzI = ("Current Satellite" , BF(self.VVqKgU, 2) , [])
   VVScQz = ("Options"   , self.VVVp6V  , [])
   header   = ("Satellite" , "Pos #" , "Position", "Tuners" , "posVal" )
   widths   = ( 50    , 10  , 10  , 30  , 0   )
   VVLIqP  = ( LEFT  , CENTER , CENTER , CENTER , CENTER )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY=VVemyB, VVkxBG=VVemyB, VVemyB=VVemyB, VVJKqd="#0a884400", VVSLOq=CFG.lastFindSatName)
  else:
   FFdw58(self, "No data found !")
 def VVVp6V(self, VV6A99, title, txt, colList):
  mSel = CCzSCo(self, VV6A99)
  isMulti = VV6A99.VVXWPu
  if isMulti : txt = "Remove ALL Services on %s Satellites" % FFjt5L(VV6A99.VVc5NH(), VVyFI2)
  else  : txt = "Remove ALL Services on : %s" % FFjt5L(VV6A99.VV5crm()[0], VVyFI2)
  VV3wat = []
  VV3wat.append((txt, "deleteSat"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Delete Empty Bouquets", "VVkTJd"))
  cbFncDict = { "deleteSat"   : BF(self.VVGqva, VV6A99)
     , "VVkTJd" : BF(self.VVkTJd, VV6A99)
     }
  mSel.VV9VR2(VV3wat, cbFncDict)
 @FFOAKH(par=1)
 def VVGqva(self, VV6A99):
  posLst = []
  isMulti = VV6A99.VVXWPu
  posLst = []
  if isMulti : posLst = VV6A99.VVf3uT(4)
  else  : posLst = [VV6A99.VV5crm()[4]]
  nsLst = []
  for pos in posLst:
   nsLst.append(self.VVUScr(pos))
  db = eDVBDB.getInstance()
  if db:
   for pos in posLst:
    db.removeServices(-1, -1, -1, int(pos))
  totCh, totBoq = self.VV3Fpq(nsLst)
  FFfpyJ(True)
  FF4lCP(self, "Deleted Satellites:\n%d\n\nDeleted Services:\n%d\n\nCleaned Bouquets:\n%d" % (len(posLst), totCh, totBoq), title="Delete Satellites")
 def VVkTJd(self, winObj):
  title = "Delete Empty Bouquets"
  FFRMYv(self, BF(self.VVnttw, winObj, title), "Delete bouquets with no services ?", title=title)
 @FFOAKH(par=1)
 def VVnttw(self, winObj, title):
  bList = CCMvE7.VVykzu()
  bNames = []
  if bList:
   fList = []
   for bName, bRef in bList:
    bFile = CCMvE7.VV896q(bRef)
    bPath = VVQe79 + bFile
    FFwgGB(bPath)
    bNames.append(bName)
    fList.append(bFile)
   if fList:
    for fil in ("bouquets.tv", "bouquets.radio"):
     path = VVQe79 + fil
     if FFCyVu(path):
      lines = FFL19l(path)
      newLines = []
      for line in lines:
       for bFile in fList:
        if bFile in line:
         break
       else:
        newLines.append(line)
      if newLines:
       with open(path, "w") as f:
        f.write("\n".join(newLines) + "\n")
   FFfpyJ(True)
  if bNames: txt = "%s\n\n%s" % (FFjt5L("Deleted Bouquets:", VVFuwR), "\n".join(bNames))
  else  : txt = "No empty bouquets."
  FF4lCP(self, txt, title=title)
 def VVUScr(self, pos):
  pos = int(pos.strip())
  if pos < 0:
   pos += 3600
  return ("%04x" % pos).upper()
 def VV3Fpq(self, nsLst):
  totCh = totBoq = 0
  files = iGlob("%suserbouquet.*.tv" % VVQe79)
  for srcF in files:
   if FFCyVu(srcF):
    lines = FFL19l(srcF)
    newLines = []
    found = False
    for line in lines:
     span = iSearch(r"#SERVICE\s+((?:[A-Za-z0-9]+:){10})$", line, IGNORECASE)
     if span:
      ns = FFARk6(span.group(1))
      if ns in nsLst:
       found = True
       totCh += 1
       continue
     newLines.append(line)
    if found and newLines:
     totBoq += 1
     with open(srcF, "w") as f:
      f.write("\n".join(newLines) + "\n")
  return totCh, totBoq
 @FFOAKH(par=1)
 def VVt2Rn(self, VV7tND, title, isWithPIcons):
  piconsPath = CCafIt.VVjkKT()
  if VVmJwX(piconsPath):
   totalPicons = 0
   for fName, fType in CCafIt.VVq4T1(piconsPath):
    if fName:
     totalPicons +=1
   if totalPicons > 0:
    VVAkuK, err = CCYrUm.VVJud0(self, self.VVp2Ed)
    if VVAkuK:
     channels = []
     for (VV1wIO, chProv, sat, VVPxk5) in VVAkuK:
      fName = VVPxk5.replace(":", "_") + ".png"
      pFile = FFZK2V(piconsPath, fName)
      if isWithPIcons:
       if pFile:
        channels.append((VV1wIO, chProv, sat, VVPxk5))
      else:
       if not pFile:
        channels.append((VV1wIO, chProv, sat, VVPxk5))
     totalServices = len(VVAkuK)
     totalFound  = len(channels)
     if isWithPIcons:
      totalWithPIcons  = totalFound
      totalMissingPIcons = totalServices - totalWithPIcons
     else:
      totalMissingPIcons = totalFound
      totalWithPIcons  = totalServices - totalMissingPIcons
     def VVJi7Q(key, val):
      return "%s\t\t: %s\n" % (key, str(val))
     txt = ""
     txt += VVJi7Q("PIcons Path"  , piconsPath)
     txt += VVJi7Q("Total PIcons" , totalPicons)
     txt += "\n"
     txt += VVJi7Q("Total services" , totalServices)
     txt += VVJi7Q("With PIcons"  , totalWithPIcons)
     txt += VVJi7Q("Missing PIcons" , totalMissingPIcons)
     if totalFound == 0:
      FF4lCP(self, txt)
     else:
      VV2ytr     = (""      , self.VVuuEx , [])
      if isWithPIcons : VV4QTJ = ("Export Current PIcon", self.VVS9oC    , [])
      else   : VV4QTJ = None
      VVScQz     = ("Statistics", FF4lCP, [txt])
      VVu1YM      = ("Zap", self.VVUJjB, [])
      channels.sort(key=lambda x: x[0].lower())
      self.VVM14T(title, channels, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVScQz=VVScQz, VV4QTJ=VV4QTJ)
   else:
    FFdw58(self, "No picons found in path:\n\n%s" % piconsPath)
  else:
   FFdw58(self, "PIcons path not found.\n\n%s" % piconsPath)
 def VVS9oC(self, VV6A99, title, txt, colList):
  png, path = CCafIt.VV81vh(colList[3], colList[0])
  if path:
   CCafIt.VVqLQB(self, png, path)
 @staticmethod
 def VVBN5t():
  VVkMso  = "%slamedb" % VVQe79
  VVEuxL = "%slamedb.disabled" % VVQe79
  return VVkMso, VVEuxL
 @staticmethod
 def VVmPK0():
  VVOVzS  = "%slamedb5" % VVQe79
  VVb8I6 = "%slamedb5.disabled" % VVQe79
  return VVOVzS, VVb8I6
 def VVm5xh(self, isEnable):
  VVkMso, VVEuxL = CCYrUm.VVBN5t()
  if isEnable and not FFCyVu(VVEuxL):
   FFipXT(self, "Already enabled.")
  elif not isEnable and not FFCyVu(VVkMso):
   FFdw58(self, "LameDB File not found!")
  else:
   if isEnable : word = "Enable"
   else  : word = "Disable"
   FFRMYv(self, BF(self.VVQP3B, isEnable), "%s Hidden Channels ?" % word)
 def VVQP3B(self, isEnable):
  VVkMso , VVEuxL = CCYrUm.VVBN5t()
  VVOVzS, VVb8I6 = CCYrUm.VVmPK0()
  cmd = ""
  if isEnable:
   word = "Enabled"
   cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVEuxL, VVEuxL, VVkMso)
   cmd += "if [ -f '%s' ]; then mv -f '%s' '%s'; fi;"   % (VVb8I6, VVb8I6, VVOVzS)
  else:
   word = "Disabled"
   cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVkMso  , VVkMso , VVEuxL)
   cmd += "if [ -f '%s' ]; then cp -f '%s' '%s'; fi;"   % (VVOVzS , VVOVzS, VVb8I6)
   cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVEuxL, VVkMso )
   cmd += "if [ -f '%s' ]; then sed -i 's/,f:2//' '%s'; fi;" % (VVb8I6, VVOVzS)
  ok = FFpwZS(cmd)
  FFfpyJ()
  if ok: FFipXT(self, "Hidden List %s" % word)
  else : FFdw58(self, "Error while restoring:\n\n%s" % fileName)
 def VV7C5D(self):
  cmd = ""
  cmd += "echo -e 'Reading current settings ...';"
  cmd += "cat %s | grep -v 'config.ParentalControl' > /tmp/settings_my_tmp.txt;" % VVfBVj
  cmd += "echo -e 'Applying new settings ...';"
  cmd += "mv /tmp/settings_my_tmp.txt %s" % VVfBVj
  FF28Zd(self, cmd)
 @FFOAKH()
 def VVHSqx(self):
  VVkMso, err = CCYrUm.VVQwcg(self)
  if err:
   return
  tmpFile = "/tmp/ajp_lamedb"
  FFwgGB(tmpFile)
  totChan = totRemoved = 0
  lines = FFL19l(VVkMso, keepends=True)
  with open(tmpFile, "w") as f:
   servFound = False
   servLines = []
   for line in lines:
    if servFound:
     if line.strip() == "end":
      f.write(line)
      break
     else:
      servLines.append(line)
      if len(servLines) == 3:
       if len(servLines[1].strip()) > 0:
        totChan += 1
        f.write(servLines[0])
        f.write(servLines[1])
        f.write(servLines[2])
       else:
        totRemoved += 1
       servLines = []
    else:
     f.write(line)
     if line.strip() == "services":
      servFound = True
  if totRemoved:
   FFRMYv(self, BF(self.VVinPT, tmpFile, VVkMso, totRemoved, totChan)
      , "Delete %d servce%s (out of %d service%s) ?" % (totRemoved, FFcacr(totRemoved), totChan, FFcacr(totChan))
      , callBack_No=BF(self.VVtLkt, tmpFile))
  else:
   FF4lCP(self, "Total Channels\t: %d\nWith no names\t: %d" % (totChan, totRemoved))
 @FFOAKH()
 def VVinPT(self, tmpFile, VVkMso, totRemoved, totChan):
  FFpwZS("mv -f '%s' '%s'" % (tmpFile, VVkMso))
  FFfpyJ()
  FF4lCP(self, "Total Channels\t: %d\nTotal Removed\t: %d" % (totChan, totRemoved))
 def VVtLkt(self, tmpFile):
  FFwgGB(tmpFile)
 @staticmethod
 def VVQwcg(SELF, VV49Lf=True, title=""):
  VVkMso, VVEuxL = CCYrUm.VVBN5t()
  if   not FFCyVu(VVkMso)       : err = "File not found !\n\n%s" % VVkMso
  elif not CClYaF.VVSOog(SELF, VVkMso) : err = "'lamedb' file is not in 'UTF-8' Encoding !"
  else             : err = ""
  if err and VV49Lf:
   FFdw58(SELF, err, title=title)
  return VVkMso, err
 @staticmethod
 def VVIoyj(VVPxk5):
  _, flg, _, _, tsid, nid, ns, _, _, _ = VVPxk5.rstrip(":").split(":")
  if flg == "0": return (":".join([ns.zfill(8), tsid.zfill(4), nid.zfill(4)])).upper()
  else   : return ""
 @staticmethod
 def VVlPsR(VVPxk5):
  _, flg, st, sid, tsid, nid, ns, _, _, _ = VVPxk5.rstrip(":").split(":")
  if flg == "0": return (":".join([sid.zfill(4), ns.zfill(8), tsid.zfill(4), nid.zfill(4), str(int(st, 16)), "0", "0"])).upper()
  else   : return ""
 @staticmethod
 def VVR51d(chCode):
  if chCode.count(":") > 4 and not "," in chCode:
   parts = chCode.split(":")
   SID  = parts[0].lstrip("0")
   NS  = parts[1].lstrip("0")
   TSID = parts[2].lstrip("0")
   ONID = parts[3].lstrip("0")
   STYPE = parts[4]
   try: sTyp = (hex(int(STYPE)))[2:].upper()
   except: sTyp = "0"
   return ("1:0:%s:%s:%s:%s:%s:0:0:0" % (sTyp, SID, TSID, ONID, NS)).replace("::", ":0:").upper()
  else:
   return ""
 @staticmethod
 def VVwhja(lameDbServId):
  return ":".join(lameDbServId.rstrip(":").split(":")[1:4]).upper()
 @staticmethod
 def VV3FRU(servTypes):
  VVX5XV  = eServiceCenter.getInstance()
  VVqzwR   = '%s ORDER BY name' % servTypes
  VV70EN   = eServiceReference(VVqzwR)
  VVM5OH = VVX5XV.list(VV70EN)
  if VVM5OH: return VVM5OH.getContent("CN", False)
  else     : return []
 @staticmethod
 def VVOjKz():
  slotSats = []
  for slot in nimmanager.nim_slots:
   if slot.frontend_id is not None:
    lst = nimmanager.getSatListForNim(slot.frontend_id)
    if lst:
     slotSats.append((slot.getSlotName(), lst))
  return slotSats
 @staticmethod
 def VV0iSP(session):
  serv = session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   shown = InfoBar.instance.shown
   session.nav.stopService()
   session.nav.playService(serv)
   if not shown: InfoBar.instance.hide()
 @staticmethod
 def VVWp6i():
  inst = InfoBar.instance
  return inst and hasattr(inst, "checkStreamrelay") or hasattr(inst, "ToggleStreamrelay")
 @staticmethod
 def VVbfMb():
  try:
   host = config.misc.softcam_streamrelay_url.value
   port = config.misc.softcam_streamrelay_port.value
   return host, port
  except:
   return "", ""
 @staticmethod
 def VVtXqQ():
  lst = []
  for line in FFL19l(VVl57H):
   line = line.strip()
   if iMatch(r"^((?:[A-Fa-f0-9]+:){10})$", line):
    lst.append(line.rstrip(":").upper())
  return lst
 @staticmethod
 def VVMJTa(r, unknown="?"):
  serv = eServiceReference(r)
  if serv:
   path = serv.getPath()
   if not path     : return FFec0y(r, False)
   elif path.startswith("/") : return "Local"
   elif FFHgaY(r)  : return "Stream Relay"
   elif FFUPnc(r)    : return "IPTV"
  return unknown
 @staticmethod
 def VVGvmp():
  try: InfoBar.instance.openServiceList()
  except: pass
 @staticmethod
 def VVotT7():
  inst = InfoBar.instance
  csel = inst and inst.servicelist
  if csel : return csel.lastroot.getValue(), csel.lastservice.getValue()
  else : return "", ""
 @staticmethod
 def VVmEYR():
  try: return [serv[-1] for serv in InfoBar.instance.servicelist.history]
  except: return []
 @staticmethod
 def VVO7YY(session, skipServ=None, mode=0):
  skipServ = skipServ or eServiceReference("")
  hLst = list(reversed(CCYrUm.VVmEYR()))
  if mode in (0, 1):
   for srv in hLst:
    if not srv.getPath().startswith(("/", "http")) and srv != skipServ:
     FFqb3C(session, srv)
     return srv
  if mode in (0, 2):
   for srv in hLst:
    if not srv.getPath().startswith("/") and srv != skipServ:
     FFqb3C(session, srv)
     return srv
  return None
class CCLAzj():
 def __init__(self, gapX=0, gapY=0):
  self.VVagVA  = []
  self["myPicF"]   = Label()
  self["myPicB"]   = Label()
  self["myPic"]   = Pixmap()
  self.VVTOb9()
  x, y, w, h = self.VVfOli["retPar"]
  x -= gapX
  y += gapY
  self.VVagVA = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
 def VVKe51(self, gapX, gapY):
  x, y, w, h = self.VVagVA[2]
  x -= gapX
  y += gapY
  self.VVagVA = ((x-1, y-1, w+2, h+2), (x, y, w, h), (x, y, w, h))
 def VVacFr(self, path):
  self.VVTOb9()
  if not (os.path.isfile(path) and CCHmnm.VVMyky(path) == "pic"):
   return False
  sz = FFXhoc(path)
  if sz == 0:
   self.VVJSEE()
   return  False
  x, y, w, h = self.VVagVA[2]
  right = x + w
  newW, newH, err = CC6u6z.VVZLHD(path)
  if not err:
   x1, y1, w, h = CCsyCY.VVF7W0(newW, newH, w, h)
   if newH > newW:
    w, h = int(w * 1.6), int(h * 1.6)
   x = right - w
  self.VVivVL(x, y, w, h)
  if FF0TBx(self["myPic"], path, fncCb_fail=self.VVJSEE):
   self.VVCcPN()
   return True
  else:
   self.VVJSEE()
   return False
 def VVJSEE(self):
  self.VVTOb9()
  if FFkDgm(self["myPic"], "noPic"):
   x, y, w, h = self.VVagVA[2]
   right = x + w
   w = h
   x = right - w
   self.VVivVL(x, y, w, h)
   self.VVCcPN()
 def VVivVL(self, x, y, w, h):
  for i, obj in enumerate(self.VVnXGn()):
   if i == 0: x1, y1, w1, h1 = x-1, y-1, w+2, h+2
   else  : x1, y1, w1, h1 = x, y, w, h
   if all((x, y, w, h)):
    obj.instance.move(ePoint(int(x1), int(y1)))
    obj.instance.resize(eSize(*(int(w1), int(h1))))
 def VVnXGn(self):
  return [self[x] for x in ("myPicF", "myPicB", "myPic")]
 def VVCcPN(self):
  try:
   for w in self.VVnXGn(): w.show()
  except:
   pass
 def VVTOb9(self):
  for w in self.VVnXGn(): w.hide()
 def VVcOjd(self):
  return self["myPicF"].getVisible()
 def VV7L9R(self):
  return self["myPicF"].instance.size().height() if self.VVcOjd() else 0
class CCvjVs(Screen, CCLAzj):
 VVvrVY  = 0
 VVL8mi    = 1
 VVFOKm    = 2
 VVvVii   = 3
 VVZImX   = 4
 VVga62   = 5
 VVXwW0    = 6
 VVhaN2    = 7
 VV1YsH   = 8
 VVUWdA   = 9
 VVFka3   = 10
 VVC2DO   = 11
 VVnSfp   = 12
 VVbSwV   = 13
 def __init__(self, session, VV7VUc, title="", params=None, VVAfO9=""):
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1400, 1000, 50, 30, 10, "#05001921", "#05001921", 30, VVdrEC=(0, 0))
  self.session  = session
  self.VV7VUc  = VV7VUc
  self.Title   = title or "Service Info."
  self.params   = params
  self.VVw8tn  = None
  self.VVPxk5  = ""
  self.VVAQqG  = ""
  self.VVZcRP  = ""
  self.VVfaDB  = ""
  self.VV1wIO   = ""
  self.VVfjDB = ""
  self.VVfbmn   = ""
  self.VVAfO9  = VVAfO9
  self.VVrhEU  = ""
  self.chUrl   = ""
  self.VV761e = ""
  self.VVr5Xg  = False
  self.VV8543  = ""
  self.VVBufu  = ""
  self.VVa81G  = ""
  self.VVSqOO  = ""
  self.VVrijt  = False
  self.VVd143 = False
  self.Sep   = FFjt5L("%s\n", VVo7S9) % SEP
  self.VVZLHV = eTimer()
  FFZMxC(self, title=self.Title + FFjt5L("    Processing ...", VVo7S9), addScrollLabel=True)
  CCLAzj.__init__(self)
  FFBep1(self,
  {
   "info" : self.VVRbRj ,
   "ok" : self.cancel   ,
   "cancel": self.cancel
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH(VVRhqH="chann_info")
  if   self.VV7VUc == self.VVvrVY : fnc = self.VVuqAd
  elif self.VV7VUc == self.VVL8mi  : fnc = self.VVvXSe
  elif self.VV7VUc == self.VVFOKm  : fnc = self.VVssBC
  elif self.VV7VUc == self.VVvVii  : fnc = self.VVH3xI
  elif self.VV7VUc == self.VVZImX : fnc = self.VVWjq3
  elif self.VV7VUc == self.VVga62  : fnc = self.VVirIt
  elif self.VV7VUc == self.VVXwW0  : fnc = self.VVQKq6
  elif self.VV7VUc == self.VVhaN2  : fnc = self.VVMLUi
  elif self.VV7VUc == self.VV1YsH  : fnc = self.VVjD5m
  elif self.VV7VUc == self.VVUWdA : fnc = self.VVCqbA
  elif self.VV7VUc == self.VVFka3  : fnc = self.VVbU6R
  elif self.VV7VUc == self.VVC2DO : fnc = self.VV3yK2
  elif self.VV7VUc == self.VVnSfp : fnc = self.VVIhUg
  elif self.VV7VUc == self.VVbSwV  : fnc = self.VVF6bP
  try: self.VVZLHV_conn = self.VVZLHV.timeout.connect(self.VVIfcm)
  except: self.VVZLHV.callback.append(self.VVIfcm)
  self.VVZLHV.start(50, False)
  self["myLabel"].setText("\n   Reading Info ...")
  self["myLabel"].VVfu0l()
  FFIElK(fnc)
 def onExit(self):
  self.VVZLHV.stop()
 def cancel(self):
  if self.VVd143:
   self.close()
 def VVuqAd(self):
  try: dum = self.session
  except: return
  s = CC3rDi(self.session)
  if not s.info:
   self.VVJrgW()
   self.VVrijt = self.VVd143 = True
   return
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  self.VVfjDB = fPath
  self.VVw8tn  = s.info
  self.VVPxk5  = s.VVPxk5
  self.VVAQqG  = s.VVAQqG
  self.VVfaDB  = s.VVfaDB
  self.VV1wIO   = s.VV1wIO
  self.VV8543  = self.VVJ25H(s)
  self.VVgvg3(s.VVZcRP)
 def VVvXSe(self):
  self.VVPxk5, self.VV1wIO, rowNum, VVrhEU = self.params
  self.Title += " " * 20 + rowNum
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  if VVPxk5 == self.VVPxk5:
   self.VVuqAd()
  else:
   self.VVrhEU = VVrhEU
   self.VVgvg3(self.VVPxk5)
 def VVssBC(self):
  self.VVPxk5, self.VV1wIO, self.VVrhEU = self.params
  self.VVgvg3(self.VVPxk5)
 def VVH3xI(self):
  self.VVPxk5, self.VV1wIO, self.VVrhEU = self.params
  self.VVgvg3(self.VVPxk5)
 def VVWjq3(self):
  self.VVPxk5, self.VV1wIO, self.VVrhEU = self.params
  self.VVgvg3()
 def VVirIt(self):
  self.VVPxk5, self.VV1wIO, self.VVrhEU, self.VVAfO9 = self.params
  self.VVgvg3()
 def VVQKq6(self):
  self.VVPxk5, self.VV1wIO, self.VVrhEU, self.VVZcRP, self.VVfaDB = self.params
  self.VVgvg3(self.VVfaDB)
 def VVMLUi(self):
  self.VVZcRP, self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
  self.VVgvg3()
 def VVjD5m(self):
  self.VVPxk5, self.VV1wIO, self.VVrhEU, self.chUrl, self.VVfbmn = self.params
  self.VVgvg3(self.chUrl)
 def VVCqbA(self):
  self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
  self.VVgvg3()
 def VVbU6R(self):
  self.VVPxk5, self.chUrl, self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
  self.VVgvg3(self.chUrl)
 def VV3yK2(self):
  self.VV1wIO, self.VVrhEU, self.VVfbmn = self.params
  self.VVgvg3()
 def VVIhUg(self):
  self.VVrhEU, self.VVAfO9 = self.params
  self.VVgvg3()
 def VVF6bP(self):
  self.VVrhEU, self.VVfbmn = self.params
  self.VVfbmn = FFXarh(self.VVfbmn)
  self.VVgvg3()
 def VVIfcm(self):
  if self.VVrijt:
   self["myTitle"].setText("  %s" % self.Title)
   self.VVZLHV.stop()
  if self.VVBufu:
   txt, self.VVBufu = self.VVBufu, ""
   txt = self["myLabel"].getText().strip() + "\n\n" + txt.strip()
   self["myLabel"].setText("\n" + txt, VV47Xm=VV5jA8)
   self.VVkd84()
  if self.VVa81G:
   evLst, self.VVa81G = self.VVa81G, ""
   self.VVe0Wr(evLst)
  if self.VVSqOO:
   path, self.VVSqOO = self.VVSqOO, ""
   self.VVr5Xg = self.VVUUd8(path)
   self.VVTsK1(path)
 def VVJrgW(self):
  txt = self.VVrhEU.strip()
  cTxt = self.VV8543.strip()
  if txt and cTxt : txt += "\n\n%s\n%s" % (self.Sep, cTxt)
  else   : txt += cTxt
  self["myLabel"].setText(txt or "No active service", VV47Xm=VV5jA8)
  self.VVkd84()
 def VVkd84(self):
  self["myLabel"].VVfu0l(minHeight=self.VV7L9R())
 def VVUUd8(self, path):
  isOk = self.VVacFr(path)
  if isOk:
   self.VVkd84()
  return isOk
 def VVgvg3(self, ref=""):
  if ref:
   span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})*(.+\/\/.+)", ref)
   if span:
    self.VV761e = FFXarh(span.group(1))
    self.VVZcRP = FFXarh(span.group(2))
  if not self.VV761e:
   self.VV761e = CCvjVs.VVHamE(self.VVPxk5) or CCvjVs.VVHamE(self.VVfaDB)
  if self.VVZcRP and not "URL:" in self.VV8543 and not "URL:" in self.VVrhEU:
   self.VVrhEU = self.VVrhEU.rstrip() + "\n\nURL:\n%s\n" % FFjt5L(CCvjVs.VV1sZM(self.VVZcRP), VVA4XU)
  self.VVJrgW()
  FFIElK(self.VVxBDI)
 def VVxBDI(self):
  if not self.VVr5Xg and self.VVAfO9:
   self.VVr5Xg = self.VVUUd8(self.VVAfO9)
  if not self.VVr5Xg and self.VVPxk5:
   png, path = CCafIt.VV81vh(self.VVPxk5, self.VV1wIO)
   if png: self.VVr5Xg = self.VVUUd8(path)
  if not self.VVr5Xg and self.VVAQqG:
   png, path = CCafIt.VV81vh(self.VVAQqG, self.VV1wIO)
   if png: self.VVr5Xg = self.VVUUd8(path)
  FFIElK(self.VVUf6L)
 def VVUf6L(self):
  VVjZ0e = CC5TsO.VVwlye(self.VVPxk5)
  if VVjZ0e: VVo7cK = []
  else  : VVo7cK = CC5TsO.VVotRV(self.VVw8tn, self.VVPxk5)
  iThread(name="ajp_info_pic", target=BF(self.VVE9TW, VVjZ0e, VVo7cK)).start()
  self.VVd143 = True
 def VVE9TW(self, VVjZ0e, VVo7cK):
  try:
   title = FFGEAF("EPG:", VVFuwR)
   epg = ""
   evLst = []
   netOk = CCuqoc.VVSuvZ
   if netOk:
    self.VVvuTk(self.VVfbmn)
    if self.VVZcRP:
     epg, evLst, VVfbmn, err = CCvjVs.VVPhf6(self.VVZcRP)
     self.VVvuTk(VVfbmn)
    if not epg and self.VVZcRP:
     epg, evLst, err = CCkEI5.VV67It(self.VVZcRP)
    if epg : self.VVBufu = title + epg
    if evLst: self.VVa81G = evLst
   if not epg and (VVjZ0e or VVo7cK):
    if   not netOk  : totTr = 0
    elif VVjZ0e  : totTr = 2
    elif VVo7cK : totTr = 2
    self.VVBufu = title + CC5TsO.VV73bj(VVjZ0e or VVo7cK, totTr)
   self.VVMX5q()
  except:
   pass
  self.VVrijt = True
 def VVMX5q(self):
  txt = ""
  if self.VVfjDB:
   txt = CC6u6z.VVZKCF(self.VVfjDB)
  elif self.VVZcRP and self.VV1wIO:
   path, headers = CC6u6z.VVmdd5(self.VVZcRP, self.VV1wIO)
   if path:
    txt = CC6u6z.VVZKCF(path, headers)
  if txt:
   self.VVBufu = txt
 @staticmethod
 def VVPhf6(VVZcRP):
  if "chCode" in VVZcRP:
   p = CC96QG()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
   uHost = uUser = uPass = uId = ""
   p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=host, mac=mac, ph1=ph1)
   if all((pHost, pUser, pPass, stID)) : uType, uHost, uUser, uPass, uId = mode, pHost, pUser, pPass, stID
   else        : return "", "", "", "No EPG (invalid URL) !"
  else:
   uType, uHost, uUser, uPass, uId, uChName = CCkEI5.VVNeuG(VVZcRP)
   if not all([uHost, uUser, uPass, uId]):
    return "", "", "", "No EPG (invalid URL) !"
   span = iSearch(r"S\d{2,3}E\d{2,3} \((.+)\)", uChName)
   catID = span.group(1) if span else ""
  qUrl = "%s/player_api.php?username=%s&password=%s&action=" % (uHost, uUser, uPass)
  if   uType in ("live", "itv") : qUrl += "get_simple_data_table&stream_id=%s" % (uId)
  elif uType in ("movie", "vod") : qUrl += "get_vod_info&vod_id=%s" % (uId)
  elif uType == "series" and catID: qUrl += "get_series_info&series_id=%s" % (catID)
  else       : return "", "", "", "Cannot process this channels"
  txt, err = CCkEI5.VVzVZL(qUrl, timeout=3)
  if err: return "", "", "", "No EPG from server (%s)" % err
  epg = VVfbmn = ""
  evLst = []
  if   uType in ("live", "itv") : epg, evLst, err = CCkEI5.VV1q43(txt, mode=3)
  elif uType in ("movie", "vod") : epg, VVfbmn, err = CCkEI5.VVfN18(txt)
  elif uType == "series"   : epg, VVfbmn, err = CCkEI5.VVYkyo(txt, VVZcRP)
  err = "" if epg else "No EPG from server !"
  return epg, evLst, VVfbmn, err
 def VVvuTk(self, url):
  if url and not self.VVr5Xg:
   path, err = FFx9uM(url, "ajp_tmp.png", timeout=2, VVzHui=True)
   if path:
    self.VVSqOO = path
 def VVe0Wr(self, evLst):
  if self.VV761e and evLst:
   totEv, totOK = CC5TsO.VV8M7K(self.VV761e, evLst, longDescDays=7)
   if totOK > 0:
    CC5TsO.VVYLja()
 def VVTsK1(self, path):
  if self.VVr5Xg and self.VV761e and FFCyVu(path) and FFayeZ("ffmpeg"):
   pPath = CCafIt.VVjkKT()
   if VVmJwX(pPath):
    picon = self.VV761e.replace(":", "_") + ".png"
    cmd = CCvjVs.VVQ9GP(path)
    cmd += FFb2oQ("mv -f '%s' '%s%s'" % (path, pPath, picon))
    FFpwZS(cmd)
 def VVJ25H(self, s):
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  txt = ""
  txt += tab("Service Name", FFjt5L(s.VV1wIO, VVFuwR))
  txt += tab("Channel Num", s.chNum) if s.chNum > 0 else ""
  txt += tab("Provider" , s.prov) if s.prov else ""
  if s.state: txt += tab("State", (FFjt5L(s.state.replace("*", ""), VVz22H) if s.state.startswith("*") else s.state))
  vRes = CCvjVs.VVZHUt(s.info)
  if vRes: txt += tab("Dimensions", vRes)
  aspect = self.VVNYXU(s.info)
  if aspect: txt += tab("Video Format", aspect)
  txt += self.VVJi7Q(s.info, "Video Type", iServiceInformation.sVideoType, 4)
  rate = FFMzWf(s.info, iServiceInformation.sFrameRate)
  if rate.isdigit() and not rate == "0":
   txt += "Frame Rate\t: %s\n" % rate
  if FFxWB5(s.info, iServiceInformation.sIsCrypted) == "1":
   txt += "Crypted\t: Yes\n"
  tot = CCvjVs.VVHlVI(self.session)
  if tot > -1: txt += tab("Audio Tracks", tot)
  tot = CCvjVs.VVbjRo()
  if tot > -1: txt += tab("Subtitles", tot)
  fPath, fDir, fName, picFile = CCvjVs.VVSY7D(self)
  isLocal = False
  isIptv  = len(s.VVfaDB) > 0
  if isIptv:
   txt += tab("Service Type", FFjt5L("Stream-Relay" if FFHgaY(s.VVZcRP) else "IPTV", VVGCYL))
   if s.VVPxk5 and s.VVAQqG and s.VVPxk5 != s.VVAQqG:
    txt += tab("S. Relay Ref.", s.VVAQqG)
   txt += CCvjVs.VVjB93(s.VVfaDB)
  elif fPath:
   isLocal = True
   txt += tab("Reference", s.VVXbok)
   txt += tab("Service Type", "Local Recording")
   txt += tab("File", fName)
   txt += tab("Directory", fDir)
   if FFCyVu(picFile):
    self.VVAfO9 = picFile
  elif s.VVPxk5:
   txt += tab("Reference", s.VVPxk5)
  if s.VVPxk5.startswith("1:64:"):
   return txt
  if not isLocal or s.VVPxk5.endswith(":" + s.VV1wIO):
   bouq = self.VVS8aV(s.VVPxk5, s.VVAQqG, s.VVfaDB, s.VV1wIO)
   if bouq:
    txt += "\n" + bouq
  if not isLocal and not isIptv or s.VVAQqG:
   txt += "\n"
   txt += self.Sep
   namespace = None
   if s.VVPxk5:
    tp = CC3Z54()
    tpTxt, namespace = tp.VVQh97([s.VVPxk5, s.VVAQqG])
    if tpTxt:
     txt += FFjt5L("Tuner:\n", VVFuwR)
     txt += tpTxt
     txt += "\n"
     txt += self.Sep
   txt += FFjt5L("Codes:\n", VVFuwR)
   if namespace: txt += "Namespace\t: %s\n" % namespace
   else  : txt += self.VVJi7Q(s.info, "Namespace", iServiceInformation.sNamespace, 1, 8)
   txt += self.VVJi7Q(s.info, "Video PID" , iServiceInformation.sVideoPID , 2, 4)
   txt += self.VVJi7Q(s.info, "Audio PID" , iServiceInformation.sAudioPID , 2, 4)
   txt += self.VVJi7Q(s.info, "PCR PID" , iServiceInformation.sPCRPID , 2, 4)
   txt += self.VVJi7Q(s.info, "PMT PID" , iServiceInformation.sPMTPID , 2, 4)
   txt += self.VVJi7Q(s.info, "TXT PID" , iServiceInformation.sTXTPID , 2, 4)
   txt += self.VVJi7Q(s.info, "SID"  , iServiceInformation.sSID  , 2, 4)
   txt += self.VVJi7Q(s.info, "ONID"  , iServiceInformation.sONID  , 2, 4)
   txt += self.VVJi7Q(s.info, "TSID"  , iServiceInformation.sTSID  , 2, 4)
  return txt
 def VVJi7Q(self, info, name, what, mode=0, digits=0):
  tab = "\t"
  txt = str(FFMzWf(info, what))
  if len(txt) > 0:
   try  : hexVal = hex(int(txt))[2:].upper()
   except : hexVal = ""
   if digits > 0:
    hexVal = hexVal.zfill(digits)
   if   mode == 1     : txt = hexVal
   elif mode == 2     : txt = "%s\tdec: %s" % (hexVal, txt)
   elif mode == 3     : txt = "Yes" if txt=="1" else "No"
   elif mode == 4     : txt = self.VVfkRn(txt)
   if txt : return "%s%s: %s\n" % (name, tab, txt)
   else : return ""
  else:
   return ""
 def VVfkRn(self, sVideoType):
  codec_data = { -1: "", 0: "MPEG-2", 1: "H.264 (MPEG-4 AVC)", 2: "H.263", 3: "VC1", 4: "MPEG-4 (VC)", 5: "VC1-SM", 6: "MPEG-1", 7: "H.265 (HEVC)", 8: "VP8", 9: "VP9", 10: "XVID", 11: "11", 12: "12", 13: "DIVX 3.11", 14: "DIVX 4", 15: "DIVX 5", 16: "AVS", 17: "17", 18: "VP6", 19: "19", 20: "20", 21: "SPARK" }
  return codec_data.get(int(sVideoType), "")
 def VVS8aV(self, VVPxk5, sRelRef, VVfaDB, VV1wIO):
  VVPxk5 = FFtCD7(VVPxk5, VVfaDB, VV1wIO)
  if not VVPxk5:
   return ""
  fList = []
  txt = FFYVq0(VVQe79 + "bouquets.tv")
  list =  iFindall(r"(userbouquet[.].*[.]tv)", txt, IGNORECASE)
  if list: fList += list
  txt = FFYVq0(VVQe79 + "bouquets.radio")
  list =  iFindall(r"(userbouquet[.].*[.]radio)", txt, IGNORECASE)
  if list: fList.extend(list)
  VVGape = []
  ref1 = FFXarh(VVPxk5)
  for item in fList:
   path = VVQe79 + item
   if FFCyVu(path):
    txt = FFXarh(FFYVq0(path))
    if ref1 in txt or sRelRef and sRelRef in txt:
     span = iSearch(r"#NAME\s+(.*)", txt, IGNORECASE)
     if span : bName = span.group(1)
     else : bName = "[ No Name ]"
     VVGape.append((bName, os.path.basename(path)))
  if not VVGape:
   return ""
  txt = self.Sep
  if len(VVGape) == 1:
   txt += "%s\t: %s%s\n" % (FFjt5L("Bouquet", VVFuwR), VVGape[0][0], " (%s)" % VVGape[0][1] if VVWe5f else "")
  else:
   txt += FFjt5L("Bouquets:\n", VVFuwR)
   for ndx, item in enumerate(VVGape):
    txt += "%d- %s%s\n" % (ndx + 1, item[0].strip(), " (%s)" % item[1] if VVWe5f else "")
  return txt
 def VVRbRj(self):
  if not VVBvqf:
   return
  def VVJi7Q(key, val):
   return "%s= %s\n" % (key.ljust(12), val)
  txt = ""
  s = CC3rDi(self.session)
  n = ("VVPxk5", "VVZcRP", "VV57TX", "VVfaDB", "VV1wIO", "prov", "state")
  v = (s.VVPxk5, s.VVZcRP, s.VV57TX, s.VVfaDB, s.VV1wIO, s.prov, s.state)
  for i in range(len(n)):
   txt += VVJi7Q(n[i], v[i])
  if "chCode" in s.VVfaDB:
   p = CC96QG()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(s.VVZcRP)
   n = ("valid", "ph1", "playHost", "mode", "host", "mac", "epNum", "epId", "chCm", "query")
   v = (valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, query)
   for i in range(len(n)):
    txt += VVJi7Q(n[i], v[i])
  path = "/tmp/ajp_channel_details"
  with open(path, "a") as f:
   f.write("%s\n%s\n" % (SEP, txt))
  FF28n1(self, "Saved to : %s" % path, 1000)
 @staticmethod
 @FFOAKH("Checking Server")
 def VVnMBE(SELF):
  if not CCwhE4.VVOJRa(SELF):
   return
  title = "File Size"
  fSize = "Not received from server"
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(SELF)
  err = url =  fSize = resumable = ""
  if VVZcRP and seekable == 3 and durVal > 0:
   url = iSub(r"[&?]mode=.+end=", r"", VVZcRP, flags=IGNORECASE)
   url = iSub(r"[?]play_token.+", r"", url, flags=IGNORECASE)
   if url.endswith(":" + VV1wIO):
    url = url[:-(len(VV1wIO) + 1)]
   if "chCode" in VVZcRP:
    url = CC96QG.VVqzuM(VVZcRP)
   try:
    import requests
    resp = requests.get(url, headers=CCkEI5.VVgoVw(), timeout=4, stream=True, verify=False)
    if not resp.ok:
     FFdw58(SELF, "Err-%d : %s" % (resp.status_code, resp.reason), title=title)
     return
    hSize = resp.headers.get("Content-Length", "")
    if hSize and hSize.isdigit():
     size = int(hSize)
     fSize = CClYaF.VV99gM(size)
     if "vnd.apple" in resp.headers.get("content-type", ""):
      fSize += FFjt5L(" (M3U/M3U8 File)", VVA4XU)
    else:
     fSize = "No info. from server. Try again later."
    resumable = "Yes" if CCHRcZ.VV5qrn(resp) else "No"
   except requests.Timeout as e: err = "Connection Timeout"
   except      : err = "Connection Error"
  else:
   err = "Not a Movie/Series !"
  def VVVuRT(subj, val):
   return "%s\n%s\n\n" % (FFjt5L("%s:" % subj, VVFuwR), val)
  title = "File Size"
  txt  = VVVuRT(title , fSize or "?")
  txt += VVVuRT("Name" , VV1wIO)
  txt += VVVuRT("URL" , url)
  if resumable: txt += VVVuRT("Supports Download-Resume", resumable)
  if err  : txt += FFjt5L("Error:\n", VVz22H) + err
  FF4lCP(SELF, txt, title=title)
 @staticmethod
 def VVSY7D(SELF):
  fPath, fDir, fName = CClYaF.VV4zSS(SELF)
  if fPath:
   fPic = CCvjVs.VVbTkM(fPath)
   return fPath, fDir, fName, fPic
  else:
   return "", "", "", ""
 @staticmethod
 def VVbTkM(path):
  p = os.path.splitext(path)[0]
  for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
   pic = "%s.%s" % (p, ext)
   if FFCyVu(pic):
    return pic
  return ""
 @staticmethod
 def VVQ9GP(path, maxW=132):
  return FFb2oQ("ffmpeg -y -i '%s' -vf scale=-1:%d '%s'" % (path, maxW, path))
 @staticmethod
 def VVi5vZ(VVPxk5):
  VVPxk5 = CCvjVs.VVHamE(VVPxk5)
  if VVPxk5 : return CCafIt.VVjkKT() + VVPxk5.replace(":", "_").upper() + ".png"
  else  : return ""
 @staticmethod
 def VVHamE(VVPxk5):
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVPxk5, IGNORECASE)
  return span.group(1).upper() if span else ""
 @staticmethod
 def VV1sZM(url):
  if not FFHgaY(url):
   span = iSearch(r"(?:[A-Fa-f0-9]+[:]){10}(.+)", url, IGNORECASE)
   if span:
    url = span.group(1)
   if not VVBvqf:
    url = iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
  return FFXarh(url)
 @staticmethod
 def VVjB93(VVPxk5, showUrl=True):
  VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(VVPxk5)
  if VVZcRP:
   txt = "Reference\t: %s\n" % VVPxk5
   p = CC96QG()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
   if valid:
    txt += "Portal Host\t: %s\n" % host
    txt += "Portal MAC\t: %s\n"  % mac
    txt += "Portal Mode\t: %s\n" % {"itv":"Live", "vod":"VOD", "series":"Series"}.get(mode, "?")
   if showUrl:
    txt += "\n"
    txt += FFjt5L("URL:", VVGCYL) + "\n%s\n" % CCvjVs.VV1sZM(VVZcRP)
  else:
   txt = "\n"
   txt += FFjt5L("Reference:", VVGCYL) + "\n%s\n" % VVPxk5
  return txt
 @staticmethod
 def VV0Xds(SELF, **kwargs):
  cbFnc = kwargs.pop("cbFnc", None)
  SELF.session.openWithCallback(cbFnc, CCvjVs, **kwargs)
 @staticmethod
 def VVUxTg(session):
  session.open(CCvjVs, VV7VUc=CCvjVs.VVvrVY)
 @staticmethod
 def VVbjRo():
  try: return len(InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList())
  except: return -1
 @staticmethod
 def VVL5jW():
  try: lst = InfoBar.instance.getCurrentServiceSubtitle().getSubtitleList() or []
  except: lst = []
  tEmb = tFil = 0
  for item in lst:
   if len(item) >= 5:
    typ, src = item[0], item[2]
    if  typ == 0: tEmb += 1
    elif typ == 1: tEmb += 1
    elif typ == 2:
     if  src == 1  : tEmb += 1
     elif 2 <= src <= 6 : tFil += 1
  if   tEmb and not tFil : return 1
  if   tFil and not tEmb : return 2
  elif tFil and tEmb  : return 3
  else     : return 0
 @staticmethod
 def VVHlVI(session):
  try: return session.nav.getCurrentService().audioTracks().getNumberOfTracks() or 0
  except: return -1
 @staticmethod
 def VVNYXU(info):
  if info:
   aspect = FFMzWf(info, iServiceInformation.sAspect)
   if aspect.isdigit():
    aspect = int(aspect)
    if aspect in ( 1, 2, 5, 6, 9, 0xA, 0xD, 0xE ) : return "4:3"
    else           : return "16:9"
  return ""
 @staticmethod
 def VVZHUt(info):
  w = FFMzWf(info, iServiceInformation.sVideoWidth)
  h = FFMzWf(info, iServiceInformation.sVideoHeight)
  if w and h and (w, h) != ("0", "0") : return "%s x %s" % (w, h)
  else        : return ""
class CC96QG():
 def __init__(self):
  self.VVawfw()
  self.VVxRkD    = ""
  self.VVnS6i   = "#f#11ffffaa#User"
  self.VVIrBX   = "#f#11aaffff#Server"
  self.portal_firstResponse = {}
  self.portal_latestResponse = {}
 def VVawfw(self):
  self.VVncdQ   = ""
  self.VVvRlC    = ""
  self.VVtmjV   = ""
  self.VVN9HP = ""
  self.VVnsdh  = ""
  self.VVdDpE = 0
 def VVNf1R(self, url, mac, ph1="", VVwb7n=True):
  self.VVawfw()
  self.VVxRkD = {"s": "/server/load.php", "p": "/portal.php", "q": "/portal1.php"}.get(ph1, "")
  host = self.VVY27l(url)
  if not host:
   if VVwb7n:
    self.VVQ5VQ("Incorrect URL Format !\n\n%s" % url)
   return False
  mac = self.VV1r6n(mac)
  if not host:
   if VVwb7n:
    self.VVQ5VQ("Incorrect MAC Format !\n\n%s" % mac)
   return False
  self.VVncdQ = host
  self.VVvRlC  = mac
  return True
 def VVaM9P(self):
  return {"/server/load.php":"s", "/portal.php":"p", "/portal1.php":"q"}.get(self.VVxRkD, "")
 def VVY27l(self, url):
  if url.endswith("mac=") : url = url[:-4]
  if url.endswith("mac") : url = url[:-3]
  url = url.rstrip("/?")
  if url.endswith("/c") : url = url[:-2]
  url = url.rstrip("/ :")
  span = iSearch(r"(.+)(\/playlist.+mac)", url, IGNORECASE)
  if span:
   url = span.group(1)
  return url
 def VV1r6n(self, mac):
  span = iSearch(r"((?:[A-Fa-f0-9]{2}:){5}[A-Fa-f0-9]{2})", mac, IGNORECASE)
  if span : return span.group(1).upper()
  else : return ""
 def VViTWL(self):
  h = self.portal_firstResponse.get("resHeaders", "")
  if h: return h.get("Server", "")
  else: return ""
 def VVBNue(self):
  res, err = self.VVnjdQ(self.VVxctv())
  self.portal_firstResponse = self.portal_latestResponse
  if "403" in err or "404" in err or res and res.status_code == 200 and not res.text.strip():
   if self.VVncdQ.endswith("/c"):
    self.VVncdQ = self.VVncdQ[:-2]
    res, err = self.VVnjdQ(self.VVxctv())
   elif self.VVncdQ.endswith("/stalker_portal"):
    self.VVncdQ = self.VVncdQ[:-15]
    res, err = self.VVnjdQ(self.VVxctv())
   else:
    self.VVncdQ += "/c"
    res, err = self.VVnjdQ(self.VVxctv())
  token = rand = ""
  if not err:
   try:
    tDict = jLoads(res.text)
    token = FFYjVd(tDict["js"], "token")
    rand  = FFYjVd(tDict["js"], "random")
   except:
    pass
  return token.strip(), rand.strip(), err
 def VVTATM(self, VVwb7n=True):
  if not self.VVxRkD:
   self.VVqjN9()
  err = blkMsg = FFipXTTxt = ""
  try:
   token, rand, err = self.VVBNue()
   if token:
    self.VVtmjV = token
    self.VVN9HP = rand
    if rand:
     self.VVdDpE = 2
    prof, retTxt = self.VVoOAz(True)
    if prof:
     self.VVnsdh = retTxt
     if any(x in retTxt for x in ("device_id mismatch", "old firmware")):
      self.VVdDpE = 3
      prof, retTxt = self.VVoOAz(False)
      if retTxt:
       self.VVnsdh = retTxt
    return token, prof, ""
  except:
   pass
  tErr = err or "Could not get Token from server !"
  if blkMsg or FFipXTTxt:
   tErr += "\n"
   if blkMsg: tErr += "\n%s" % blkMsg
   if FFipXTTxt: tErr += "\n%s" % FFipXTTxt
  if VVwb7n:
   self.VVQ5VQ(tErr)
  return "", "", tErr
 def VVqjN9(self):
  try:
   import requests
   url = self.VVTr19()
   jsFile = "xpcom.common.js"
   res = requests.get("%s/stalker_portal/c/%s" % (url, jsFile), headers=CCkEI5.VVgoVw(), stream=True, timeout=2)
   if not res.ok or not "javascript" in res.headers.get("content-type"):
    res = requests.get("%s/c/%s" % (url, jsFile), headers=CCkEI5.VVgoVw(), stream=True, timeout=2)
   if res.ok and "javascript" in res.headers.get("content-type"):
    patt = ""
    for line in res.iter_lines():
     if len(line) > 500:
      continue
     elif line:
      line = str(line.decode('utf-8'))
      span = iSearch(r"\s*var\s+pattern\s*=\s*\/(.+)\/\s*;", line, IGNORECASE)
      if span:
       patt = span.group(1)
      span = iSearch(r".+ajax_loader.+'(\/.+\.php)'", line, IGNORECASE)
      if span:
       if "portal_path" in line:
        if patt.endswith(r"*\/(.)*"): url += "/c"
        else      : url += "/stalker_portal"
       self.VVncdQ = url
       self.VVxRkD = span.group(1)
       return
  except:
   pass
  self.VVxRkD = "/server/load.php"
 def VVTr19(self):
  url = self.VVncdQ.rstrip("/")
  if url.endswith("/c")    : url = url[:-2]
  if url.endswith("/stalker_portal") : url = url[:-15]
  if url.endswith("/c")    : url = url[:-2]
  return url
 def VVI5kn(self, url, isJsFile=False):
  import requests
  jsFile = "xpcom.common.js" if isJsFile else "version.js"
  res, err = self.VVnjdQ("%s/stalker_portal/c/%s" % (url, jsFile))
  if not res or not "javascript" in res.headers.get("content-type"):
   res, err = self.VVnjdQ("%s/c/%s" % (url, jsFile))
  if res and "javascript" in res.headers.get("content-type"):
   if isJsFile:
    return str(res.content), ""
   else:
    span = iSearch(r"var\s+ver\s*=\s*'(.+)'", res.text, IGNORECASE)
    if span:
     return span.group(1), ""
  return "", err
 def VVoOAz(self, capMac):
  res, err = self.VVnjdQ(self.VVIxOg(capMac))
  if not err:
   try:
    tDict = jLoads(res.text)
    word = "m" + "sg"
    blkMsg = FFYjVd(tDict["js"], "block_%s" % word)
    FFipXTTxt = FFYjVd(tDict["js"], word)
    return tDict, FFipXTTxt.strip() or blkMsg.strip()
   except:
    pass
  return "", ""
 def VVIxOg(self, capMac):
  param = ""
  if self.VVnsdh or self.VVN9HP:
   param = self.getMoreAuth_params(self.getMoreAuth_IDs(self.VVvRlC.upper() if capMac else self.VVvRlC.lower(), self.VVN9HP))
  elif FFQqEJ("bW9sLTI=") in self.VVncdQ:
   param = self.getMoreAuth_basic(self.VVvRlC.upper())
  return self.VVbKTa() + "type=stb&JsHttpRequest=1-xml&action=get_profile" + param
 exec(FFQqEJ("ZGVmIGdldE1vcmVBdXRoX3BhcmFtcyhzZWxmLCBJZCk6DQogcGFyYW0gPSAiJmF1dGhfc2Vjb25kX3N0ZXA9MSZod192ZXJzaW9uPTIuMTctSUItMDAmaHdfdmVyc2lvbl8yPTYyJnNuPSVzJmRldmljZV9pZD0lcyZkZXZpY2VfaWQyPSVzJnNpZ25hdHVyZT0lcyIgJSAoSWRbMF0sIElkWzFdLCBJZFsxXSwgSWRbMl0pDQogcmV0dXJuIHBhcmFtICsgJyZ2ZXI9UGxheWVyIEVuZ2luZSB2ZXJzaW9uOiAweDU4YyZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwidHlwZSI6IlNUQiIsIm1vZGVsIjoiTUFHMjUwIiwicmFuZG9tIjoiJXMifScgJSAoSWRbM10sIElkWzBdLCBJZFs0XSkNCmRlZiBnZXRNb3JlQXV0aF9JRHMoc2VsZiwgbSwgcik6DQogaW1wb3J0IGhhc2hsaWINCiBtYWNVdGY4ID0gbS5lbmNvZGUoJ3V0Zi04JykNCiBzID0gaGFzaGxpYi5tZDUobWFjVXRmOCkuaGV4ZGlnZXN0KCkudXBwZXIoKVs6MTNdDQogcmV0dXJuIHMsIGhhc2hsaWIuc2hhMjU2KG1hY1V0ZjgpLmhleGRpZ2VzdCgpLnVwcGVyKCksIGhhc2hsaWIuc2hhMjU2KChzICsgbSkuZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpLCBtLCBy"))
 exec(FFQqEJ("ZGVmIGdldE1vcmVBdXRoX2Jhc2ljKHNlbGYsIG0pOiByZXR1cm4gJyZod192ZXJzaW9uPTEuNy1CRC0wMCZtZXRyaWNzPXsibWFjIjoiJXMiLCJzbiI6IiVzIiwibW9kZWwiOiJNQUcyNTAiLCJ0eXBlIjoiU1RCIn0nICUgKG0sIGhhc2hsaWIubWQ1KG0uZW5jb2RlKCd1dGYtOCcpKS5oZXhkaWdlc3QoKS51cHBlcigpWzoxM10p"))
 def VVIr7V(self, forceMoreInfo=False):
  rows = []
  if not forceMoreInfo:
   rows = self.VVdsoA()
  if len(rows) < 10:
   rows = self.VVJt5a()
  if not rows or len(rows[0]) == 2:
   rows.append(("Host"    , self.VVncdQ ))
   rows.append(("MAC (from URL)" , self.VVvRlC ))
   rows.append(("Token"   , self.VVtmjV ))
   rows.sort(key=lambda x: x[0].lower())
   return rows, 2
  else:
   rows.append(("1", self.VVnS6i  , "MAC" , self.VVvRlC ))
   rows.append(("2", self.VVIrBX, "Host" , self.VVncdQ ))
   rows.append(("2", self.VVIrBX, "Token" , self.VVtmjV ))
   rows.sort(key=lambda x: (x[0], x[2]))
   return rows, 4
 def VVdsoA(self):
  p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=self.VVncdQ, mac=self.VVvRlC)
  rows = []
  if pUrlAcc:
   res, err = self.VVnjdQ(pUrlAcc)
   if not err:
    try:
     tDict = jLoads(res.text)
     for key, val in tDict["user_info"].items() :
      if any(x in key for x in ("exp_date", "created_at")): val = FFTS4w(int(val))
      if isinstance(val, list): val = str(" , ".join(val))
      else     : val = str(val)
      rows.append(("1", self.VVnS6i, str(key).replace("_", " ").title(), val))
     for key, val in tDict["server_info"].items():
      if "timestamp_now"  in key : val = FFTS4w(int(val))
      else      : val = str(val)
      rows.append(("2", self.VVIrBX, str(key).replace("_", " ").title(), val))
    except:
     pass
  return rows
 def VVJt5a(self):
  token, profile, tErr = self.VVTATM()
  try:
   item = profile["js"]
  except:
   return []
  if not isinstance(item, dict):
   return []
  rows = []
  c  = "#f#11ffff55#"
  rows = []
  for key, val in item.items():
   if not val:
    continue
   try:
    if key == "mac":
     if val and FFBAsJ(val): val = FFQqEJ(val.decode("UTF-8"))
     else     : val = self.VVvRlC
    elif key == "play_token":
     parts = val.split(":")
     if len(parts) == 3:
      pToken = parts[0]
      started = FFTS4w(int(parts[1]))
      if parts[2] : ends = FFTS4w(int(parts[1]) + int(parts[2]))
      else  : ends = ""
      val = "%s (%s ... %s)" % (pToken, started, ends)
    elif key == "aspect":
     val = " , ".join(["%s=%s" % (k, v) for k, v in jLoads(val)["js"].items()])
    elif key in ("created", "last_watchdog"):
     val = FFTS4w(int(val))
    elif isinstance(val, list):
     val = str(" , ".join(val))
    elif isinstance(val, dict):
     val = str(val).replace("u'", "").replace("'", "").strip("{} ")
    else:
     val = str(val).strip()
   except:
    val = str(val)
   rows.append(((str(key).replace("_", " ").title(), str(val))))
  return rows
 def VVsbRz(self, mode, chCm, epNum, epId):
  token, profile, tErr = self.VVTATM(VVwb7n=False)
  if not token:
   return ""
  crLinkUrl = self.VVYCAa(mode, chCm, epNum, epId)
  res, err = self.VVnjdQ(crLinkUrl)
  chUrl = ""
  if not err:
   try: chUrl = FFYjVd(jLoads(res.text)['js'], "cmd")
   except: pass
  chUrl = chUrl.replace("\t", "")
  if " " in chUrl:
   chUrl = chUrl.split(" ")[1].strip(" _")
  chUrl = chUrl.replace(":", "%3a")
  return chUrl
 def VVbKTa(self):
  return self.VVncdQ + self.VVxRkD + "?"
 def VVxctv(self):
  return self.VVbKTa() + "type=stb&action=handshake&JsHttpRequest=1-xml&token="
 def VVryIa(self, mode):
  url = self.VVbKTa() + "type=%s&JsHttpRequest=1-xml&action=" % mode
  if   mode == "itv"  : url += "get_genres"
  elif mode == "vod"  : url += "get_categories&force_ch_link_check="
  elif mode == "series": url += "get_categories"
  return url
 def VVhjC5(self, catID):
  return self.VVbKTa() + "type=series&action=get_ordered_list&sortby=added&movie_id=%s&p=1" % catID
 def VV7Kcq(self, mode, catID, page):
  url = self.VVbKTa() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&sortby=number&p=%d&" % (mode, page)
  if mode == "itv": url += "genre=%s" % catID
  else   : url += "category=%s&force_ch_link_check=" % catID
  return url
 def VVLfbI(self, mode, searVV1wIO, catId, page):
  catId = ("&category=%s" % catId) if catId else ""
  return self.VVbKTa() + "type=%s&JsHttpRequest=1-xml&action=get_ordered_list&search=%s&%s&p=%d" % (mode, searVV1wIO, catId, page)
 def VVc7nF(self, stID):
  return self.VVbKTa() + "type=itv&JsHttpRequest=1-xml&action=get_short_epg&ch_id=%s" % stID
 def VVYCAa(self, mode, chCm, serCode, serId):
  url = self.VVbKTa() + "action=create_link&"
  if mode == "series" : url += "type=vod&series=%s&JsHttpRequest=1-xml&cmd=/media/%s.mpg" % (serCode, serId)
  else    : url += "type=%s&cmd=%s&JsHttpRequest=1-xml&forced_storage=0&disable_ad=0&download=0" % (mode, chCm)
  return url
 def VVX37W(self):
  return self.VVbKTa() + "type=itv&JsHttpRequest=1-xml&action=create_link"
 def VVfi1S(self, host, mac, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId):
  VVPxk5 = self.VVpX1r(catID, stID, chNum)
  query = self.VVn2QP(mode, self.VVaM9P(), FFiPNn(host), FFiPNn(mac), serCode, serId, chCm, catID, stID)
  if   chCm.endswith(".m3u8") : chUrl = "%s?%s" % (chCm, query)
  elif "deviceMac=" in chCm : chUrl = "%s?%s" % (chCm, query)
  else      : chUrl = "%s/j.php?%s" % (host, query)
  chUrl = VVPxk5 + chUrl.replace(":", "%3a") + ":" + VV1wIO
  return VVPxk5, chUrl
 def VVn2QP(self, mode, ph1, host, mac, serCode, serId, chCm, catID, stID):
  query = "mode=%s&ph1=%s&hst=%s&chCode=%s&epNum=%s&epId=%s&cId=%s&sId=%s&chCm=%s&end=" % (mode, ph1, host, mac, serCode, serId, catID, stID, chCm)
  return query.replace("ffmpeg ", "").replace(":", "%3a")
 def VVGNGo(self, url):
  if   "mode=itv"  in url: mode = "itv"
  elif "mode=vod"  in url: mode = "vod"
  elif "mode=series" in url: mode = "series"
  else       : return False, "", "", "", "", "", "", "", "", "", "", ""
  res  = iUrlparse(url)
  scheme = res.scheme
  netloc = res.netloc
  tDict = iUrlparse_qs(res.query)
  ph1  = tDict.get("ph1" , [""])[0].strip()
  host = tDict.get("hst" , [""])[0].strip()
  mac  = tDict.get("chCode", [""])[0].strip()
  epNum = tDict.get("epNum" , [""])[0].strip().replace(":" , "%3a")
  epId = tDict.get("epId" , [""])[0].strip().replace(":" , "%3a")
  chCm = tDict.get("chCm" , [""])[0].strip().replace("ffmpeg ", "").replace(":" , "%3a")
  catID = tDict.get("cId" , [""])[0].strip()
  stID = tDict.get("sId" , [""])[0].strip()
  span = iSearch(r"chCm=(.+)&end=", url, IGNORECASE)
  if span: chCm = span.group(1)
  query = self.VVn2QP(mode, ph1, host, mac, epNum, epId, FFSiPR(chCm), catID, stID)
  if scheme: scheme += "://"
  playHost = scheme + netloc
  host  = FFQqEJ(host)
  mac   = FFQqEJ(mac)
  valid = False
  if self.VVY27l(playHost) and self.VVY27l(host) and self.VVY27l(mac):
   if (mode in ("itv", "vod") and chCm) or (mode == "series" and epNum and epId):
    valid = True
  return valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query
 def VVmjF4(self, url):
  return iSub(r"[&?]mode=.+end=", "", url, flags=IGNORECASE)
 def VVnjdQ(self, url, useCookies=True):
  self.portal_latestResponse = {"url": url, "resErr": ""}
  try: import requests
  except: return "", 'The "Requests" library is not installed'
  err = ""
  crErr = False
  try:
   headers = CCkEI5.VVgoVw()
   if self.VVtmjV:
    headers["Authorization"] = "Bearer %s" % self.VVtmjV
   self.portal_latestResponse["headers"] = headers
   if useCookies : cookies = {"mac": self.VVvRlC, "stb_lang": "en"}
   else   : cookies = None
   self.portal_latestResponse["cookies"] = cookies
   res = requests.get(url, headers=headers, allow_redirects=True, timeout=CFG.portalConnTimeout.getValue(), cookies=cookies)
   self.portal_latestResponse["resHeaders"] = res.headers
   self.portal_latestResponse["resErrCode"] = res.status_code
   if res.ok:
    return res, ""
   else:
    if res.status_code == 407: reason = "Proxy Authentication Required"
    if res.status_code == 423: reason = "Access Locked"
    if res.status_code == 521: reason = "Server Is Down"
    else      : reason = "Unknown"
    err = "Err-%d : %s" % (res.status_code, res.reason or reason)
  except requests.Timeout as e  : crErr, err = True, "Connection Timeout"
  except requests.ConnectionError as e: crErr, err = True, "Connection Error"
  except Exception as e    : crErr, err = True, "Error\n" + str(e)[:120]
  self.portal_latestResponse["resErr"] = err
  self.portal_latestResponse["resCritical"] = crErr
  return "", err
 @staticmethod
 def VVKe8x(url, extraHeaders=None, cookies=None, timeout=3, verify=False):
  resp, txt, err = None, "", ""
  try:
   import requests
   headers = CCkEI5.VVgoVw()
   if extraHeaders: headers.update(extraHeaders)
   resp = requests.get(url, headers=headers, allow_redirects=True, timeout=timeout, cookies=cookies, verify=verify)
   if resp.ok : txt = str(resp.text)
   else  : err = "Error %d\n\n%s" % (resp.status_code, resp.reason)
  except:
   err = "Error while contacting server !"
  return resp, txt, err
 def VVQ5VQ(self, err, title="Portal Browser"):
  FFdw58(self, str(err), title=title)
 def VVdGiv(self, mode):
  if   mode in ("itv"  , CCkEI5.VVgkvV , CCkEI5.VVXewY)  : return "Live"
  elif mode in ("vod"  , CCkEI5.VVgL8R , CCkEI5.VVw3vg)  : return "VOD"
  elif mode in ("series" , CCkEI5.VV6cbr , CCkEI5.VVtP50) : return "Series"
  else                          : return "IPTV"
 def VVvwJ7(self, mode, searVV1wIO):
  return 'Find in %s : %s' % (self.VVdGiv(mode), FFjt5L(searVV1wIO, VVA4XU))
 def VVafii(self, catchup=False):
  VV3wat = []
  VV3wat.append(("Live"    , "live"  ))
  VV3wat.append(("VOD"    , "vod"   ))
  VV3wat.append(("Series"   , "series"  ))
  if catchup:
   VV3wat.append(VVAL3j)
   VV3wat.append(("Catch-up TV" , "catchup"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Account Info." , "accountInfo" ))
  return VV3wat
 @staticmethod
 def VVfs3s(VVZcRP):
  p = CC96QG()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
  if valid and chCm:
   if   mode == "itv"  : patt = r'.+ch\/(\d+)_'
   elif mode == "vod"  : patt = r'stream_id":"*(\d+)'
   elif mode == "series": patt = r'series_id":"*(\d+)'
   span = iSearch(patt, FFQqEJ(chCm), IGNORECASE)
   if span:
    return span.group(1)
  return ""
 @staticmethod
 def VVqzuM(VVZcRP):
  p = CC96QG()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
  if valid:
   if CC96QG.VVdkFC(chCm):
    return FFXarh(chCm)
   else:
    ok = p.VVNf1R(host, mac, ph1, VVwb7n=False)
    if ok:
     try:
      chUrl = p.VVsbRz(mode, chCm, epNum, epId)
      return FFXarh(chUrl)
     except:
      pass
  return ""
 @staticmethod
 def VVdkFC(chCm):
  return chCm.startswith("http") and not "//localhost/" in chCm
 @staticmethod
 def VV9eVr(VVZcRP):
  if not "chCode" in VVZcRP: return None, "Not Portal"
  p = CC96QG()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
  if not valid: return None, "Invalid URL"
  return CC96QG.VV5yj4(host, mac, ph1)
 @staticmethod
 def VV5yj4(host, mac, ph1=""):
  p = CC96QG()
  if not p.VVNf1R(host, mac, ph1=ph1, VVwb7n=False): return None, "Invalid Host/MAC"
  token, profile, tErr = p.VVTATM(VVwb7n=False)
  if not token: return None, tErr
  return p, ""
 @staticmethod
 def VV1SNn(VVZcRP="", host="", mac="", ph1=""):
  pUrl = pUrlAcc = pUrlDnld = pHost = pUser = pPass = err = ""
  if   VVZcRP  : p, err = CC96QG.VV9eVr(VVZcRP)
  elif host and mac : p, err = CC96QG.VV5yj4(host, mac, ph1=ph1)
  else    : p, err = None, "Incorrect fnc params"
  if err:
   return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
  url = p.VVX37W()
  res, err = p.VVnjdQ(url)
  try: cmd = FFYjVd(jLoads(res.text)["js"], "cmd")
  except: return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
  cmd = cmd.replace("\t", "")
  span = iSearch(r"(http.+)\/(.+)\/(.+)(\/\?.+)", cmd)
  if span:
   pHost = span.group(1)
   pUser = FFSiPR(span.group(2))
   pPass = FFSiPR(span.group(3))
   pUrl = "%s/%s/%s/" % (pHost, pUser, pPass)
   pUrlAcc = "%s/player_api.php?username=%s&password=%s" % (pHost, pUser, pPass)
   pUrlDnld= "%s/get.php?username=%s&password=%s&type=m3u" % (pHost, pUser, pPass)
  else:
   err = "Not found"
  return p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err
class CChyfE(CC96QG):
 def __init__(self):
  CC96QG.__init__(self)
  self.mode   = ""
  self.VVPxk5  = ""
  self.VV1wIO   = ""
  self.VVfaDB  = ""
  self.chCm   = ""
  self.epNum   = ""
  self.epId   = ""
  self.query   = ""
 def VVgBJL(self, VVPxk5, VV1wIO, VVZcRP, VVfaDB):
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVGNGo(VVZcRP)
  if valid:
   if self.VVNf1R(host, mac, ph1, VVwb7n=False):
    self.mode  = mode
    self.VVPxk5 = VVPxk5
    self.VV1wIO  = VV1wIO
    self.VVfaDB = VVfaDB
    self.chCm  = chCm
    self.epNum  = epNum
    self.epId  = epId
    self.query  = query
    return True
  return False
 def VVIguo(self, session):
  chUrl = ""
  try:
   if self.chCm.startswith("Zz1"):
    self.chCm = FFQqEJ(self.chCm[3:])
   else:
    chUrl = self.VVsbRz(self.mode, self.chCm, self.epNum, self.epId)
  except:
   return False
  if CC96QG.VVdkFC(self.chCm) and ("get_download_link" in chUrl or not chUrl):
   chUrl = FFXarh(self.chCm)
   chUrl = FFSiPR(self.chCm)
   chUrl = chUrl.replace("%253a", "%3a")
   if not "?" in chUrl:
    chUrl += "?"
  elif " " in self.chCm or " " in chUrl:
   if " " in chUrl:
    chUrl = chUrl.split(" ")[1]
   if not "?" in chUrl:
    chUrl += "?"
  if not chUrl.startswith("http"):
   return False
  if not self.VVPxk5.endswith(":"):
   self.VVPxk5 += ":"
  chUrl = chUrl.strip()
  chUrl = self.VVPxk5 + chUrl + ":" + self.VV1wIO
  newIptvRef = self.VVvY5A(chUrl, self.VV1wIO)
  bPath = CCMvE7.VVvNtR()
  if newIptvRef:
   newIptvRef1 = newIptvRef
   if CFG.simplePortal.getValue():
    newIptvRef1 = self.VVmjF4(newIptvRef)
   FFnfiC(session, newIptvRef1)
   if self.VVfaDB and newIptvRef and bPath:
    serv = eServiceReference(newIptvRef)
    newCode = serv and serv.toString()
    if newCode:
     self.VVhDjf(self.VVfaDB, newCode, bPath)
   return True
  else:
   return False
 def VVvY5A(self, chUrl, VV1wIO):
  newIptvRef = ""
  playMarks = ("play_token=", "/play/", "lid=")
  for toFind in playMarks:
   if toFind in chUrl:
    ndx = chUrl.find(toFind)
    if ndx > -1:
     ndx = chUrl.find(":", ndx)
     if ndx > -1:
      left  = chUrl[:ndx]
      right  = chUrl[ndx:]
      newIptvRef = left + "&" + self.query + right
    break
  if not newIptvRef:
   x1 = chUrl.find("?")
   if x1 > -1:
    x2 = chUrl[x1:].find(":")
    if x2 > -1:
     newIptvRef = chUrl[:x1+x2] + "&" + self.query + chUrl[x1+x2:]
  if not newIptvRef and VV1wIO:
   VV1wIO = ":" + VV1wIO
   if chUrl.endswith(VV1wIO):
    newIptvRef = chUrl[:-len(VV1wIO)].rstrip("?&") + "&" + self.query + VV1wIO
  return newIptvRef
 def VVhDjf(self, oldCode, newCode, bPath):
  patt = r"((?:[A-Fa-f0-9]+[:]){10}).+(mode=.+)chCm="
  span = iSearch(patt, newCode, IGNORECASE)
  if span:
   newRef, newPar = span.group(1).upper(), span.group(2)
   params = ("ph1", "cId", "sId")
   for par in params:
    newPar = iSub(r"&%s=.*?&" % par, "&", newPar)
   span = iSearch(r"(sId=.+?)&", oldCode)
   sidTxt = span.group(1) if span else ""
   lines = FFL19l(bPath)
   for ndx, line in enumerate(lines):
    span = iSearch(patt, line, IGNORECASE)
    if span and sidTxt in line:
     fileRef, filePar = span.group(1).upper(), span.group(2)
     if newRef == fileRef:
      for par in params:
       filePar = iSub(r"&%s=.*?&" % par, "&", filePar)
      if newPar == filePar:
       lines[ndx] = "#SERVICE %s" % newCode
       with open(bPath, "w") as f: f.write("\n".join(lines) + "\n")
       FFfpyJ()
class CC6F0F(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVlrZA, 510, 510, 30, 0, 0, "#ff000000", "#ff000000", 30, VVU4ws=False)
  self.session  = session
  self.Title   = "Movies Resume History"
  self.tbl   = None
  self.VVRE6N = 0
  FFZMxC(self)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVvB4L()
 @FFOAKH()
 def VVvB4L(self):
  path, lst, err = CC6F0F.VVjp9r()
  if not lst:
   FFdw58(self, "No resume points.", title=self.Title)
   self.cancel()
   return
  fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
  self.VVRE6N = grnB = 0
  rows = []
  for fName1 in lst:
   d = CCzUSd.VV0NUN(path + fName1)
   if d:
    if fName == fName1 : c, grnB = "#f#0022ff22#", 1
    else    : c = ""
    prog = str(int(round(100.0 * d["pos"] / d["dur"])))
    rows.append((c + d["nm"], c + FFFHEC(d["dur"] / 90000.0), c + FFFHEC(d["pos"] / 90000.0), "", prog, c + FFTS4w(d["w"]), fName1, d["u"], d["r"]))
   else:
    self.VVRE6N += 1
  if self.tbl:
   self.tbl.VVMqQ9(rows)
  elif rows:
   settTxt = FFjt5L("Settings : ", VVA4XU) + (FFjt5L(CFG.resumeMovies.getText(), VVYjI5 if CFG.resumeMovies.getValue() == "off" else VVJEMb))
   rows.sort(key=lambda x: x[0][12:].lower() if iMatch(r"^\s*#(f|b)#[a-fA-F0-9]{8}#", x[0]) else x[0].lower())
   bg = "#1a111020"
   VVp1bQ = (3, 4, 80, 20)
   VVu8qI = self.cancel
   VVCOpO = (""  , BF(self.VVInj5, False), [])
   VVu1YM  = ("Play" , self.VVXuZ7     , [])
   VV2ytr = (""  , self.VVPO8c    , [])
   VVwSzI = ("Current", BF(self.VVInj5, True) , [])
   VVScQz = ("Options", self.VVSYXm    , [])
   header  = ("Name" , "Duration", "Resume" , "Pos %" , "Pos %" , "Watched" , "File", "Source" , "ref" )
   widths  = (46  , 12  , 12  , 7   , 0.03  , 23  , 0.01 , 0.01  , 0  )
   VVLIqP = (LEFT  , CENTER , CENTER , CENTER , CENTER , CENTER , LEFT , LEFT  , LEFT )
   self.tbl = FFUQ0v(self, None, title=self.Title, VVCNdI=settTxt, header=header, VVGape=rows, VVLIqP=VVLIqP, width=1600, height=900, VV3cHe=widths, VVwdmN=27, VVp1bQ=VVp1bQ, VVCOpO=VVCOpO, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VV2ytr=VV2ytr, VVwSzI=VVwSzI, VVScQz=VVScQz
        , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06004455", VVbcr0="#00333333", VVX9AA="#0a332244")
  else:
   FFdw58(self, err, title=self.Title)
   self.cancel()
  if self.tbl:
   if grnB : self.tbl.VVsd6P()
   else : self.tbl.VVucBj()
 def cancel(self, VV6A99=None):
  if self.tbl: self.tbl.cancel()
  self.close()
 def VVXuZ7(self, VV6A99, title, txt, colList):
  CCqWM2.VVHc02(self.session, VVEBd5=False, VVOOLD=False, VVaHNe=colList[8], cbFnc=self.VVvB4L)
 def VVPO8c(self, VV6A99, title, txt, colList):
  txt = "%s\n\n%s" % (title, txt)
  VV1wIO, VVPxk5 = colList[0], colList[8]
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVPxk5.strip(), IGNORECASE)
  if span:
   VVPxk5 = span.group(1)
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVZImX, params=(VVPxk5, VV1wIO, txt))
 def VVInj5(self, VVwb7n, VV6A99, title, txt, colList):
  fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
  if fName:
   VV6A99.VVn5CC(6, fName, VVwb7n=VVwb7n)
 def VVSYXm(self, VV6A99, title, txt, colList):
  isMulti = VV6A99.VVXWPu
  rows = VV6A99.VVbF9W()
  ok = not isMulti or isMulti and rows
  VV3wat = []
  VV3wat.append(FFsLU5("Delete All"         , "all", not isMulti, VVz22H))
  VV3wat.append(FFsLU5("Delete Selected Row%s" % FFcacr(len(rows)) , "sel", ok))
  if self.VVRE6N:
   VV3wat.append(VVAL3j)
   VV3wat.append((VVJEMb + "Clear Unreadable Files"  , "bad"))
  params = [VV6A99, isMulti, rows]
  cbFncDict = { "all": BF(self.VVzdsk, params + ["all"])
     , "sel": BF(self.VVzdsk, params + ["sel"])
     , "bad": BF(self.VVzdsk, params + ["bad"])
     }
  CCzSCo(self, VV6A99, setsOk=True).VV9VR2(VV3wat, cbFncDict, width=500)
 def VVzdsk(self, params):
  VV6A99, isMulti, rows, item = params
  if item:
   if item == "sel":
    tot = len(rows)
    if isMulti : ques = "Delete %d Resume Point%s ?" % (tot, FFcacr(tot))
    else  : ques = "Delete Selected Point ?"
   elif item == "all" : ques = "Delete all Resume Points ?"
   elif item == "bad" : ques = "Found %d unusable file%s that could not be added to table.\n\nDelete unusable files ?" % (self.VVRE6N, FFcacr(self.VVRE6N))
   FFRMYv(self, BF(self.VVAzBM, params), ques, title=self.Title)
 def VVAzBM(self, params):
  VV6A99, isMulti, rows, item = params
  path = CCzUSd.VVc5Po("")
  if item == "sel":
   if isMulti:
    for fName in self.tbl.VVf3uT(6):
     FFwgGB(CCzUSd.VVc5Po(fName))
   else:
    FFwgGB(CCzUSd.VVc5Po(self.tbl.VVeE40(6)))
   self.VVvB4L()
  elif item == "all":
   for row in self.tbl.VVrrm9():
    FFwgGB(path + row[6])
   FF8D5P(self.session, "Done")
   self.cancel()
  elif item == "bad":
   path, lst, err = CC6F0F.VVjp9r()
   tot = 0
   for fName in lst:
    d = CCzUSd.VV0NUN(path + fName)
    if not d:
     FFwgGB(path + fName)
     tot += 1
   self.VVRE6N = 0
   FFipXT(self, "Deleted %d unreadable file%s." % (tot, FFcacr(tot)) if tot else "All files are OK.", title=self.Title)
 @staticmethod
 def VVjp9r():
  path = CCzUSd.VVc5Po("")
  try:
   return path, os.listdir(path), ""
  except Exception as e:
   return path, [], str(e)
class CCzUSd():
 def __init__(self, VVeO1i):
  self.VVNzyE = None
  self.VV6Wmd = False
  self.VVbU22 = 0
  self.VV6jnW = 0
  self.VVTBfp = eTimer()
  try: self.VVTBfp_conn = self.VVTBfp.timeout.connect(self.VVHPUa)
  except: self.VVTBfp.callback.append(self.VVHPUa)
  self.VVTBfp.start(500, False)
  self.VVkHre()
 def VVkHre(self):
  path = self.VVc5Po("")
  if VVmJwX(path):
   return os.path.isdir(path)
  else:
   try:
    os.makedirs(path)
    return True
   except:
    return False
 def VVHPUa(self):
  self.VVbU22, self.VV6jnW = CCzUSd.VVaNW3(self.VVeO1i)
  if self.VV6Wmd and self.VVbU22:
   self.VV6Wmd = False
   self.VV44ld()
 def VVlDEX(self):
  self.VV6Wmd = True
 def VV44ld(self):
  fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.VVeO1i)
  if not fName or self.VVNzyE == fName:
   return
  tDict = CCzUSd.VV0NUN(self.VVc5Po(fName))
  if tDict and "pos" in tDict and "dur" in tDict:
   newPos, newDur = tDict["pos"], tDict["dur"]
   if abs(self.VVbU22 - newPos) // 90000.0 and newPos > 900000 and newPos < self.VVbU22 - 900000:
    InfoBar.instance.doSeek(int(newPos))
    InfoBar.instance.hide()
    self.VVNzyE = fName
 def VVB1ug(self):
  self.VVNzyE = None
  fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.VVeO1i)
  if not fName or self.VVbU22 == 0:
   return
  if abs(self.VVbU22 - self.VV6jnW) < 90000 * 2:
   FFwgGB(self.VVc5Po(fName))
   return
  if self.VV6jnW > 90000 * 60 and self.VV6jnW < self.VVbU22 - 900000 and self.VVbU22 > 90000 * 60:
   self.VVkHre()
   tDict = {"v":1, "nm": str(VV1wIO), "u": str(fTxt), "r": str(VVu06s), "pos": self.VV6jnW, "dur": self.VVbU22, "w": int(iTime())}
   try:
    import pickle
    with open(self.VVc5Po(fName), 'wb') as f:
     pickle.dump(tDict, f, 2)
   except:
    pass
 @staticmethod
 def VVwtlp(session):
  s = CC3rDi(session)
  fName = fTxt = ""
  conf = CFG.resumeMovies.getValue()
  if   conf in ("a", "i") and FFUl6q(s.VVZcRP): pass
  elif conf in ("a", "l") and s.Path.startswith("/")   : pass
  else              : return fName, fTxt, s.VV1wIO, s.VVu06s
  fName = FFbhOc(s.uniqueId)
  fTxt = s.userTxt
  return fName, fTxt, s.VV1wIO, s.VVu06s
 @staticmethod
 def VV0NUN(fPath):
  try:
   import pickle
   with open(fPath, 'rb') as f:
    d = pickle.load(f)
    if all(k in d for k in ("v", "nm", "u", "r", "pos", "dur", "w")):
     d["nm"], d["u"], d["r"] = str(d["nm"]), str(d["u"]), str(d["r"])
     return d
  except:
   pass
  return None
 @staticmethod
 def VVc5Po(fName):
  return "%sajpanel_resume/%s" % (FF0cqc(), fName)
 @staticmethod
 def VVaNW3(session):
  serv = session.nav.getCurrentService()
  pSeek = serv and serv.seek()
  if not pSeek is None:
   durLst = pSeek.getLength()
   posLst = pSeek.getPlayPosition()
   if durLst[0] == 0 and posLst[0] == 0:
    return durLst[1], posLst[1]
  return 0, 0
class CCo1b7(CCzUSd):
 VVYCbB = "START"
 VVaGf1 = "INFO"
 VV26Iy = "EOF"
 VVEOlk = "End"
 def __init__(self, VVeO1i):
  CCzUSd.__init__(self, VVeO1i)
  self.VVeO1i   = VVeO1i
  self.VVTd3k    = eTimer()
  self.VVJA3Z    = None
  self.VV7LKE  = 0
  self.VVedk0   = ""
  self.VVr4qo   = ""
  self.lastSimulatedEOF  = ""
  self.VVazTO   = ""
  try:
   from Components.ServiceEventTracker import ServiceEventTracker
   from enigma import iPlayableService
   evTrk = ServiceEventTracker(screen=self.VVeO1i.screen, eventmap={iPlayableService.evStart: self.VV4MOb, iPlayableService.evEOF: self.VVqGXQ, iPlayableService.evEnd: self.VVUHQ4, iPlayableService.evUpdatedInfo: self.VVs2rG})
  except:
   pass
  try: self.VVTd3k_conn = self.VVTd3k.timeout.connect(self.VVCjf0)
  except: self.VVTd3k.callback.append(self.VVCjf0)
  self.VVTd3k.start(3000, False)
  self.VVCjf0()
 def VVCjf0(self):
  if not CFG.downloadMonitor.getValue():
   self.VVQoPc()
   return
  lst = CCHRcZ.VVs4T7()
  avPerc = []
  txt = ""
  if lst:
   for path, totSz, logF in lst:
    if totSz:
     totSz = int(totSz) if totSz.isdigit() else 0
     curSz = 0
     sz = FFXhoc(path)
     if sz > -1:
      curSz = sz
     if totSz:
      perc = (float(curSz) / float(totSz) * 100.0)
      avPerc.append(perc)
    elif logF:
     perc = CCHRcZ.VVlzpX(logF)
     if perc > -1:
      avPerc.append(perc)
   if lst:
    txt = "Files=%d" % len(lst)
    if avPerc:
     perc = sum(avPerc) / len(avPerc)
     if perc: txt += "   %.2f %%" % perc
  if txt:
   if not self.VVJA3Z : self.VVJA3Z = CChMGW.VVNLfa(self.VVeO1i, txt, 30)
   else    : CChMGW.VVr9Gs(self.VVJA3Z, txt)
  elif self.VVJA3Z:
   self.VVQoPc()
 def VVQoPc(self):
  if self.VVJA3Z:
   self.VVeO1i.deleteDialog(self.VVJA3Z)
   self.VVJA3Z = None
 def VV4MOb(self):
  self.VVTufo(CCo1b7.VVYCbB)
 def VVs2rG(self):
  self.VVTufo(CCo1b7.VVaGf1)
  VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
  self.VVazTO = VVX8pK
  self.VVlDEX()
 def VVUHQ4(self):
  self.VVTufo(CCo1b7.VVEOlk)
  self.VVazTO = ""
  FFOKt0(self, 1000, self.VV2VGZ)
  self.VVB1ug()
 def VVqGXQ(self):
  self.VVTufo(CCo1b7.VV26Iy)
  durVal, posVal = CCzUSd.VVaNW3(self.VVeO1i)
  if durVal and posVal and (((durVal - posVal) // 90000.0) < 5):
   return
  if CFG.autoResetFrozenIptvChan.getValue() == "off":
   return
  VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
  if not VVfaDB or "file?file" in VVfaDB or ":ftp%3a//" in VVfaDB:
   return
  if iMatch(r"http.+(?:[A-Za-f0-9]+(%3a|:)){10}", VVZcRP):
   return
  if self.VVr4qo == VVX8pK and self.VV7LKE > 0 and (iTime()- self.VV7LKE) < 10:
   return
  if self.VVazTO == VVX8pK:
   if CFG.autoResetFrozenIptvChan.getValue() == "on+":
    CChMGW(self.VVeO1i, "Refreshing")
   CCYrUm.VV0iSP(self.VVeO1i)
  elif "&end=:" in VVfaDB:
   VV1wIO = VVfaDB[VVfaDB.index("&end=:") + 6:]
   pr = CChyfE()
   if pr.VVgBJL(VVPxk5, VV1wIO, VVZcRP, VVfaDB):
    shown = InfoBar.instance.shown
    pr.VVIguo(self.VVeO1i)
    if not shown: InfoBar.instance.hide()
  self.VVr4qo = VVX8pK
  self.VV7LKE = iTime()
 def VV2VGZ(self):
  VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
  if VVPxk5.startswith("4097:") and self.lastSimulatedEOF != VVX8pK:
   FFOKt0(self, 1000, BF(self.VVMC2i, VVX8pK))
 def VVMC2i(self, ref):
  VVPxk5, VVZcRP, VVfaDB, VVX8pK = self.VVAwKT()
  if ref == VVX8pK and self.VVedk0 in (CCo1b7.VVYCbB, CCo1b7.VVEOlk):
   self.lastSimulatedEOF = VVX8pK
   self.VVqGXQ()
 def VVAwKT(self):
  s = CC3rDi(self.VVeO1i)
  return s.VVPxk5, s.VVZcRP, s.VVfaDB, s.myPhp or s.VVZcRP
 def VVTufo(self, state):
  self.VVedk0 = state
  global VVfaPN_VAL
  VVfaPN_VAL = state
class CCdt86():
 def __init__(self, SELF):
  self.SELF  = SELF
  self.Title  = "Update Current Bouquet EPG/PIcons"
  self.pPath  = CCafIt.VVjkKT()
  self.updErr  = ""
  self.isFfmpeg = FFayeZ("ffmpeg")
  self.totCh  = 0
  self.totIptv = 0
  self.totNotIptv = 0
  self.totEpgDnl = 0
  self.totPic  = 0
  self.totPicOK = 0
  self.epgLst  = []
  self.bName  = ""
  CCh3tv.VV7Nf4(SELF
      , VVixvy  = self.VVrwj0
      , VVbYwR = self.VV6fLO)
 def VVrwj0(self, VVXyP6):
  VVXyP6.VVaks5("Reading Services ...")
  self.bName = CCMvE7.VVCWrE()
  services = CCMvE7.VVqZTI()
  if not services:
   self.updErr = 'Cannot read service from: \n\n"%s"' % self.bName
   return
  elif len(services) == 0:
   self.updErr = 'No services in: \n\n"%s"' % self.bName
   return
  else:
   self.totCh = len(services)
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVq8NF(self.totCh)
  VVXyP6.VVaks5("Downloading ...")
  for ndx, (VVu06s, VV1wIO) in enumerate(services):
   if not VVXyP6 or VVXyP6.isCancelled: return
   if FFUPnc(VVu06s):
    self.totIptv += 1
    VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(VVu06s)
    if not VVXyP6 or VVXyP6.isCancelled: return
    evLst = []
    epg = VVfbmn = ""
    if VVZcRP:
     epg, evLst, VVfbmn, err = CCvjVs.VVPhf6(VVZcRP)
     if VVfbmn: self.totPic += 1
    else:
     continue
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VV6j41(self.totEpgDnl, self.totPic)
    if not epg:
     epg, evLst, err = CCkEI5.VV67It(VVZcRP)
    if evLst:
     self.epgLst.append((VVPxk5, evLst))
     self.totEpgDnl += len(evLst)
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VV6j41(self.totEpgDnl, self.totPic)
    self.totPicOK += self.VVRHhq(VVu06s, VVfbmn)
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VV6j41(self.totEpgDnl, self.totPic)
   else:
    self.totNotIptv += 1
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
 def VV6fLO(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if self.updErr:
   FFdw58(self.SELF, self.updErr, title=self.Title)
   return
  totEpgOK = 0
  for VVPxk5, evLst in self.epgLst:
   if evLst:
    totEv, totOK = CC5TsO.VV8M7K(VVPxk5, evLst)
    totEpgOK += totOK
  if totEpgOK > 0:
   CC5TsO.VVYLja()
  tab = lambda x, y: "%s\t: %s\n" % (x, y)
  txt = ""
  txt += tab("Bouquet"  , self.bName)
  txt += "\n"
  txt += tab("Services"  , self.totCh)
  txt += tab("Processed"  , self.totIptv)
  txt += tab("Non-IPTV"  , self.totNotIptv)
  txt += "\n"
  txt += tab("Events Found" , self.totEpgDnl)
  txt += tab("Events Added" , totEpgOK)
  txt += "\n"
  txt += tab("PIcons Found" , self.totPic)
  txt += tab("PIcons Added" , self.totPicOK)
  if not VVRI6P:
   self.Title += "  (stopped)"
  FF4lCP(self.SELF, txt, title=self.Title)
 def VVRHhq(self, VVu06s, url):
  if not all((url, self.isFfmpeg, VVmJwX(self.pPath))):
   return 0
  path, err = FFx9uM(url, "ajp_tmp.png", timeout=2, VVzHui=True)
  if not FFCyVu(path) or not VVmJwX(self.pPath):
   return 0
  VVPxk5 = CCvjVs.VVHamE(VVu06s)
  picon = VVPxk5.replace(":", "_") + ".png"
  cmd = CCvjVs.VVQ9GP(path)
  cmd += FFb2oQ("mv -f '%s' '%s%s'" % (path, self.pPath, picon))
  ok = FFpwZS(cmd)
  return 1 if ok else 0
class CCa36K():
 def __init__(self, VVCk9g=False):
  self.VVX6Ut  = CFG.hideIptvServerChannPrefix.getValue()
  self.VVWmRw  = VVCk9g or CFG.hideIptvServerAdultWords.getValue()
  self.VVDx9q = r"(b[-]*e[-]*I[-]*N)"
  self.VVcAqm  = r"beIN"
  self.VVcGaa = iCompile( r"\s*^[A-Za-z]{2,4}\d*\s*(?:[|:-]|[^\x00-\x7F])+\s*(.+)"
          r"|^\[.{2}\]\s*(.+\[.{2}\]\s*\[.{2,}\])"
          r"|^(?!\[)*\s*[\[(|:][ A-Za-z0-9\/\-._:|\]\[]+[\])|:](.+)"
          r"|^[A-Za-z]{,3}[^\x21-\x7E]\s(.+)")
  self.VVustK = self.VVAJyh(self.VVX6Ut, "ajpanel_iptv_prefix", False, ())
  self.VV2YHg = self.VVAJyh(self.VVWmRw, "ajpanel_iptv_blacklist", True, ("+18","18 rated","18+","aduld","adult","adulte","adulto","aikuinen","blue film","blue movie","dirty film","dirty movie","dorosly","erotic","erwachsene","porn","r-17 film","r-17 movie","r-18 film","r-18 movie","r18 film","r18 movie","sex","skin flick","voksen","volwassen","vuxen","x-rated","xrated","xxi","xx","xvideo","xyz"))
 def VVAJyh(self, cond, fName, isLower, tSet):
  tSet = set(tSet)
  if cond:
   for path in (VVIp2p, FF0cqc()):
    path += fName
    if FFCyVu(path):
     for line in FFL19l(path):
      line = line.strip()
      if len(line) >= 3:
       tSet.add(line.lower() if isLower else line)
  return tuple(sorted(tSet, key=lambda x: x.lower()))
 def VVcBrZ(self, name,  censored=""):
  if self.VVWmRw and (censored == "1" or any(x in name.lower() for x in self.VV2YHg)):
   return ""
  name = iSub(self.VVDx9q, self.VVcAqm, name, flags=IGNORECASE).strip()
  if CCkEI5.VVAP76(name):
   return CCkEI5.VVBmSe(name)
  return self.VVZNMg(name)
 def VVZNMg(self, name):
  newName = ""
  if self.VVX6Ut:
   span = iSearch(self.VVcGaa, name)
   if span:
    tName = span.group(1) or span.group(2) or span.group(3) or span.group(4)
    if not tName.startswith(("HD", "[HD]", "SD", "[SD]")):
     newName = tName
   for t in self.VVustK:
    if name.startswith(t):
     newName = name[len(t):]
     break
  return newName.strip() or name
 def VVBgSG(self, name):
  name = iSub(self.VVDx9q, self.VVcAqm, name, flags=IGNORECASE).strip()
  name = self.VVZNMg(name)
  return name.lower().replace(" hd", "").replace(" fm", "").replace(" 4k", "").replace(" tv", "").replace(" sd", "").strip()
 def VV1vXv(self, name):
  if self.VVWmRw and any(x in name.lower() for x in self.VV2YHg):
   return ""
  return name.strip()
 def VVZI1i(self, wordsList):
  lst = list(map(str.lower, wordsList))
  return any(x in self.VV2YHg for x in lst)
 def VVmBMi(self):
  return 'Cannot continue with adults words !\n\n"Skip Adults Channels" is activated in settings.'
 @staticmethod
 def VVD1PA():
  badW1 = CCwklK.VVO6rU()
  badW2 = CCwklK.VVu30K()
  nameCl = CCa36K()
  def VVZwiy(txt):
   txt = nameCl.VVZNMg(txt)
   txt = txt.replace("24/7", "")
   for ch in ":|_-+.[](){}#!@$%^*": txt = txt.replace(ch, " ")
   if len(txt) > 4: txt = iSub(r"\d{4,}", "", txt, flags=IGNORECASE)
   while "  " in txt: txt = txt.replace("  ", " ")
   words = []
   for word in txt.split():
    if not word.lower() in badW1 and not badW2.match(word):
     words.append(word)
   txt = " ".join(words)
   return txt.strip()
  return VVZwiy
class CCWz9v(CCa36K):
 def __init__(self, SELF, VVs2Wm, VVKWLJ="", VVdgZS="", cbFnc=None, chkExt=False):
  self.SELF  = SELF
  self.VVs2Wm = VVs2Wm
  self.VVKWLJ  = VVKWLJ
  self.outD  = "%s%s/" % (CCjZbZ.VVz4Ig(), VVdgZS or os.path.basename(VVs2Wm)[:-4])
  self.cbFnc  = cbFnc
  self.chkExt  = chkExt
  self.Title  = "Create Local Server"
  self.err  = ""
  self.totGrp  = 0
  self.totCh  = 0
  self.totL  = self.totLh = 0
  self.totV  = self.totVh = 0
  self.totS  = self.totSh = 0
  self.totK  = self.totKh = 0
  self.totM  = self.totMh = 0
  self.totR  = self.totRh = 0
  self.totD  = self.totDh = 0
  self.totF  = self.totFh = 0
  self.totAll  = 0
  self.lineNum = 0
  CCa36K.__init__(self, VVCk9g=True)
  CCh3tv.VV7Nf4(self.SELF, VVLL7M="Checking File ...", titleBg="#22220022", bodyBg="#22220022"
      , VVixvy  = self.VVaAJo
      , VVbYwR = self.VVUown)
 def VVaAJo(self, VVXyP6):
  if VVmJwX(self.outD):
   for f in iGlob(FFoWxR(self.outD) + "*"):
    FFwgGB(f)
  elif not FFpwZS("mkdir -p '%s'" % self.outD):
   self.err = "Cannot make directory."
   return
  par = grp = url = marker = ""
  bDict = {}
  enc, totLines = CC7ocD.VVm9FZ(self.VVs2Wm)
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVq8NF(totLines)
  with ioOpen(self.VVs2Wm, "r", encoding=enc) as f:
   for line in f:
    self.lineNum += 1
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVxtQs(1)
    line = str(line.strip())
    if line.startswith("#EXTINF:"):
     par = line
     continue
    elif line.startswith("#EXTGRP:"):
     grp = line.partition("#EXTGRP:")[2].strip()
     continue
    elif not line.startswith("#"):
     url = line
    elif line.startswith("#EXTM3U"):
     continue
    if not (par and url):
     continue
    par = par.replace('""', '" "')
    span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
    VV1wIO = (((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else "") or "No-name"
    chBlk = 0 if self.VVcBrZ(VV1wIO) else 1
    span = iSearch(r'tvg-logo="(.+?)"', par, IGNORECASE)
    icn = ((span.group(1)).replace("\t", "").strip() if span else "") or "-"
    span = iSearch(r'group-title="(.+?)"', par, IGNORECASE)
    cat = (grp or (span.group(1) if span else "")).replace("\t", "").strip()
    catBlk = 1 if cat and not self.VV1vXv(cat) else 0
    val1 = catBlk or chBlk
    typ = CCjZbZ.VVZXSg(url, self.chkExt)
    if   typ == "Live"  : self.totL, self.totLh = self.totL + 1, self.totLh + 1 * val1
    elif typ == "VOD"  : self.totV, self.totVh = self.totV + 1, self.totVh + 1 * val1
    elif typ == "Series" : self.totS, self.totSh = self.totS + 1, self.totSh + 1 * val1
    elif typ == "Marker" : self.totK, self.totKh = self.totK + 1, self.totKh + 1 * val1
    elif typ == "Movie"  : self.totM, self.totMh = self.totM + 1, self.totMh + 1 * val1
    elif typ == "S.Relay" : self.totR, self.totRh = self.totR + 1, self.totRh + 1 * val1
    elif typ == "DVB"  : self.totD, self.totDh = self.totD + 1, self.totDh + 1 * val1
    elif typ == "FTP"  : self.totF, self.totFh = self.totF + 1, self.totFh + 1 * val1
    cat = cat or "* Uncategorized %s Channels *" % typ
    VVXyP6.VVaks5("Ch=%s  ( L=%s  V=%s  S=%s )" % (self.totCh, self.totL, self.totV, self.totS))
    if typ == "Marker":
     marker = "%s\t%s\t%s\n" % (url, VV1wIO, "-")
     continue
    fileId = typ + cat
    fName = FFbhOc(fileId)
    totCh = (bDict[fileId][3] + 1) if fileId in bDict else 1
    bDict[fileId] = (typ, catBlk, fName, totCh, cat)
    with open(self.outD + fName, "a") as f:
     if marker:
      f.write(marker)
      marker = ""
      self.totAll += 1
     f.write("%s\t%s\t%s\t%s\n" % (chBlk or catBlk, url, VV1wIO, icn))
     self.totCh += 1
     self.totAll += 1
    par = grp = url = ""
  self.totGrp = len(bDict)
  if bDict:
   bLst = ["\t".join((typ, str(catBlk), fName, str(totCh), cat)) for ttl, (typ, catBlk, fName, totCh, cat) in bDict.items()]
   if bLst:
    try: fmTime = int(os.path.getmtime(self.VVs2Wm))
    except: fmTime = ""
    tab = lambda x, y: "#" + " %s: %s\n" % (x, y)
    with open(os.path.join(self.outD, "_main"), "w") as f:
     f.write(tab("File"  , self.VVs2Wm))
     f.write(tab("Modified" , fmTime))
     f.write(tab("URL"  , self.VVKWLJ.partition("&type")[0]))
     f.write(tab("Saved"  , FFIPdt()))
     f.write(tab("Entries" , self.totAll))
     f.write(tab("Services" , self.totCh))
     f.write(tab("Live"  , self.totL))
     f.write(tab("VOD"  , self.totV))
     f.write(tab("Series" , self.totS))
     if self.totK: f.write(tab("Marker" , self.totK))
     if self.totM: f.write(tab("Movie" , self.totM))
     if self.totR: f.write(tab("S.Relay" , self.totR))
     if self.totD: f.write(tab("DVB"  , self.totD))
     if self.totF: f.write(tab("FTP"  , self.totF))
     if self.totLh: f.write(tab("Blk_Live" , self.totLh))
     if self.totVh: f.write(tab("Blk_VOD" , self.totVh))
     if self.totSh: f.write(tab("Blk_Series" , self.totSh))
     if self.totKh: f.write(tab("Blk_Marker" , self.totKh))
     if self.totMh: f.write(tab("Blk_Movie" , self.totMh))
     if self.totRh: f.write(tab("Blk_S.Relay", self.totRh))
     if self.totDh: f.write(tab("Blk_DVB" , self.totDh))
     if self.totFh: f.write(tab("Blk_FTP" , self.totFh))
     f.write("\n".join(bLst))
 def VVUown(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  mainOk = FFCyVu(os.path.join(self.outD, "_main"))
  if not VVRI6P or not mainOk:
   FFVyW4(self.outD)
  ln = "\n\nLine Number : %s" % self.lineNum
  if   not VVRI6P     : pass
  elif self.err      : FFdw58(self.SELF, self.err, self.Title)
  elif threadCounter != threadTotal : FFdw58(self.SELF, "Error in conversion process %s" % ln, self.Title)
  elif not mainOk      : FFdw58(self.SELF, "Cannot extract channels", self.Title)
  elif self.cbFnc      : self.cbFnc(self.VVs2Wm, self.outD)
  else:
   tab = lambda x, y: "%s\t: %s\n" % (x, y)
   txt  = tab("Groups", self.totGrp)
   txt += tab("Services", self.totCh)
   txt += tab("\nEntries" , self.totAll)
   txt += tab("  Live"  , self.totL)
   txt += tab("  VOD"  , self.totV)
   txt += tab("  Series" , self.totS)
   txt += tab("  Movie" , self.totM)
   txt += tab("  DVB"  , self.totD)
   txt += tab("  S.Relay" , self.totR)
   txt += tab("  FTP"  , self.totF)
   txt += tab("  Marker" , self.totK)
   txt += "\n%s\n%s" % (FFjt5L("Output File:", VVJEMb), self.outD)
   FF4lCP(self.SELF, txt, self.Title)
class CCjZbZ(CCa36K):
 VVbu5l   = 0
 VVCAqE  = 1
 VVWcXC = 2
 VVCKX0 = 3
 VV4Vv0  = 4
 VVry11   = 5
 def __init__(self, SELF, mode, url="", m3uF="", VVMye8=None):
  self.SELF   = SELF
  self.mode   = mode
  self.VVMye8= VVMye8
  self.Title   = "Local Servers & M3U Cache"
  self.VVjS9t  = ""
  self.url   = ""
  self.hst   = ""
  self.usr   = ""
  self.pas   = ""
  self.VVGWyE  = ""
  self.VVLLPC   = ""
  CCa36K.__init__(self)
  if not iZip:
   SELF.VVQ5VQ('"zipfile" Module not found !')
   return
  if   mode == CCjZbZ.VVbu5l   : self.VVVrOO()
  elif mode == CCjZbZ.VVCAqE  : self.VVLdPO(self.SELF, m3uF)
  elif mode == CCjZbZ.VVWcXC : self.VVt4iC(m3uF)
  elif mode == CCjZbZ.VVCKX0: self.VVV72a(url)
  elif mode == CCjZbZ.VV4Vv0 : self.VVV72a(url)
  elif mode == CCjZbZ.VVry11   : self.VVLdPO(self.SELF, m3uF)
 def VVV72a(self, url):
  self.url = url
  self.hst, self.usr, self.pas, self.VVGWyE = CCjZbZ.VVir5C(self.url)
  if not all((self.hst, self.usr, self.pas, self.VVGWyE)):
   self.VVQ5VQ("Cannot process URL")
   return
  c1, c2, c3 = VVJEMb, VVFuwR, VVZtfx
  VV3wat = []
  zipFile = "%s%s.zip" % (CCjZbZ.VVz4Ig(), self.VVGWyE)
  if FFCyVu(zipFile):
   VV3wat.append((c1 + "Browse Local Server", "brwLS"))
   VV3wat.append((c1 + "Update Local Server", "updLS"))
  else:
   VV3wat.append((c1 + "Download Resources and Browse Locally", "newLS"))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Save to M3U (Live/VOD)"   , "toM3U1"))
  VV3wat.append((c2 + "Save to M3U (Live/VOD/Series)" , "toM3U2"))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Download M3U  (Live=ts)"     , "ful" ))
  VV3wat.append((c3 + "Download M3U  (Live=m3u8)"    , "ful8"))
  VV3wat.append((c3 + "Download M3U  (Uncategorized Channels)" , "low" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Download EPG (XML-TV File)", "epg"))
  FFLFTC(self.SELF, BF(self.VVMDHX, zipFile), title="Server Resources", VV3wat=VV3wat, width=1000, VVU8mZ=True, VVwltY="#22002233", VVkxBG="#22001122")
 def VVMDHX(self, zipFile, item=""):
  if item:
   title, ref, ndx = item
   if   ref == "brwLS" : self.VVF0tW(zipFile)
   elif ref == "updLS" : FFRMYv(self.SELF, BF(self.VVFVJ5, title, "newLS"), 'Update Local Cache ?\n\n"%s"' % self.VVGWyE, title=self.Title)
   elif ref == "toM3U1": self.SELF.VVLk4s(0, self.hst, self.usr, self.pas, title)
   elif ref == "toM3U2": self.SELF.VVLk4s(1, self.hst, self.usr, self.pas, title)
   else    : self.VVFVJ5(title, ref)
 def VVFVJ5(self, title, ref):
  if ref == "epg" : ext, php, fNm, typ = "xml", "xmltv", "epg"  , ""
  else   : ext, php, fNm, typ = "m3u", "get"  , "channels_" , "&type=m3u"
  if ref in ("newLS", "ful", "ful8"): typ += "_plus"
  if ref == "ful8": typ += "&output=m3u8"
  url = "%s/%s.php?username=%s&password=%s%s" % (self.hst, php, self.usr, self.pas, typ)
  if   ref == "epg": pass
  elif ref == "low": fNm += "uncat"
  else    : fNm += "grouped_" + ("m3u8" if ref == "ful8" else "ts")
  fName = "%s_%s_%s.%s" % (iUrlparse(self.hst).hostname, fNm, FFjTQe(), ext)
  cbFnc = self.VVgIYM if ref == "newLS" else None
  timeout = 90
  CCzCDl(self.SELF, url, os.path.join(FF0cqc(), fName), title=self.Title, pbTxt="Preparing file in server ...", cbFnc=cbFnc, timeout=timeout)
 def VVgIYM(self, ok, url, webFile, path):
  if ok:
   VVuPkC = iUrlparse(url).hostname
   cbFnc = BF(self.VVquSl, True)
   CCWz9v(self.SELF, VVs2Wm=path, VVKWLJ=url, VVdgZS=VVuPkC, cbFnc=cbFnc)
  else:
   FFwgGB(path)
 def VVt4iC(self, path):
  m3File, m3Dir, VVcwFG, zPath, zFound = CCjZbZ.VVuYvs(path)
  cbFnc = BF(self.VVquSl, False)
  CCWz9v(self.SELF, VVs2Wm=path, VVdgZS=VVcwFG, cbFnc=cbFnc)
 def VVquSl(self, delSrc, path, outD):
  if VVmJwX(outD):
   if delSrc : FFwgGB(path)
   VVTiJ2 = outD.rstrip("/") + ".zip"
   CCjZbZ.VVICcD(self.SELF, outD, VVTiJ2, cbFnc=BF(self.VVPlwE, outD))
 def VVPlwE(self, outD, VVTiJ2, tot, err):
  FFVyW4(outD)
  if   tot: self.VVF0tW(VVTiJ2)
  elif err: self.VVQ5VQ(err)
  else : self.VVQ5VQ("No files to compress !")
 @FFOAKH("Checking File Encoding ...", par=1)
 def VVLdPO(self, SELF, path):
  if not self.VVdT8C(path):
   m3File, m3Dir, VVcwFG, zPath, zFound = CCjZbZ.VVuYvs(path)
   if zFound: self.VVF0tW(zPath)
   else  : self.VVt4iC(path)
 def VVdT8C(self, path):
  if FFXhoc(path) > pow(10, 4):
   return False
  m3u8 = False
  lst = []
  par = url = ""
  try:
   enc = CC7ocD.VV51oT(path)
   with ioOpen(path, "r", encoding=enc) as f:
    c = 0
    for line in f:
     c += 1
     line = str(line).strip()
     if   c > 30          : break
     elif line.startswith("#EXTM3U")     : continue
     elif line.startswith("#EXTINF:")    : par = line
     elif line.startswith("#EXT-X-MEDIA-SEQUENCE:") : m3u8 = True
     elif par and not line.startswith("#")   : url = line
     if par and url:
      lst.append((par, url))
  except:
   self.VVQ5VQ("Cannot read file.\n\n%s" % path)
   return True
  if m3u8:
   VV1wIO = os.path.splitext(os.path.basename(path))[0]
   VVPxk5, chUrl, VVZcRP = CCjZbZ.VVYrGK(1, path, VV1wIO)
   CCqWM2.VVHc02(self.SELF.session, VVaHNe=chUrl)
   return True
  if len(lst) == 1: par, url = lst[0]
  else   : return False
  if iMatch(r"^(?:[A-Za-z0-9]+:){10}$", url):
   CCqWM2.VVHc02(self.SELF.session, VVaHNe=url)
   return True
  span = iSearch(r"^http.+((?:[A-Za-z0-9]+:){10})$", url)
  if span:
   CCqWM2.VVHc02(self.SELF.session, VVaHNe=span.group(1))
   return True
  span = iSearch(r"^http.+\/((?:[A-Za-z0-9]+:){10}\/.+)", url)
  if span:
   CCqWM2.VVHc02(self.SELF.session, VVaHNe=span.group(1))
   return True
  span = iSearch(r'(?:tvg-name="(.+?)")*.+,(.+)', par, IGNORECASE)
  VV1wIO = ((span.group(1) or span.group(2))).replace(":", "|").replace("||", "|").strip() if span else ""
  VV1wIO = VV1wIO or os.path.splitext(os.path.basename(path))[0]
  span = iSearch(r"^((?:[A-Za-z0-9]+:){10})(http.+(?:[A-Za-z0-9]+:){10})$", url)
  if span:
   chUrl = "%s%s:%s" % (span.group(1), FFSiPR(span.group(2)), VV1wIO)
   CCqWM2.VVHc02(self.SELF.session, VVaHNe=chUrl)
   return True
  return False
 def VVVrOO(self):
  lst = [(os.path.splitext(os.path.basename(f))[0], f) for f in iGlob("%s/*.zip" % CCjZbZ.VVz4Ig()) if os.path.isfile(f)]
  if lst:
   lst.sort(key=lambda x: x[0].lower())
   VVOa1G  = self.VVCvez
   VVJbOd  = self.VVQlNq
   VVHGnw  = ("Home Menu" , FF8lJ1)
   VVaTeF  = ("Rename" , self.VVhYc1)
   FFLFTC(self.SELF, None, title=self.Title, VV3wat=lst, width=1200, VVyRCy=3, VVtboQ="", VVOa1G=VVOa1G, VVJbOd=VVJbOd, VVHGnw=VVHGnw, VVaTeF=VVaTeF
     , VVwltY="#08000011", VVkxBG="#08111122", VVoCB2="#08333344")
  else:
   self.VVQ5VQ('No Local Servers.\n\nYou can add local server form %s.' % FFjt5L("Server Resources", VVFuwR))
 def VVCvez(self, item):
  self.VVF0tW(item[2])
 def VVQlNq(self, VV7tND, txt, ref, ndx):
  self.VVcsah(ref)
 def VVhYc1(self, VV7tND, path):
  oName = os.path.basename(path)[:-4]
  FF4z45(self.SELF, BF(self.VVq4FS, VV7tND, path, oName), defaultText=oName, title="Rename", message="New name")
 def VVq4FS(self, VV7tND, path, oName, nName):
  if not nName or not nName.strip(): return
  title = "Rename : %s" % oName
  nName = nName.strip()
  nPath = os.path.join(os.path.dirname(path), "%s.zip" % nName)
  if   path == nPath  : FF28n1(VV7tND, "No change", 800)
  elif FFCyVu(nPath) : FFdw58(self.SELF, "Name already exists:\n\n%s" % nName, title=title)
  else     : FFRMYv(self.SELF, BF(self.VV8Z0k, VV7tND, title, path, nPath, nName), "Rename to:\n\n%s" % nName, title=title)
 def VV8Z0k(self, VV7tND, title, path, nPath, nName):
  try:
   os.rename(path, nPath)
   VV7tND.VVKjBW((nName, nPath))
   FF1mVE(VV7tND, "Renamed", 800)
  except Exception as e:
   FFdw58(self.SELF, str(e), title=title)
 def VVF0tW(self, path):
  if path:
   self.VVLLPC = path
   title = os.path.splitext(FFxtW5(path))[0]
   if len(title) > 40: title = "%s .." % title[:40]
   cl = CCjZbZ.VVs0Rm(path)
   if cl.err or not cl.valid or not cl.totAll:
    self.VVQ5VQ("Invalid file:\n\n%s" % os.path.basename(path))
    return
   lst = []
   lst.append(("Live" , cl.totL, cl.totChL))
   lst.append(("VOD" , cl.totV, cl.totChV))
   lst.append(("Series", cl.totS, cl.totChS))
   if cl.totM or cl.totChM: lst.append(("Movie" , cl.totM, cl.totChM))
   if cl.totD or cl.totChD: lst.append(("DVB"  , cl.totD, cl.totChD))
   if cl.totR or cl.totChR: lst.append(("S.Relay" , cl.totR, cl.totChR))
   if cl.totF or cl.totChF: lst.append(("FTP"  , cl.totF, cl.totChF))
   lst = [(s, str(g), str(ch))for s, g, ch in lst]
   yelBtn = self.mode != CCjZbZ.VVbu5l
   VVu1YM  = (""    , BF(self.VVImuI, path)   , [])
   VV2ytr = (""    , BF(self.VV7sbT, path) , [])
   VVwWmA = ("Home Menu"  , FF8lJ1             , [])
   VVScQz = ("Delete Cache" , BF(self.VVhhAb, path) , []) if yelBtn else None
   header  = ("Type" , "Groups" , "Channels")
   widths  = (50  , 25  , 25  )
   VVLIqP = (LEFT  , CENTER , CENTER )
   FFUQ0v(self.SELF, self.VVMye8, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths
     , VVllEU=30, VViIEz=20, width=1000, VVwdmN=28, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVScQz=VVScQz, VVKDPJ=2
     , VVwltY="#08222233", VVkxBG="#08222233", VVemyB="#08222233", VVJKqd="#083a4a4a", VVbcr0="#08222233", VVX9AA="#08333355")
 def VV7sbT(self, path, VV6A99, txt, ref, ndx):
  self.VVcsah(path)
 def VVhhAb(self, path, VV6A99, txt, ref, ndx):
  FFRMYv(self.SELF, BF(self.VVTGie, VV6A99, path), "Delete ?\n\n%s" % path, title="Delete Local Cache")
 def VVTGie(self, VV6A99, path):
  FFwgGB(path)
  if FFCyVu(path) : FF28n1(VV6A99, "No deleted", 1000)
  else    : VV6A99.close()
 @FFOAKH(par=2)
 def VVImuI(self, path, VV6A99, title, txt, colList):
  self.VVjS9t = colList[0]
  lines, err = CCjZbZ.VV2LK6(path, "_main", mode=1)
  if err:
   self.VVQ5VQ(err)
   return
  lst = []
  srcFil = VVKWLJ = srcTm = ""
  for line in lines:
   if line.startswith("#"):
    subj, _, val = line.partition(":")
    subj, val = subj[1:].strip().lower(), val.strip()
    if   subj == "file"  : srcFil = val
    elif subj == "url"   : VVKWLJ = val
    elif subj == "created" : srcTm  = val
   else:
    parts = line.split("\t")
    if len(parts) == 5:
     typ, catBlk, fName, totCh, cat = parts
     cat = self.VV1vXv(cat)
     if cat and typ == self.VVjS9t:
      lst.append((cat, totCh, fName))
  if len(lst) == 1 and iMatch(r"\* Uncategorized.+Channels \*", lst[0][0]):
   self.VVv1KP(VV6A99, path, lst[0][0], lst[0][2])
  elif lst:
   mode = {"l": CCkEI5.VVgkvV, "v": CCkEI5.VVgL8R, "s": CCkEI5.VV6cbr}.get(self.VVjS9t[:1].lower())
   VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D(mode)
   lst.sort(key=lambda x: x[0].lower())
   VVu1YM  = ("Channels" , BF(self.VVZIbs, path), [])
   VVwWmA = ("Home Menu" , FF8lJ1         , [])
   VVScQz = ("Find in %s" % self.VVjS9t, BF(self.VVdWVr, path) , [])
   header  = ("Category" , "Channels", "fName")
   widths  = (84   , 16  , 0   )
   VVLIqP = (LEFT   , CENTER , CENTER )
   FFUQ0v(self.SELF, None, title=self.VVjS9t, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, height=960, VVwdmN=30, VVu1YM=VVu1YM, VVwWmA=VVwWmA, VVScQz=VVScQz, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
  else:
   FFjADj(VV6A99, "No Groups/Channels", 1000)
 def VVdWVr(self, path, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("Keyboard"  , "manualEntry"))
  VV3wat.append(("From Filter" , "fromFilter"))
  FFLFTC(self.SELF, BF(self.VVwY9a, VV6A99, path), title="Input Type", VV3wat=VV3wat, width=400)
 def VVwY9a(self, VV6A99, path, item=None):
  if item == "manualEntry":
   FF4z45(self.SELF, BF(self.VVpIvt, VV6A99, path), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCoErY(self.SELF)
   filterObj.VVVPGN(BF(self.VVpIvt, VV6A99, path))
 def VVpIvt(self, VV6A99, path, item):
  if not item is None:
   title = "Find in %s" % self.VVjS9t
   words = None
   toFind = item.strip()
   FFjt1c(CFG.lastFindIptv, toFind)
   if toFind:
    words, asPrefix = CCoErY.VVPBNm(toFind)
    if words:
     if len(words) == 1 and len(words[0]) < 3:
      self.VVQ5VQ("Enter at least 3 characters.", title=title)
      return
     else:
      for word in words:
       if len(word) < 3:
        self.VVQ5VQ("All words must be at least 3 characters !", title=title)
        return
     if CFG.hideIptvServerAdultWords.getValue() and self.VVZI1i(words):
      self.VVQ5VQ(self.VVmBMi(), title="Find: %s" % " , ".join(words))
      return
     else:
      CCh3tv.VV7Nf4(self.SELF, VVLL7M="Searching for:%s" % toFind[:15], totBars=2
          , VVixvy  = BF(self.VVQ6ks, VV6A99, path, title, words, toFind, asPrefix)
          , VVbYwR = BF(self.VVjprO, VV6A99, title))
   if not words:
    FF28n1(VV6A99, "Nothing to find !", 1500)
 def VVQ6ks(self, VV6A99, path, title, words, toFind, asPrefix, VVXyP6):
  VVXyP6.VVNc18 = []
  VVXyP6.VVq8NF(VV6A99.VVn1uo())
  c = 0
  for ndx, (cat, totCh, fName) in enumerate(VV6A99.VVrrm9()):
   lines, err = CCjZbZ.VV2LK6(path, fName, mode=1)
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
   VVXyP6.VVUIH1(len(lines))
   VVXyP6.VVV3RA(0)
   VVXyP6.VVSW9b(cat)
   for line in lines:
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVg2Dw(1)
    parts = line.split("\t")
    if len(parts) == 4:
     chBlk, url, name, icn = parts
     name = self.VVcBrZ(name)
     if name:
      nm = name.lower()
      if asPrefix and not nm.startswith(words): continue
      elif any(x in nm for x in words)  : pass
      else         : continue
      if CCkEI5.VVAP76(name):
       name = CCkEI5.VVBmSe(name)
      if icn == "-": icn =""
      c += 1
      if not VVXyP6 or VVXyP6.isCancelled: return
      VVXyP6.VVNc18.append((str(c), name, "Yes" if icn else "", url, icn))
 def VVjprO(self, winObj, cat, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18 : self.VVtKxj(cat, VVNc18)
  elif VVRI6P : FFjADj(winObj, "Not found", 1500)
 def VVZIbs(self, path, VV6A99, title, txt, colList):
  cat, totCh, fName = colList
  self.VVv1KP(VV6A99, path, cat, fName)
 def VVv1KP(self, winObj, path, cat, fName):
  CCh3tv.VV7Nf4(self.SELF, VVLL7M="Reading Channels ...", VVIZBP=CCh3tv.VVgJkc
      , VVixvy  = BF(self.VVWSvQ, path, fName)
      , VVbYwR = BF(self.VV2e9Q, winObj, cat))
 def VVWSvQ(self, path, fName, VVXyP6):
  VVXyP6.VVNc18 = []
  lines, err = CCjZbZ.VV2LK6(path, fName, mode=1)
  if err:
   self.VVQ5VQ(err)
   return
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVq8NF(len(lines))
  c = 0
  for line in lines:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
   parts = line.split("\t")
   if len(parts) == 4:
    chBlk, url, name, icn = parts
    name = self.VVcBrZ(name)
    if name:
     if CCkEI5.VVAP76(name):
      name = CCkEI5.VVBmSe(name)
     if icn == "-": icn =""
     c += 1
     if not VVXyP6 or VVXyP6.isCancelled: return
     VVXyP6.VVNc18.append((str(c), name, "Yes" if icn else "", url, icn))
 def VV2e9Q(self, winObj, cat, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18 : self.VVtKxj(cat, VVNc18)
  else   : FFjADj(winObj, "No channels", 1000)
 def VVtKxj(self, cat, lst):
  showGrn = self.VVIcUn() != "m3u"
  VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D(CCkEI5.VVXewY)
  VVu1YM  = ("Play"   , self.VVcz9s   , [])
  VV2ytr = (""    , self.VVPzom, [])
  VVwWmA = ("Home Menu"  , FF8lJ1      , [])
  VVwSzI = ("Download Options", self.VVC0sq,[]) if showGrn else None
  VVScQz = ("Options"  , BF(self.VV8t6b, cat), [])
  VV4QTJ = ("Posters Mode" , self.VVelOl , [])
  header  = ("Num" , "Name", "Logo", "url" , "icn" )
  widths  = (8  , 84 , 8  , 0  , 0  )
  VVLIqP = (CENTER , LEFT , CENTER, CENTER, CENTER)
  FFUQ0v(self.SELF, None, title=cat, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
 def VV8t6b(self, VVIu85, VV6A99, title, txt, colList):
  isMulti = VV6A99.VVXWPu
  itemsOK = True
  totTxt = "ALL"
  if isMulti:
   tot = VV6A99.VVc5NH()
   totTxt = "%d Service%s" % (tot, FFcacr(tot))
   if tot < 1:
    itemsOK = False
  totTxt = FFjt5L(totTxt, VVFuwR)
  cl = CCjZbZ.VVs0Rm(self.VVLLPC)
  hst, usr, pas, VVGWyE = CCjZbZ.VVir5C(cl.VVKWLJ)
  if not VVGWyE:
   num, name, logo, url, VVfbmn = colList
   hst, usr, pas, VVGWyE = CCjZbZ.VVir5C(url)
  VVIu852 = ("%s (%s)" % (VVIu85, VVGWyE)) if VVGWyE else ""
  mSel = CCzSCo(self.SELF, VV6A99, addSep=False, setsOk=True, setsBlue=True)
  VV3wat, cbFncDict = [], None
  VV3wat.append(VVAL3j)
  if itemsOK:
   VV3wat.append(("Add %s to New Bouquet : %s"    % (totTxt, FFjt5L(VVIu85 , VVSGsk)), "addToCur1"))
   if VVIu852: VV3wat.append(("Add %s to New Bouquet : %s" % (totTxt, FFjt5L(VVIu852, VVGCYL)) , "addToCur2"))
   VV3wat.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
   title = "Add to Bouquet"
   cbFncDict = { "addToCur1": BF(self.VVb9G5 , VVIu85 , VV6A99, title)
      , "addToCur2": BF(self.VVb9G5 , VVIu852, VV6A99, title)
      , "addToNew" : BF(self.VVGjBm, VVIu85, VV6A99, title)
      }
  else:
   VV3wat.append(("Add to Bouquet (nothing selected)", ))
  mSel.VV9VR2(VV3wat, cbFncDict, width=1400)
 @FFOAKH("Adding Services ...", par=2)
 def VVb9G5(self, VVIu85, VV6A99, Title):
  chUrlLst = self.VV1tr7(VV6A99)
  CCMvE7.VVPJK0(self.SELF, Title, VVIu85, "", chUrlLst)
 def VVGjBm(self, VVIu85, VV6A99, Title):
  picker = CCMvE7(self.SELF, VV6A99, Title, BF(self.VV1tr7, VV6A99), VVFjhV=VVIu85)
 def VV1tr7(self, VV6A99):
  isMulti = VV6A99.VVXWPu
  chUrlLst = []
  rowNum = 0
  for ndx, (num, name, logo, url, VVfbmn) in enumerate(VV6A99.VVrrm9()):
   if not isMulti or VV6A99.VVvlf4(ndx):
    chUrl = self.VVBIA4(rowNum, url, name)
    rowNum += 1
    if chUrl and name:
     chUrlLst.append(chUrl)
  return chUrlLst
 def VVC0sq(self, VV6A99, title, txt, colList):
  isMulti = VV6A99.VVXWPu
  tot  = VV6A99.VVc5NH()
  if isMulti:
   if tot < 1:
    FF28n1(VV6A99, "Select rows first.", 1000)
    return
   else:
    name = "%d Selected" % tot
   plural = FFcacr(tot)
  else:
   name = "ALL"
   plural = "s"
  VV3wat = []
  VV3wat.append(("Download %s %s%s" % (name, "PIcon" if self.VVjS9t == "Live" else "Poster", plural), "dnldPicons" ))
  if self.VVjS9t in ("VOD", "Series"):
   VV3wat.append(VVAL3j)
   tName = "Movie" if self.VVjS9t == "VOD" else "Episode"
   VV3wat.append(("Download Current %s" % tName    , "dnldSel"  ))
   VV3wat.append(("Add Current %s to Download List" % tName , "addSel"  ))
   if not CCHRcZ.VVAbZK():
    VV3wat.append(VVAL3j)
    VV3wat.append(("Download Manager"      , "dload_stat" ))
  FFLFTC(self.SELF, BF(self.VVn1PO, VV6A99, colList), title="Download Options", VV3wat=VV3wat)
 def VVn1PO(self, VV6A99, colList, item=None):
  if item:
   if   item == "dnldPicons" : CCkEI5.VVE5LS(self.SELF, VV6A99, "m3u")
   elif item == "dnldSel"  : self.VVKXOQ(VV6A99, colList, True)
   elif item == "addSel"  : self.VVKXOQ(VV6A99, colList, False)
   elif item == "dload_stat" : CCHRcZ.VVSZMa(self.SELF, VV6A99)
 def VVKXOQ(self, VV6A99, colList, startDnld):
  VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
  if startDnld:
   CCHRcZ.VVXNDk(self.SELF, VVZcRP)
  else:
   self.VVtE9u(VV6A99, "Add to Download list", VV1wIO, [VVZcRP], startDnld)
 def VVtE9u(self, VV6A99, title, VV1wIO, VVC9AM, startDnld):
  FFRMYv(self.SELF, BF(self.VVDOiu, VV6A99, VVC9AM, startDnld), VV1wIO, title=title)
 def VVDOiu(self, VV6A99, VVC9AM, startDnld):
  added, skipped = CCHRcZ.VVNrGg(VVC9AM)
  FF28n1(VV6A99, "Added", 1000)
 def VVcz9s(self, VV6A99, title, txt, colList):
  VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
  if isMark:
   FF28n1(VV6A99, "Cannot play markers", 500)
  else:
   chUrl = CCwhE4.VVtjAF(self.SELF, chUrl)
   VVAfO9 = self.VV0w88(VVfbmn)
   CCqWM2.VVHc02(self.SELF.session, VVwqHQ=(self, VV6A99, "localServer"), VVaHNe=chUrl, VVAfO9=VVAfO9)
 def VVDnYt(self, colList):
  return CCjZbZ.VVOteG(self.SELF, colList)
 def VVJlyo(self, VV6A99, colList, isUp):
  VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
  if isMark:
   for i in range(VV6A99.VVn1uo()):
    if isUp : VV6A99.VVIRjv()
    else : VV6A99.VVgexy()
    VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(VV6A99.VV5crm())
    if not isMark:
     break
  VVAfO9 = self.VV0w88(VVfbmn)
  return VV1wIO, chUrl, VVAfO9
 def VVPzom(self, VV6A99, title, txt, colList):
  VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = self.VVDnYt(colList)
  CCvjVs.VV0Xds(self.SELF, VV7VUc=CCvjVs.VV1YsH, params=(VVPxk5, VV1wIO, txt, chUrl, VVfbmn))
 def VVelOl(self, VV6A99, title, txt, colList):
  FFimQ3(VV6A99, BF(self.SELF.session.open, CCUYzx, VV6A99, self.VVvlpm(), 1, 4, 0, "Num"))
 def VVIcUn(self):
  return self.VVjS9t.lower() if self.VVjS9t in ("Live", "VOD", "Series") else "m3u"
 def VVvlpm(self):
  return CCkEI5.VVYrUH(self.VVIcUn())
 def VV0w88(self, VVfbmn):
  return os.path.join(self.VVvlpm(), os.path.basename(VVfbmn)) if VVfbmn else ""
 def VVcsah(self, path):
  cl = CCjZbZ.VVs0Rm(path)
  srcFil = cl.srcFil or path
  if any((srcFil, cl.srv, cl.VVKWLJ, cl.srcTm, cl.totAll)):
   c1 = VVFuwR
   tab = lambda x, y: ("   %s\t: %s\n" % (x, y))
   tab1 = lambda x, y: ("   %s\t: %s\n" % (x, y)) if y else ""
   ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, c1), str(y)) if y else ""
   txt  = ttl("Name"  , cl.srv)
   txt += ttl("Saved"  , cl.srcTm)
   if FFCyVu(srcFil):
    t = srcFil + FFjt5L("\nNote : Original file was modified.", VVyFI2) if cl.toUpd else ""
    txt += ttl("Source File", t)
   txt += ttl("Source URL"  , cl.VVKWLJ)
   txt += FFjt5L("Total:\n", c1)
   txt += tab("Groups"  , cl.totGrp)
   txt += tab("Services" , cl.totSrv)
   if cl.totEnt:
    txt += FFjt5L("\nEntries (%s):\n" % cl.totEnt, c1)
    txt += tab1("  Live" , cl.totChL)
    txt += tab1("  VOD"  , cl.totChV)
    txt += tab1("  Series" , cl.totChS)
    txt += tab1("  Movie" , cl.totChM)
    txt += tab1("  DVB"  , cl.totChD)
    txt += tab1("  S.Relay" , cl.totChR)
    txt += tab1("  FTP"  , cl.totChF)
    txt += tab1("  Marker" , cl.totChK)
   FF4lCP(self.SELF, txt, "Services")
  else:
   FF28n1(VV7tND, "No info", 500)
 @staticmethod
 def VVs0Rm(path):
  class CCDNtC():
   def __init__(self):
    self.srv = os.path.splitext(FFxtW5(path))[0]
    self.srcFil = self.srcMod = self.VVKWLJ = self.srcTm = ""
    self.totL = self.totV = self.totS = self.totM = self.totD = self.totR = self.totF = 0
    self.totChL = self.totChV = self.totChS = self.totChM = self.totChD = self.totChR = self.totChF = self.totChK = 0
    self.totEnt = self.totSrv = self.totAll = 0
    self.valid = False
    self.toUpd = False
    self.err = ""
    lines, self.err = CCjZbZ.VV2LK6(path, "_main", mode=1)
    if self.err:
     return
    skip = CFG.hideIptvServerAdultWords.getValue()
    tab1 = lambda s, v, t: int(v) if s == t and v.isdigit() else 0
    tab2 = lambda s, v, t: int(v) if s == "blk_" + t and v.isdigit() else 0
    tab3 = lambda x, catBlk: 1 if (line.startswith(x) and not (skip and catBlk)) else 0
    for line in lines:
     if line.startswith("#"):
      subj, _, val = line.partition(":")
      subj, val = subj[1:].strip().lower(), val.strip()
      if   subj == "file"  : self.srcFil = val
      elif subj == "modified" : self.srcMod = val
      elif subj == "url"  : self.VVKWLJ = val
      elif subj == "saved" : self.srcTm  = val
      elif subj == "entries" : self.totEnt = val
      elif subj == "services" : self.totSrv = val
      self.totChL += tab1(subj, val, "live" )
      self.totChV += tab1(subj, val, "vod" )
      self.totChS += tab1(subj, val, "series" )
      self.totChM += tab1(subj, val, "movie" )
      self.totChD += tab1(subj, val, "dvb" )
      self.totChR += tab1(subj, val, "s.relay")
      self.totChF += tab1(subj, val, "ftp" )
      self.totChK += tab1(subj, val, "marker" )
      if skip:
       self.totChL -= tab2(subj, val, "live" )
       self.totChV -= tab2(subj, val, "vod" )
       self.totChS -= tab2(subj, val, "series" )
       self.totChM -= tab2(subj, val, "movie" )
       self.totChD -= tab2(subj, val, "dvb" )
       self.totChR -= tab2(subj, val, "s.relay")
       self.totChF -= tab2(subj, val, "ftp" )
       self.totChK -= tab2(subj, val, "marker" )
     else:
      parts = line.split("\t")
      if len(parts) == 5:
       typ, catBlk, fName, totCh, cat = line.split("\t")
       catBlk = catBlk == "1"
       self.totL += tab3("Live" , catBlk)
       self.totV += tab3("VOD"  , catBlk)
       self.totS += tab3("Series" , catBlk)
       self.totM += tab3("Movie" , catBlk)
       self.totD += tab3("DVB"  , catBlk)
       self.totR += tab3("S.Relay" , catBlk)
       self.totF += tab3("FTP"  , catBlk)
    self.totGrp = self.totL + self.totV + self.totS + self.totM + self.totD + self.totR + self.totF
    self.totCh = self.totChL + self.totChV + self.totChS + self.totChM + self.totChD + self.totChR + self.totChF
    self.totAll = self.totGrp + self.totCh
    self.valid = any((self.srv, self.srcFil, self.VVKWLJ, self.srcTm, self.totAll))
    if self.srcMod and FFCyVu(self.srcFil):
     try:
      old = int(self.srcMod)
      cur = int(os.path.getmtime(self.srcFil))
      self.toUpd = old != cur
     except:
      pass
  return CCDNtC()
 def VVQ5VQ(self, err, title=""):
  FFdw58(self.SELF, err, title=title or self.Title)
 def VVBIA4(self, rowNum, url, VV1wIO):
  VVPxk5 = CCjZbZ.VVeaoE(rowNum + 1, url)
  span1 = iSearch(r"((?:[a-z0-9]+:){10})(.+)(:.+)", url, IGNORECASE)
  span2 = iSearch(r"((?:[a-z0-9]+:){10})(.+)"  , url, IGNORECASE)
  span3 = iSearch(r"((?:[a-z0-9]+:){10})$"  , url, IGNORECASE)
  span4 = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", url, IGNORECASE)
  if   span1 : return "%s%s%s"  % (span1.group(1), FFSiPR(span1.group(2)), span1.group(3))
  elif span2 : return "%s%s:%s" % (span2.group(1), FFSiPR(span2.group(2)), VV1wIO)
  elif span3 : return span3.group(1)
  elif span4 : return "%s%s:%s" % (VVPxk5, FFSiPR(span4.group(1)) + span4.group(2) + FFSiPR(span4.group(3)) + span4.group(4), VV1wIO)
  else  : return "%s%s:%s" % (VVPxk5, FFSiPR(url), VV1wIO)
 @staticmethod
 def VVeaoE(rowNum, url):
  span = iSearch(r".+\/(\d+)\.?", url)
  num = span.group(1) if span else "444"
  catID = "333"
  chNum = str(rowNum)
  stID = num if int(num) < 0xeeee0000 else "444"
  VVPxk5 = CCkEI5.VVpX1r(catID, stID, chNum)
  return VVPxk5
 @staticmethod
 def VVuYvs(path):
  m3Dir = FFoWxR(os.path.dirname(path))
  m3File = os.path.basename(path)
  VVcwFG = os.path.splitext(m3File)[0]
  zPath = "%s%s.zip" % (CCjZbZ.VVz4Ig(), VVcwFG)
  zFound = FFCyVu(zPath)
  return m3File, m3Dir, VVcwFG, zPath, zFound
 @staticmethod
 def VVz4Ig():
  return FF0cqc() + "ajpanel_local_servers/"
 @staticmethod
 def VVOteG(SELF, colList):
  num, name, logo, url, VVfbmn = colList
  VV1wIO = FFzBfi(name)
  isMark = FFhPtm(url)
  if iMatch(r"^([A-Fa-f0-9]+[:]){10}", url):
   VVPxk5 = chUrl = url
   VVZcRP = ""
  else:
   VVPxk5, chUrl, VVZcRP = CCjZbZ.VVYrGK(int(num) + 1, url, VV1wIO)
  return VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark
 @staticmethod
 def VVYrGK(num, url, VV1wIO):
  VVZcRP = FFXarh(url)
  VVPxk5 = CCjZbZ.VVeaoE(num, VVZcRP)
  span = iSearch(r"(.+)([&?]mode=.+&chCm=)(.*)(&end.+)", VVZcRP, IGNORECASE)
  if span : encUrl = FFSiPR(span.group(1)) + span.group(2) + FFSiPR(span.group(3)) + span.group(4)
  else : encUrl = FFSiPR(VVZcRP)
  chUrl = "%s%s:%s" % (VVPxk5, encUrl, VV1wIO)
  VVZcRP = "%s:%s" % (VVZcRP, VV1wIO)
  return VVPxk5, chUrl, VVZcRP
 @staticmethod
 def VVICcD(SELF, Dir, VVTiJ2, cbFnc=None):
  CCh3tv.VV7Nf4(SELF, VVLL7M="Counting Files ...", titleBg="#22220022", bodyBg="#22002211", barBg="#0a226622"
      , VVixvy  = BF(CCjZbZ.VVviSu, Dir, VVTiJ2)
      , VVbYwR = BF(CCjZbZ.VV1g3w, SELF, VVTiJ2, cbFnc))
 @staticmethod
 def VVviSu(Dir, VVTiJ2, VVXyP6):
  tot = 0
  for root, dirs, files in os.walk(Dir):
   tot += len(files)
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVq8NF(tot)
  VVXyP6.VVNc18 = (0, "")
  tot, err = 0, ""
  try:
   with iZip.ZipFile(VVTiJ2, 'w', iZip.ZIP_DEFLATED) as zipF:
    for root, dirs, files in os.walk(Dir):
     for file in files:
      zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
      tot += 1
      if not VVXyP6 or VVXyP6.isCancelled: return
      VVXyP6.VVxtQs(1)
      VVXyP6.VVaks5("Archiving Files : %s" % tot)
      VVXyP6.VVNc18 = (tot, "")
  except Exception as e:
   VVXyP6.VVNc18 = (tot, str(e))
 @staticmethod
 def VV1g3w(SELF, VVTiJ2, cbFnc, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  tot, err = VVNc18
  if err: FFwgGB(VVTiJ2)
  if cbFnc: cbFnc(VVTiJ2, tot, err)
 @staticmethod
 def VV8fEW(Dir, VVTiJ2):
  tot, err = 0, ""
  try:
   with iZip.ZipFile(VVTiJ2, 'w', iZip.ZIP_DEFLATED) as zipF:
    for root, dirs, files in os.walk(Dir):
     for file in files:
      zipF.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(Dir, '..')))
      tot += 1
  except Exception as e:
   err = str(e)
  return tot, err
 @staticmethod
 def VV2LK6(VVTiJ2, fil, mode=0):
  try:
   with iZip.ZipFile(VVTiJ2) as zipF:
    zInfLst = zipF.infolist()
    for zipInfo in zInfLst:
     fName = os.path.basename(zipInfo.filename)
     if fName == fil:
      with zipF.open(zipInfo.filename) as f:
       txt = f.read().decode()
       if mode == 0: return str(txt), ""
       else  : return [str(x.strip()) for x in txt.splitlines()], ""
  except Exception as e:
   return "", str(e)
  return "", "Missing file"
 @staticmethod
 def VVir5C(url):
  try: res = iUrlparse(url)
  except: return [""] * 4
  scheme = res.scheme
  netloc = res.netloc
  query = res.query
  VVGWyE = res.hostname or ""
  hst  = "%s://%s" % ((scheme or "http"), netloc)
  d = iUrlparse_qs(query)
  usr = d.get("username")[0] if "username" in d else ""
  pas = d.get("password")[0] if "password" in d else ""
  return hst, usr, pas, VVGWyE
 @staticmethod
 def VVZXSg(url, chkExt=False):
  if any(x in url for x in ("/series/", "mode=series")):
   return "Series"
  if any(x in url for x in ("/movie/", "/movie.php", "/media/vod", "mode=vod", "/vod/", "/video/", "/timeshift/")):
   return "VOD"
  if any(x in url for x in ("/live/", "/live2/", "/live.php", "mode=itv", "?ext=.ts", "/index.m3u8")):
   return "Live"
  if url.startswith("1:64:")       : return "Marker"
  if url.startswith("/")        : return "Movie"
  if FFHgaY(url)        : return "S.Relay"
  if iMatch(r"^(?:[A-Fa-f0-9]+:){10}", url)   : return "DVB"
  if iMatch(r"^http.+(?:[A-Fa-f0-9]+:){10}", url)  : return "DVB"
  if any(x in url for x in ("file?file", ":ftp%3a//")): return "FTP"
  if chkExt and any(x in url for x in (".mp4", ".mkv", ".avi")):
   return "VOD"
  return "Live"
class CCwhE4(CC96QG):
 def __init__(self):
  self.curPortalCatId = ""
  CC96QG.__init__(self)
 def VV0z9x(self):
  if CCwhE4.VVOJRa(self):
   self.VV0muG(2)
 def VVAw1p(self, winSession, url, mac):
  self.VV2rlK = url
  if CCwhE4.VVOJRa(self):
   if self.VVNf1R(url, mac):
    FFimQ3(winSession, self.VVG6wB, title="Checking Server ...")
   else:
    FFdw58(self, "Incorrect URL or MAC format !", title="Starting Portal Browser")
 def VVDtP0(self, item=None):
  if item:
   VV7tND, txt, path, ndx = item
   enc = CC7ocD.VV51oT(path, self)
   if enc == -1:
    return
   CCh3tv.VV7Nf4(self, VVLL7M="Processing file lines"
       , VVixvy  = BF(self.VVW8Um, path, enc)
       , VVbYwR = BF(self.VVzcIH, VV7tND, path))
 def VVW8Um(self, path, enc, VVXyP6):
  urlMacPatt  = r"(.*)(https?:\/\/.+(?::[0-9]+)*)(?:.+)((?:[A-Fa-f0-9]{2}\s*:\s*){5}[A-Fa-f0-9]{2})(.*)"
  urlOnlyPatt = r"\s*(https?:\/\/.+(?::[0-9]+)*)"
  macOnlyPatt = r"((?:(?:.*mac\s*)[^A-Fa-f0-9]\s*)*)((?:(?:(?:[A-Fa-f0-9]{2})\s*:\s*){5})\s*(?:[A-Fa-f0-9]{2}))(.*)"
  tableRows, url = [], ""
  lineNum = 0
  totLines = 0
  with ioOpen(path, "r", encoding=enc) as f:
   for line in f:
    totLines += 1
  VVXyP6.VVq8NF(totLines)
  VVXyP6.VVNc18 = []
  def VVZwiy(subj, host, mac, info):
   if host and mac and VVXyP6:
    if not [1 for _, _, _, host1, mac1, _ in VVXyP6.VVNc18 if (host1, mac1) == (host, mac)]:
     VVXyP6.VVNc18.append((str(len(VVXyP6.VVNc18) + 1), str(lineNum), subj, host, mac, info))
  with ioOpen(path, "r", encoding=enc) as f:
   for line in f:
    lineNum += 1
    if not VVXyP6 or VVXyP6.isCancelled:
     return
    VVXyP6.VVxtQs(1, True)
    line = str(line).strip()
    if not line or len(line) > 500 or "password" in line:
     continue
    span = iSearch(urlMacPatt, line, IGNORECASE)
    if span:
     subj = span.group(1).strip().strip(',"') or "-"
     url  = span.group(2).strip().split(" ")[0].split("\t")[0].strip()
     mac  = span.group(3).strip().replace(" ", "").upper()
     info = span.group(4).strip().strip(',;"\t') or "-"
     host = self.VVY27l(url).replace('"mac', "").strip(',"')
     mac  = self.VV1r6n(mac)
     VVZwiy(subj, host, mac, info)
     url = ""
     continue
    if not url:
     span = iSearch(urlMacPatt, line, IGNORECASE)
     if not span:
      span = iSearch(urlOnlyPatt, line, IGNORECASE)
      if span:
       url = span.group(1).split(" ")[0]
    else:
     span = iSearch(macOnlyPatt, line.replace("\t", " "), IGNORECASE)
     if span:
      subj = span.group(1).strip().strip(',"') or "-"
      mac  = span.group(2).strip().replace(" ", "").upper()
      info = span.group(3).strip().strip(',;"') or "-"
      host = self.VVY27l(url).strip(',;"\t')
      mac  = self.VV1r6n(mac)
      VVZwiy("", host, mac, info)
     else:
      span = iSearch(urlOnlyPatt, line, IGNORECASE)
      if span:
       url = span.group(1).split(" ")[0]
 def VVzcIH(self, VVr7eD, path, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18:
   VVu1YM  = ("Select"   , self.VVCfle , [])
   VVGuQE  = BF(self.VVEo3E, VVr7eD)
   VVwWmA  = ("Home Menu"  , FF8lJ1            , [])
   VVwSzI = ("Browse as M3U" , self.VVFMSv        , [])
   VVScQz = ("Edit File"  , BF(self.VVStbP, path)       , [])
   VV4QTJ = ("Options"  , BF(self.VVpKUL, VVr7eD, path) , [])
   header   = ("Num" , "LineNum" , "Title" , "Host", "MAC-Address" , "Comments")
   widths   = (7  , 0   , 12  , 36 , 20   , 25  )
   VVLIqP  = (CENTER , CENTER , LEFT  , LEFT , CENTER  , LEFT  )
   VV6A99 = FFUQ0v(self, None, title=os.path.basename(path), header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVGuQE=VVGuQE, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVwltY="#0a001122", VVkxBG="#0a001122", VVemyB="#0a001122", VVJKqd="#00004455", VVbcr0="#0a333333", VVX9AA="#11331100", VVHPI7=True, VVMfsO=3, VVSLOq=CFG.lastFindServers)
   if not VVRI6P:
    FF28n1(VV6A99, "Stopped at line %s" % threadCounter, 1000)
  else:
   if VVRI6P:
    FFdw58(self, "No valid portal data (or incorrect file format) in:\n\n%s" % path, title="Get Portal Data")
 @FFOAKH("Checking Access ...", par=1, clearMsg=False)
 def VVFMSv(self, VV6A99, title, txt, colList):
  host, mac = colList[3], colList[4]
  p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=host, mac=mac)
  VV6A99.VVrmMb()
  if pUrlAcc and pUrlDnld : self.VVgCCs(VV6A99, title, pUrlAcc)
  else     : FFdw58(self, err or "No response from Server !", title="Playlist for : %s" % host)
 def VVCfle(self, VV6A99, title, txt, colList):
  self.VVAw1p(VV6A99, colList[3], colList[4])
 def VVStbP(self, path, VV6A99, title, txt, colList):
  rowNum = int(colList[1].strip()) - 1
  if FFCyVu(path) : CCyMCP(self, path, VVbYwR=BF(self.VVzm4T, VV6A99), VVPhQC=rowNum)
  else    : FF8Wsn(self, path)
 def VVpKUL(self, VVr7eD, path, VV6A99, title, txt, colList):
  VV3wat =[]
  VV3wat.append(("Filter Responsive Servers"  , "tok"))
  VV3wat.append(("Find Servers with Playlist Access", "plst"))
  FFLFTC(self, BF(self.VVEaMp, VVr7eD, VV6A99, path), title="Portal Options", VV3wat=VV3wat, width=700)
 def VVEaMp(self, VVr7eD, VV6A99, path, item):
  if not item: return
  isToken = item == "tok"
  nm, ext = os.path.splitext(os.path.basename(path))
  for s in ("TOKEN_", "PLAYLIST_", "OK_"): nm = nm.replace(s, "")
  nm = iSub(r"(_\d{8})", "", nm)
  nm = iSub(r"(_\d{6})", "", nm)
  nm, _ = os.path.splitext(nm)
  txt = "TOKEN" if item == "tok" else "PLAYLIST"
  nm = "%s_%s_%s.txt" % (nm, "TOKEN" if isToken else "PLAYLIST", FFjTQe())
  outF = os.path.join(os.path.dirname(path), nm)
  self.VVspUi(VVr7eD, VV6A99, outF, isToken, VV6A99.VVrrm9(), VV6A99.VVn1uo())
 def VVspUi(self, VVr7eD, VV6A99, outF, isToken, lst, tot):
  CCh3tv.VV7Nf4(self, VVLL7M="Checking Portals"
      , VVixvy  = BF(self.VV7QJ2, outF, isToken, lst, tot)
      , VVbYwR = BF(self.VVPd3Z, VVr7eD, VV6A99, outF, isToken))
 def VV7QJ2(self, outF, isToken, lst, tot, VVXyP6):
  totOk = totNotOK = totHstErr = totSkip = 0
  VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, "")
  VVXyP6.VVq8NF(tot)
  skipHosts = set()
  for row in lst:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVEpLv(0, totOk)
   num, lNum, titl, host, mac, cmnt = row
   valid = False
   if host in skipHosts        : totSkip += 1
   elif self.VVNf1R(host, mac, VVwb7n=False) : valid = True
   else            : totHstErr += 1
   if valid:
    fLine = token = pUrlAcc = ""
    if isToken:
     t1 = iTime()
     token, profile, tErr = self.VVTATM(VVwb7n=False)
     took = "%.3f" % (iTime() - t1)
     if token:
      fLine = "%s\t%s\t%s\t(Token: %s sec) %s" % (titl, host, mac, took, "" if cmnt == "-" else cmnt)
    else:
     p, pUrl, pUrlAcc, pUrlDnld, pHost, pUser, pPass, err = CC96QG.VV1SNn(host=host, mac=mac)
     if pUrlAcc:
      fLine = "%s\t%s\n%s\n" % (host, mac, pUrlAcc)
    if not VVXyP6 or VVXyP6.isCancelled: return
    if isToken and token or not isToken and pUrlAcc:
     try:
      with open(outF, "a") as f:
       f.write("%s\n" % fLine)
      totOk += 1
      if not VVXyP6 or VVXyP6.isCancelled: return
      VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, "")
     except Exception as e:
      if not VVXyP6 or VVXyP6.isCancelled: return
      VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, str(e))
      return
    else:
     if self.portal_latestResponse.get("resCritical", ""):
      skipHosts.add(host)
      totSkip += 1
     else:
      totNotOK += 1
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVNc18 = (totOk, totNotOK, totHstErr, totSkip, "")
   VVXyP6.VVEpLv(1, totOk)
 def VVPd3Z(self, VVr7eD, VV6A99, outF, isToken, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  totOk, totNotOK, totHstErr, totSkip, err = VVNc18
  c1, c2 = VVSGsk, VVz22H
  tab = lambda a, b: "%s\t: %s\n" % (a, b)
  txt  = tab("Servers" ,  threadTotal)
  txt += tab("Checked" ,  threadCounter)
  txt += tab("Accessible" ,  FFjt5L(totOk, c1 if totOk else c2))
  if totNotOK   : txt += tab("No Token" if isToken else "Not found", totNotOK)
  if totSkip   : txt += tab("Skipped"  , "%d (host access error)" % totSkip)
  if totHstErr  : txt += tab("Host Error" , totHstErr)
  if err    : txt += tab("\nError" , FFjt5L(err, c2))
  if not VVRI6P : txt += tab("\nProcess", FFjt5L("Stopped", c2))
  if totOk   : txt += "\n%s\n%s\n" % (FFjt5L("Output File:", c1), outF)
  FF4lCP(self, txt, title="Portal Servers Filtering")
  if totOk:
   if VVr7eD: VVr7eD.VV5HD3((outF, outF), isSort=True)
   if VV6A99: VV6A99.close()
 def VVG6wB(self):
  token, profile, tErr = self.VVTATM()
  if token:
   dots = "." * self.VVdDpE
   dots += {"s":"", "p":"+", "q":"++"}.get(self.VVaM9P(), "")
   dots += "*" if not self.VVncdQ == self.VV2rlK else ""
   if dots:
    dots = FFjt5L(dots, VVo7S9)
   if CFG.simplePortal.getValue() : VVwltY, VVkxBG = "#22553344", "#22552233"
   else       : VVwltY, VVkxBG = "#22003344", "#22002233"
   VV3wat  = self.VVafii()
   VVOa1G = self.VV9X9b
   VVJbOd = BF(self.VV49j5, 1)
   VVHGnw = ("Home Menu", FF8lJ1)
   VVB4pu= ("Add to Menu", BF(CCkEI5.VVoyt7, self, True, self.VVncdQ + "\t" + self.VVvRlC))
   VVaTeF = ("Bookmark", BF(CCkEI5.VVwOWK, self, True, self.VVncdQ + "\t" + self.VVvRlC))
   VV7tND = FFLFTC(self, None, title="Portal Resources (MAC=%s) %s" % (self.VVvRlC, dots), VV3wat=VV3wat, VVOa1G=VVOa1G, VVJbOd=VVJbOd, VVHGnw=VVHGnw, VVB4pu=VVB4pu, VVaTeF=VVaTeF, VVwltY=VVwltY, VVkxBG=VVkxBG)
   self.VVANDc(VV7tND)
 def VV9X9b(self, item=None):
  if item:
   VV7tND, title, ref, ndx = item
   if   ref == "live"   : mode = "itv"
   elif ref == "vod"   : mode = "vod"
   elif ref == "series"  : mode = "series"
   elif ref == "accountInfo" : mode = ""
   if mode : self.VV5K0A(VV7tND, mode)
   else : self.VVkOTh(VV7tND, title)
 @FFOAKH("Reading Account ...", par=1)
 def VVkOTh(self, VV7tND, title, forceMoreInfo=False):
  rows, totCols = self.VVIr7V(forceMoreInfo)
  title = "%s (MAC=%s)" % (title, self.VVvRlC)
  VVwWmA  = ("Home Menu" , FF8lJ1           , [])
  VVwSzI  = None
  if VVBvqf:
   VVwSzI = ("Get JS"  , BF(self.VV7Vtg, self.VVTr19()) , [])
  if totCols == 2:
   VV4QTJ = None
   header   = ("Subject" , "Value" )
   widths   = (43   , 57  )
   VVMfsO  = 0
  else:
   VV4QTJ = ("More Info.", BF(self.VVNkUI, VV7tND)    , [])
   header   = ("Num", "User/Server" , "Subject" , "Value" )
   widths   = (0 , 15   , 35  , 50  )
   VVMfsO  = 2
  FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=rows, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VV4QTJ=VV4QTJ, VVwltY="#0a00292B", VVkxBG="#0a002126", VVemyB="#0a002126", VVJKqd="#00000000", VVMfsO=VVMfsO)
 @FFOAKH("Getting JS ...", par=2)
 def VV7Vtg(self, url, VV6A99, title, txt, colList):
  txt  = "// Host\t: %s\t%s\n" % (url, self.VVvRlC)
  ver, err = self.VVI5kn(url)
  txt += "// Version\t: %s\n\n" % (ver or err)
  js , err = self.VVI5kn(url, isJsFile=True)
  if err: txt += "Error : %s" % err
  else  : txt += js
  FF4lCP(self, txt, title="JS Info", VVRhqH="Server_xpcom.common.js")
 def VVNkUI(self, VV7tND, VV6A99, title, txt, colList):
  VV6A99.cancel()
  self.VVkOTh(VV7tND, "Account Info.", forceMoreInfo=True)
 @FFOAKH("Reading Categories ...", par=1)
 def VV5K0A(self, VV7tND, mode):
  token, profile, tErr = self.VVTATM()
  if not token:
   return
  res, err = self.VVnjdQ(self.VVryIa(mode))
  list = []
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     chList = tDict["js"]
     for item in chList:
      Id   = FFYjVd(item, "id"       )
      Title  = FFYjVd(item, "title"      )
      censored = FFYjVd(item, "censored"      )
      Title = self.VV1vXv(Title)
      if Title:
       isAll = Title.strip().lower() in ("all", "all channels")
       if not isAll or isAll and VVWe5f:
        list.append((Title.strip(), Id))
   except:
    pass
  title = self.VVdGiv(mode)
  if list:
   list.sort(key=lambda x: x[0].lower())
   self.VVLp7F = dict([(x[1], x[0]) for x in list])
   VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
   mName = self.VVdGiv(mode)
   VVCOpO  = (""     , BF(self.VVqVx2, mode), [])
   VVu1YM   = ("Show List"   , BF(self.VVDIxp, mode)   , [])
   VVwWmA  = ("Home Menu"   , FF8lJ1        , [])
   if mode in ("vod", "series"):
    VVScQz = ("Find in %s" % mName , BF(self.VVa107, mode, False), [])
    VV4QTJ = ("Find in Selected" , BF(self.VVa107, mode, True) , [])
   else:
    VVScQz = None
    VV4QTJ = None
   header   = None
   widths   = (100   , 0  )
   FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=list, VV3cHe=widths, VVwdmN=30, VVwWmA=VVwWmA, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVCOpO=VVCOpO, VVu1YM=VVu1YM, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVSLOq=CFG.lastFindIptv)
  else:
   s = "Authorization failed"
   if err:
    txt = err
   elif s in res.text:
    txt = s
    if self.VVnsdh:
     txt += "\n\n( %s )" % self.VVnsdh
   else:
    txt = "Could not get Categories from server!"
   FFdw58(self, txt, title=title)
 @FFOAKH("Downloading ...", par=2)
 def VVuCrJ(self, mode, VV6A99, title, txt, colList):
  token, profile, tErr = self.VVTATM()
  if not token:
   return
  VVetid = colList[1]
  catID  = colList[2]
  res, err = self.VVnjdQ(self.VVhjC5(catID))
  list = []
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     chList = tDict["js"]['data']
     for item in chList:
      Id    = FFYjVd(item, "id"    )
      actors   = FFYjVd(item, "actors"   )
      added   = FFYjVd(item, "added"   )
      age    = FFYjVd(item, "age"    )
      category_id  = FFYjVd(item, "category_id"  )
      description  = FFYjVd(item, "description"  )
      director  = FFYjVd(item, "director"   )
      genres_str  = FFYjVd(item, "genres_str"  )
      name   = FFYjVd(item, "name"    )
      path   = FFYjVd(item, "path"    )
      screenshot_uri = FFYjVd(item, "screenshot_uri" )
      series   = FFYjVd(item, "series"   )
      cmd    = FFYjVd(item, "cmd"    )
      cmd    = cmd.replace("ffmpeg ", "")
      for episode in eval(series):
       list.append((VVetid, name, str(episode), category_id, Id, added, age, cmd, director, genres_str, actors, description, screenshot_uri, path))
   except:
    pass
  if list:
   list.sort(key=lambda x: (x[1], int(x[2])))
   VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D("")
   VVCOpO = (""     , BF(self.VVFT0S, mode, True)  , [])
   VVu1YM  = ("Play"    , BF(self.VVzqdS, mode)       , [])
   VV2ytr = (""     , BF(self.VVzUBN, mode)     , [])
   VVwWmA = ("Home Menu"   , FF8lJ1            , [])
   VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "sp", VVetid) , [])
   VVScQz = ("Options"   , BF(self.VVCbC2, "pEp", mode, VVetid) , [])
   VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, True)      , [])
   header   = ("Name" , "Season" , "Episode" , "catID" , "ID" , "Added" , "Age" , "cmd" , "Director", "Genre" , "Actors" , "Description" , "Screenshot" , "Path")
   widths   = (65  , 20  , 15  , 0   , 0   , 0.01 , 0.01 , 0  , 0.01  , 0.01  , 0   , 0    , 0    , 0  )
   VVLIqP  = (LEFT  , LEFT  , CENTER , LEFT  , LEFT  , LEFT , LEFT , LEFT , LEFT  , LEFT  , LEFT  , LEFT   , LEFT   , LEFT )
   FFUQ0v(self, None, title=VVetid, width=1200, header=header, VVGape=list, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVCOpO=VVCOpO, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
  else:
   FFdw58(self, "Could not get Episodes from server!", title=VVetid)
 def VVa107(self, mode, searchInCat, VV6A99, title, txt, colList):
  searchCatId = colList[1].strip() if searchInCat else ""
  VV3wat = []
  VV3wat.append(("Keyboard"  , "manualEntry"))
  VV3wat.append(("From Filter" , "fromFilter"))
  FFLFTC(self, BF(self.VVCmc8, VV6A99, mode, searchCatId), title="Input Type", VV3wat=VV3wat, width=400)
 def VVCmc8(self, VV6A99, mode, searchCatId, item=None):
  if item == "manualEntry":
   FF4z45(self, BF(self.VVyUAG, VV6A99, mode, searchCatId), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCoErY(self)
   filterObj.VVVPGN(BF(self.VVyUAG, VV6A99, mode, searchCatId))
 def VVyUAG(self, VV6A99, mode, searchCatId, item):
  if not item is None:
   searVV1wIO = item.strip()
   FFjt1c(CFG.lastFindIptv, searVV1wIO)
   title = self.VVvwJ7(mode, searVV1wIO)
   if "," in searVV1wIO : FFdw58(self, "Use only one word to search in Portal Servers !\n\nRemove the comma.", title=title)
   elif len(searVV1wIO) < 3: FFdw58(self, "Enter at least 3 characters.", title=title)
   else     :
    if CFG.hideIptvServerAdultWords.getValue() and self.VVZI1i([searVV1wIO]):
     FFdw58(self, self.VVmBMi(), title=title)
    else:
     self.VVQqfr(mode, searVV1wIO, "", searVV1wIO, searchCatId)
 def VVDIxp(self, mode, VV6A99, title, txt, colList):
  bName = colList[0].strip()
  catID = colList[1].strip()
  self.curPortalCatId = catID
  self.VVQqfr(mode, bName, catID, "", "")
 def VVQqfr(self, mode, bName, catID, searVV1wIO, searchCatId):
  CCh3tv.VV7Nf4(self, VVLL7M="Reading from server"
      , VVixvy  = BF(self.VVxrxQ, mode, bName, catID, searVV1wIO, searchCatId)
      , VVbYwR = BF(self.VV9ldE, mode, bName, catID, searVV1wIO, searchCatId))
 def VV9ldE(self, mode, bName, catID, searVV1wIO, searchCatId, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if searVV1wIO : title = self.VVvwJ7(mode, searVV1wIO)
  else   : title = "%s : %s" % (self.VVdGiv(mode), bName)
  if VVNc18:
   VVwSzI = None
   VVScQz = None
   if mode == "series":
    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("series2")
    VVu1YM  = ("Episodes"   , BF(self.VVuCrJ, mode)           , [])
   else:
    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("")
    VVu1YM  = ("Play"    , BF(self.VVzqdS, mode)           , [])
    VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "vp" if mode == "vod" else "", "") , [])
    VVScQz = ("Options"   , BF(self.VVCbC2, "pCh", mode, bName)      , [])
   VVCOpO = (""      , BF(self.VVFT0S, mode, False)      , [])
   VV2ytr = (""      , BF(self.VVbf1q, mode)         , [])
   VVwWmA = ("Home Menu"    , FF8lJ1                , [])
   VV4QTJ = ("Posters Mode"   , BF(self.VVTdR5, mode, False)         , [])
   header   = ("Num" , "Name", "catID", "genreID" , "Icon", "cmd" , "Cat./Genre" , "Logo", "play", "actors" , "descr" , "director", "Catch-up")
   widths   = (9  , 50  , 0   , 0     , 0  , 0  , 25   , 6  , 0  , 0   , 0   , 0   , 10  )
   VVLIqP  = (CENTER, LEFT  , CENTER , CENTER  , LEFT , LEFT , LEFT   , CENTER, LEFT , LEFT  , LEFT  , LEFT  , CENTER )
   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVu1YM=VVu1YM, VVCOpO=VVCOpO, VV2ytr=VV2ytr, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
   if not VVRI6P:
    if not threadCounter == threadTotal:
     tot = " (Stopped at %d of %d) " % (threadCounter, threadTotal)
     VV6A99.VV0ZtI(VV6A99.VVpVUj() + tot)
    if threadErr: FF28n1(VV6A99, "Error while reading !", 2000)
    else  : FF28n1(VV6A99, "Stopped at channel %s" % threadCounter, 1000)
  else:
   if searVV1wIO : FFdw58(self, "Could not find names with:\n\n%s" % searVV1wIO, title=title)
   else   : FFdw58(self, "Could not get list from server !", title=title)
 def VVbf1q(self, mode, VV6A99, title, txt, colList):
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), str(y)) if y.strip() and not "N/A" in y else ""
  tab = lambda x, y: "%s\t: %s\n" % (x, y) if y.strip() and not "N/A" in y else ""
  Num, Name, catID, genreID, Icon, cmd, Cat_Genre, Logo, play, actors, descr, director, arch = colList
  txt  = tab("Number"  , Num)
  txt += tab("Name"  , Name)
  txt += tab("Category" , self.VVLp7F.get(genreID, ""))
  txt += tab("Cat./Genre" , Cat_Genre)
  txt += tab("Director" , director)
  txt += "\n"
  txt += ttl("Actors"  , actors)
  txt += ttl("Description", descr)
  play = play.strip()
  if play and not play.startswith("[No "):
   txt += ttl("Cur. Playing", play)
  if mode == "series":
   VV1wIO = colList[1]
   VVfbmn = colList[4]
   txt  = "%s\n\n%s" % (title, txt)
   CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVC2DO, params=(VV1wIO, txt, VVfbmn))
  else:
   self.VVbND6(mode, VV6A99, title, txt, colList)
 def VVzUBN(self, mode, VV6A99, title, txt, colList):
  txt += "\n"
  txt += "Actors:\n%s\n\n" % FFjt5L(colList[10], VVA4XU)
  txt += "Description:\n%s" % FFjt5L(colList[11], VVA4XU)
  self.VVbND6(mode, VV6A99, title, txt, colList)
 def VVbND6(self, mode, VV6A99, title, txt, colList):
  VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
  VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
  txt = "%s\n\n%s" % (title, txt)
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVFka3, params=(VVPxk5, chUrl, VV1wIO, txt, VVfbmn))
 def VVxrxQ(self, mode, bName, catID, searVV1wIO, searchCatId, VVXyP6):
  try:
   token, profile, tErr = self.VVTATM()
   if not token:
    return
   if VVXyP6.isCancelled:
    return
   VVXyP6.VVNc18, total_items, max_page_items, err = self.VVyTNm(mode, catID, 1, 1, searVV1wIO, searchCatId)
   if VVXyP6.isCancelled:
    return
   if VVXyP6.VVNc18 and total_items > -1 and max_page_items > -1:
    VVXyP6.VVq8NF(total_items)
    VVXyP6.VVxtQs(max_page_items, True)
    pages = int(iCeil(float(total_items) / float(max_page_items)))
    total_items = pages
    for i in range(pages - 1):
     if VVXyP6.isCancelled:
      return
     page = i + 2
     counter = (i + 1) * max_page_items + 1
     list, total_items, max_page_items, err = self.VVyTNm(mode, catID, page, counter, searVV1wIO, searchCatId)
     if err:
      VVXyP6.VVlmol()
     if VVXyP6.isCancelled:
      return
     if list:
      VVXyP6.VVNc18 += list
      VVXyP6.VVxtQs(len(list), True)
  except:
   pass
 def VVyTNm(self, mode, catID, page, counter, searVV1wIO, searchCatId):
  list = []
  total_items = max_page_items = -1
  if searVV1wIO : url = self.VVLfbI(mode, searVV1wIO, searchCatId, page)
  else   : url = self.VV7Kcq(mode, catID, page)
  res, err = self.VVnjdQ(url)
  if not err:
   try:
    tDict = jLoads(res.text)
    if tDict:
     item = tDict["js"]
     total_items  = self.VVgyFk(FFYjVd(item, "total_items"  ))
     max_page_items = self.VVgyFk(FFYjVd(item, "max_page_items" ))
     chList = tDict["js"]['data']
     cmdStr = "http://localhost/ch/"
     for item in chList:
      Id    = FFYjVd(item, "id"     )
      name   = FFYjVd(item, "name"     )
      o_name   = FFYjVd(item, "o_name"    )
      category_id  = FFYjVd(item, "category_id"   )
      tv_genre_id  = FFYjVd(item, "tv_genre_id"   )
      number   = FFYjVd(item, "number"    ) or str(counter)
      logo   = FFYjVd(item, "logo"     )
      screenshot_uri = FFYjVd(item, "screenshot_uri"  )
      pic    = FFYjVd(item, "pic"     )
      cmd    = FFYjVd(item, "cmd"     )
      censored  = FFYjVd(item, "censored"    )
      genres_str  = FFYjVd(item, "genres_str"   )
      curPlay   = FFYjVd(item, "cur_playing"   )
      actors   = FFYjVd(item, "actors"    )
      descr   = FFYjVd(item, "description"   )
      director  = FFYjVd(item, "director"    )
      archive   = FFYjVd(item, "archive"    )
      archDur   = FFYjVd(item, "tv_archive_duration" )
      catID   = category_id or tv_genre_id
      arch = "Yes" if archive == "1" else ""
      if archDur:
       if archDur.isdigit():
        tot = int(archDur)
        if tot > 0: arch = "%s hour%s" % (tot, FFcacr(tot))
       else:
        arch = archDur
      name = o_name or name
      if " " in cmd :
       cmd = cmd.split(" ")[1].strip()
      if mode == "itv" and not cmdStr in cmd and not cmd.endswith(".m3u8") and not "ffrt" in cmd:
       if ("token=" in cmd and "d=Mag" in cmd) or "AuthToken=" in cmd or "play_token=" in cmd:
        cmd = "Zz1" + FFiPNn(cmd)
       else:
        span = iSearch(r"stream=(.+)&", cmd)
        if span:
         cmd = "%s%s_" % (cmdStr, span.group(1))
        else:
         span = iSearch(r".+\/.+\/.+\/(.+)", cmd)
         if span:
          cmd = "%s%s_" % (cmdStr, span.group(1))
      if   logo.startswith("http")   : picon = logo
      elif pic.startswith("http")    : picon = pic
      elif screenshot_uri.startswith("http") : picon = screenshot_uri
      else         : picon = logo or screenshot_uri or pic
      sp = "/stalker_portal"
      if picon.startswith(sp):
       picon = (self.VVncdQ + picon).replace(sp * 2, sp)
      isIcon = "Yes" if picon.startswith("http") else ""
      counter += 1
      name = self.VVcBrZ(name, censored=censored)
      if name:
       list.append((number, name, Id, catID, picon, cmd, genres_str, isIcon, curPlay, actors, descr, director, arch))
   except:
    err = "Channel Parse Error !"
  return list, total_items, max_page_items, err
 def VVgyFk(self, valStr):
  try:
   return int(valStr)
  except:
   return -1
 def VVzqdS(self, mode, VV6A99, title, txt, colList):
  VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
  VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
  if self.VVAP76(VV1wIO):
   FF28n1(VV6A99, "This is a marker!", 300)
  else:
   chUrl = CCwhE4.VVtjAF(self, chUrl)
   VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
   CCqWM2.VVHc02(self.session, VVwqHQ=(self, VV6A99, mode), VVaHNe=chUrl, VVAfO9=VVAfO9)
 def VVsQmE(self, mode, VV6A99, colList):
  VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
  VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
  VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
  return VV1wIO, chUrl, VVAfO9
 def VVcP3g(self, mode, colList):
  if mode == "series":
   VV1wIO = colList[0]
   season = colList[1]
   serCode = colList[2]
   catID = colList[3]
   serId = colList[4]
   chCm = colList[7]
   VVfbmn = colList[12]
   VV1wIO = "%s (%s - %s)" % (VV1wIO, season, serCode)
   chNum = serCode
   stID = serId.replace(":", "_")
  else:
   chNum = colList[0]
   VV1wIO = colList[1]
   stID = colList[2]
   catID = colList[3]
   VVfbmn = colList[4]
   chCm = colList[5]
   serCode = ""
   serId = ""
  return VV1wIO.strip(), catID.strip(), stID.strip(), chNum.strip(), chCm.strip(), serCode.strip(), serId.strip(), VVfbmn.strip()
 @staticmethod
 def VVOJRa(SELF, install=True, cbFnc=None):
  try:
   import requests
   return True
  except:
   if install:
    title = 'Install "Requests"'
    VV3wat = []
    VV3wat.append((title        , "inst" ))
    VV3wat.append(("Update Packages then %s" % title , "updInst" ))
    FFLFTC(SELF, BF(CCwhE4.VVWBq0, SELF, cbFnc=cbFnc), title='This requires Python "Requests" library', VV3wat=VV3wat)
   return False
 @staticmethod
 def VVWBq0(SELF, item=None, cbFnc=None):
  if item:
   cmdUpd = FFoY7E(VVaNvq)
   if cmdUpd:
    cmdInst = FF5sZa(VVwFAi, "python-requests")
    if pyVersion[0] >= 3:
     cmdInst = cmdInst.replace("python-", "python3-")
    if   item == "inst"  : cmd = cmdInst
    elif item == "updInst" : cmd = cmdUpd + " && " + cmdInst
    FFbi5l(SELF, cmd, VV62hm=True, title='Installing "Requests" Library', VVoasw=cbFnc)
   else:
    FFfone(SELF)
 def VVkX5P(self):
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = self.VVGNGo(CC3rDi(self.session).VVZcRP)
  return mode, host, catID, stID, epNum.replace("%3a", ":"), epId.replace("%3a", ":")
 def VVANDc(self, VV7tND):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVkX5P()
  if all((curMode, curHost, curCat)) and curHost == self.VVncdQ:
   VV7tND.VVx2yy({"itv": 0, "vod": 1, "series": 2}.get(curMode, 0))
 def VVqVx2(self, mode, VV6A99, title, txt, colList):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVkX5P()
  if all((curMode, curHost, curCat)) and curMode == mode and curHost == self.VVncdQ:
   VV6A99.VVPkdw({1:curCat})
 def VVFT0S(self, mode, isEp, VV6A99, title, txt, colList):
  curMode, curHost, curCat, curStID, curEpNum, curEpId = self.VVkX5P()
  if all((curMode, curHost, curCat)) and curCat == self.curPortalCatId and curMode == mode and curHost == self.VVncdQ:
   if mode in ("itv", "vod"):
    VV6A99.VVPkdw({2:curStID})
   else: #series
    if isEp:
     VV6A99.VVPkdw({2:curEpNum, 4:curEpId})
    elif mode == "series":
     ser1 = curEpId.split(":")[0]
     ser2 = "%s:%s" % (ser1, ser1)
     ok = VV6A99.VVPkdw({2:ser2})
     if not ok: VV6A99.VVPkdw({2:ser1})
 @staticmethod
 def VVFP1K(VVZcRP):
  span = iSearch(r"(mode=.+)&chCm=.+&end=:(.+)", VVZcRP, IGNORECASE)
  if span : return span.group(1), span.group(2)
  else : return "", ""
 @staticmethod
 def VVtjAF(SELF, chUrl):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
  phpPart1, VV1wIO1 = CCwhE4.VVFP1K(VVZcRP)
  phpPart2, VV1wIO2 = CCwhE4.VVFP1K(FFXarh(chUrl))
  return None if phpPart1 and (phpPart1, VV1wIO1) == (phpPart2, VV1wIO2) else chUrl
class CCkEI5(Screen, CCwhE4, CCa36K, CCwnHL):
 VVwTwt    = 0
 VVH6Pi    = 1
 VVvCuq    = 2
 VV17gf    = 3
 VVqJ6d     = 4
 VVa4UD     = 5
 VVYSwZ     = 6
 VVdQtp     = 7
 VV5dgQ     = 8
 VVKkG6     = 9
 VVL3RT      = 10
 VVQVpf     = 11
 VV08wu     = 12
 VVvTCX     = 13
 VVMDMz     = 14
 VV1MxY      = 15
 VVQaZg      = 16
 VVCz9o      = 17
 VV5aRM      = 18
 VVDxcx      = 19
 VVJbaD    = 0
 VVgkvV   = 1
 VVgL8R   = 2
 VV6cbr   = 3
 VVspif  = 4
 VVhkSg  = 5
 VVXewY   = 6
 VVw3vg   = 7
 VVtP50  = 8
 VV4kmD  = 9
 VVZUri  = 10
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 970, 1050, 50, 40, 30, "#0a0a0a2a", "#0a0a0a1a", 28, VV0Ay7=1)
  self.session     = session
  self.VV6A99    = None
  self.VVXTPg     = "Local IPTV Services"
  self.VVfymn    = {}
  self.VVV9Jd = False
  self.VVvnTo   = CCkEI5.VVjMS6(atLeastOne=True)
  self.VVpQCY    = True
  self.VV2rlK      = ""
  self.VVBk7J    = None
  self.VVLp7F     = {}
  CCwhE4.__init__(self)
  CCa36K.__init__(self)
  VV3wat = self.VVLywV()
  FFZMxC(self, title="IPTV", VV3wat=VV3wat)
  FFBep1(self, {"menu" : self.VV7Oxs})
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VV0wwP)
  global VVyXy5
  VVyXy5 = True
 def VV7OzD(self):
  self["myMenu"].setList(self.VVLywV())
  FF2GM8(self)
  FF6W0I(self)
  if self.VVpQCY:
   self.VVpQCY = False
   FF4IPF(self["myMenu"])
   self.VVctp3()
   FFf6kX()
 def VVctp3(self):
  qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
  if qUrl or "chCode" in VVfaDB:
   for ndx, item in enumerate(self["myMenu"].list):
    if item[0] == "IPTV Server Browser (from Current Channel)" and len(item) > 1:
     self["myMenu"].moveToIndex(ndx)
     break
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  FFYDZ6("VVyXy5")
 def VV0wwP(self):
  if self["myMenu"].getCurrent()[1] in ("VVgmdJ", "VVmoT7Portal") : self["keyMenu"].show()
  else                      : self["keyMenu"].hide()
 def VV7Oxs(self):
  if self["myMenu"].getVisible():
   title, item = self["myMenu"].getCurrent()
   if   item == "VVgmdJ" : confItem = CFG.favServerPlaylist
   elif item == "VVmoT7Portal" : confItem = CFG.favServerPortal
   else         : return
   url = confItem.getValue().strip().split()[0]
   title += (" : %s" % FFjt5L(CCkEI5.VVRLKG(url)[1], VVyFI2)) if url else ""
   FFRMYv(self, BF(self.VVJNv0, confItem), "Remove from menu ?", title=title)
 def VVJNv0(self, confItem):
  FFjt1c(confItem, "")
  self.VV7OzD()
 def VVLywV(self):
  fav1, fav2 = CFG.favServerPlaylist.getValue(), CFG.favServerPortal.getValue()
  c1 = VVIH76
  VV3wat = []
  if fav1: VV3wat.append((c1 +  "Favourite Playlist Server"    , "VVgmdJ" ))
  if fav2: VV3wat.append((c1 +  "Favourite Portal Server"    , "VVmoT7Portal" ))
  VV3wat.append(("IPTV Server Browser (from Playlists)"     , "VVrIJU_fromPlayList" ))
  VV3wat.append(("IPTV Server Browser (from Portal List)"    , "VVrIJU_fromMac"  ))
  qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
  fromCurCond = qUrl or "chCode" in VVfaDB
  VV3wat.append(FFsLU5("IPTV Server Browser (from Current Channel)", "VVrIJU_fromCurrChan", fromCurCond))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Local Servers & M3U Cache"       , "browser_localServ"  ))
  VV3wat.append(("M3U/M3U8 File Browser"        , "VV9w3Z"   ))
  if self.VVvnTo:
   VV3wat.append(("IPTV Services (from Local Bouquets)"    , "iptvTable_all"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Update Current Bouquet EPG/PIcons (from IPTV Server)", "VVFT2F", fromCurCond))
  if self.VVvnTo:
   VV3wat.append(VVAL3j)
   c1, c2 = VVZtfx, VVFuwR
   t1 = FFjt5L("auto-match names", VVIH76)
   t2 = FFjt5L("from xml file"  , VVIH76)
   VV3wat.append((c1 + "Count Available IPTV Channels"    , "VVXKGz"    ))
   VV3wat.append((c1 + "Copy EPG/PIcons between Channels (%s)" % t2 , "copyEpgPicons"   ))
   VV3wat.append(VVAL3j)
   VV3wat.append((c2 + "Share Reference with DVB Channels (%s)" % t2 , "renumIptvRef_fromFile" ))
   VV3wat.append((c2 + "Share Reference with DVB Channels (%s)" % t1 , "VVkIRr" ))
   VV3wat.append((VVyFI2 + "More Reference Tools ..."  , "VVDcKO"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Reload Channels and Bouquets"       , "VV8d5Y"   ))
  VV3wat.append(VVAL3j)
  if not CCHRcZ.VVAbZK():
   VV3wat.append(("Download Manager"         , "dload_stat"    ))
  else:
   VV3wat.append(("Download Manager ... No downloads"    ,       ))
  return VV3wat
 def VVeDfm(self, item):
  self.VV2rlK = ""
  tTitle = "Share Reference with DVB Service"
  if item is not None:
   if   item == "VVPgSR"   : self.VVPgSR()
   elif item == "VVL3AS" : self.VVL3AS()
   elif item == "VVWnDr" : FFRMYv(self, self.VVWnDr, "Change Current List References to Unique Codes ?")
   elif item == "VVthI4_rows" : FFRMYv(self, BF(FFimQ3, self.VV6A99, self.VVthI4), "Change Current List References to Identical Codes ?")
   elif item == "VVdBzQ"   : self.VVdBzQ(tTitle)
   elif item == "VVOPJS"   : self.VVOPJS(tTitle)
   elif item == "VVgmdJ" : self.VVmoT7(False)
   elif item == "VVmoT7Portal" : self.VVmoT7(True)
   elif item == "VVrIJU_fromPlayList" : self.VV0muG(1)
   elif item == "VVrIJU_fromMac"  : self.VV0z9x()
   elif item == "VVrIJU_fromCurrChan" : self.VVsUXV()
   elif item == "browser_localServ"  : CCjZbZ(self, CCjZbZ.VVbu5l)
   elif item == "VV9w3Z"   : self.VV9w3Z()
   elif item == "iptvTable_all"   : self.VVr1GE(self.VVwTwt)
   elif item == "VVFT2F" : CCkEI5.VVFT2F(self)
   elif item == "VVXKGz"    : self.VVXKGz()
   elif item == "copyEpgPicons"   : self.VVNXsZ(False)
   elif item == "renumIptvRef_fromFile" : self.VVNXsZ(True)
   elif item == "VVkIRr" : FFRMYv(self, self.VVkIRr, VVsWSA="Continue ?")
   elif item == "VVDcKO"    : self.VVDcKO()
   elif item == "VV8d5Y"   : CCYrUm.VV8d5Y(self)
   elif item == "dload_stat"    : CCHRcZ.VVSZMa(self)
 def VVPr1F(self):
  item = FFTmHZ(self)
  self.VVeDfm(item)
 @FFOAKH("Loading Channels ...")
 def VVr1GE(self, mode):
  VVAkuK = self.VVoN6g(mode)
  if VVAkuK:
   bg = "#1b001121"
   VVwSzI = ("Current Service", self.VVEzbx , [])
   VVScQz = ("Options"  , self.VV6N3C   , [])
   VV4QTJ = ("Filter"   , self.VVI81R   , [])
   VVu1YM  = ("Play"   , BF(self.VVG1o1)  , [])
   VV2ytr = (""    , self.VVen0D    , [])
   VVCOpO = (""    , self.VVMBc4     , [])
   header   = ("Num" , "Name", "Bouquet" , "Type", "Ref.", "URL" )
   widths   = (8  , 30 , 30  , 6  , 26 , 0  )
   VVLIqP  = (CENTER , LEFT , LEFT  , CENTER, LEFT , LEFT )
   FFUQ0v(self, None, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1750, height=1000, VVwdmN=25
     , VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VV2ytr=VV2ytr, VVCOpO=VVCOpO
     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#11004a55", VVHPI7=True, VVMfsO=1)
  else:
   if mode == self.VVKkG6: err = "No Live IPTV channels !"
   else       : err = "No IPTV channels !"
   FFdw58(self, err)
 def VVMBc4(self, VV6A99, title, txt, colList):
  self.VV6A99 = VV6A99
 def VV6N3C(self, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("Add Current List to a New Bouquet"     , "VVPgSR"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Delete Current List (from all Bouquets)" , "VVL3AS" , VV6A99.VVpVUj().startswith("Filter:"), VVz22H))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Change Current List References to Unique Codes" , "VVWnDr"))
  VV3wat.append(("Change Current List References to Identical Codes", "VVthI4_rows" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Share Reference with DVB Service (manual entry)" , "VVdBzQ"   ))
  VV3wat.append(("Share Reference with DVB Service (auto-find)"  , "VVOPJS"   ))
  FFLFTC(self, self.VVeDfm, title="IPTV Tools", VV3wat=VV3wat)
 @FFOAKH(par=1)
 def VVI81R(self, VV6A99, title, txt, colList):
  VV3wat = []
  VV3wat.append(("All"         , "all"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Prefix of Selected Channel"   , "sameName" ))
  VV3wat.append(("Suggest Words from Selected Channel" , "partName" ))
  VV3wat.append(("Names with Non-English Characters" , "nonEnglish" ))
  VV3wat.append(("Duplicate References"     , "depRef"  ))
  VV3wat.append(("Reference x:x:x:x:0:0:0:0:0:0:"  , "ref00"  ))
  VV3wat.append(("Stream Relay"       , "SRelay"  ))
  VV3wat.append(FF0bQE("Category"))
  VV3wat.append(("Live"         , "live"  ))
  VV3wat.append(("VOD"         , "vod"   ))
  VV3wat.append(("Series"        , "series"  ))
  VV3wat.append(("Uncategorized"      , "uncat"  ))
  VV3wat.append(FF0bQE("Media"))
  VV3wat.append(("Video"        , "video"  ))
  VV3wat.append(("Audio"        , "audio"  ))
  VV3wat.append(FF0bQE("File Type"))
  VV3wat.append(("MKV"         , "MKV"   ))
  VV3wat.append(("MP4"         , "MP4"   ))
  VV3wat.append(("MP3"         , "MP3"   ))
  VV3wat.append(("AVI"         , "AVI"   ))
  VV3wat.append(("FLV"         , "FLV"   ))
  VV3wat.extend(CCMvE7.VVlHzq(prefix="__b__", onlyIptv=True))
  inFilterFnc = BF(self.VVMQBC, VV6A99) if VV6A99.VVpVUj().startswith("Filter:") else None
  filterObj = CCoErY(self)
  filterObj.VVywN2(VV3wat, VV3wat, BF(self.VVPKOr, VV6A99, False), inFilterFnc=inFilterFnc)
 def VVMQBC(self, VV6A99, VV7tND, item):
  self.VVPKOr(VV6A99, True, item)
 def VVPKOr(self, VV6A99, inFilter, item=None):
  self.VVV9Jd = inFilter
  prefix = VV6A99.VVeE40(1).split(" ")[0]
  if item is not None:
   if   item == "all"    : mode, words, title = self.VVwTwt , ""  , self.VVXTPg
   elif item == "sameName"   : mode, words, title = self.VVH6Pi , prefix , prefix + " ..."
   elif item == "partName"   : mode, words, title = self.VVvCuq , ""  , ""
   elif item == "nonEnglish"  : mode, words, title = self.VV17gf , ""  , "Names with Non-English Characters"
   elif item == "depRef"   : mode, words, title = self.VVYSwZ  , ""  , "Duplicate References"
   elif item == "ref00"   : mode, words, title = self.VVdQtp  , ""  , "Reference x:x:x:x:0:0:0:0:0:0:"
   elif item == "SRelay"   : mode, words, title = self.VV5dgQ  , ""  , "Stream Relay"
   elif item == "live"    : mode, words, title = self.VVKkG6  , ""  , "Live"
   elif item == "vod"    : mode, words, title = self.VVL3RT   , ""  , "VOD"
   elif item == "series"   : mode, words, title = self.VVQVpf  , ""  , "Series"
   elif item == "uncat"   : mode, words, title = self.VV08wu  , ""  , "Uncategorized"
   elif item == "video"   : mode, words, title = self.VVvTCX  , ""  , "Video"
   elif item == "audio"   : mode, words, title = self.VVMDMz  , ""  , "Audio"
   elif item == "MKV"    : mode, words, title = self.VV1MxY   , ""  , "MKV"
   elif item == "MP4"    : mode, words, title = self.VVQaZg   , ""  , "MP4"
   elif item == "MP3"    : mode, words, title = self.VVCz9o   , ""  , "MP3"
   elif item == "AVI"    : mode, words, title = self.VV5aRM   , ""  , "AVI"
   elif item == "FLV"    : mode, words, title = self.VVDxcx   , ""  , "FLV"
   elif item.startswith("__b__") : mode, words, title = self.VVqJ6d  , item[5:] , item[5:]
   elif item.startswith("__w__") : mode, words, title = self.VVa4UD  , item[5:] , item[5:]
   else       : return
  if mode != self.VVwTwt:
   tTitle = "Filter: "
   if mode == self.VVqJ6d:
    tTitle += " Bouquet = "
   title = tTitle + FFjt5L(title, VVJEMb)
  if len(title) > 85:
   title = title[:85] + ".."
  if mode == self.VVvCuq:
   VV3wat = []
   VV1wIO = VV6A99.VVeE40(1)
   if VV1wIO:
    list = set()
    for match in iFinditer(r"((?:[^\x00-\x7F]+\s*)+)", VV1wIO, IGNORECASE):
     list.add(match.group(1).strip())
    if list:
     for match in iFinditer(r"(\w+)", VV1wIO, IGNORECASE):
      list.add(match.group(1).strip())
    words = VV1wIO.split(" ")
    tWord = ""
    for word in words:
     tWord += " " + word
     list.add(word.strip())
     list.add(tWord.strip())
    for item in sorted(list):
     if item:
      VV3wat.append((item, item))
    if not VV3wat and VV1wIO:
     VV3wat.append((VV1wIO, VV1wIO))
    FFLFTC(self, self.VVF5KS, VV3wat=VV3wat)
   else:
    VV6A99.VV6fGE("Invalid Channel Name")
  else:
   words, asPrefix = CCoErY.VVPBNm(words)
   if not words and mode in (self.VVqJ6d, self.VVa4UD):
    FF28n1(self.VV6A99, "Incorrect filter", 2000)
   else:
    self.VVBk7J = BF(FFimQ3, self.VV6A99, BF(self.VVKAPw, mode, words, asPrefix, title), clearMsg=False, title="Filtering ...")
    self.VVBk7J()
 def VVF5KS(self, word=None):
  if word:
   title = "Filter: %s" % FFjt5L(word, VVJEMb)
   self.VVBk7J = BF(FFimQ3, self.VV6A99, BF(self.VVKAPw, self.VVvCuq, [word.lower()], False, title), clearMsg=False, title="Filtering ...")
   self.VVBk7J()
 @staticmethod
 def VVBmSe(txt):
  return "#f#11ffff00#" + txt
 def VVKAPw(self, mode, words, asPrefix, title):
  if self.VVV9Jd : VVAkuK = self.VV1l8Y(mode=mode, words=words, asPrefix=asPrefix)
  else       : VVAkuK = self.VVoN6g(mode=mode, words=words, asPrefix=asPrefix)
  if VVAkuK:
   self.VV6A99.VVMqQ9(VVAkuK, title)
   return True
  else:
   self.VV6A99.VV6fGE("Not found")
   return False
 def VV1l8Y(self, mode=0, words=None, asPrefix=False):
  VVAkuK = []
  for row in self.VV6A99.VVrrm9():
   row = list(map(str.strip, row))
   chNum, VV1wIO, VVY5Mx, chType, VVPxk5, url = row
   if self.VVDWbD(mode, VVPxk5, FFXarh(url).lower(), VV1wIO, words, VVY5Mx.lower(), asPrefix):
    VVAkuK.append(row)
  VVAkuK = self.VVEhJo(mode, VVAkuK)
  return VVAkuK
 def VVoN6g(self, mode=0, words=None, asPrefix=False, isStripChan=False):
  patt = r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8})(http.+)\n#DESCRIPTION\s+"
  if isStripChan: patt += r"[^\x00-\x7F]*(.+)[^\x00-\x7F]*"
  else    : patt += r"(.+)"
  VVAkuK = []
  files = CCkEI5.VVjMS6()
  if files:
   chNum = 1
   for path in files:
    if path.endswith("radio"): chType = "Radio"
    else      : chType = "TV"
    txt = FFYVq0(path)
    span = iSearch(r"#NAME\s(.+)", txt, IGNORECASE)
    if span : VVY5Mx = span.group(1)
    else : VVY5Mx = ""
    VVY5Mx_lCase = VVY5Mx.lower()
    for match in iFinditer(patt, txt, IGNORECASE):
     VVPxk5 = match.group(1).upper()
     url  = match.group(2).strip()
     VV1wIO = match.group(3).strip()
     if self.VVAP76(VV1wIO): VViido = self.VVBmSe(VV1wIO)
     else        : VViido = VV1wIO
     row = (str(chNum), VViido, VVY5Mx, chType + (" SRel" if FFHgaY(url) else ""), VVPxk5, url)
     if self.VVDWbD(mode, VVPxk5, FFXarh(url).lower(), VV1wIO, words, VVY5Mx_lCase, asPrefix):
      VVAkuK.append(row)
      chNum += 1
  VVAkuK = self.VVEhJo(mode, VVAkuK)
  return VVAkuK
 def VVEhJo(self, mode, VVAkuK):
  newRows = []
  if VVAkuK and mode == self.VVYSwZ:
   counted  = iCounter(elem[4] for elem in VVAkuK)
   for item in VVAkuK:
    tot = counted.get(item[4], 0)
    if tot > 1:
     newRows.append(item)
   return newRows
  else:
   return VVAkuK
 def VVDWbD(self, mode, VVPxk5, tUrl, VV1wIO, words, VVY5Mx_lCase, asPrefix):
  if   mode == self.VVwTwt : return True
  elif mode == self.VVYSwZ : return True
  elif mode == self.VVdQtp  : return ":0:0:0:0:0:0:" in VVPxk5
  elif mode == self.VV5dgQ : return FFHgaY(tUrl)
  elif mode == self.VVvTCX  : return CCkEI5.VVNeuG(tUrl, getAudVid=True) == "vid"
  elif mode == self.VVMDMz  : return CCkEI5.VVNeuG(tUrl, getAudVid=True) == "aud"
  elif mode == self.VVKkG6  : return CCkEI5.VVNeuG(tUrl, compareType="live")
  elif mode == self.VVL3RT  : return CCkEI5.VVNeuG(tUrl, compareType="vod")
  elif mode == self.VVQVpf : return CCkEI5.VVNeuG(tUrl, compareType="series")
  elif mode == self.VV08wu  : return CCkEI5.VVNeuG(tUrl, compareType="")
  elif mode == self.VV1MxY  : return CCkEI5.VVNeuG(tUrl, compareExt="mkv")
  elif mode == self.VVQaZg  : return CCkEI5.VVNeuG(tUrl, compareExt="mp4")
  elif mode == self.VVCz9o  : return CCkEI5.VVNeuG(tUrl, compareExt="mp3")
  elif mode == self.VV5aRM  : return CCkEI5.VVNeuG(tUrl, compareExt="avi")
  elif mode == self.VVDxcx  : return CCkEI5.VVNeuG(tUrl, compareExt="flv")
  elif mode == self.VVH6Pi: return VV1wIO.lower().startswith(words[0])
  elif mode == self.VVvCuq: return words[0] in VV1wIO.lower()
  elif mode == self.VV17gf: return bool(iSearch(r"[^\x00-\x7F]", VV1wIO))
  elif mode == self.VVqJ6d : return words[0] == VVY5Mx_lCase
  elif mode == self.VVa4UD :
   name = VV1wIO.lower()
   for word in words:
    if asPrefix:
     if name.startswith(word) : return True
    elif word in name    : return True
  return False
 def VVPgSR(self):
  picker = CCMvE7(self, self.VV6A99, "Add to Bouquet", self.VVmOKe)
 def VVmOKe(self):
  chUrlLst = []
  for row in self.VV6A99.VVrrm9():
   chUrlLst.append(row[4] + row[5])
  return chUrlLst
 def VVL3AS(self):
  tot = self.VV6A99.VVn1uo()
  FFRMYv(self, self.VV7cGE, "Delete %s IPTV Channel%s ?" % (tot, FFcacr(tot)))
 def VV7cGE(self):
  bFiles = CCkEI5.VVjMS6()
  if not bFiles:
   FF28n1(self.VV6A99, "No bouquets files !", 1500)
   return
  totRows = self.VV6A99.VVn1uo()
  if not totRows:
   FF28n1(self.VV6A99, "Cannot read list", 1500)
   return
  CCh3tv.VV7Nf4(self, VVLL7M="Renumbering References", VVIZBP=CCh3tv.VVgJkc, totBars=2
      , VVixvy  = BF(self.VVp9DE, totRows, bFiles)
      , VVbYwR = self.VVtXN6 )
 def VVp9DE(self, totRows, bFiles, VVXyP6):
  totDel = totBouq = 0
  VVXyP6.VVq8NF(len(bFiles))
  VVXyP6.VVUIH1(totRows)
  VVXyP6.VVNc18 = (totRows, totDel, totBouq)
  for path in bFiles:
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   if FFCyVu(path):
    toSave = False
    txt  = FFYVq0(path)
    span = iSearch(r"#NAME\s+(.+)", txt, IGNORECASE)
    if span : bName = span.group(1)
    else : bName = os.path.splitext(os.path.basename(path))[0]
    VVXyP6.VVaks5("%s   %s" % (totDel, bName))
    VVXyP6.VVxtQs(1)
    VVXyP6.VVV3RA(0)
    for row in self.VV6A99.VVrrm9():
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     VVXyP6.VVg2Dw(1)
     ref = row[4] + row[5]
     if ref in txt:
      txt, tot = iSubn(r"(#SERVICE\s+%s\n#DESCRIPTION.+\n?)" % iEscape(ref), "", txt)
      if tot > 0:
       totDel += tot
       VVXyP6.VVNc18 = (totRows, totDel, totBouq)
       toSave = True
    if toSave:
     totBouq += 1
     VVXyP6.VVNc18 = (totRows, totDel, totBouq)
     with open(path, "w") as f:
      f.write(txt)
 def VVtXN6(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  totRows, totDel, totBouq = VVNc18
  if totBouq:
   FFfpyJ()
   txt  = "Channels\t: %s\n" % totRows
   txt += "Deleted\t: %s   (from %s bouquet%s)" % (totDel, totBouq, FFcacr(totBouq))
   FF4lCP(self, txt, VVbYwR=BF(FFimQ3, self.VV6A99 or self, self.VVZ00Q, clearMsg=False))
  else:
   FFipXT(self, "No changes.")
 def VVZ00Q(self):
  if self.VV6A99:
   if not self.VVBk7J():
    if not self.VVKAPw(self.VVwTwt, "", False, "Local IPTV Services"):
     self.VV6A99.cancel()
 def VVDcKO(self):
  t1 = FFjt5L("Bouquet" , VVFuwR)
  t2 = FFjt5L("ALL"  , VVyFI2)
  t3 = FFjt5L("Unique"  , VVZtfx)
  t4 = FFjt5L("Identical" , VVIH76)
  VV3wat = []
  VV3wat.append((VVJEMb + "Check System Acceptable Reference Types", "VVhMoT"))
  VV3wat.append(FFsLU5("Check Reference Codes Format", "VVWgKX", self.VVvnTo, VVJEMb))
  VV3wat.append(VVAL3j)
  txt = "Change %s Ref. Types to (1/4097/5001/5002/8192/8193/8793) .."
  VV3wat.append((txt % t1, "VVOO3I" ))
  VV3wat.append((txt % t2, "VVcMWv_all"  ))
  VV3wat.append(VVAL3j)
  txt = "Change %s References to %s Codes .."
  VV3wat.append((txt % (t1, t3), "VV5I9P" ))
  VV3wat.append((txt % (t2, t3), "VVFTpS"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Change %s References to %s Codes" % (t2, t4) , "VVthI4_all"))
  VVOa1G = self.VVK6T4
  FFLFTC(self, None, width=1220, title="IPTV Reference Tools", VV3wat=VV3wat, VVOa1G=VVOa1G, VVwltY="#22002233", VVkxBG="#22001122")
 def VVK6T4(self, item=None):
  if item:
   ques = "Continue ?"
   VV7tND, txt, item, ndx = item
   if   item == "VVhMoT"    : FFimQ3(VV7tND, self.VVhMoT)
   elif item == "VVWgKX"     : FFimQ3(VV7tND, self.VVWgKX)
   elif item == "VVOO3I" : self.VVHp9J(VV7tND, self.VVEOTS)
   elif item == "VVcMWv_all"  : self.VVEOTS(VV7tND, None, None)
   elif item == "VV5I9P" : self.VV5I9P(VV7tND, txt)
   elif item == "VVFTpS"  : FFRMYv(self, BF(self.VVFTpS , VV7tND, txt), title=txt, VVsWSA=ques)
   elif item == "VVthI4_all"  : FFRMYv(self, BF(FFimQ3, VV7tND, self.VVthI4), title=txt, VVsWSA=ques)
 def VVEOTS(self, VV7tND, bName, bPath):
  VV3wat = []
  for rt in CCkEI5.VV5LSJ():
   VV3wat.append(("%s\t ... %s" % (rt, CCkEI5.VVDWCB(rt)), rt))
  FFLFTC(self, BF(self.VV9RIk, VV7tND, bName, bPath), VV3wat=VV3wat, width=800, title="Change Reference Types to:")
 def VV9RIk(self, VV7tND, bName, bPath, rType=None):
  if rType:
   self.VVte9c(VV7tND, bName, bPath, rType)
 def VVHp9J(self, VV7tND, fnc):
  VV3wat = CCMvE7.VVlHzq()
  if VV3wat:
   FFLFTC(self, BF(self.VVNL6A, VV7tND, fnc), VV3wat=VV3wat, title="IPTV Bouquets", VVU8mZ=True)
  else:
   FF28n1(VV7tND, "No bouquets Found !", 1500)
 def VVNL6A(self, VV7tND, fnc, item=None):
  if item:
   bName, bRef, ndx = item
   span = iSearch(r'BOUQUET "(.+)" ORDER', bRef, IGNORECASE)
   if span:
    bPath = VVQe79 + span.group(1)
    if FFCyVu(bPath): fnc(VV7tND, bName, bPath)
    else    : FF28n1(VV7tND, "Bouquet file not found!", 2000)
   else:
    FF28n1(VV7tND, "Cannot process bouquet !", 2000)
 def VVte9c(self, VV7tND, bName, bPath, rType):
  if bPath: title = "Change for Bouquet : %s" % FFjt5L(bName, VV1fx4)
  else : title = "Change for %s" % FFjt5L("All IPTV Services", VV1fx4)
  FFRMYv(self, BF(self.VVoQBH, VV7tND, bName, bPath, rType), "Change to : %s ?" % FFjt5L(rType, VV1fx4), title=title)
 @FFOAKH("Changing Type ...", par=1)
 def VVoQBH(self, VV7tND, bName, bPath, rType):
  totChange = 0
  if bPath: files = [bPath]
  else : files = CCkEI5.VVjMS6()
  if files:
   newRType = rType + ":"
   piconPath = CCafIt.VVjkKT()
   for path in files:
    if   not FFCyVu(path)      : err = "Cannot read the file:\n\n%s" % path
    elif not CClYaF.VVSOog(self, path) : err = "File is not in 'UTF-8' Encoding:\n\n%s" % path
    else           : err = ""
    if err:
     FFdw58(self, err)
     return
    newpFile = path + ".tmp"
    totMod = 0
    with open(newpFile, "w") as tFile:
     with ioOpen(path, "r", encoding="utf-8") as f:
      for line in f:
       span = iSearch(r"#SERVICE\s+([A-Fa-f0-9]+[:]).+http.+", line)
       if span:
        oldRType = span.group(1)
        if not oldRType == newRType:
         totMod += 1
         totChange += 1
         span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
         if span : oldPicon = piconPath + span.group(1).strip(":").replace(":", "_") + ".png"
         else : oldPicon = ""
         line = iSub(r"(#SERVICE)\s+[A-Fa-f0-9]+[:](.+http.+)", r"\1 %s\2" % newRType, line)
         if FFCyVu(oldPicon):
          span = iSearch(r"((?:[A-Fa-f0-9]+[:]){10})", line)
          if span:
           FFpwZS("mv -f '%s' '%s'" % (oldPicon, piconPath + span.group(1).strip(":").replace(":", "_") + ".png"))
       tFile.write(line)
    if totMod: cmd = "mv -f '%s' '%s'" % (newpFile, path)
    else  : cmd = "rm -f '%s'" % newpFile
    FFpwZS(cmd)
  self.VVkNdH(totChange > 0, 'Change Ref. Codes to "%s"' % rType, "Changes = %d" % totChange)
 @FFOAKH()
 def VVXKGz(self):
  totFiles = 0
  files  = CCkEI5.VVjMS6()
  if files:
   totFiles = len(files)
  totChans = 0
  VVAkuK = self.VVoN6g()
  if VVAkuK:
   totChans = len(VVAkuK)
  FF4lCP(self, "Total Files\t: %d\nTotal Channels\t: %d" % (totFiles, totChans))
 def VVWgKX(self):
  files = CCkEI5.VVjMS6()
  if files:
   totInvalid = 0
   invTxt  = ""
   for path in files:
    txt = FFYVq0(path)
    for match in iFinditer(r"#SERVICE\s+(?!(?:(?:[A-Fa-f0-9]+[:]){10})).+\n#DESCRIPTION\s+(.+)", txt, IGNORECASE):
     totInvalid += 1
     invTxt += "%s\t: %s\n" % (os.path.basename(path), match.group(1))
   if totInvalid == 0 : color = VVSGsk
   else    : color = VVz22H
   totInvalid = FFjt5L(totInvalid, color)
   txt  = "Processed Files\t\t: %d\n" % len(files)
   txt += "Invalid References\t: %s\n" % totInvalid
   if invTxt:
    txt += FFjt5L("\nInvalid Refrences (File & Chan. Name):\n", color)
    txt += invTxt
  else:
   txt = "No IPTV Files processed."
  FF4lCP(self, txt, title="Check IPTV References")
 def VVhMoT(self):
  bName  = "%s_IPTV_TMP_BOUQUET_DEL" % VVh9hj
  userBName = "userbouquet.%s.tv"  % bName
  chPrefix = "Testing RType "
  rTypeList = CCkEI5.VV5LSJ()
  chUrlLst = []
  for rType in (rTypeList):
   ref = "%s:0:1:DDD:DDD:DDD:DDD:0:0:0:http%%3a//testUrl.com/aa/bb.m3u8:Testing RType %s" % (rType, rType)
   chUrlLst.append(ref)
  CCMvE7.VVPJK0(self, "", bName, "", chUrlLst, showRes=False)
  acceptedList = []
  VVKETx = eServiceReference('1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % userBName)
  if VVKETx:
   VVlGGv = FFZcDI(VVKETx)
   if VVlGGv:
    for service in VVlGGv:
     VV1wIO = service[1]
     acceptedList.append(VV1wIO.replace(chPrefix, ""))
  path = VVQe79 + userBName
  bFile = VVQe79 + "bouquets.tv"
  tmpF = bFile + ".tmp"
  cmd = FFb2oQ("grep -v '%s' '%s' > '%s'; mv '%s' '%s'" % (userBName, bFile, tmpF, tmpF, bFile))
  cmd += FFb2oQ("rm -f '%s'" % path)
  FFpwZS(cmd)
  FFfpyJ()
  title = "System Acceptable Reference Types"
  if acceptedList:
   txt = ""
   for item in rTypeList:
    if item in acceptedList : res, color = "Yes", VVSGsk
    else     : res, color = "No" , VVz22H
    pl = CCkEI5.VVDWCB(item)
    txt += "    %s\t: %s%s\n" % (item, FFjt5L(res, color), FFjt5L("\t... %s" % pl, VVA4XU) if pl else "")
   FF4lCP(self, txt, title=title)
  else:
   txt = FFdw58(self, "Could not complete the test on your system!", title=title)
 @FFOAKH()
 def VVkIRr(self):
  VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVmjC7)
  if VVHj48:
   totChannels = 0
   totChange = 0
   for path in CCkEI5.VVjMS6():
    toSave = False
    txt = FFYVq0(path)
    for match in iFinditer(r"(#SERVICE\s+[A-Fa-f0-9]+:)0:(?:[A-Fa-f0-9]+[:]){8}(.+\n#DESCRIPTION\s+(?:.+[:()|\]\[])*(.+))", txt, IGNORECASE):
     totChannels += 1
     VV1wIO = match.group(3).strip(" !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~")
     VVPxk5 = VVHj48.get(VV1wIO, "")
     if VVPxk5:
      VVPxk5  = VVPxk5[VVPxk5.index(":") + 1:]
      toSave  = True
      totChange += 1
      txt = txt.replace(match.group(0), match.group(1) + VVPxk5 + ":" + match.group(2))
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
   txt  = "Channels\t: %d\n" % totChannels
   txt += "Changed\t: %d\n" % totChange
   self.VVkNdH(totChange > 0, "Copy Ref. from existing Channels", txt)
  else:
   FFdw58(self, 'No channels in "lamedb" !')
 def VVFTpS(self, VV7tND, title):
  bFiles = CCkEI5.VVjMS6()
  if bFiles: self.VV0cc4(bFiles, title)
  else  : FF28n1(VV7tND, "No bouquets files !", 1500)
 def VV5I9P(self, VV7tND, title):
  self.VVHp9J(VV7tND, BF(self.VV9ynJ, title))
 def VV9ynJ(self, title, VV7tND, bName, bPath):
  self.VV0cc4([bPath], title)
 def VV0cc4(self, bFiles, title):
  CCh3tv.VV7Nf4(self, VVLL7M="Renumbering References"
      , VVixvy  = BF(self.VVXz3o, bFiles)
      , VVbYwR = BF(self.VVKsbI, title))
 def VVXz3o(self, bFiles, VVXyP6):
  VVXyP6.VVNc18 = ""
  VVXyP6.VVaks5("Calculating Reference ...")
  totLines = 0
  patt = r"#SERVICE\s+(?:[A-Fa-f0-9]+[:]){10}(.+\/\/.+)"
  for path in bFiles:
   if FFCyVu(path):
    lines = FFL19l(path)
    for line in lines:
     span = iSearch(patt, line)
     if span:
      totLines += 1
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  elif not totLines:
   VVXyP6.VVNc18 = "No IPTV Services !"
   return
  else:
   VVXyP6.VVq8NF(totLines)
  rType = CFG.iptvAddToBouquetRefType.getValue()
  startId = startNS = 0
  for path in bFiles:
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   if FFCyVu(path):
    toSave = False
    bName  = os.path.basename(path)
    lines  = FFL19l(path)
    for ndx, line in enumerate(lines):
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     if ndx == 0:
      span = iSearch(r"#NAME\s+(.+)", line, IGNORECASE)
      if span:
       bName = span.group(1)
      if VVXyP6:
       VVXyP6.VVaks5("Processing : %s " % bName)
     span = iSearch(patt, line)
     if span:
      if VVXyP6:
       VVXyP6.VVxtQs(1)
      VVPxk5, startId, startNS = CCMvE7.VVIGWw(rType, CCMvE7.VVZ6bs, [], startId, startNS)
      if VVPxk5:
       lines[ndx] = "#SERVICE %s" % (VVPxk5 + span.group(1))
       toSave = True
      else:
       if VVXyP6:
        VVXyP6.VVNc18 = "Out of Free References while processing the file:\n%s" % path
       return
    if toSave:
     with open(path, "w") as f:
      f.write("\n".join(lines) + "\n")
 def VVKsbI(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  txt  = "Found\t: %d\n"  % threadTotal
  txt += "Changed\t: %d\n" % threadCounter
  if VVNc18:
   txt += "\n\n%s\n%s" % (FFjt5L("Ended with Error:", VVz22H), VVNc18)
  self.VVkNdH(True, title, txt)
 def VVWnDr(self):
  bFiles = CCkEI5.VVjMS6()
  if not bFiles:
   FF28n1(self.VV6A99, "No bouquets files !", 1500)
   return
  tableRefList = []
  for row in self.VV6A99.VVrrm9():
   tableRefList.append((row[4], row[5]))
  if not tableRefList:
   FF28n1(self.VV6A99, "Cannot read list", 1500)
   return
  CCh3tv.VV7Nf4(self, VVLL7M="Renumbering References"
      , VVixvy  = BF(self.VV61QR, bFiles, tableRefList)
      , VVbYwR = BF(self.VVKsbI, "Change Current List References to Unique Codes"))
 def VV61QR(self, bFiles, tableRefList, VVXyP6):
  VVXyP6.VVNc18 = ""
  VVXyP6.VVaks5("Reading System References ...")
  refLst = CCMvE7.VVc8iI(CCMvE7.VVZ6bs, stripRType=True)
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVq8NF(len(tableRefList))
  rType = CFG.iptvAddToBouquetRefType.getValue()
  startId = startNS = 0
  for path in bFiles:
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   if FFCyVu(path):
    toSave = False
    bName = os.path.basename(path)
    txt  = FFYVq0(path)
    span = iSearch(r"#NAME\s+(.+)", txt, IGNORECASE)
    if span:
     bName = span.group(1)
    if not VVXyP6 or VVXyP6.isCancelled:
     return
    VVXyP6.VVaks5("Processing : %s " % bName)
    for ref, url in tableRefList:
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     VVu06s = ref + url
     if VVu06s in txt:
      VVXyP6.VVxtQs(1)
      VVPxk5, startId, startNS = CCMvE7.VVIGWw(rType, CCMvE7.VVZ6bs, refLst, startId, startNS)
      if VVPxk5:
       tot = txt.count(VVu06s)
       if tot > 0:
        txt = txt.replace(VVu06s, VVPxk5 + url)
        toSave = True
      else:
       if VVXyP6:
        VVXyP6.VVNc18 = "Out of Free References while processing the file:\n%s" % path
       return
    if toSave:
     with open(path, "w") as f:
      f.write(txt)
 def VVthI4(self):
  list = None
  if self.VV6A99:
   list = []
   for row in self.VV6A99.VVrrm9():
    list.append(row[4] + row[5])
  files = CCkEI5.VVjMS6()
  totChange = 0
  if files:
   for path in files:
    lines = FFL19l(path)
    toSave = False
    for ndx, line in enumerate(lines):
     span = iSearch(r"#SERVICE\s+(.+\/\/.+)", line, IGNORECASE)
     if span:
      if not list or span.group(1) in list:
       txt, tot = iSubn(r"(#SERVICE\s+(?:[A-Fa-f0-9]+[:]){3})(?:[A-Fa-f0-9]+[:]){7}(.+\/\/.+)", r"\g<1>%s\2" % ("0:" * 7), line, IGNORECASE)
       if tot > 0:
        lines[ndx] = txt
        toSave  = True
        totChange += 1
    if toSave:
     with open(path, "w") as f:
      f.write("\n".join(lines) + "\n")
  self.VVkNdH(totChange > 0, "Change to Identical Ref. Codes", "Changes = %d" % totChange)
 def VVkNdH(self, isChanged, title, txt, refreshTable=True):
  if isChanged:
   FFfpyJ()
   if refreshTable and self.VV6A99:
    VVAkuK = self.VVoN6g()
    if VVAkuK and self.VV6A99:
     self.VV6A99.VVMqQ9(VVAkuK, self.VVXTPg)
     self.VV6A99.VV6fGE(txt)
   FF4lCP(self, txt, title=title)
  else:
   FFipXT(self, "No changes.")
 @staticmethod
 def VVjMS6(atLeastOne=False, onlyFileName=False):
  types = ('*.tv', '*.radio')
  files = []
  for f in types:
   files.extend(iGlob(VVQe79 + f))
  if files:
   iptvFiles = []
   for path in files:
    if FFCyVu(path):
     txt = FFYVq0(path)
     span = iSearch(r"#SERVICE.+\/\/.+\n#DESCRIPTION.+", txt, IGNORECASE)
     if span:
      iptvFiles.append(os.path.basename(path) if onlyFileName else path)
      if atLeastOne:
       return iptvFiles
   return iptvFiles
  else:
   return None
 def VVen0D(self, VV6A99, title, txt, colList):
  Num, Name, Bouquet, Type, Ref, URL = VV6A99.VV5crm()
  VVZcRP = FFXarh(URL)
  VVfaDB = "%s:%s" % (Ref.rstrip(":"), URL.rstrip(":"))
  if not VVfaDB.endswith(":" + Name):
   VVfaDB += ":" + Name
  txt  = "%s\n\n" % title
  txt += "Name\t: %s\n" % FFjt5L(Name, VVFuwR)
  txt += "Bouquet\t: %s\n" % Bouquet
  txt += CCvjVs.VVjB93(FFXarh(VVfaDB), showUrl=False)
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVXwW0, params=(Ref, Name, txt, VVZcRP, VVfaDB))
 def VVIHV3(self, VV6A99, colList):
  VV1wIO = colList[1]
  VVPxk5 = colList[4]
  url  = colList[5]
  chUrl = VVPxk5 + url
  return VV1wIO, chUrl
 def VVG1o1(self, VV6A99, title, txt, colList):
  VV1wIO, chUrl = self.VVIHV3(VV6A99, colList)
  self.VVMp7d(VV6A99, VV1wIO, chUrl, "localIptv")
 def VVYAch(self, mode, VV6A99, colList):
  VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
  VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
  return VV1wIO, chUrl, VVAfO9
 def VVF9cb(self, mode, VV6A99, title, txt, colList):
  VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
  VVAfO9 = os.path.join(self.VVYrUH(mode), os.path.basename(VVfbmn)) if VVfbmn else ""
  self.VVMp7d(VV6A99, VV1wIO, chUrl, mode, VVAfO9)
 def VVMp7d(self, VV6A99, VV1wIO, chUrl, mode, VVAfO9=""):
  VV1wIO = FFzBfi(VV1wIO)
  if self.VVAP76(VV1wIO):
   FF28n1(VV6A99, "This is a marker!", 300)
  else:
   CCqWM2.VVHc02(self.session, VVwqHQ=(self, VV6A99, mode), VVaHNe=chUrl, VVAfO9=VVAfO9, VVV4a7=mode == self.VV4kmD)
 @staticmethod
 def VVAP76(VV1wIO):
  mark = ("--", "__", "==", "##",  "**", "_*", "*_", str(u"\u2605" * 2))
  if VV1wIO.startswith(mark) and VV1wIO.endswith(mark):
   return True
  return False
 def VVEzbx(self, VV6A99, title, txt, colList):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  if VVPxk5:
   url1 = FFXarh(VV57TX.strip())
   for ndx, row in enumerate(VV6A99.VVrrm9()):
    if VVPxk5 in row[4]:
     tableRow = FFXarh(row[5].strip())
     if url1 in tableRow or tableRow in url1:
      VV6A99.VVrqBw(ndx)
      break
   else:
    FF28n1(VV6A99, "Not found", 1000)
 def VV9w3Z(self):
  if CCwhE4.VVOJRa(self):
   self.VVj5lb()
 @FFOAKH("Searching ...")
 def VVj5lb(self):
  lines = self.VVKEO0(3)
  if lines:
   lst = []
   for f in lines:
    if os.path.isfile(f):
     m3File, m3Dir, VVcwFG, zPath, zFound = CCjZbZ.VVuYvs(f)
     sz = FFXhoc(f)
     (m3SzT, m3Sz) = (CClYaF.VV99gM(sz, mode=4), str(sz)) if sz > -1 else ("", "")
     m3Tm = zSz = ""
     if zFound:
      sz = FFXhoc(zPath)
      zSz = CClYaF.VV99gM(sz, mode=4) if sz > -1 else ""
      if zSz: m3SzT = "#f#0066ff66#" + m3SzT
      m3Tm = CCjZbZ.VVs0Rm(zPath).srcMod
     lst.append((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
   title = "M3U/M3U8 File Browser"
   if lst:
    lst.sort(key=lambda x: x[0].lower())
    bTitle = "Playlist Options"
    bg = "#11221122"
    VVb5gJ  = {3:2}
    VVu1YM  = ("Select"    , self.VVSTF4       , [])
    VVwSzI = ("Refresh File Cache" , self.VVisGJ    , [])
    VVScQz = ("File Options"  , self.VVoEEw       , [])
    VV4QTJ = (bTitle    , BF(self.VVRhAi, bTitle) , [])
    header   = ("File" , "Path", "Size","Size" , "zPath" , "Cached Size" , "m3Tm" )
    widths   = (50  , 38 , 0.02 , 12 , 0   , 0.01   , 0   )
    VVLIqP  = (LEFT  , LEFT , CENTER, CENTER, CENTER , CENTER  , CENTER )
    tbl = FFUQ0v(self, None, title=title, header=header, VVGape=lst, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVb5gJ=VVb5gJ, VVu1YM=VVu1YM, VV4QTJ=VV4QTJ, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY="#11221122", VVkxBG=bg, VVemyB=bg, VVJKqd="#11004a55", VVbcr0="#0a333333", VVX9AA="#06333333")
    tbl.VVIOX6(BF(self.VVJ5wF, tbl))
   else:
    FFdw58(self,"No files found." , title=title)
 def VVSTF4(self, VV6A99, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  CCjZbZ(VV6A99, CCjZbZ.VVCAqE, m3uF=m3Dir+m3File, VVMye8=BF(self.VVMaF7, VV6A99))
 def VVisGJ(self, VV6A99, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  if VV6A99["keyGreen"].getVisible():
   CCjZbZ(self, CCjZbZ.VVWcXC, m3uF=m3Dir+m3File, VVMye8=BF(self.VVMaF7, VV6A99))
 def VVoEEw(self, VV6A99, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  VV3wat = []
  VV3wat.append(("Delete Selected File"   , "delm3u"))
  if zSz: VV3wat.append(("Delete Local Cache" , "delZip"))
  FFLFTC(self, BF(self.VVHXsl, VV6A99, colList), title="File Options", VV3wat=VV3wat, width=700, VVU8mZ=True)
 def VVHXsl(self, VV6A99, colList, item):
  if item:
   title, ref, ndx = item
   m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
   if  ref == "delm3u": path = m3Dir + m3File
   elif ref == "delZip": path = zPath
   FFRMYv(self, BF(self.VVav84, VV6A99, path, ref), "Delete ?\n\n%s" % path, title=title)
 def VVav84(self, VV6A99, path, ref):
  FFwgGB(path)
  if ref == "delm3u":
   if FFCyVu(path) : FF28n1(VV6A99, "No deleted", 1000)
   else    : VV6A99.VVtM2v()
  elif ref == "delZip":
   self.VVMaF7(VV6A99)
 def VVRhAi(self, Title, VV6A99, title, txt, colList):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = colList
  VV3wat = []
  VV3wat.append(("Browse Selected Server Online"  , "br"))
  VV3wat.append(("Filter Playlist URLs (from all Files)", "fl"))
  FFLFTC(self, BF(self.VVBhfH, VV6A99, m3Dir+m3File), title=Title, VV3wat=VV3wat, width=700, VVU8mZ=True)
 def VVBhfH(self, VV6A99, path, item):
  if item:
   title, ref, ndx = item
   if  ref == "br": self.VV57zg(VV6A99, title, path)
   elif ref == "fl": self.VVDcLv(VV6A99)
 def VVMaF7(self, VV6A99, *arg):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VV6A99.VV5crm()
  sz = FFXhoc(zPath)
  zSz = CClYaF.VV99gM(sz, mode=4) if sz > -1 else ""
  try: m3Tm = str(int(os.path.getmtime(m3Dir + m3File)))
  except: m3Tm = ""
  VV6A99.VViSLW((m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm))
  if zSz:
   fg = FFRUST("#0066ff66")
   ndx = VV6A99.VVGTqU()
   VV6A99.VVmMYI(ndx, 3, 8, fg)
   VV6A99.VVmMYI(ndx, 3, 9, fg)
  self.VVJ5wF(VV6A99)
 def VVJ5wF(self, VV6A99):
  m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm = VV6A99.VV5crm()
  VV6A99["keyGreen"].hide()
  if zSz and m3Tm:
   try: curTm = int(os.path.getmtime(m3Dir + m3File))
   except: curTm = ""
   if curTm and m3Tm != str(curTm):
    VV6A99["keyGreen"].show()
 def VVDcLv(self, VV6A99):
  CCh3tv.VV7Nf4(self, titleBg="#22003344", bodyBg="#22001122"
      , VVixvy  = BF(self.VVCGdA, VV6A99)
      , VVbYwR = self.VVVcMx)
 def VVCGdA(self, VV6A99, VVXyP6):
  lst = []
  dupl = 0
  totF = VV6A99.VVn1uo()
  VVXyP6.VVq8NF(totF)
  VVXyP6.VVNc18 = (totF, dupl, lst)
  for ndx, (m3File, m3Dir, m3Sz, m3SzT, zPath, zSz, m3Tm) in enumerate(VV6A99.VVrrm9()):
   path = m3Dir + m3File
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVaks5(os.path.basename(path))
   VVXyP6.VVxtQs(1)
   if FFCyVu(path):
    enc = CC7ocD.VV51oT(path)
    if not enc == -1:
     with ioOpen(path, "r", encoding=enc) as f:
      for line in f:
       if not VVXyP6 or VVXyP6.isCancelled: return
       line = str(line).strip()
       line, _, _ = line.partition("?")
       line, _, _ = line.partition("&")
       if len(line) < 500:
        url = CCkEI5.VVyZOO(line)
        if url:
         if not url in lst: lst.append(url)
         else    : dupl += 1
         VVXyP6.VVNc18 = (totF, dupl, lst)
         break
 def VVVcMx(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  title = "Create Playlist from m3u Files"
  totF, dupl, lst = VVNc18
  if not lst:
   FFdw58(self, "Could not obtain URLs from this file list !", title=title)
   return
  lst.sort()
  pListF = "%sPlaylist_%s.txt" % (FF7BT0(), FFjTQe())
  with open(pListF, "w") as f:
   for url in lst:
    f.write(url + "\n")
  txt = ""
  txt += "Total Files\t: %d\n" % totF
  txt += "Prcessed Files\t: %d\n" % threadCounter
  if dupl > 0: txt += "Duplicates\t: %d  (removed)\n" % dupl
  txt += "Created Lines\t: %d\n" % len(lst)
  txt += "Playlist File\t: %s" % pListF
  FF4lCP(self, txt, title=title)
 @FFOAKH("Searching ...")
 def VV0muG(self, mode):
  if   mode == 1: title, okFnc = "Select Playlist File", self.VVtDsx
  elif mode == 2: title, okFnc = "Select Portal File"  , self.VVDtP0
  lines = self.VVKEO0(mode)
  if lines:
   lines.sort()
   VV3wat = []
   for line in lines:
    VV3wat.append((FFjt5L(line, VVFuwR) if "Bookmarks" in line else line, line))
   t = CC6u6z.VVZxjK(901 if mode==1 else 902) if mode in (1, 2) and VVBvqf else None
   VVJbOd = self.VVNhTV
   VVwJOl = (VVFuwR + t, BF(self.VVHgVh, mode, t)) if t else None
   VVaTeF = ("Merge All Files", BF(self.VVYmtc, mode)) if len(VV3wat) > 1 else None
   FFLFTC(self, None, title=title, VV3wat=VV3wat, width=1700, height=900, VVOa1G=okFnc, VVJbOd=VVJbOd, VVwJOl=VVwJOl, VVaTeF=VVaTeF, VVtboQ="")
 def VVKEO0(self, mode):
  err = excl = ""
  dirs = []
  path = "/"
  if CFG.iptvHostsMode.getValue() == VVSBbs:
   excl = FF5W9s(1)
  else:
   lst = list(set(list(map(str.strip, CFG.iptvHostsDirs.getValue().split(",")))))
   tList = []
   for Dir in lst:
    if VVmJwX(Dir):
     tList.append(Dir)
   lst = sorted(tList, key=len)
   for Dir in lst:
    for dir1 in dirs:
     if len(Dir) > len(dir1) and Dir.startswith(dir1):
      break
    else:
     dirs.append(Dir)
   if   len(dirs) == 1 : path = dirs[0]
   elif len(dirs) > 1 : path = "{%s}" % ",".join(dirs)
   if not dirs:
    FFdw58(self, 'Directory not found !\n\nCheck your settings option:\n\n"IPTV Hosts Files Path (Playlist, Portal, M3U)"')
    return []
  if   mode == 1: par = r'\( -iname "*playlist*" -o -iname "*stalker*" -o -iname "*urlscan.io*" \) | grep -i "\.txt\|\.json"'
  elif mode == 2: par = r'\( -iname "*portal*" -o -iname "*stalker*" -o -iname "*urlscan.io*"  \) | grep -i "\.txt\|\.conf\|\.json"'
  elif mode == 3: par = r'-iname "*.m3u" -o -iname "*.m3u8" | grep -i "\.m3u\|\.m3u8"'
  files = FF3xOt("find %s %s %s 2> /dev/null" % (path, excl, par))
  if files:
   err = CClYaF.VV8isu(files)
   if err : FFdw58(self, err + FFjt5L('\n\n( Change "IPTV Hosts Files Path" to "Custom" and try again )', VVFuwR))
   else : return files
  else:
   if   path == "/": txt = "!"
   elif dirs  : txt = "in directories listed in settings !"
   else   : txt = "in :\n%s" % path
   if   mode == 1: err = 'No Playlist files found %s\n\n Expecting ".txt" files\n(names must include the word "playlist")' % txt
   elif mode == 2: err = 'No portal files found %s\n\n Expecting ".txt" or ".conf" files\n(name must include the word "portal" or "stalker")' % txt
   elif mode == 3: err = 'No ".m3u" files found %s' % txt
   t = CC6u6z.VVZxjK(901 if mode==1 else 902) if mode in (1, 2) and VVBvqf else None
   if t: FFRMYv(self, BF(self.VVHgVh, mode, t), "%s ?" % t)
   else: FFdw58(self, err)
  return []
 def VVYmtc(self, mode, VV7tND, item):
  lst = VV7tND.VV35XX()
  title = "Merge %s files" % len(lst)
  w1 = w2 = ""
  for nm in lst:
   nm = nm.lower()
   if "playlist" in nm: w1 = "Playlist_"
   if "portal" in nm or "stalker" in nm: w2 = "Portal_"
  path = "%sMerged_%s%s%s.txt" % (FF7BT0(), w1, w2, FFjTQe())
  err = ""
  with open(path, "w") as outF:
   sep = "=" * 100
   c = 0
   try:
    for fil in lst:
     c += 1
     outF.write("#%s\nFile-%s: %s\n#%s\n" % (sep, c, fil, sep))
     outF.write("%s\n\n" % FFYVq0(fil).strip())
   except Exception as e:
    err = str(e)
  if err:
   FFwgGB(path)
   FFdw58(self, "Error in:\n%s\n\n%s" % (fil, err), title=title)
  else:
   FFipXT(self, "Saved to:\n\n%s" % path, title=title)
   VV7tND.VV5HD3((path, path), isSort=True)
 def VVHgVh(self, mode, t, VV7tND=None, item=None):
  if   mode == 1: fnc = self.VVu7ic(t, VV7tND)
  elif mode == 2: fnc = self.VVrYB9(t, VV7tND)
 @FFOAKH(par=2)
 def VVu7ic(self, title, VV7tND):
  lst = []
  for i in range(100, 118): lst.append(CC6u6z.VVZxjK(i))
  try: l1, l2, l3, r, t, u, p, U, P, H, J, L, x1, x2, x3, x4, x5, x6 = lst
  except: return
  if not all(lst): return
  exp = iCompile(r".*(%s.+)\/.*%s=(.+)&%s=([^&]+)" % (H, U, P), IGNORECASE)
  lst, eLst, mT = set(), [], ""
  fTm = FFjTQe()
  dstPath = FF7BT0()
  for ndx, l in enumerate((l1, l2, l3), start=1):
   resp, txt, err = CC96QG.VVKe8x(l, verify=True)
   if err:
    eLst.append(err)
   else:
    try: d = jLoads(txt)[r]
    except: d = {}
    for par in d:
     span = exp.search(str(par[t][u]))
     if span and all(span.groups()):
      lst.add(L % tuple([FFXarh(x).strip() for x in span.groups()]))
   if VVBvqf > 1:
    mT += ("%s\n%s\n%s\n\n" % (l, resp.headers, "\n".join([("%s\t: %s" % (x.ljust(30), resp.headers.get(x, ""))) for x in (x1, x2, x3, x4, x5, x6)]))) if resp else ""
    with open("%s%s_%s_%s.%s" % (dstPath, p, fTm, ndx, J), "w") as f: f.write(txt)
  if VVBvqf > 1:
   with open("%s%s_%s_0" % (dstPath, p, fTm), "w") as f: f.write(mT)
  if lst  : self.VVCnnM(VV7tND, None, "%s%s_%s.txt" % (dstPath, p, fTm), [(u, "") for u in lst], False)
  elif eLst: FFdw58(self, "\n\n".join(eLst), title=title)
  else  : FFdw58(self, "Not found", title=title)
 @FFOAKH(par=2)
 def VVrYB9(self, title, VV7tND):
  u, p = CC6u6z.VVZxjK(200), CC6u6z.VVZxjK(201)
  if not all(u and p): return
  resp, txt, err = CC96QG.VVKe8x(u, verify=True)
  U = iFindall(r'"@id": "(.+\.html)"', txt, IGNORECASE) if resp else None
  lst = set()
  for u in U:
   resp, txt, err = CC96QG.VVKe8x(u, verify=True)
   if not txt: continue
   txt = txt.replace("http", "\nhttp")
   for line in txt.split("\n"):
    span = iSearch(r"(http[^< ]+).+(?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}", line)
    if span:
     u = span.group(1).partition("&")[0].partition("#")[0]
     for m in iFindall(r"((?:[a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2})", line):
      lst.add(("0", "0", "-", u, m.upper(), "-"))
  if lst:
   lst = sorted(lst)
   outF = "%s%s_%s.txt" % (FF7BT0(), p, FFjTQe())
   if VVBvqf > 1:
    self.VVspUi(None, None, outF, True, lst, len(lst))
   else:
    with open(outF, "w") as f:
     for _, _, _, h, m, _ in lst: f.write("%s\t%s\n" % (h, m))
    VV7tND.VV5HD3((outF, outF), isSort=True)
  else:
   FFdw58(self, "Not found")
 def VVNhTV(self, VV7tND, txt, ref, ndx):
  txt = ref
  sz = FFXhoc(ref)
  if sz > 0:
   txt += "\n\nSize: %s" % CClYaF.VV99gM(sz)
  FF4lCP(self, txt, title="File Path")
 def VVtDsx(self, item=None):
  if item:
   VV7tND, txt, path, ndx = item
   self.VVCTSY(VV7tND, path)
 @FFOAKH(par=1)
 def VVCTSY(self, VV7tND, path):
  enc = CC7ocD.VV51oT(path, self)
  if enc == -1:
   return
  num, lineNum, VVAkuK = 1, 0, []
  datePatt = iCompile(r"(?:(?:ends?|exp)(?:[\w]+))[: ]*(\d{4})[-_](\d{2})[-_](\d{2})(?:\s+(\d{2}):(\d{2}):(\d{2}))?", IGNORECASE)
  def VV0Kuq(url, rem=""):
   if url:
    modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCkEI5.VVRLKG(url)
    uURL = uURL.rstrip("/")
    for item in VVAkuK:
     if item[2] == uURL and item[3] == uUser and item[4] == uPass:
      return 0
    span = datePatt.search(rem)
    c1 = ""
    if span:
     y, m, d, H, M, S = span.groups()
     H = int(H) if str(H).isdigit() else 0
     M = int(M) if str(M).isdigit() else 0
     S = int(S) if str(S).isdigit() else 0
     try:
      end = mktime(datetime(int(y), int(m), int(d), H, M, S).timetuple())
      c1 = "#f#00ff5555#" if iTime() > end else "#f#0055ff55#"
     except:
      c1 = "#f#00888888#"
    VVAkuK.append((str(len(VVAkuK)+1), str(lineNum), str(uURL), str(uUser), str(uPass), c1 + rem, url))
    return 1
   return 0
  title = "Get Playlist URLs"
  with ioOpen(path, "r", encoding=enc) as f:
   if path.endswith(".json"):
    fTxt = f.read()
    try:
     data = jLoads(fTxt)
     for d in data:
      uURL, uUser, uPass, end = d.get("host", ""), d.get("username", ""), d.get("password", ""), d.get("end_date", "")
      rem = ("Ends: %s" % FFTS4w(float(end))) if str(end).isdigit() else ""
      url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
      num += VV0Kuq(url, rem)
    except:
     try:
      exp = iCompile(r".*(http.+)\/.*username=(.+)&password=([^&]+)", IGNORECASE)
      for d in jLoads(fTxt)["results"]:
       span = exp.search(str(d["task"]["url"]))
       if span and all(span.groups()):
        uURL, uUser, uPass = [FFXarh(x.strip()) for x in span.groups()]
        url = "%s/get.php?username=%s&password=%s&type=m3u" % (uURL, uUser, uPass) if all((uURL, uUser, uPass)) else ""
        num += VV0Kuq(url)
     except Exception as e:
      FFdw58(self, str(e), title=title)
      return
   else:
    l3 = []
    hstPatt = iCompile(r"(http?:\/\/[^\/]+)[^\s]+(?:\s+#(.+))?", IGNORECASE)
    usrPatt = iCompile(r"username\s*[=:]\s*(\S+)", IGNORECASE)
    pasPatt = iCompile(r"password\s*[=:]\s*(\S+)", IGNORECASE)
    for line in f:
     lineNum += 1
     line = str(line).strip()
     if not line or len(line) > 500:
      continue
     span = iSearch(r"(?:http.+)?(http.+php.+username=.+password=[^\s<]+)(?:\s+#(.+))?", line, IGNORECASE)
     url = rem = ""
     if span:
      url = span.group(1)
      rem = span.group(2).strip() if span.group(2) else ""
     else:
      span = iSearch(r"(http.+)\s+username(.+)\s+password\s+([^\s]+)(?:\s+#(.+))?", line, IGNORECASE)
      if span:
       host = FFoWxR(span.group(1).strip())
       user1 = span.group(2).strip()
       pass1 = span.group(3).strip()
       rem  = span.group(4).strip() if span.group(4) else ""
       url  = "%sget.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
     if url:
      l3 = []
     else:
      l3.append(line)
      if len(l3) > 3: l3.pop(0)
      if len(l3) == 3:
       spanH = hstPatt.search(l3[0])
       spanU = usrPatt.search(l3[1]) or usrPatt.search(l3[2])
       spanP = pasPatt.search(l3[2]) or pasPatt.search(l3[1])
       if spanH and spanU and spanP:
        host, user1, pass1 = spanH.group(1), spanU.group(1), spanP.group(1)
        rem = spanH.group(2).strip() if spanH.group(2) else ""
        if all((host, user1, pass1)): url = "%s/get.php?username=%s&password=%s&type=m3u" % (host, user1, pass1)
        l3 = []
     num += VV0Kuq(url, rem)
  if VVAkuK:
   VVu1YM  = ("Start"    , BF(self.VVVpkf, "Playlist File")      , [])
   VVGuQE  = BF(self.VVEo3E, VV7tND)
   VVwWmA = ("Home Menu"   , FF8lJ1             , [])
   VVwSzI = ("Server Resources" , self.VVFuB7     , [])
   VVScQz = ("Edit File"   , BF(self.VVk4dv, path)        , [])
   VV4QTJ = ("Check & Filter"  , BF(self.VVPu1w, VV7tND, path) , [])
   header   = ("Num" , "LineNum" , "Address" , "User" , "Password" , "Remarks" , "URL" )
   widths   = (7  , 0   , 33  , 17  , 17   , 26  , 0.03 )
   VVLIqP  = (CENTER , CENTER , LEFT  , LEFT   , LEFT   , LEFT  , LEFT  )
   FFUQ0v(self, None, title=os.path.basename(path), header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, height=1000, VVwdmN=26, VVu1YM=VVu1YM, VVGuQE=VVGuQE, VVwWmA=VVwWmA, VV4QTJ=VV4QTJ, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY="#11001116", VVkxBG="#11001116", VVemyB="#11001116", VVJKqd="#00003635", VVbcr0="#0a333333", VVX9AA="#11331100", VVHPI7=True, VVMfsO=2, VVSLOq=CFG.lastFindServers)
  else:
   FFdw58(self, "No valid URLs line in this file:\n\n%s" % path, title=title)
 def VVEo3E(self, VV7tND, VV6A99, path):
  if VV7tND and path.endswith(".txt"):
   VV7tND.VV5HD3((path, path), isSort=True)
 def VVFuB7(self, VV6A99, title, txt, colList):
  CCjZbZ(self, CCjZbZ.VV4Vv0, url=colList[6])
 def VV2jvq(self, VV7tND, item):
  CCjZbZ(self, CCjZbZ.VVCKX0, url=self.VVfymn["playListURL"])
 def VVVpkf(self, Title, VV6A99, title, txt, colList):
  url = colList[6]
  self.VVgCCs(VV6A99, Title, url)
 def VVk4dv(self, path, VV6A99, title, txt, colList):
  rowNum = int(colList[1].strip()) - 1
  if FFCyVu(path) : CCyMCP(self, path, VVbYwR=BF(self.VVzm4T, VV6A99), VVPhQC=rowNum)
  else    : FF8Wsn(self, path)
 def VVzm4T(self, VV6A99, fileChanged):
  if fileChanged:
   VV6A99.cancel()
 def VVdBzQ(self, title):
  curChName = self.VV6A99.VVeE40(1)
  FF4z45(self, BF(self.VVIOKi, self.VV6A99, title), defaultText=curChName, title=title, message="Enter Name:")
 @FFOAKH(par=1)
 def VVIOKi(self, VV6A99, title, name):
  if name:
   VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVp2Ed, VVXwzE=False, VV49Lf=False)
   list = []
   if VVHj48:
    name = self.VVBgSG(name)
    ratio = "1"
    for item in VVHj48:
     if name in item[0].lower():
      list.append((item[0], FFR9yH(item[2]), item[3], ratio))
   if list : self.VVuprI(list, title)
   else : FFdw58(self, "Not found:\n\n%s" % name, title=title)
 def VVOPJS(self, title):
  curChName = self.VV6A99.VVeE40(1)
  CCh3tv.VV7Nf4(self, VVLL7M="Find similar names"
      , VVixvy  = self.VVIzGB
      , VVbYwR = BF(self.VVYeFR, title, curChName))
 def VVIzGB(self, VVXyP6):
  curChName = self.VV6A99.VVeE40(1)
  VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVXNWJ, VVXwzE=False, VV49Lf=False)
  if not VVHj48 or not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVNc18 = []
  VVXyP6.VVq8NF(len(VVHj48))
  curCh = self.VVBgSG(curChName)
  for VVPxk5 in VVHj48:
   VV1wIO, sat, inDB = VVHj48.get(VVPxk5, ("", "", 0))
   ratio = CCafIt.VV8e0X(VV1wIO.lower(), curCh)
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   VVXyP6.VVxtQs(1, True)
   if VVXyP6 and ratio > 50:
    VVXyP6.VVNc18.append((VV1wIO, FFR9yH(sat), VVPxk5.replace("_", ":"), str(ratio)))
 def VVYeFR(self, title, curChName, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18: self.VVuprI(VVNc18, title)
  elif VVRI6P: FFdw58(self, "No similar names found for:\n\n%s" % curChName, title)
 def VVuprI(self, VVAkuK, title):
  FFimQ3(self.VV6A99, BF(self.VVlMA3, VVAkuK, title))
 def VVlMA3(self, VVAkuK, title):
  curChName = self.VV6A99.VVeE40(1)
  VVVvc0 = self.VV6A99.VVeE40(4)
  VV2rlK  = self.VV6A99.VVeE40(5)
  VVAkuK.sort(key=lambda x: (100-int(x[3]), x[0].lower()))
  VVu1YM  = ("Share Sat/C/T Ref.", BF(self.VV0BPS, title, curChName, VVVvc0, VV2rlK), [])
  header   = ("Name" , "Sat"  , "Reference" , "Ratio" )
  widths   = (34  , 33  , 33   , 0   )
  FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVwltY="#0a00112B", VVkxBG="#0a001126", VVemyB="#0a001126", VVJKqd="#00000000")
 def VV0BPS(self, newtitle, curChName, VVVvc0, VV2rlK, VV6A99, title, txt, colList):
  newChName = colList[0]
  newRefCode = colList[2]
  data  = newtitle, curChName, VVVvc0, VV2rlK, newChName, newRefCode
  ques  = "IPTV Channel\t: %s\n\nSat/C/T Chan. \t: %s\n" % (curChName, newChName)
  FFRMYv(self.VV6A99, BF(self.VVgToo, VV6A99, data), ques, title=newtitle, VVAgUy=True)
 @FFOAKH(par=1)
 def VVgToo(self, VV6A99, data):
  VV6A99.cancel()
  title, curChName, VVVvc0, VV2rlK, newChName, newRefCode = data
  VV2rlK  = VV2rlK.strip()
  VVVvc0 = VVVvc0.strip()
  newRefCode = newRefCode.strip()
  if not VVVvc0.endswith(":") : VVVvc0 += ":"
  if not newRefCode.endswith(":") : newRefCode += ":"
  curFullUrl = newFullUrl = ""
  span = iSearch(r"([A-Fa-f0-9]+:).+", VVVvc0, IGNORECASE)
  if span:
   curRType = span.group(1)
   span = iSearch(r"[A-Fa-f0-9]+:(.+)", newRefCode, IGNORECASE)
   if span:
    newRefCode = curRType + span.group(1)
    curFullUrl = VVVvc0 + VV2rlK
    newFullUrl = newRefCode + VV2rlK
  totChanges = 0
  resTxt = resErr = ""
  if curFullUrl and newFullUrl:
   for path in CCkEI5.VVjMS6():
    txt = FFYVq0(path)
    if curFullUrl in txt:
     totChanges += 1
     txt = txt.replace(curFullUrl, newFullUrl)
     with open(path, "w") as f:
      f.write(txt)
   if totChanges > 0:
    FFfpyJ()
    newRow = []
    for i in range(6):
     newRow.append(self.VV6A99.VVeE40(i))
    newRow[4] = newRefCode
    done = self.VV6A99.VViSLW(newRow)
    resTxt = "Done"
   else:
    resErr = "Not found in IPTV files"
  else:
   resErr = "Cannot read Chan. Info."
  if   resTxt: FFIElK(BF(FFipXT , self, resTxt, title=title))
  elif resErr: FFIElK(BF(FFdw58, self, resErr, title=title))
 def VVPu1w(self, VVr7eD, path, VV6A99, title, txt, colList):
  outF = "%s_OK_%s.txt" % (path, FFjTQe())
  lst = [(url, remarks) for num, lineNum, hst, usr, pas, remarks, url in VV6A99.VVrrm9()]
  self.VVCnnM(VVr7eD, VV6A99, outF, lst, True)
 def VVCnnM(self, VVr7eD, VV6A99, outF, lst, hasFile):
  CCh3tv.VV7Nf4(self, VVLL7M="Checking Authorized Servers"
      , VVixvy  = BF(self.VVrXIm, VV6A99, lst)
      , VVbYwR = BF(self.VVTtko, VVr7eD, VV6A99, outF, len(lst), hasFile))
 def VVrXIm(self, VV6A99, lst, VVXyP6):
  VVXyP6.VVq8NF(len(lst))
  VVXyP6.VVNc18 = []
  datePatt = iCompile(r"(?:ends?|exp)[\w]+[: ]*\d{4}[-_]\d{2}[-_]\d{2}(?:\s+\d{2}:\d{2}:\d{2})?(.*)", IGNORECASE)
  for url, remarks in lst:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1, True)
   qUrl = self.VVGaR8(self.VVJbaD, url)
   txt, err = self.VVzVZL(qUrl, timeout=1)
   if not err:
    try:
     tDict = jLoads(txt)
     if tDict and not err and "server_info" in tDict:
      item = tDict["user_info"]
      if not FFYjVd(item, "auth") == "0":
       end = item.get("exp_date", "")
       rem = ("Ends: %s" % FFTS4w(float(end))) if str(end).isdigit() else ""
       if remarks:
        span = datePatt.search(remarks)
        if span : rem += (" ... %s" % span.group(1)) if span.group(1) else ""
        else : rem += " ... %s" % remarks
       if not VVXyP6 or VVXyP6.isCancelled: return
       VVXyP6.VVNc18.append("%s%s" % (qUrl, ("\t#" + " " + rem) if rem else ""))
    except:
     pass
 def VVTtko(self, VVr7eD, VV6A99, outF, totChk, hasFile, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  title = "Authorized Servers"
  if VVNc18:
   totAuth = len(VVNc18)
   if hasFile and totAuth == totChk:
    FFipXT(self, "All URLs are authorized.", title=title)
   else:
    with open(outF, "w") as f:
     for item in VVNc18:
      f.write("%s\n" % item)
    if VVr7eD : VVr7eD.VV5HD3((outF, outF), isSort=True)
    else   : self.VV0muG(1)
    txt = FFjt5L("Process Stopped\n\n", VVYjI5) if not VVRI6P else ""
    txt += "Checked\t: %d/%d\n"  %  (threadCounter, totChk)
    txt += "Authorized\t: %s\n\n" %  FFjt5L(totAuth, VVSGsk)
    txt += "%s\n%s"    %  (FFjt5L("Result File:", VVFuwR), outF)
    FF4lCP(self, txt, title=title)
    if VV6A99: VV6A99.close()
  else:
   FFdw58(self, "No authorized URL found !", title=title)
 @staticmethod
 def VVzVZL(url, timeout=3, allowDocType=False):
  if not iRequest:
   return "" , "Cannot import URLLIB/URLLIB2 !"
  try:
   req = iRequest(url)
   req.add_header("User-Agent", CCkEI5.VVQNEW())
   res = iUrlopen(req, timeout=timeout)
   resCode = res.code
   if resCode == 200 :
    cont = res.headers.get("Content-Type")
    if cont:
     if not any(x in cont for x in ("/json", "/ld+json", "text/html", "text/plain")):
      return "", "Unexpected server data type ( %s )" % cont
     res = res.read().decode("UTF-8", "replace")
     if res:
      if not allowDocType and ("<!DOCTYPE html" in res or "<html" in res):
       sErr = "Username or password is invalid."
       if sErr in res : return "", sErr
       else   : return "", "Incorrect data format from server (html)."
      else:
       return res, ""
     else:
      return "", "No data from server."
    else:
     return "", "No data received from server"
   elif resCode == 401 : err = "Unauthorized"
   elif resCode == 402 : err = "Payment Required"
   elif resCode == 408 : err = "Request Timeout"
   else    : err = "err=%d" % resCode
   return "", err
  except Exception as e:
   return "", str(e)
 @staticmethod
 def VVRLKG(url):
  uURL = uProtoc = uHost = uPort = uQuery = uUser = uPass = ""
  modified = False
  uQueryParam = {}
  span  = iSearch(r"\s*(?:(.+):\/\/)*([^:^\/]*)(?::(\d*)\/)*\/*([^\?]*)\?*(.+)", url, IGNORECASE)
  if span:
   modified = True
   uProtoc = span.group(1) or ""
   uHost = span.group(2) or ""
   uPort = span.group(3) or ""
   uQuery = span.group(4) or ""
   param = span.group(5) or ""
   for part in param.split("&"):
    if "=" in part:
     if   part.lower().startswith("username"): uUser = part.split("=")[1]
     elif part.lower().startswith("password"): uPass = part.split("=")[1]
     parts = part.split("=")
     key = parts[0]
     val = parts[1]
     uQueryParam[key] = val
  if uProtoc : uProtoc += "://"
  if uPort : uPort = ":" + uPort
  uURL = "%s%s%s/" % (uProtoc, uHost, uPort)
  return modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam
 @staticmethod
 def VVNeuG(url, justValidate=False, getAudVid=False, compareType=None, compareExt=None, justRetDotExt=False):
  res = scheme = netloc = path = params = query = fragment = username = password = hostname = port = ""
  try:
   if not iUrlparse(url).scheme:
    url = url.lstrip("/")
    url = "http://" + url
   res   = iUrlparse(url)
   scheme  = res.scheme
   netloc  = res.netloc
   path  = res.path
   params  = res.params
   query  = res.query
   fragment = res.fragment
   username = res.username or ""
   password = res.password or ""
   hostname = res.hostname or ""
   port  = res.port  or ""
  except:
   pass
  if justValidate:
   return all([scheme, netloc, path])
  tmpPath = path.strip("/")
  if   path.startswith("/live/") : chType, tmpPath = "live" , path[6:]
  elif path.startswith("/movie/") : chType, tmpPath = "vod" , path[7:]
  elif path.startswith("/series/"): chType, tmpPath = "series", path[8:]
  elif any(x in url for x in ("mode=itv", "/stream.", "/live."))     : chType = "live"
  elif any(x in url for x in ("mode=vod", "/movie/", "/vod/", "/video/", ".m3u8")): chType = "vod"
  elif "mode=series" in url  : chType = "series"
  else       : chType = ""
  parts = tmpPath.split("/")
  if len(parts) >= 2:
   username = parts[0]
   password = parts[1]
   if len(parts) > 2:
    tmpPath  = "/".join(parts[2:])
  parts  = tmpPath.split(":")
  fileName = parts[0]
  if len(parts) > 1: VV1wIO = ":".join(parts[1:])
  elif ":" in query: VV1wIO = query.split(":")[1]
  else    : VV1wIO = ""
  streamId, dotExt = os.path.splitext(fileName)
  ext = dotExt[1:]
  if justRetDotExt:
   return dotExt
  if compareExt:
   if compareExt == ext: return True
   else    : return False
  if getAudVid:
   if ext:
    tDict = CCHmnm.VViatp()
    if   ext in list(tDict["mov"]): return "vid"
    elif ext in list(tDict["mus"]): return "aud"
   return ""
  if streamId.isdigit():
   if not chType :
    if not ext              : chType = "live"
    elif iSearch(r"(s\d\d.*e\d\d|e\d\d.*s\d\d)", VV1wIO, IGNORECASE): chType = "series"
    else               : chType = "movie:"
  else:
   streamId = ""
  if compareType is not None:
   if compareType == chType: return True
   else     : return False
  else:
   if scheme:
    scheme += "://"
   host = scheme + netloc
   return chType, host, username, password, streamId, VV1wIO
 @staticmethod
 def VVZniM(VVZcRP):
  return CCkEI5.VVNeuG(VVZcRP, justRetDotExt=True)
 def VVGaR8(self, mode, url, Id="0"):
  Id = str(Id).strip()
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVRLKG(url)
  url = "%splayer_api.php?username=%s&password=%s" % (uURL, uUser, uPass)
  if   mode == self.VVJbaD   : return "%s"            % url
  elif mode == self.VVgkvV   : return "%s&action=get_live_categories"     % url
  elif mode == self.VVgL8R   : return "%s&action=get_vod_categories"      % url
  elif mode == self.VV6cbr  : return "%s&action=get_series_categories"     % url
  elif mode == self.VVspif  : return "%s&action=get_live_categories"     % url
  elif mode == self.VVhkSg : return "%s&action=get_series_info&series_id=%s"   % (url, Id)
  elif mode == self.VVXewY   : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
  elif mode == self.VVw3vg    : return "%s&action=get_vod_streams&category_id=%s"   % (url, Id)
  elif mode == self.VVtP50  : return "%s&action=get_series&category_id=%s"    % (url, Id)
  elif mode == self.VVZUri : return "%s&action=get_live_streams"      % url
  elif mode == self.VV4kmD  : return "%s&action=get_live_streams&category_id=%s"  % (url, Id)
 @FFOAKH(par=1, clearMsg=False)
 def VV57zg(self, VV6A99, title, path):
  if FFCyVu(path):
   enc = CC7ocD.VV51oT(path, self)
   if enc == -1: return
   qUrl = ""
   with ioOpen(path, "r", encoding=enc) as f:
    for line in f:
     line = str(line).strip()
     if not line or len(line) > 500: continue
     qUrl = CCkEI5.VVyZOO(line)
     if qUrl:
      break
   VV6A99.VVrmMb()
   if qUrl : self.VVgCCs(VV6A99, title, qUrl)
   else : FFdw58(self, "Invalid M3U line format in:\n\n%s" % path, title=title)
  else:
   FFdw58(self, "Cannot open file :\n\n%s" % path, title=title)
 def VVsUXV(self):
  title = "Current Channel Server"
  qUrl, VVZcRP, VVfaDB = CCkEI5.VVs0fr(self)
  if qUrl or "chCode" in VVfaDB:
   p = CC96QG()
   valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
   if valid:
    self.VVAw1p(self, host, mac)
    return
   elif qUrl:
    self.VVgCCs(self, title, qUrl)
    return
  FFdw58(self, "Error in current channel URL !", title=title)
 @staticmethod
 def VVs0fr(SELF):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
  qUrl = CCkEI5.VVyZOO(VVZcRP)
  return qUrl, VVZcRP, VVfaDB
 @staticmethod
 def VVyZOO(url):
  if url.startswith("#"):
   return ""
  url = url.strip(" /")
  try: res = iUrlparse(url)
  except: return ""
  scheme = res.scheme
  netloc = res.netloc
  if not scheme or not netloc:
   return ""
  host = scheme + "://" +  netloc
  path = res.path.strip("/")
  if   path.startswith("live/") : path = path[5:]
  elif path.startswith("movie/") : path = path[6:]
  elif path.startswith("series/") : path = path[7:]
  parts = path.split("/")
  part = "%s/get.php?username=%s&password=%s&type=m3u"
  if len(parts) == 3 and len(parts[0]) > 1:
   return part % (host, parts[0], parts[1])
  else:
   data = CCkEI5.VV9F1k(url)
   if data : return part % (data[0], data[1], data[2])
   else : return ""
 @FFOAKH("Checking Server ...", par=1)
 def VVgCCs(self, SELF, title, url):
  self.VV2rlK = url
  self.VVfymn = {}
  qUrl = self.VVGaR8(self.VVJbaD, url)
  txt, err = self.VVzVZL(qUrl)
  if err:
   err = "Server Error:\n\n%s" % err
  tDict = {}
  if not err:
   try: tDict = jLoads(txt)
   except: pass
   if not tDict:
    err = "Could not parse server data !"
  if tDict and not err:
   self.VVfymn = {"playListURL": url}
   if "user_info" in tDict and "server_info" in tDict:
    item = tDict["user_info"]
    self.VVfymn["username"    ] = FFYjVd(item, "username" )
    self.VVfymn["password"    ] = FFYjVd(item, "password" )
    self.VVfymn["message"    ] = FFYjVd(item, "message" )
    self.VVfymn["auth"     ] = FFYjVd(item, "auth"  )
    self.VVfymn["status"    ] = FFYjVd(item, "status"  )
    self.VVfymn["exp_date"    ] = FFYjVd(item, "exp_date" , isDate=True)
    self.VVfymn["is_trial"    ] = FFYjVd(item, "is_trial" )
    self.VVfymn["active_cons"   ] = FFYjVd(item, "active_cons")
    self.VVfymn["created_at"   ] = FFYjVd(item, "created_at" , isDate=True)
    self.VVfymn["max_connections"  ] = FFYjVd(item, "max_connections")
    self.VVfymn["allowed_output_formats"] = FFYjVd(item, "allowed_output_formats")
    key = "allowed_output_formats"
    val = item.get(key, None)
    if isinstance(val, list):
     self.VVfymn[key] = " , ".join(val)
    item = tDict["server_info"]
    self.VVfymn["url"    ] = FFYjVd(item, "url"   )
    self.VVfymn["port"    ] = FFYjVd(item, "port"   )
    self.VVfymn["https_port"  ] = FFYjVd(item, "https_port"  )
    self.VVfymn["server_protocol" ] = FFYjVd(item, "server_protocol")
    self.VVfymn["rtmp_port"   ] = FFYjVd(item, "rtmp_port"  )
    self.VVfymn["timezone"   ] = FFYjVd(item, "timezone"  )
    self.VVfymn["timestamp_now"  ] = FFYjVd(item, "timestamp_now" , isDate=True)
    self.VVfymn["time_now"   ] = FFYjVd(item, "time_now"  )
    VV3wat  = self.VVafii(True)
    VVOa1G = self.VVegLh
    VVJbOd = BF(self.VV49j5, 0)
    VVHGnw = ("Home Menu" , FF8lJ1)
    VVwJOl = ("Resources" , self.VV2jvq)
    VVB4pu= ("Add to Menu", BF(CCkEI5.VVoyt7, self, False, self.VVfymn["playListURL"]))
    VVaTeF = ("Bookmark" , BF(CCkEI5.VVwOWK, self, False, self.VVfymn["playListURL"]))
    VV7tND = FFLFTC(self, None, title="IPTV Server Resources", VV3wat=VV3wat, VVOa1G=VVOa1G, VVJbOd=VVJbOd, VVHGnw=VVHGnw, VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVaTeF=VVaTeF)
    self.VVX4OZ(VV7tND)
   else:
    err = "Cannot get User-Data from server !"
  if err:
   FFdw58(self, err, title=title)
  FF28n1(self)
 def VVegLh(self, item=None):
  if item:
   VV7tND, title, ref, ndx = item
   if   ref == "live"   : self.VVQ18M(VV7tND, self.VVgkvV , title=title)
   elif ref == "vod"   : self.VVQ18M(VV7tND, self.VVgL8R , title=title)
   elif ref == "series"  : self.VVQ18M(VV7tND, self.VV6cbr , title=title)
   elif ref == "catchup"  : self.VVQ18M(VV7tND, self.VVspif, title=title)
   elif ref == "accountInfo" : FFimQ3(VV7tND, BF(self.VVfi5g, title=title))
 def VVX4OZ(self, VV7tND):
  dUrl = CC3rDi(self.session).VVZcRP
  if   FF1BEt(dUrl): VV7tND.VVx2yy(2)
  elif FFKxIH(dUrl) : VV7tND.VVx2yy(1)
 @FFOAKH(par=2)
 def VV49j5(self, isPortal, VV7tND, txt, ref, ndx):
  txt  = "%s\n\n" % self.VV2rlK
  if isPortal:
   tab  = lambda x, y: "%s\t: %s\n" % (x, y)
   wServ = self.VViTWL()
   if wServ:
    txt += tab("Web Server", wServ)
   if VVBvqf:
    ver, err = self.VVI5kn(self.VVTr19())
    txt += tab("Original", self.VV2rlK)
    txt += tab("Modified", self.VVncdQ)
    txt += tab("PHP"  , self.VVxRkD)
    txt += tab("Extra"  , {2:"Big", 3:"Sml"}.get(self.VVdDpE, "-"))
    txt += tab("Version" , (ver or err))
    txt += "\n%s\n..\tBig\n...\tSml\nBlank\t/s/l.p\n+\t/p.p\n++\t/p1.p\n*\tModed" % SEP
  FF4lCP(self, txt, title="Current Server")
 def VVfi5g(self, title):
  rows = []
  for key, val in self.VVfymn.items():
   if isinstance(val, list): val = str(" , ".join(val))
   else     : val = str(val)
   if any(x in key for x in ("url", "port", "https_port", "server_protocol", "rtmp_port", "timezone", "timestamp_now", "time_now")):
    num, part = "2", self.VVIrBX
   else:
    num, part = "1", self.VVnS6i
   rows.append((num, part, str(key).replace("_", " ").title(), str(val)))
  rows.sort(key=lambda x: (x[0], x[2]))
  VVwWmA  = ("Home Menu", FF8lJ1, [])
  VVwSzI  = None
  if VVBvqf:
   VVwSzI = ("Get JS" , BF(self.VV7Vtg, "/".join(self.VVfymn["playListURL"].split("/")[:-1])), [])
  header    = ("Num", "User/Server" , "Subject" , "Value" )
  widths    = (0 , 15   , 35  , 50  )
  FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=rows, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVwltY="#0a00292B", VVkxBG="#0a002126", VVemyB="#0a002126", VVJKqd="#00000000", VVMfsO=2)
 def VVmYeb(self, mode, jData):
  list = []
  err  = ""
  try:
   tDict = jLoads(jData)
   if tDict:
    if mode in (self.VVXewY, self.VV4kmD):
     for ndx, item in enumerate(tDict, start=1):
      num      = FFYjVd(item, "num"     )
      name     = FFYjVd(item, "name"     )
      stream_id    = FFYjVd(item, "stream_id"   )
      stream_icon    = FFYjVd(item, "stream_icon"   )
      epg_channel_id   = FFYjVd(item, "epg_channel_id"  )
      added     = FFYjVd(item, "added"    , isDate=True)
      is_adult    = FFYjVd(item, "is_adult"    )
      category_id    = FFYjVd(item, "category_id"   )
      tv_archive    = FFYjVd(item, "tv_archive"   )
      direct_source   = FFYjVd(item, "direct_source"  )
      archDur     = FFYjVd(item, "tv_archive_duration" )
      name = self.VVcBrZ(name, censored=is_adult)
      if name:
       if mode == self.VVXewY or mode == self.VV4kmD and tv_archive == "1":
        hasPicon = "Yes" if stream_icon else ""
        VVArDB = "Yes" if tv_archive == "1" else ""
        if archDur:
         if archDur.isdigit():
          tot = int(archDur)
          if tot > 0: VVArDB = "%s day%s" % (tot, FFcacr(tot))
         else:
          VVArDB = archDur
        list.append((num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVArDB, direct_source))
    elif mode == self.VVw3vg:
     for ndx, item in enumerate(tDict, start=1):
      num     = FFYjVd(item, "num"     )
      name    = FFYjVd(item, "name"     )
      stream_id   = FFYjVd(item, "stream_id"   )
      stream_icon   = FFYjVd(item, "stream_icon"   )
      added    = FFYjVd(item, "added"    , isDate=True)
      is_adult   = FFYjVd(item, "is_adult"    )
      category_id   = FFYjVd(item, "category_id"   )
      container_extension = FFYjVd(item, "container_extension" ) or "mp4"
      name = self.VVcBrZ(name, censored=is_adult)
      if name:
       isPicon = "Yes" if stream_icon else ""
       list.append((num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon))
    elif mode == self.VVtP50:
     for ndx, item in enumerate(tDict, start=1):
      num     = FFYjVd(item, "num"     )
      name    = FFYjVd(item, "name"     )
      series_id   = FFYjVd(item, "series_id"   )
      cover    = FFYjVd(item, "cover"    )
      genre    = FFYjVd(item, "genre"    )
      episode_run_time = FFYjVd(item, "episode_run_time"  )
      category_id   = FFYjVd(item, "category_id"   )
      container_extension = FFYjVd(item, "container_extension" ) or "mp4"
      name = self.VVcBrZ(name)
      if name:
       isPicon = "Yes" if cover else ""
       list.append((num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon))
  except:
   err = "Cannot parse received data !"
  return list, err
 @FFOAKH("Downloading ...", par=1)
 def VVQ18M(self, VV7tND, mode, title):
  cList, err = self.VVzrt7(mode)
  if cList and mode == self.VVspif:
   cList = self.VVGTjd(cList)
  if err:
   FFdw58(self, err, title=title)
  elif cList:
   cList.sort(key=lambda x: x[0].lower())
   self.VVLp7F = dict([(x[1], x[0]) for x in cList])
   VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
   mName = self.VVdGiv(mode)
   if   mode == self.VVgkvV  : fMode = self.VVXewY
   elif mode == self.VVgL8R  : fMode = self.VVw3vg
   elif mode == self.VV6cbr : fMode = self.VVtP50
   elif mode == self.VVspif : fMode = self.VV4kmD
   if mode == self.VVspif:
    VVScQz = None
    VV4QTJ = None
   else:
    VVScQz = ("Find in %s" % mName , BF(self.VVjRkU, fMode, True) , [])
    VV4QTJ = ("Find in Selected" , BF(self.VVjRkU, fMode, False) , [])
   VVu1YM   = ("Show List"   , BF(self.VVbiGO, mode)  , [])
   VVwWmA  = ("Home Menu"   , FF8lJ1         , [])
   header   = ("Category Name", "catID","Parent ID", "Server Default Sorting" )
   widths   = (100, 0, 0, 0.02)
   FFUQ0v(self, None, title=title, width=1200, header=header, VVGape=cList, VV3cHe=widths, VVwdmN=30, VV8LLn=True, VVwWmA=VVwWmA, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVu1YM=VVu1YM, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVSLOq=CFG.lastFindIptv)
  else:
   FFdw58(self, "No list from server !", title=title)
  FF28n1(self)
 def VVzrt7(self, mode, url=None, chkAdult=True):
  qUrl  = self.VVGaR8(mode, url or self.VVfymn["playListURL"])
  timeout = 20 if mode in (self.VVgkvV, self.VVspif) else 3
  txt, err = self.VVzVZL(qUrl, timeout=timeout)
  if err:
   return [], "Server Error:\n\n" + err
  list = []
  try:
   tDict = jLoads(txt)
   if tDict:
    c = 0
    for item in tDict:
     category_id  = FFYjVd(item, "category_id" )
     category_name = FFYjVd(item, "category_name")
     parent_id  = FFYjVd(item, "parent_id" )
     if chkAdult: category_name = self.VV1vXv(category_name)
     if category_name:
      c += 1
      list.append((category_name, category_id, parent_id, str(c)))
  except:
   return "", "Cannot parse received data !"
  return list, ""
 def VVGTjd(self, catList):
  mode = self.VV4kmD
  qUrl = self.VVGaR8(mode, self.VVfymn["playListURL"])
  txt, err= self.VVzVZL(qUrl)
  chanList= []
  if err:
   return []
  chanList, err = self.VVmYeb(mode, txt)
  newCatList = []
  for cat in catList:
   for ch in chanList:
    if cat[1] == ch[2] and not cat in newCatList:
     newCatList.append(cat)
  return newCatList
 @FFOAKH("Downloading ...", par=2)
 def VVbiGO(self, mode, VV6A99, title, txt, colList):
  bName  = colList[0]
  catID  = colList[1]
  parentID = colList[2]
  title = self.VVdGiv(mode) + " : "+ bName
  if   mode == self.VVgkvV  : mode = self.VVXewY
  elif mode == self.VVgL8R  : mode = self.VVw3vg
  elif mode == self.VV6cbr : mode = self.VVtP50
  elif mode == self.VVspif : mode = self.VV4kmD
  qUrl  = self.VVGaR8(mode, self.VVfymn["playListURL"], catID)
  txt, err = self.VVzVZL(qUrl, timeout=20)
  list  = []
  if not err and mode in (self.VVXewY, self.VVw3vg, self.VVtP50, self.VV4kmD):
   list, err = self.VVmYeb(mode, txt)
  if err:
   FFdw58(self, err, title=title)
  elif list:
   VVwWmA  = ("Home Menu"   , FF8lJ1            , [])
   if mode in (self.VVXewY, self.VV4kmD):
    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
    VV2ytr = (""     , BF(self.VVMxey, mode)      , [])
    VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "", "")   , [])
    VVScQz = ("Options"   , BF(self.VVCbC2, "lv", mode, bName)   , [])
    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)     , [])
    VVu1YM  = ("Play"    , BF(self.VVF9cb, mode)       , [])
   elif mode == self.VVw3vg:
    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
    VVu1YM  = ("Play"    , BF(self.VVF9cb, mode)       , [])
    VV2ytr = (""     , BF(self.VVMxey, mode)      , [])
    VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "v", "")   , [])
    VVScQz = ("Options"   , BF(self.VVCbC2, "v", mode, bName)   , [])
    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)     , [])
   elif mode == self.VVtP50:
    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("series2")
    VVu1YM  = ("Show Seasons"  , BF(self.VVhnCl, mode)       , [])
    VV2ytr = (""     , BF(self.VVotEo, mode)     , [])
    VVwSzI = None
    VVScQz = None
    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, True)      , [])
   header, widths, VVLIqP = self.VVlJdN(mode)
   FFUQ0v(self, None, title=title, header=header, VVGape=list, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VV2ytr=VV2ytr, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
  else:
   FFdw58(self, "No Channels found !", title=title)
  FF28n1(self)
 def VVlJdN(self, mode):
  if mode in (self.VVXewY, self.VV4kmD):
   header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "epgID" , "Is Adult", "Logo", "Catch-up", "Link")
   widths   = (8  , 55  , 0   , 0   , 0  , 22  , 0   , 0   , 6  , 9   , 0.03 )
   VVLIqP  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER , CENTER, CENTER , CENTER)
  elif mode == self.VVw3vg:
   header   = ("Num" , "Name", "catID", "ID"  , "Icon" , "Added" , "isAdult" , "Ext" , "Logo")
   widths   = (8  , 62  , 0   , 0   , 0  , 24  , 0   , 0  , 6  )
   VVLIqP  = (CENTER, LEFT  , CENTER , CENTER, LEFT , CENTER , CENTER , CENTER, CENTER)
  elif mode == self.VVtP50:
   header   = ("Num" , "Name", "catID", "ID"  , "Genre" , "Dur.", "Ext" , "Cover" , "Logo" )
   widths   = (8  , 56  , 0   , 0   , 30  , 0  , 0  , 0   , 6   )
   VVLIqP  = (CENTER, LEFT  , LEFT   , CENTER , LEFT , CENTER, CENTER, LEFT  , CENTER )
  return header, widths, VVLIqP
 @FFOAKH("Downloading ...", par=2)
 def VVhnCl(self, mode, VV6A99, title, txt, colList):
  title = colList[1]
  list, err = self.VVdLhN(colList[3])
  if err:
   FFdw58(self, err, title=title)
  elif list:
   VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D("")
   VVwWmA = ("Home Menu"   , FF8lJ1          , [])
   VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, "s", title), [])
   VVScQz = ("Options"   , BF(self.VVCbC2, "s", mode, title) , [])
   VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)   , [])
   VV2ytr = (""     , BF(self.VVMxey, mode)    , [])
   VVu1YM  = ("Play"    , BF(self.VVF9cb, mode)     , [])
   header   = ("Season" , "Episode" , "Title" , "catID" , "stID", "Icon", "Ext" )
   widths   = (10  , 10  , 80  , 0   , 0  , 0  , 0  )
   VVLIqP  = (CENTER , CENTER , LEFT  , CENTER , CENTER, LEFT , CENTER)
   FFUQ0v(self, None, title=title, header=header, VVGape=list, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
  else:
   FFdw58(self, "No Channels found !", title=title)
  FF28n1(self)
 def VVdLhN(self, series_id, url=None):
  qUrl  = self.VVGaR8(self.VVhkSg, url or self.VVfymn["playListURL"], series_id)
  txt, err = self.VVzVZL(qUrl)
  list  = []
  if not err:
   list = []
   err  = ""
   try:
    tDict = jLoads(txt)
    if tDict:
     title  = "Seasons"
     category_id = "222"
     icon  = ""
     if "info" in tDict:
      sName  = FFYjVd(tDict["info"], "name"  )
      category_id = FFYjVd(tDict["info"], "category_id" )
      icon  = FFYjVd(tDict["info"], "cover"  )
     if "episodes" in tDict:
      seasons = tDict["episodes"]
      for season in seasons:
       item = seasons[season]
       for EP in item:
        stream_id   = FFYjVd(EP, "id"     )
        episode_num   = FFYjVd(EP, "episode_num"  )
        epTitle    = FFYjVd(EP, "title"    )
        container_extension = FFYjVd(EP, "container_extension")
        seasonNum   = FFYjVd(EP, "season"    )
        sName = self.VVcBrZ(sName)
        epTitle = self.VVcBrZ(epTitle)
        epTitle = self.VVAcpQ(series_id, sName, epTitle, seasonNum, episode_num)
        list.append((seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension))
   except:
    err = "Cannot parse received data !"
  return list, err
 def VVAcpQ(self, catID, sName, eName, sNum, eNum):
  SeEp = ( "S%.2dE%.2d (%s)" % (int(sNum), int(eNum), catID) ) if sNum.isdigit() and eNum.isdigit() else ""
  prefix = sName + " " + SeEp
  patt = r"(S\d{1,3}\W*E\d{1,3})|(E\d{1,3}\W*S\d{1,3})"
  if eName.lower().startswith(sName.lower()):
   eName = sName + eName[len(sName):]
  if iMatch(r"^%s" % patt, eName, IGNORECASE):
   return iSub(patt, prefix, eName, flags=IGNORECASE)
  elif not eName.startswith(sName):
   return prefix + " " + eName
  elif eName.startswith(sName):
   eName, tot = iSubn(patt, SeEp, eName, flags=IGNORECASE)
   if tot : return eName
   else : return prefix + " " + eName[len(sName):].strip()
  return eName
 def VVLk4s(self, ser, hst, usr, pas, title):
  typ = "LVS" if ser else "LV"
  outF = "%s%s_%s_%s.m3u" % (FF7BT0(), FFOu5Y(iUrlparse(hst).hostname), typ, FFjTQe())
  CCh3tv.VV7Nf4(self, VVLL7M="Reading Categories ...", totBars=2
      , VVixvy  = BF(self.VVOuIu, ser, hst, usr, pas, outF, title)
      , VVbYwR = BF(self.VVLKJF, ser, outF, title))
 def VVOuIu(self, ser, hst, usr, pas, outF, title, VVXyP6):
  VVXyP6.VVq8NF(7)
  self._tDic = {"totL": 0, "totV": 0, "totS": 0, "addL": 0, "addV": 0, "addS": 0, "addEp": 0, "err": ""}
  lCat, vCat, sCat = {}, {}, {}
  srcs = ("Live", "VOD", "Series")
  catMode = [self.VVgkvV, self.VVgL8R, self.VV6cbr]
  modes = [self.VVXewY, self.VVw3vg, self.VVtP50]
  acts = ["get_live_streams", "get_vod_streams", "get_series"]
  if not ser: catMode, modes, acts = catMode[:2], modes[:2], acts[:2]
  url  = "%s/player_api.php?username=%s&password=%s" % (hst, usr, pas)
  catErr = ""
  for mode in catMode:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
   lst, err = self.VVzrt7(mode, url=url, chkAdult=False)
   catErr = err or catErr
   if not lst: continue
   dic = {Id: nm for nm, Id, pId, num in lst}
   if dic:
    if  mode == self.VVgkvV  : lCat = dic
    elif mode == self.VVgL8R  : vCat = dic
    elif mode == self.VV6cbr: sCat = dic
  cats = [lCat, vCat, sCat]
  if not ser: cats = cats[:2]
  if not any((lCat, vCat, sCat)):
   self._tDic["err"] = catErr or "Cannot read categories."
   return
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for mode, src, catLst, act in tuple(zip(modes, srcs, cats, acts)):
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVaks5("Reading %s ..." % src)
    VVXyP6.VVxtQs(1)
    VVXyP6.VVV3RA(0)
    txt, err = self.VVzVZL("%s&action=%s" % (url, act), timeout=20)
    if txt:
     lst, err = self.VVmYeb(mode, txt)
     if not lst: continue
    else:
     continue
    tot = len(lst)
    if  mode == self.VVXewY : self._tDic["totL"] = tot
    elif mode == self.VVw3vg  : self._tDic["totV"] = tot
    elif mode == self.VVtP50 : self._tDic["totS"] = tot
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVaks5("Saving %s ..." % src)
    VVXyP6.VVUIH1(len(lst))
    VVXyP6.VVV3RA(0)
    for row in lst:
     if not VVXyP6 or VVXyP6.isCancelled: return
     VVXyP6.VVg2Dw(1)
     colList = list(map(str.strip, row))
     if mode in (self.VVXewY, self.VVw3vg):
      if mode == self.VVXewY:
       num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVArDB, direct_source = colList
       VVfbmn, ext, uCat = stream_icon, "", ""
      elif mode == self.VVw3vg:
       num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
       VVfbmn, ext, uCat = stream_icon, "." + container_extension, "movie/"
      catNm = catLst.get(category_id, "")
      catNm = (' group-title="%s"' % catLst[category_id]) if category_id in catLst else ""
      pUrl  = (' tvg-logo="%s"' % VVfbmn) if VVfbmn else ""
      chUrl = "%s/%s%s/%s/%s%s" % (hst, uCat, usr, pas, stream_id, ext)
      f.write('#EXTINF:-1%s%s,%s\n' % (catNm, pUrl, name))
      f.write("%s\n" % chUrl)
      if mode == self.VVXewY : self._tDic["addL"] += 1
      elif mode == self.VVw3vg : self._tDic["addV"] += 1
     else:
      num, name, category_id, series_id, genre, episode_run_time, container_extension, cover, isPicon = row
      seLst, err = self.VVdLhN(series_id, url=url)
      if not seLst: continue
      addSer = 0
      for ep in seLst:
       if not VVXyP6 or VVXyP6.isCancelled: return
       seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = list(map(str.strip, ep))
       pUrl = (' tvg-logo="%s"' % cover) if cover else ""
       chUrl= "%s/series/%s/%s/%s.%s" % (hst, usr, pas, stream_id, container_extension)
       f.write('#EXTINF:-1 group-title="%s"%s,%s (SE%s:EP%s)\n' % (name, pUrl, name, seasonNum, episode_num))
       f.write("%s\n" % chUrl)
       if not VVXyP6 or VVXyP6.isCancelled: return
       self._tDic["addEp"] += 1
       addSer = 1
      self._tDic["addS"] += addSer
 def VVLKJF(self, ser, outF, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  d = self._tDic
  totL, totV, totS, addL, addV, addS, addEp = d["totL"], d["totV"], d["totS"], d["addL"], d["addV"], d["addS"], d["addEp"]
  if VVRI6P: txt = ""
  else   : txt = "%s\n\n" % FFjt5L("Process stopped.", VVIH76)
  if (addL + addV + addS + addEp) > 0:
   txt += "Added Live\t: %s%s\n" % (addL, (" of %s" % totL) if (addL != totL) else "")
   txt += "Added VOD\t: %s%s\n"  % (addV, (" of %s" % totV) if (addV != totV) else "")
   if ser: txt += "Added Series\t: %s%s  ( Episodes : %s )\n" % (addS, (" of %s" % totS) if (addS != totS) else "", addEp)
   if FFCyVu(outF): txt += "\n%s\n%s" % (FFjt5L("Saved to:", VVJEMb), outF)
   FF4lCP(self, txt, title)
  elif d["err"]:
   FFdw58(self, d["err"], title)
   FFwgGB(outF)
  else:
   FFwgGB(outF)
 def VVjRkU(self, mode, isAll, VV6A99, title, txt, colList):
  onlyCatID = None if isAll else colList[1]
  VV3wat = []
  VV3wat.append(("Keyboard"  , "manualEntry"))
  VV3wat.append(("From Filter" , "fromFilter"))
  FFLFTC(self, BF(self.VVliHG, VV6A99, mode, onlyCatID), title="Input Type", VV3wat=VV3wat, width=400)
 def VVliHG(self, VV6A99, mode, onlyCatID, item=None):
  if item == "manualEntry":
   FF4z45(self, BF(self.VV9OZ2, VV6A99, mode, onlyCatID), defaultText=CFG.lastFindIptv.getValue(), title="Find", message="Enter Name (or names separated by a comma)")
  elif item == "fromFilter":
   filterObj = CCoErY(self)
   filterObj.VVVPGN(BF(self.VV9OZ2, VV6A99, mode, onlyCatID))
 def VV9OZ2(self, VV6A99, mode, onlyCatID, item):
  if not item is None:
   title = "Find in names"
   words = None
   toFind = item.strip()
   FFjt1c(CFG.lastFindIptv, toFind)
   if toFind:
    words, asPrefix = CCoErY.VVPBNm(toFind)
    if words:
     if len(words) == 1 and len(words[0]) < 3:
      FFdw58(self, "Enter at least 3 characters.", title=title)
      return
     else:
      for word in words:
       if len(word) < 3:
        FFdw58(self, "All words must be at least 3 characters !", title=title)
        return
     if CFG.hideIptvServerAdultWords.getValue() and self.VVZI1i(words):
      FFdw58(self, self.VVmBMi(), title="Find: %s" % " , ".join(words))
      return
     else:
      CCh3tv.VV7Nf4(self, VVLL7M="Searching for:%s" % toFind[:15], totBars=2
          , VVixvy  = BF(self.VVP3Pw, VV6A99, mode, onlyCatID, title, words, toFind, asPrefix)
          , VVbYwR = BF(self.VViBDc, mode, toFind, title))
   if not words:
    FF28n1(VV6A99, "Nothing to find !", 1500)
 def VVP3Pw(self, VV6A99, mode, onlyCatID, title, words, toFind, asPrefix, VVXyP6):
  VVXyP6.VVq8NF(VV6A99.VVn1uo() if onlyCatID is None else 1)
  VVXyP6.VVNc18 = []
  for row in VV6A99.VVrrm9():
   catName = row[0]
   catID = row[1]
   if not onlyCatID is None and not catID == onlyCatID:
    continue
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
   VVXyP6.VVV3RA(0)
   VVXyP6.VVSW9b(catName)
   qUrl = self.VVGaR8(mode, self.VVfymn["playListURL"], catID)
   txt, err= self.VVzVZL(qUrl, timeout=20)
   if not err:
    tList, err = self.VVmYeb(mode, txt)
    if tList:
     if not VVXyP6 or VVXyP6.isCancelled: return
     VVXyP6.VVUIH1(len(tList))
     for item in tList:
      if not VVXyP6 or VVXyP6.isCancelled: return
      VVXyP6.VVg2Dw(1)
      name = item[1].strip().lower()
      name = self.VVcBrZ(name)
      if name:
       if asPrefix and not name.startswith(words) : continue
       elif any(x in name for x in words)   : pass
       else          : continue
       if not VVXyP6 or VVXyP6.isCancelled:
        return
       VVXyP6.VVNc18.append(item)
       VVXyP6.VVSW9b(catName)
 def VViBDc(self, mode, toFind, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18:
   title = self.VVvwJ7(mode, toFind)
   VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D(mode)
   if mode == self.VVXewY or mode == self.VVw3vg:
    if mode == self.VVw3vg : typ = "v"
    else          : typ = ""
    bName   = CCkEI5.VVPjQO(toFind)
    VVu1YM  = ("Play"     , BF(self.VVF9cb, mode)     , [])
    VVwSzI = ("Download Options" , BF(self.VVnHDd, mode, typ, "") , [])
    VVScQz = ("Options"   , BF(self.VVCbC2, "fnd", mode, bName), [])
    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, False)   , [])
    VV2ytr = (""     , BF(self.VVMxey, mode)    , [])
   elif mode == self.VVtP50:
    VVwltY, VVkxBG, VVemyB, VVJKqd = self.VVxV5D("series2")
    VVu1YM  = ("Show Seasons"  , BF(self.VVhnCl, mode)     , [])
    VVScQz = None
    VVwSzI = None
    VV4QTJ = ("Posters Mode"  , BF(self.VVTdR5, mode, True)    , [])
    VV2ytr = (""     , BF(self.VVotEo, mode)   , [])
   VVwWmA  = ("Home Menu"   , FF8lJ1          , [])
   header, widths, VVLIqP = self.VVlJdN(mode)
   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVNc18, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VV2ytr=VV2ytr, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd, VVHPI7=True, VVMfsO=1)
   if not VVRI6P:
    FF28n1(VV6A99, "Stopped" , 1000)
  else:
   if VVRI6P:
    FFdw58(self, "Not found in names !\n\n( %s )" % toFind, title=title)
 def VVK5K0(self, mode, colList):
  colList = list(map(str.strip, colList))
  if mode in (self.VVXewY, self.VV4kmD):
   num, name, category_id, stream_id, stream_icon, added, epg_channel_id, is_adult, hasPicon, VVArDB, direct_source = colList
   chNum, VV1wIO, catID, stID, VVfbmn, ext, uCat = num, name, category_id, stream_id, stream_icon, "", ""
  elif mode == self.VVw3vg:
   num, name, category_id, stream_id, stream_icon, added, is_adult, container_extension, isPicon = colList
   chNum, VV1wIO, catID, stID, VVfbmn, ext, uCat = num, name, category_id, stream_id, stream_icon, "." + container_extension, "movie/"
  else:
   seasonNum, episode_num, epTitle, category_id, stream_id, icon, container_extension = colList
   chNum, VV1wIO, catID, stID, VVfbmn, ext, uCat = "222", epTitle, category_id, stream_id, icon, "." + container_extension, "series/"
  VV1wIO = FFd1WZ(VV1wIO)
  url = self.VVfymn["playListURL"]
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = self.VVRLKG(url)
  VVPxk5 = self.VVpX1r(catID, stID, chNum)
  chUrl = "%s%s%s/%s/%s%s"  % (uURL, uCat, uUser, uPass, stID, ext)
  chUrl = chUrl.replace(":", "%3a")
  chUrl = VVPxk5 + chUrl + ":" + VV1wIO
  return VV1wIO, chUrl, VVfbmn, VVPxk5
 def VVMxey(self, mode, VV6A99, title, txt, colList):
  if mode in (self.VVXewY, self.VV4kmD): catID = colList[2]
  elif mode == self.VVw3vg          : catID = colList[2]
  else                   : catID = colList[3]
  catName = self.VVLp7F.get(catID, "")
  if catName:
   txt = txt.strip() + "\nCategory\t: %s" % catName
  self.VV19VQ(mode, VV6A99, title, txt, colList)
 @FFOAKH(par=2)
 def VV19VQ(self, mode, VV6A99, title, txt, colList):
  VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
  txt = "%s\n\n%s" % (title, txt)
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VV1YsH, params=(VVPxk5, VV1wIO, txt, chUrl, VVfbmn))
 @FFOAKH(par=2)
 def VVotEo(self, mode, VV6A99, title, txt, colList):
  name = colList[1]
  Dur  = colList[5]
  Cover = colList[7]
  txt  = "%s\n\n%s" % (title, txt)
  txt  += "Duration\t: %s" % Dur
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVUWdA, params=(name, txt, Cover))
 def VVTdR5(self, mode, isSerNames, VV6A99, title, txt, colList):
  if mode == "m3u":
   nameCol, picCol, descCol, descTxt = 1, 4, 2, "Group"
  elif mode in ("itv", "vod", "series"):
   if isSerNames: nameCol, picCol, descCol, descTxt = 0, 12, 9, "Genre"
   else   : nameCol, picCol, descCol, descTxt = 1, 4 , 6, "Category/Genre"
  else:
   nameCol = 1
   if isSerNames         : picCol, descCol, descTxt = 7, 4, "Genre"
   elif mode == self.VVXewY : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VV4kmD : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVw3vg  : picCol, descCol, descTxt = 4, 5, "Added"
   elif mode == self.VVtP50 : picCol, descCol, descTxt = 5, 0, "Season"
  FFimQ3(VV6A99, BF(self.session.open, CCUYzx, VV6A99, self.VVYrUH(mode), nameCol, picCol, descCol, descTxt))
 @staticmethod
 def VVYrUH(mode):
  if   mode in ("itv", "live" , CCkEI5.VVXewY, CCkEI5.VV4kmD): subD = "Live"
  elif mode in ("vod"   , CCkEI5.VVw3vg )          : subD = "VOD"
  elif mode in ("series"  , CCkEI5.VVtP50)          : subD = "Series"
  elif mode == "m3u"                       : subD = "M3U"
  else                          : subD = ""
  return FFoWxR(os.path.join(FF0cqc(), "Posters", subD))
 def VVnHDd(self, mode, typ, VVetid, VV6A99, title, txt, colList):
  VV3wat = []
  isMulti = VV6A99.VVXWPu
  tot  = VV6A99.VVc5NH()
  if isMulti:
   if tot < 1:
    FF28n1(VV6A99, "Select rows first.", 1000)
    return
   else:
    name = "%d Selected" % tot
   plural = FFcacr(tot)
  else:
   name = "ALL"
   plural = "s"
  txt = "PIcon" if mode in ("itv", CCkEI5.VVXewY, CCkEI5.VV4kmD) else "Poster"
  VV3wat.append(("Download %s %s%s" % (name, txt, plural)  , "dnldPicons" ))
  if typ:
   VV3wat.append(VVAL3j)
   tName = "Movie" if typ.startswith("v") else "Episode"
   VV3wat.append(("Download Current %s" % tName    , "dnldSel"  ))
   VV3wat.append(("Add Current %s to Download List" % tName , "addSel"  ))
   if typ.startswith("s"):
    VV3wat.append(("Add All Episodes to Download List" , "addAllEp" ))
   if not CCHRcZ.VVAbZK():
    VV3wat.append(VVAL3j)
    VV3wat.append(("Download Manager"      , "dload_stat" ))
  FFLFTC(self, BF(self.VVmUow, VV6A99, mode, typ, VVetid, colList), title="Download Options", VV3wat=VV3wat)
 def VVmUow(self, VV6A99, mode, typ, VVetid, colList, item=None):
  if item:
   if   item == "dnldPicons" : self.VVE5LS(self, VV6A99, mode)
   elif item == "dnldSel"  : self.VVGjeL(VV6A99, mode, typ, colList, True)
   elif item == "addSel"  : self.VVGjeL(VV6A99, mode, typ, colList, False)
   elif item == "addAllEp"  : self.VVLLey(VV6A99, mode, typ, VVetid)
   elif item == "dload_stat" : CCHRcZ.VVSZMa(self, VV6A99)
 @FFOAKH(par=1)
 def VVGjeL(self, VV6A99, mode, typ, colList, startDnld):
  VV1wIO, VVZcRP = self.VVOkm6(mode, typ, colList)
  if startDnld:
   CCHRcZ.VVXNDk(self, VVZcRP)
  else:
   self.VV1lS7(VV6A99, "Add to Download list", VV1wIO, [VVZcRP], startDnld)
 def VVLLey(self, VV6A99, mode, typ, VVetid):
  VVC9AM = []
  for row in VV6A99.VVrrm9():
   VV1wIO, VVZcRP = self.VVOkm6(mode, typ, row)
   VVC9AM.append(VVZcRP)
  self.VV1lS7(VV6A99, "Add to Download list", "%s\n\n( %d Episodes )" % (VVetid, len(VVC9AM)), VVC9AM, False)
 def VV1lS7(self, VV6A99, title, VV1wIO, VVC9AM, startDnld):
  FFRMYv(self, BF(self.VVvUrN, VV6A99, VVC9AM, startDnld), VV1wIO, title=title)
 def VVvUrN(self, VV6A99, VVC9AM, startDnld):
  added, skipped = CCHRcZ.VVNrGg(VVC9AM)
  FF28n1(VV6A99, "Added", 1000)
 def VVOkm6(self, mode, typ, colList):
  if typ in ("v", "s"):
   VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, colList)
  elif typ in ("vp", "sp"):
   VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, colList)
   VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
  VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(chUrl)
  return VV1wIO, VVZcRP
 @staticmethod
 def VVE5LS(SELF, VV6A99, mode):
  if FFayeZ("ffmpeg"):
   CCh3tv.VV7Nf4(SELF, VVLL7M="Downloading PIcons"
       , VVixvy  = BF(CCkEI5.VVC4jj, SELF, VV6A99, mode)
       , VVbYwR = BF(CCkEI5.VV7Oqv, SELF))
  else:
   FFRMYv(SELF, BF(CCkEI5.VVGS56, SELF), '"FFmpeg" is required to resize the PIcons.\n\nInstall FFmpeg ?', title="Download all PIcons")
 @staticmethod
 def VVC4jj(SELF, VV6A99, mode, VVXyP6):
  VVXyP6.VVNc18 = {"total": 0, "threads": 0, "proces": 0, "badUrl": 0, "exist": 0, "attempt": 0, "ok": 0, "size0": 0, "fail": 0, "err": ""}
  VV1tA1 = set()
  pPath = CCafIt.VVjkKT()
  VVXyP6.VVaks5("Collecting list ...")
  ndxLst = []
  for ndx, row in enumerate(VV6A99.VVrrm9()):
   if not VV6A99.VVXWPu or VV6A99.VVvlf4(ndx):
    ndxLst.append(ndx)
  if not VVXyP6 or VVXyP6.isCancelled: return
  if ndxLst:
   VVXyP6.VVNc18["total"] = len(ndxLst)
   VVXyP6.VVq8NF(len(ndxLst))
   VVXyP6.VV0ddK(0)
  else:
   VVXyP6.VVNc18["err"] = "No valid URLs"
   return
  def VVBIzy(VVfbmn, picon):
   VVXyP6.VVNc18["threads"] += 1
   VVXyP6.VVNc18["attempt"] += 1
   path, err = FFx9uM(VVfbmn, picon, timeout=2, VVzHui=True)
   if not VVXyP6 or VVXyP6.isCancelled:
    FFwgGB(path)
   elif err:
    VVXyP6.VVNc18["fail"] += 1
    if any(x in err.lower() for x in ("time-out", "unauthorized")):
     VVXyP6.VVNc18["err"] = err.title()
   elif not path:
    pass
   elif FFXhoc(path) == 0:
    VVXyP6.VVNc18["size0"] += 1
    FFwgGB(path)
   else:
    VVXyP6.VVNc18["ok"] += 1
    totOk = VVXyP6.VVNc18["ok"]
    VVXyP6.VV0ddK(totOk)
    cmd = CCvjVs.VVQ9GP(path)
    cmd += FFb2oQ("mv -f '%s' '%s'" % (path, pPath))
    FFpwZS(cmd)
   if VVXyP6 and not VVXyP6.isCancelled:
    VVXyP6.VVNc18["threads"] -= 1
  while ndxLst or VVXyP6.VVNc18["threads"] > 0:
   try:
    if not VVXyP6 or VVXyP6.isCancelled : return
    elif VVXyP6.VVNc18["err"]   : return
    elif VVXyP6.VVNc18["threads"] >= 8: continue
    elif not ndxLst        : continue
   except:
    return
   row = VV6A99.VVMADj(ndxLst[0])
   ndxLst.pop(0)
   VVXyP6.VVxtQs(1)
   VVXyP6.VVNc18["proces"] += 1
   if mode in ("itv", "vod", "series"):
    VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = SELF.VVcP3g(mode, row)
    VVPxk5 = CCkEI5.VVpX1r(catID, stID, chNum)
   elif mode == "m3u":
    VVPxk5, VV1wIO, chUrl, VVfbmn, VVZcRP, isMark = CCjZbZ.VVOteG(SELF, row)
   else:
    VV1wIO, chUrl, VVfbmn, VVPxk5 = SELF.VVK5K0(mode, row)
   if not VVfbmn:
    VVXyP6.VVNc18["badUrl"] += 1
    continue
   picon = VVPxk5.replace(":", "_").rstrip("_") + ".png"
   if not VVXyP6 or VVXyP6.isCancelled:
    return
   if FFCyVu(pPath + picon):
    VVXyP6.VVNc18["exist"] += 1
   elif not picon in VV1tA1:
    VV1tA1.add(picon)
    iThread(name="ajp_DnldPic", target=BF(VVBIzy, VVfbmn, picon)).start()
 @staticmethod
 def VV7Oqv(SELF, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  tDict = VVNc18
  txt  = ""
  txt += "Total Processed\t\t: %d of %d\n" % (tDict["proces"], tDict["total"])
  txt += "Download Success\t: %d of %s\n"  % (tDict["ok"], tDict["attempt"])
  txt += "Skipped (PIcon exist)\t: %d\n"  % tDict["exist"]
  txt += "Skipped (Size = 0)\t: %d\n"   % tDict["size0"]
  txt += "Incorrect PIcon URL\t: %d\n"  % tDict["badUrl"]
  txt += "Download Failure\t: %d\n"   % tDict["fail"]
  txt += "PIcons Path\t\t: %s\n"    % CCafIt.VVjkKT()
  if not VVRI6P: color = "#11402000"
  elif tDict["err"]: color = "#11201000"
  else    : color = "#22001122"
  if tDict["err"]:
   txt = "Critical Error\t\t: %s\n\n%s"  % (tDict["err"], txt)
  title = "PIcons Download Result"
  if not VVRI6P:
   title += "  (cancelled)"
  FF4lCP(SELF, txt, title=title, VVemyB=color)
 @staticmethod
 def VVGS56(SELF):
  cmd = FF5sZa(VVwFAi, "ffmpeg")
  if cmd : FFbi5l(SELF, cmd, title="Installing FFmpeg")
  else : FFfone(SELF)
 @staticmethod
 def VVFT2F(SELF):
  CCdt86(SELF)
 @staticmethod
 def VVigje(chUrl, streamId, mode):
  modified, uURL, uProtoc, uHost, uPort, uQuery, uUser, uPass, uQueryParam = CCkEI5.VVRLKG(chUrl)
  qUrl = "%splayer_api.php?username=%s&password=%s&action=get_simple_data_table&stream_id=%s" % (uURL, uUser, uPass, streamId)
  txt, err = CCkEI5.VVzVZL(qUrl)
  if err : return "", err
  else : return CCkEI5.VV1q43(txt, mode=mode)
 @staticmethod
 def VV1q43(txt, mode):
  lst = []
  evLst = []
  try:
   tDict = jLoads(txt)
   for item in tDict["epg_listings"]:
    description = FFYjVd(item, "description"  , is_base64=True).replace("\n", " .. ")
    has_archive = FFYjVd(item, "has_archive"      )
    lang  = FFYjVd(item, "lang"        ).upper()
    now_playing = FFYjVd(item, "now_playing"      )
    tTitle  = FFYjVd(item, "title"   , is_base64=True)
    startServ = FFYjVd(item, "start"       )
    startT  = FFYjVd(item, "start_timestamp" , isDate=True )
    startTs  = FFYjVd(item, "start_timestamp"     )
    stopT  = FFYjVd(item, "stop_timestamp" , isDate=True )
    stopTs  = FFYjVd(item, "stop_timestamp"     )
    if mode == 0:
     if has_archive == "1":
      return True, ""
    elif mode == 1:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if has_archive == "1" or (startTs < iTime() and stopTs > iTime()):
       durMin = str((stopTs - startTs) // 60)
       durTm = FFFHEC(stopTs - startTs)
       row = (startT[:-3], stopT[:-3], durTm, lang, tTitle, description, startServ, now_playing, durMin)
       if not row in lst:
        lst.append(row)
     except:
      pass
    elif mode == 2:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if stopTs > iTime():
       dur = stopTs - startTs
       shortDesc = ("Language : %s" % lang) if lang else ""
       lst.append((startTs, dur, tTitle, shortDesc, description, 1))
     except:
      pass
    elif mode == 3:
     try:
      startTs, stopTs = int(startTs), int(stopTs)
      if stopTs > iTime():
       dur = stopTs - startTs
       row = (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs)
       if not row in lst:
        lst.append(row)
        shortDesc = ("Language : %s" % lang) if lang else ""
        evLst.append((startTs, dur, tTitle, shortDesc, description, 1))
     except:
      pass
  except:
   return "", "Cannot parse received data !"
  if   mode == 0: return False, ""
  elif mode == 1: return lst, ""
  elif mode == 2: return lst, ""
  elif mode == 3:
   sep = FFjt5L("_" * 32 + "\n", VVo7S9)
   fg1, fg2, curTxt = VVwdUw, VVz22H, "    (CURRENT EVENT)"
   epg = ""
   for evNum, (description, has_archive, lang, now_playing, tTitle, startT, startTs, stopT, stopTs) in enumerate(lst, start=1):
    if now_playing == "0": color, txt = fg1, ""
    else     : color, txt = fg2, curTxt
    epg += sep
    epg += FFjt5L("Event\t: %d%s\n" % (evNum, txt), color)
    epg += "Title\t: %s\n"    % FFjt5L(tTitle, VVFuwR)
    epg += "Start\t: %s\n"    % startT
    epg += "End\t: %s\n"    % stopT
    if lang   : epg += "Language\t: %s\n"  % lang
    if description : epg += "Description:\n%s\n" % FFjt5L(description, VVA4XU)
   return epg, evLst, ""
  else:
   return lst, ""
 @staticmethod
 def VV67It(VVZcRP):
  epg, evLst, err = "", [], ""
  if "mode=itv" in VVZcRP:
   p, err = CC96QG.VV9eVr(VVZcRP)
   if p:
    valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
    if valid and stID:
     res, err = p.VVnjdQ(p.VVc7nF(stID))
     if res:
      epg, err = CCkEI5.VVhcmB(res.text, retLst=False)
      evLst, err = CCkEI5.VVhcmB(res.text, retLst=True)
      return epg, evLst, err
  else:
   data = CCkEI5.VV9F1k(VVZcRP)
   if data:
    uHost, uUser, uPass, uId, VV1wIO = data
    if all((uHost, uUser, uPass, uId)):
     qUrl = "%s/player_api.php?username=%s&password=%s&action=get_short_epg&stream_id=%s" % (uHost, uUser, uPass, uId)
     txt, err = CCkEI5.VVzVZL(qUrl, timeout=3)
     if txt:
      epg, evLst, err = CCkEI5.VV1q43(txt, mode=3)
  return epg, evLst, err
 @staticmethod
 def VVhcmB(txt, retLst=False):
  epg = ""
  lst = []
  now = iTime()
  try:
   tDict = jLoads(txt)
   for item in tDict["js"]:
    actor = FFYjVd(item, "actor"       )
    cat  = FFYjVd(item, "category"       )
    descr = FFYjVd(item, "descr"   , is_base64=True).replace("\n", " .. ")
    director= FFYjVd(item, "director"       )
    name = FFYjVd(item, "name"    , is_base64=True)
    startT = FFYjVd(item, "start_timestamp" , isDate=True )
    startTs = FFYjVd(item, "start_timestamp"     )
    stopT = FFYjVd(item, "stop_timestamp" , isDate=True )
    stopTs = FFYjVd(item, "stop_timestamp"     )
    try:
     startTs, stopTs = int(startTs), int(stopTs)
     if stopTs > now:
      dur = stopTs - startTs
      row = (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur)
      if not row in lst:
       lst.append(row)
    except:
     pass
  except:
   return "", "Cannot parse received data !"
  if retLst:
   lst = [(startTs, dur, name, "", descr, 1) for (actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur) in lst]
   return lst, ""
  else:
   sep  = FFjt5L("_" * 32 + "\n", VVo7S9)
   curTxt = FFjt5L("    (CURRENT EVENT)", VVJEMb)
   evNum = 1
   for actor, cat, descr, director, name, startT, stopT, startTs, stopTs, dur in lst:
    curEv = curTxt if (startTs < now and stopTs > now) else ""
    epg += sep
    epg += "Event\t: %d%s\n" % (evNum, curEv)
    epg += "Title\t: %s\n"  % FFjt5L(name, VVFuwR)
    epg += "Start\t: %s\n"  % startT
    epg += "End\t: %s\n"  % stopT
    epg += "Description:\n%s\n" % FFjt5L(descr , VVA4XU) if descr else "Description\t: - \n"
    epg += "Genre:\n%s\n"  % FFjt5L(cat  , VVA4XU) if cat else ""
    epg += "Actors:\n%s\n"  % FFjt5L(actor , VVA4XU) if actor else ""
    epg += "Director:\n%s\n" % FFjt5L(director, VVA4XU) if director else ""
    evNum += 1
   return epg, ""
 @staticmethod
 def VVfN18(txt):
  epg = movie_image = err = ""
  try:
   tDict = jLoads(txt)
   item = tDict["info"]
   movie_image = FFYjVd(item, "movie_image" )
   genre  = FFYjVd(item, "genre"  )
   plot  = FFYjVd(item, "plot"   )
   country  = FFYjVd(item, "country"  )
   actors  = FFYjVd(item, "actors"  )
   cast  = FFYjVd(item, "cast"   )
   rating  = FFYjVd(item, "rating"  )
   director = FFYjVd(item, "director"  )
   releasedate = FFYjVd(item, "releasedate" )
   duration = FFYjVd(item, "duration"  )
   tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y and y != "-" else ""
   try:
    lang = FFYjVd(tDict["info"]["audio"]["tags"], "language")
    if lang:
     epg += tab("Language", lang.capitalize())
   except:
    pass
   epg += tab("Genre"  , genre)
   epg += tab("Released" , releasedate)
   epg += tab("Country" , country)
   epg += tab("Duration" , duration)
   epg += tab("Director" , director)
   epg += tab("Rating"  , rating)
   if cast or actors : epg += "Cast:\n%s\n\n" % FFjt5L(cast or actors, VVA4XU)
   if plot    : epg += "Plot:\n%s"  % FFjt5L(plot, VVA4XU)
  except Exception as e:
   err = str(e)
  return epg, movie_image, err
 @staticmethod
 def VVYkyo(txt, VVZcRP):
  span = iSearch(r".+\/series\/.+\/.+\/(\d+)", VVZcRP)
  epId = span.group(1) if span else ""
  epg = epSeason = epTitle = cover = err = ""
  try:
   tDict = jLoads(txt)
   item = tDict["info"]
   cast  = FFYjVd(item, "cast"    )
   cover  = FFYjVd(item, "cover"   )
   director = FFYjVd(item, "director"   )
   genre  = FFYjVd(item, "genre"   )
   name  = FFYjVd(item, "name"    )
   plot  = FFYjVd(item, "plot"    )
   if epId:
    for sName, ep in tDict["episodes"].items():
     for item in ep:
      Id   = FFYjVd(item, "id"     )
      season  = FFYjVd(item, "season"    )
      Title  = FFYjVd(item, "title"    )
      if Id  == epId:
       epSeason, epTitle = season, Title
       break
     if epSeason or epTitle:
      break
   ttl = lambda x, y: "\n%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), str(y)) if y else ""
   tab = lambda x, y: ("%s\t: %s\n" % (x, y)) if y else ""
   epg =  tab("Season"  , epSeason)
   epg += tab("Title"  , epTitle)
   epg += tab("Name"  , name)
   epg += tab("Genre"  , genre)
   epg += tab("Director" , director)
   epg += ttl("Cast"  , cast)
   epg += ttl("Plot"  , plot)
  except Exception as e:
   err = str(e)
  return epg, cover, err
 @staticmethod
 def VVpX1r(catID, stID, chNum):
  MAX_4b = 65535
  MAX_8b = 4294967295
  SID  = CCkEI5.VVHz2c(catID, MAX_4b)
  TSID = CCkEI5.VVHz2c(chNum, MAX_4b)
  ONID = CCkEI5.VVHz2c(chNum, MAX_4b)
  NS  = CCkEI5.VVHz2c(stID, MAX_8b)
  if len(NS) == 4:
   NS = "1" + NS
  rType = CFG.iptvAddToBouquetRefType.getValue()
  return "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, TSID, ONID, NS)
 @staticmethod
 def VVHz2c(numStr, limit):
  if numStr.isdigit():
   i = int(numStr)
   if i > limit:
    i = limit
   return (hex(i))[2:].upper()
  else:
   return "222"
 @staticmethod
 def VVPjQO(txt):
  txt = iSub(iCompile(r'\W'), "_", txt)
  txt = FFMYNg(txt, "_")
  return "Bouquet" if txt == "_" else txt
 @staticmethod
 def VVxV5D(mode):
  if   mode in ("itv"  , CCkEI5.VVgkvV)  : return "#0a21303C", "#0a21303C", "#0a21303C", "#00005566"
  elif mode in ("vod"  , CCkEI5.VVgL8R)  : return "#1a260518", "#1a260518", "#1a260518", "#04224040"
  elif mode in ("series" , CCkEI5.VV6cbr) : return "#1a36013F", "#1a26012F", "#1a26012F", "#04224040"
  elif mode in ("catchup" , CCkEI5.VVspif) : return "#0a213044", "#0a213044", "#0a21303C", "#04224040"
  elif mode == CCkEI5.VV4kmD    : return "#0a202020", "#0a202020", "#0a202020", "#04663366"
  elif mode == "catchupEv"           : return "#0a00191B", "#0a001116", "#0a001116", "#00553344"
  elif mode == "series2"            : return "#0a462538", "#0a462538", "#0a462538", "#04224040"
  else                : return "#0a00292B", "#0a002126", "#0a002126", "#00005566"
 @staticmethod
 @FFOAKH("Reading ...")
 def VVvSue(SELF, hostUrl, VV1wIO, streamId, ok_fnc, rst_fnc=None):
  pList, err = CCkEI5.VVigje(hostUrl, streamId, mode=1)
  title = "Catch-up TV Programs"
  if err:
   FFdw58(SELF, "Server Error:\n\n%s" % err, title=title)
   return
  elif not pList:
   FFdw58(SELF, "No Programs from server", title=title)
   return
  pList.sort(key=lambda x: x[0], reverse=True)
  grnSTime = ""
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(SELF)
  span = iSearch(r"(\d{4}-\d{2}-\d{2}):(\d{2})-(\d{2})", VVZcRP)
  if span : sTime = span.group(1) + " " + span.group(2) + ":" + span.group(3)
  else : sTime = ""
  grn = False
  for ndx, row in enumerate(pList):
   if sTime in row[6] and row[4] in VV1wIO:
    pList[ndx] = tuple(["#f#0055ff55#" + x for x in row])
    grnSTime = row[6]
   elif row[7] == "1":
    pList[ndx] = tuple(["#f#00ffff00#" + x for x in row])
    grnSTime = row[6]
  span = iSearch(r"(.+)\/timeshift(\/.+\/.+)\/.+\/.+(\/.+)\.ts(.+)\s>>", VVPxk5 + ":" + VV57TX, IGNORECASE)
  chUrl = "".join(span.groups()) if span else ""
  def VVL1aK(VV6A99, title, txt, colList):
   FFnfiC(SELF.session, chUrl)
   VV6A99.cancel()
   if rst_fnc: rst_fnc()
  def VV8YHC(VV6A99, title, txt, colList):
   VV6A99.VVn5CC(6, grnSTime, VVwb7n=True)
  title = "Programs for : " + FFjt5L(VV1wIO, VVJEMb)
  VVwltY, VVkxBG, VVemyB, VVJKqd = CCkEI5.VVxV5D("catchupEv")
  VVwSzI = ("Current Event" , VV8YHC , []) if grnSTime else None
  VVScQz = ("Play Latest" , VVL1aK , []) if chUrl else None
  VVu1YM  = ("Play"  , ok_fnc  , [])
  header   = ("Start" , "End" , "Duration", "Lang", "Title" , "Description" , "sTime" , "Playing" , "DurMin" )
  widths   = (16  , 16 , 9   , 6  , 30  , 23   , 0   , 0   , 0   )
  VVLIqP  = (CENTER , CENTER, CENTER , CENTER, LEFT  , LEFT   , CENTER , CENTER , CENTER )
  FFUQ0v(SELF, None, title=title, header=header, VVGape=pList, VVLIqP=VVLIqP, VV3cHe=widths, width=1800, height=950, VVwdmN=24, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz, VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVJKqd=VVJKqd)
 @staticmethod
 def VVyjSu(rUrl, fPath):
  fPath = fPath.strip()
  if fPath.startswith("http://"):
   return fPath
  elif fPath.startswith("/"):
   try:
    res = iUrlparse(rUrl)
    scheme = res.scheme
    netloc = res.netloc
    if scheme and netloc:
     host = "%s://%s" % (scheme, netloc)
     return os.path.join(host, fPath.lstrip("/"))
   except:
    pass
   return ""
  else:
   baseUrl = os.path.dirname(rUrl).strip()
   fName = os.path.basename(rUrl).strip()
   return os.path.join(baseUrl, fPath)
 def VVoyt7(self, isPortal, line, selectionObj, item):
  title = "Add server to IPTV Menu (for easy access)"
  if isPortal : typ, confItem = "Portal" , CFG.favServerPortal
  else  : typ, confItem = "Playlist", CFG.favServerPlaylist
  rmTxt = "Removed from IPTV Menu."
  svTxt = 'Added to IPTV Menu.\n\nWill be shown as "%s"' % FFjt5L("Favourite %s Server" % typ, VVSGsk)
  cur = confItem.getValue().strip().replace("\t", "\n")
  if cur == line.strip():
   FFRMYv(self, BF(self.VVvDHm, title, rmTxt, typ, confItem, ""), "Already in IPTV Menu !\n\nRemove ?", title=title)
  elif cur:
   FFRMYv(self, BF(self.VVvDHm, title, svTxt, typ, confItem, line), "Replace current favourite item ?\n\n%s" % ((cur[:60] + "..") if len(cur) > 60 else cur), title=title)
  else:
   self.VVvDHm(title, svTxt, typ, confItem, line)
 def VVvDHm(self, title, txt, typ, confItem, line):
  FFjt1c(confItem, line)
  FFipXT(self, txt, title=title)
 def VVmoT7(self, isPortal):
  if isPortal:
   span = iSearch(r"(.+)\s((?:[A-Fa-f0-9]+:){5}.+[A-Fa-f0-9]+)", CFG.favServerPortal.getValue(), IGNORECASE)
   if span:
    self.VVAw1p(self, span.group(1), span.group(2))
    return
  else:
   span = iSearch(r"(http.+\/\/.+\/.+username=.+&password=.+)", CFG.favServerPlaylist.getValue(), IGNORECASE)
   if span:
    self.VVgCCs(self, "Favourite Playlist Server", span.group(1))
    return
  FFdw58(self, "Incorrect server data !")
 @staticmethod
 def VVwOWK(SELF, isPortal, line, selectionObj, item):
  path = FF7BT0()
  if isPortal : path += "Portal_Bookmarks.txt"
  else  : path += "Playlist_Bookmarks.txt"
  title = "Bookmark Current Server"
  try:
   if FFCyVu(path):
    with ioOpen(path, "r", encoding="utf-8") as f:
     for fLine in f:
      if str(line) in str(fLine):
       FFdw58(SELF, "Already added to file:\n\n%s" % path, title=title)
       return
   with open(path, "a") as f:
    f.write(line + "\n")
   FFipXT(SELF, "Added to file:\n\n%s" % path, title=title)
  except Exception as e:
   FFdw58(SELF, "Error:\n\n%s" % str(e), title=title)
 def VVCbC2(self, source, mode, VVIu85, VV6A99, title, txt, colList):
  isMulti = VV6A99.VVXWPu
  itemsOK = True
  totTxt = "ALL"
  if isMulti:
   tot = VV6A99.VVc5NH()
   totTxt = "%d Service%s" % (tot, FFcacr(tot))
   if tot < 1:
    itemsOK = False
  totTxt = FFjt5L(totTxt, VVFuwR)
  VVIu852 = ""
  if self.VV2rlK:
   name = iUrlparse(self.VV2rlK).netloc
   if name:
    VVIu852 = "%s (%s)" % (VVIu85, name.split(":")[0])
  mSel = CCzSCo(self, VV6A99, addSep=False, setsOk=True, setsBlue=True)
  VV3wat, cbFncDict = [], None
  VV3wat.append(VVAL3j)
  if itemsOK:
   title = "Add to Bouquet"
   thTxt = "Adding Services ..."
   VV3wat.append(("Add %s to New Bouquet : %s"    % (totTxt, FFjt5L(VVIu85 , VVSGsk)), "addToCur1"))
   if VVIu852: VV3wat.append(("Add %s to New Bouquet : %s" % (totTxt, FFjt5L(VVIu852, VVGCYL)) , "addToCur2"))
   VV3wat.append(("Add %s to Existing/New Bouquet ..."  % (totTxt)            , "addToNew" ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Save %s to M3U File" % (totTxt), "toM3u" ))
   cbFncDict = { "addToCur1": BF(self.VVDDgR, source, mode, VVIu85 , VV6A99, title)
      , "addToCur2": BF(self.VVDDgR, source, mode, VVIu852, VV6A99, title)
      , "toM3u"  : BF(self.VVwVFk   , source, mode, VVIu852, VV6A99, "Save to M3U File")
      , "addToNew" : BF(self.VVSXwS, source, mode, VVIu85, VV6A99, title)
      }
  else:
   VV3wat.append(("Add to Bouquet (nothing selected)", ))
  mSel.VV9VR2(VV3wat, cbFncDict, width=1400)
 @FFOAKH("Adding Services ...", par=4)
 def VVDDgR(self, source, mode, VVIu85, VV6A99, Title):
  chUrlLst = self.VVznPA(source, mode, VV6A99)
  CCMvE7.VVPJK0(self, Title, VVIu85, "", chUrlLst)
 def VVSXwS(self, source, mode, VVIu85, VV6A99, Title):
  picker = CCMvE7(self, VV6A99, Title, BF(self.VVznPA, source, mode, VV6A99), VVFjhV=VVIu85)
 def VVznPA(self, source, mode, VV6A99):
  isMulti = VV6A99.VVXWPu
  chUrlLst = []
  rowNum = 0
  for ndx, row in enumerate(VV6A99.VVrrm9()):
   if not isMulti or VV6A99.VVvlf4(ndx):
    chUrl = VV1wIO = ""
    if source in ("pEp", "pCh"):
     VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, row)
     VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
    elif source in ("lv", "v", "s", "fnd"):
     VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, row)
    if chUrl and VV1wIO:
     chUrlLst.append(chUrl)
  return chUrlLst
 @FFOAKH("Adding Services ...", par=4)
 def VVwVFk(self, source, mode, VVIu85, VV6A99, Title):
  chUrlLst = []
  outF = "%s%s_%s.m3u" % (FF7BT0(), FFOu5Y(VVIu85), FFjTQe())
  totCh = toB = 0
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for ndx, row in enumerate(VV6A99.VVrrm9()):
    if not VV6A99.VVXWPu or VV6A99.VVvlf4(ndx):
     chUrl = VV1wIO = ""
     if source in ("pEp", "pCh"):
      VV1wIO, catID, stID, chNum, chCm, serCode, serId, VVfbmn = self.VVcP3g(mode, row)
      VVPxk5, chUrl = self.VVfi1S(self.VVncdQ, self.VVvRlC, mode, VV1wIO, catID, stID, chNum, chCm, serCode, serId)
     elif source in ("lv", "v", "s", "fnd"):
      VV1wIO, chUrl, VVfbmn, VVPxk5 = self.VVK5K0(mode, row)
     if VV1wIO and chUrl:
      chR = chUrl.replace(":" + VV1wIO, "").strip()
      span = iSearch(r'^(?:[A-Fa-f0-9]+:){10}(.*)', chR, IGNORECASE)
      if span:
       totCh += 1
       pUrl = (' tvg-logo="%s"' % VVfbmn) if VVfbmn else ""
       f.write('#EXTINF:-1 group-title="%s"%s,%s\n' % (VVIu85, pUrl, VV1wIO))
       f.write("%s\n" % FFXarh(span.group(1)))
  if totCh:
   FFipXT(self, "Exported %s Channel%s to:\n\n%s" % (totCh, FFcacr(totCh), outF), title=Title)
  else:
   FFdw58(self, "Nothing to save.", title=Title)
   FFwgGB(outF)
 @staticmethod
 def VVnmMH():
  return {"1": "DVB Stream", "4097": "ServiceMp3", "5001": "GST Player", "5002": "ExtEPlayer3", "8192": "HDMI input", "8193": "eServiceUri", "8793": "ServiceUrl"}
 @staticmethod
 def VV5LSJ():
  return sorted(tuple(CCkEI5.VVnmMH()))
 @staticmethod
 def VVDWCB(rt):
  return CCkEI5.VVnmMH().get(str(rt), "")
 @staticmethod
 def VVBbrv(VVPxk5):
  span = iSearch(r"(?:([A-Fa-f0-9]+):){1}(?:[A-Fa-f0-9]+:){8}", VVPxk5)
  return span.group(1) if span else ""
 @staticmethod
 def VV4IKy(VVPxk5):
  return CCkEI5.VVDWCB(CCkEI5.VVBbrv(VVPxk5))
 @staticmethod
 def VVUDPe(rt):
  if   rt == "1"  : return True
  elif rt == "4097": return True
  elif rt == "5001": return FFCyVu("/usr/bin/gstplayer") or FFCyVu("/usr/bin/gstplayer_gst-1.0")
  elif rt == "5002": return FFCyVu("/usr/bin/exteplayer3")
  elif rt == "8192": return False
  elif rt == "8193": return FFCyVu("/usr/bin/apt-get")
  elif rt == "8793": return FFCyVu("/usr/bin/apt-get")
  else    : return False
 @staticmethod
 def VVMYQY(SELF, cbFnc):
  def VVTWCX(rt, selectionObj, item):
   FFRMYv(SELF, BF(VVRdGX, rt, selectionObj), "Save as Default Player ?", title="Current Player : %s (%s)" % (rt, CCkEI5.VVDWCB(rt)))
  def VVRdGX(rt, selectionObj):
   FFjt1c(CFG.iptvAddToBouquetRefType, rt)
   selectionObj.cancel()
   FF1mVE(SELF, "Saved", 800)
  curRt = CC3rDi(SELF.session).refType
  defRt = CFG.iptvAddToBouquetRefType.getValue()
  VV3wat = []
  for ndx, rt in enumerate(CCkEI5.VV5LSJ()):
   if   rt == curRt: color, txt = VVFuwR, "(Current)"
   elif rt == defRt: color, txt = VVZtfx, "(Default)"
   else   : color = txt = ""
   VV3wat.append(FFsLU5("%s\t%s %s" % (CCkEI5.VVDWCB(rt), rt, txt), rt, CCkEI5.VVUDPe(rt), color))
   if ndx < 4 and ndx % 2: VV3wat.append(VVAL3j)
  VVB4pu = ("Save", BF(VVTWCX, curRt)) if curRt != defRt else None
  FFLFTC(SELF, cbFnc, VV3wat=VV3wat, width=700, title="Select Player", VVB4pu=VVB4pu, VVwltY="#11220000", VVkxBG="#11220000")
 @staticmethod
 def VVYuoh(VVZcRP):
  if not FFHgaY(VVZcRP) and iMatch(r"(.+)(?:(?:\/live)*|\/movie|\/series)\/(.+)\/(.+)\/(.+):(.+)", VVZcRP):
   return True
  else:
   return bool(CCkEI5.VV9F1k(VVZcRP))
 @staticmethod
 def VV9F1k(VVZcRP):
  if "/timeshift/" in VVZcRP:
   span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/.+\/.+\/(.+)\.ts:(.+)(?:\s>>)?", VVZcRP)
   if span and all(span.groups()): return span.groups()
  else:
   span = iSearch(r"(.+)\/(.+)\/(.+)\/(\d+):(.+)", VVZcRP)
   if span and all(span.groups()):
    return span.groups()
   elif "chCode" in VVZcRP:
    span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+&end=:(.+)", VVZcRP)
    if span and all(span.groups()):
     return span.groups()
  return None
 @staticmethod
 def VVQNEW():
  return "Mozilla/5.0 (U; Linux; C; Emulator/1.2.12) AppleWebKit/533.3 (KHTML, like Gecko) Safari/533.3"
 @staticmethod
 def VVgoVw():
  return { 'User-Agent': CCkEI5.VVQNEW() }
class CCE4dD(object):
 def __init__(self, SELF):
  SELF["mySbFrm"] = Label()
  SELF["mySbBak"] = Label()
  SELF["mySbSld"] = Label()
  self.frm, self.bak, self.sld = SELF["mySbFrm"], SELF["mySbBak"], SELF["mySbSld"]
  self.frmI = self.bakI = self.sldI = None
  self.sldX = self.sldY = self.sldW = self.sldH = 0
  for obj in (self.frm, self.bak, self.sld): obj.hide()
 def VVdDaQ(self, x, y, w, h, bW=1, frmColor="#11aaaaaa", bakColor="#11003344", sldColor="#11ff8000"):
  x, y, w, h = int(x), int(y), int(w), int(h)
  FFZ0AC(self.frm, frmColor)
  FFZ0AC(self.bak, bakColor)
  FFZ0AC(self.sld, sldColor)
  self.frmI, self.bakI, self.sldI = self.frm.instance, self.bak.instance, self.sld.instance
  self.frmI.move(ePoint(x, y))
  self.frmI.resize(eSize(w, h))
  self.bakI.move(ePoint(x + bW, y + bW))
  self.bakI.resize(eSize(w - bW * 2, h - bW * 2))
  self.sldX = x + bW
  self.sldY = y + bW
  self.sldW = w - bW * 2
  self.sldH = h - bW * 2
  self.sldI.move(ePoint(self.sldX, self.sldY))
  self.sldI.resize(eSize(self.sldW, self.sldH))
 def VVO0oI(self, val, maxN):
  if maxN < 2:
   for obj in (self.frm, self.bak, self.sld): obj.hide()
  else:
   for obj in (self.frm, self.bak, self.sld): obj.show()
   visH = max(self.sldH / maxN, self.sldH * 0.05)
   self.sldI.resize(eSize(self.sldW, int(visH)))
   y = FFjFSv(val, 1, maxN, 0, self.sldH - visH)
   self.sldI.move(ePoint(self.sldX, int(self.sldY + y)))
class CCsyCY(CCE4dD):
 def __init__(self, VV6zIF=""):
  self.VVQ3Dp  = self.VVfOli["VVUuJZ"]["rows"]
  self.VVsHeH  = self.VVfOli["VVUuJZ"]["cols"]
  self.VVg3d5  = self.VVQ3Dp * self.VVsHeH
  self.VV6zIF  = VV6zIF
  self.VVUwNK  = self.VVfOli["VVUuJZ"].get("percBar", 0)
  self.VVbKuB  = 0
  self.VVUeUp  = 0
  self.VVSmMg  = 0
  self.curRow   = 0
  self.curCol   = 0
  self.VVBGsZ  = 0
  self.VV3uAw  = 0
  self.VVcG7K  = 0
  self.VVGCBk  = 0
  self.VV6wbi   = False
  self.VVzIFK   = {}
  self.VVuKJI  = None
  self.VVa0gN  = {}
  self.VVP8y1  = 0
  self.VVIgWJ  = 0
  self.VVC1Tl  = ""
  self.VVQODt = True
  self.VVLEOv = False
  CCE4dD.__init__(self, self)
  self["myCursorLbl"]  = Label()
  self["myCursorPic"]  = Pixmap()
  self["myPiconF"]  = Label()
  self["myPiconBG"]  = Label()
  self["myPiconPic"]  = Pixmap()
  self["myPiconF"].hide()
  self["myPiconBG"].hide()
  self["myPiconPic"].hide()
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    self["myPosterBak%d%d" % (row, col)] = Pixmap()
    self["myPosterRep%d%d" % (row, col)] = Label()
    self["myPosterPic%d%d" % (row, col)] = Pixmap()
    self["myPosterPic%d%d" % (row, col)].hide()
    self["myPosterBak%d%d" % (row, col)].hide()
    self["myPosterLbl%d%d" % (row, col)] = Label()
    self["myPosterLbl%d%d" % (row, col)].hide()
    if self.VVUwNK:
     for nm in ("myPercFr", "myPercBG", "myPercFG"):
      self[nm + "%d%d" % (row, col)] = Label()
      self[nm + "%d%d" % (row, col)].hide()
  self.VVaFRk()
  VVSZWt, boxT, boxW, boxH, infT, infH, totInf, bGap = self.VVfOli["retPar"]
  for i in range(totInf):
   self["myPiconInf%d" % i] = Label()
  FFHlAU(self,
  {
   "up"  : self.VVx0di   ,
   "down"  : self.VVDBsZ  ,
   "left"  : self.VVziFC  ,
   "right"  : self.VVLe1s  ,
   "next"  : self.VVSYHQ ,
   "last"  : self.VVLlE3  ,
   "pageUp" : self.VVLlE3  ,
   "chanUp" : self.VVLlE3  ,
   "pageDown" : self.VVSYHQ ,
   "chanDown" : self.VVSYHQ ,
   "0"   : self.VVkrIc
  })
 def VVCHVq(self, sbDim=None, sbFrmW=1, sbFrmColor="#11aaaaaa", sbBg="#11003344", sbSldBg="#11ff8000", shade="", cursor="#00ffff55"):
  self.VVGEkC(shade)
  if cursor == "swap" : self.VVLEOv = True
  else    : self.VVrs4x(cursor)
  self.VVGyYL()
  self["myPiconPic"].instance.setScale(1)
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    self["myPosterPic%d%d" % (row, col)].instance.setScale(1)
    sz = self["myPosterPic%d%d" % (row, col)].instance.size()
    pos= self["myPosterPic%d%d" % (row, col)].instance.position()
    self.VVzIFK[(row, col)] = ((pos.x(), pos.y()))
    self.VVuKJI = (sz.width(), sz.height())
  gap = int(self.VVfOli["VVSZWt"] / 1)
  topBox = self["myPosterPic%d%d" % (0, 0)].instance
  sz = topBox.size()
  self.VVP8y1 = sz.width()
  self.VVIgWJ = sz.height()
  boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVfOli["retPar"]
  if sbDim:
   x, y, w, h = sbDim
  elif self.VVfOli["VVUuJZ"].get("upSBar", False):
   x, y, w, h = self.VVfOli["width"] - 22, self.VVfOli["titleH"] + 8, 15, infH - 12
  else:
   w = 20
   y = infT + infH + 3
   h = self.VVfOli["height"] - self.VVfOli["VVeFSs"] - y - 2
   x = self.VVfOli["width"] - w - 2
  self.VVdDaQ(x, y, w, h, bW=sbFrmW, frmColor=sbFrmColor, bakColor=sbBg, sldColor=sbSldBg)
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    FFK4PQ(self["myPosterLbl%d%d" % (row, col)], "#000000", 2)
  self["myCursorLbl"].hide()
  self["myCursorPic"].hide()
 def VVGEkC(self, val):
  self.VVC1Tl = val
  if val:
   p = CC6u6z.VVQuYE(self["myPosterBak00"], val, toPng=True) or VVIp2p + "frm2.png"
   png = FFmNfu(p)
  else:
   png = None
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    pic = self["myPosterBak%d%d" % (row, col)]
    pic.instance.setPixmap(png)
    pic.instance.invalidate()
    if self.VVC1Tl:
     pic.show()
 def VVrs4x(self, cursor):
  if not cursor or cursor.startswith("/"):
   self["myCursorLbl"].hide()
   self["myCursorPic"].show()
   FFBFPY(self["myCursorPic"], cursor if FFCyVu(cursor) else VVIp2p + "frm1.png")
  else:
   self.VVQODt = False
   self["myCursorPic"].hide()
   self["myCursorLbl"].show()
   if iMatch(r"^#[A-Fa-f0-9]{6}$|^#[A-Fa-f0-9]{8}$", cursor):
    FFZ0AC(self["myCursorLbl"], cursor)
 def VVTrjr(self):
  if not self.VVuKJI:
   return
  normC, cursC = "#00444444", "#00ffff00"
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    ndx = self.VVvg4K(row, col)
    picInst = self["myPosterPic%d%d" % (row, col)].instance
    cursInst = self["myCursorPic"].instance
    cPos, cSz = cursInst.position(), cursInst.size()
    if (row, col) == (self.curRow, self.curCol):
     x, y, w, h = cPos.x(), cPos.y(), cSz.width(), cSz.height()
     if ndx in self.VVa0gN:
      _, y, w1, h1 = self.VVa0gN[ndx]
      _, _, w, h = self.VVF7W0(w1, h1, w, h)
      x, w = x + 6, w - 12
      self["myCursorPic"].show()
      cursInst.setBorderColor(parseColor(cursC))
      cursInst.setBorderWidth(4)
     else:
      picInst.setBorderColor(parseColor(cursC))
      picInst.setBorderWidth(4)
    elif ndx in self.VVa0gN:
     x, y, w, h = self.VVa0gN[ndx]
    else:
     (x, y), (w, h) = self.VVzIFK[(row, col)], self.VVuKJI
     if self.VV3uAw == self.VVvg4K(row, col):
      picInst.setBorderColor(parseColor(normC))
      picInst.setBorderWidth(1)
    picInst.move(ePoint(x, y))
    picInst.resize(eSize(*(w, h)))
 def VVaJVd(self, ndx, row, col, pic, path, reset=False):
  inst = pic.instance
  if reset:
   if (row, col) == (self.curRow, self.curCol):
    curs = self["myCursorPic"].instance
    cPos, cSz = curs.position(), curs.size()
    boxX, boxY, boxW, boxH = cPos.x(), cPos.y(), cSz.width(), cSz.height()
   else:
    (boxX, boxY), (boxW, boxH) = self.VVzIFK[(row, col)], self.VVuKJI
   if ndx in self.VVa0gN:
    del self.VVa0gN[ndx]
  else:
   boxX, boxY = self.VVzIFK[(row, col)]
   boxW, boxH = self.VVuKJI
  png = FFmNfu(path) or FFmNfu(VVIp2p + "noPic.png")
  if png:
   inst.setBorderWidth(0)
  else:
   inst.setBorderColor(parseColor("#00ff8055"))
   inst.setBorderWidth(2)
   return False
  pngSz = png.size()
  pngW, pngH = pngSz.width(), pngSz.height()
  inst.setPixmap(png)
  if (pngW > pngH and boxH > boxW) or (pngH > pngW and boxW > boxH) or (pngW == pngH and boxW != boxH):
   x, y, w, h = CCsyCY.VVF7W0(pngW, pngH, boxW, boxH)
   x += boxX
   y += boxY
   self.VVa0gN[ndx] = (x, y, w, h)
  else:
   x, y, w, h = boxX, boxY, boxW, boxH
   inst.setBorderColor(parseColor("#00444444"))
   inst.setBorderWidth(1)
  inst.resize(eSize(*(w, h)))
  inst.move(ePoint(x, y))
  return True
 def VVjkVK(self, colors):
  for i, (fg, bg) in enumerate(colors):
   if fg: FFGUI5(self["myPiconInf%d" % i], fg)
   if bg: FFZ0AC(self["myPiconInf%d" % i], bg)
 def VVkhlj(self, inf0, inf1):
  self["myPiconInf0"].setText("  %s  " % inf0 )
  self["myPiconInf1"].setText("   %s   " % inf1)
  self["myPiconInf2"].setText("Num. : %d / %d" % (self.VVBGsZ + 1, self.VVbKuB))
  self["myPiconInf3"].setText("Page: %d / %d"  % (self.VVSmMg  + 1, self.VVUeUp))
 def VVS7BN(self):
  f1 = self.VVSmMg * self.VVg3d5
  f2 = f1 + self.VVg3d5
  if f1 > self.VVbKuB: f1 = self.VVbKuB
  if f2 > self.VVbKuB: f2 = self.VVbKuB
  return f1, f2
 def VVx0di(self):
  if self.VVSmMg == self.curRow == self.curCol == 0:
   self.VVGc2k()
  else:
   if self.VVSmMg == 0 and self.curRow == 0: self.curCol = 0
   else          : self.curRow -= 1
   self.VVLckG()
 def VVDBsZ(self):
  if self.VVSmMg == self.VVUeUp - 1 and self.curRow == self.VVcG7K and self.curCol == self.VVGCBk:
   self.VVPhaY()
  else:
   if self.VVSmMg == self.VVUeUp - 1 and self.curRow == self.VVcG7K:
    self.curCol = self.VVGCBk
   else:
    self.curRow += 1
   self.VVLckG()
 def VVziFC(self):
  if self.VVSmMg == self.curRow == self.curCol == 0:
   self.VVGc2k()
  else:
   self.curCol -= 1
   self.VVLckG()
 def VVLe1s(self):
  if self.VVSmMg == self.VVUeUp - 1 and self.curRow == self.VVcG7K and self.curCol == self.VVGCBk:
   self.VVPhaY()
  else:
   self.curCol += 1
   self.VVLckG()
 def VVLlE3(self):
  oldPage = self.VVSmMg
  if self.VVSmMg == 0:
   self.curRow = 0
   self.curCol = 0
  else:
   self.VVSmMg -= 1
  self.VVLckG(oldPage != self.VVSmMg)
 def VVSYHQ(self):
  oldPage = self.VVSmMg
  if self.VVSmMg == self.VVUeUp - 1:
   self.curRow = self.VVcG7K
   self.curCol = self.VVGCBk
  else:
   self.VVSmMg += 1
  self.VVLckG(oldPage != self.VVSmMg)
 def VVkrIc(self):
  if self.VVBGsZ == 0: self.VVGc2k()
  else     : self.VVPhaY()
 def VVPhaY(self):
  force = self.VVSmMg != 0
  self.curRow  = 0
  self.curCol  = 0
  self.VVSmMg = 0
  self.VVLckG(force)
 def VVGc2k(self):
  force = self.VVSmMg != self.VVUeUp - 1
  self.VVSmMg = self.VVUeUp - 1
  self.curRow  = (self.VVQ3Dp - 1)
  self.curCol  = (self.VVsHeH - 1)
  self.VVLckG(force)
 def VVLckG(self, force=False):
  if self.VV6wbi:
   return
  oldPage = self.VVSmMg
  if self.curCol > self.VVsHeH - 1:
   self.curCol = 0
   self.curRow += 1
  elif self.curCol < 0:
   self.curCol = self.VVsHeH - 1
   self.curRow -= 1
  if self.curRow > self.VVQ3Dp - 1:
   self.curRow = 0
   self.VVSmMg += 1
  elif self.curRow < 0:
   self.curRow = self.VVQ3Dp - 1
   self.VVSmMg -= 1
  VVSI5d = self.VVUeUp -1
  if   self.VVSmMg < 0  : self.VVSmMg = 0
  elif self.VVSmMg > VVSI5d: self.VVSmMg = VVSI5d
  if self.curRow > self.VVQ3Dp - 1: self.curRow = self.VVQ3Dp - 1
  if self.curCol < 0     : self.curCol = 0
  self.VVHvUS()
  self["myCursorLbl"].hide()
  self["myCursorPic"].hide()
  self.VVO0oI(self.VVSmMg + 1, self.VVUeUp)
  FFIElK(BF(self.VVF5e6, force or not oldPage == self.VVSmMg, VVSI5d))
 def VVF5e6(self, force, VVSI5d):
  try:
   if force:
    self.VVa0gN = {}
    self.VVe4Ro()
   if self.VVSmMg == VVSI5d:
    if self.curRow > self.VVcG7K:
     self.curRow = self.VVcG7K
    if self.curRow == self.VVcG7K and self.curCol > self.VVGCBk:
     self.curCol = self.VVGCBk
   self.VV3uAw = self.VVBGsZ
   self.VVBGsZ = self.VVSmMg * self.VVg3d5 + self.curRow * self.VVsHeH + self.curCol
   self.VVHvUS()
   boxX, boxY, boxW, boxH, infT, infH, totInf, bGap = self.VVfOli["retPar"]
   self["myCursorLbl"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
   self["myCursorPic"].instance.move(ePoint(int(boxX + (boxW + bGap) * self.curCol) + 1, int(boxY + (boxH + bGap) * self.curRow) + 1))
   if self.VVLEOv:
    self.VVTrjr()
   else:
    if self.VVQODt : self["myCursorPic"].show()
    else    : self["myCursorLbl"].show()
  except:
   pass
 def VVvg4K(self, row, col):
  return self.VVSmMg * self.VVg3d5 + row * self.VVsHeH + col
 def VVdLxd(self, ndx):
  if ndx > -1 and ndx < self.VVbKuB:
   oldPage   = self.VVSmMg
   self.VVSmMg = int(ndx / self.VVg3d5)
   firstInPage  = self.VVSmMg * self.VVg3d5
   diff   = ndx - firstInPage
   self.curRow  = int(diff / self.VVsHeH)
   firstInRow  = self.curRow * self.VVsHeH
   diff   = ndx - firstInPage
   self.curCol  = diff - self.curRow * self.VVsHeH
   self.VVLckG(False if oldPage == self.VVSmMg else True)
  else:
   FF28n1(self, "Not found", 1000)
 def VVozNN(self):
  if self.VV6zIF:
   for row in range(self.VVQ3Dp):
    for col in range(self.VVsHeH):
     self["myPosterRep%d%d" % (row, col)].hide()
 def VVaFRk(self):
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    for nm in ("myPosterBak", "myPosterRep", "myPosterPic", "myPosterLbl"):
     self[nm + "%d%d" % (row, col)].hide()
    if self.VVUwNK:
     for nm in ("myPercFr", "myPercBG", "myPercFG"):
      self[nm + "%d%d" % (row, col)].hide()
 def VVwbpA(self, row, col):
  if self.VVC1Tl:
   self["myPosterBak%d%d" % (row, col)].show()
  if not self.VVLEOv:
   self["myPosterRep%d%d" % (row, col)].show()
  pic = self["myPosterPic%d%d" % (row, col)]
  lbl = self["myPosterLbl%d%d" % (row, col)]
  pic.show()
  lbl.show()
  return pic, lbl
 def VV3wsR(self, row, col, perc):
  if self.VVUwNK and perc > -1:
   if perc > -1:
    bgLbl = self["myPercBG%d%d" % (row, col)]
    fgLbl = self["myPercFG%d%d" % (row, col)]
    sz = bgLbl.instance.size()
    fgLbl.instance.resize(eSize(*(min(perc, 100) * sz.width() // 100, sz.height())))
    for nm in ("myPercFr", "myPercBG", "myPercFG"):
     self[nm + "%d%d" % (row, col)].show()
 def VVA2WD(self):
  if self.VV6zIF:
   fg = bg = self.VV6zIF.getValue()
   self.session.openWithCallback(self.VVnMYE, CC1FS2, defFG=fg, defBG=bg, onlyBG=True)
 def VVnMYE(self, fg, bg):
  if self.VV6zIF and bg:
   FFjt1c(self.VV6zIF, bg)
   self.VVGyYL()
 def VVGyYL(self):
  if self.VV6zIF:
   for row in range(self.VVQ3Dp):
    for col in range(self.VVsHeH):
     FFZ0AC(self["myPosterRep%d%d" % (row, col)], self.VV6zIF.getValue())
 def VVExY8(self, lbl, txt, color=""):
  CCsyCY.VVaiX0(lbl, txt, color)
 @staticmethod
 def VVaiX0(lbl, txt, color=""):
  lbl.show()
  lbl.setText(txt)
  txtW = lbl.instance.calculateSize().width()
  lblW = lbl.instance.size().width() - 15
  if txtW > lblW:
   for i in range(len(txt), 5, -1):
    txt = txt[:-1]
    lbl.setText("%s.." % txt)
    txtW = lbl.instance.calculateSize().width()
    if txtW < lblW:
     break
  if color:
   lbl.setText("%s%s" % (color, txt))
 @staticmethod
 def VVF7W0(pngW, pngH, boxW, boxH):
  r_old = float(pngW) / pngH
  r_new = float(boxW) / boxH
  if (r_old > r_new):
   w = boxW
   h = int(float(w) / r_old)
   x = 0
   y = int((boxH - h) / 2.0) + 4
  else:
   h = boxH
   w = int(h * r_old)
   y = 2
   x = int((boxW - w) / 2.0)
  return x, y, w, h
class CCUYzx(Screen, CCsyCY):
 CANCEL_POSTER_DOWNLOAD = False
 def __init__(self, session, VV6A99, pPath, nameCol, picCol, descCol, descTxt):
  self.skin, self.VVfOli = FFiNEe(VVpLGo, 1870, 1030, 50, 20, 20, "#06112a33", "#06112a33", 50, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":35, "gapY":35})
  self.session   = session
  self.VV6A99  = VV6A99
  self.pPath    = pPath
  self.nameCol   = nameCol
  self.picCol    = picCol
  self.descCol   = descCol
  self.descTxt   = descTxt
  self.Title    = VV6A99.Title or "Server Browser"
  self.timer_updPic  = eTimer()
  self.totThreads   = 0
  self.VV1tA1 = set()
  self.totDownloads  = 0
  self.VVGape    = []
  self.postersNdxLst  = []
  self.totPosterUrls  = 0
  self.VVbKuB   = 0
  self.VVpQCY  = True
  self.isInPlayer   = False
  FFZMxC(self, self.Title)
  CCsyCY.__init__(self)
  if not VVmJwX(self.pPath):
   FFpwZS("mkdir -p '%s'" % self.pPath)
   if not VVmJwX(self.pPath):
    self.pPath = "/tmp/"
  FFBep1(self,
  {
   "ok" : self.VVPr1F    ,
   "cancel": self.close    ,
   "menu" : self.VVFYyH ,
   "info" : self.VVLrXf
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  if self.VVpQCY:
   self.VVpQCY = False
   FF6W0I(self)
   FFWgBS(self)
   self.VVCHVq(cursor="swap", sbSldBg="#00777777")
   for i in range(4):
    FFZ0AC(self["myPiconInf%s" % i], "#0a001a22")
   self.VV35bc()
  elif self.isInPlayer:
   self.isInPlayer = False
   VVSmMg, curRow, curCol = self.VVSmMg, self.curRow, self.curCol
   self.VVjT0n()
   if (VVSmMg, curRow, curCol) != (self.VVSmMg, self.curRow, self.curCol):
    self.VVLckG(False if VVSmMg == self.VVSmMg else True)
 def VVjT0n(self):
  ndx = self.VV6A99.VVGTqU()
  self.VVSmMg = int(ndx / self.VVg3d5)
  ndx     -= self.VVSmMg * self.VVg3d5
  self.curRow  = int((ndx / self.VVsHeH))
  ndx     -= self.curRow * self.VVsHeH
  self.curCol  = int((ndx % self.VVsHeH))
 def onExit(self):
  CCUYzx.CANCEL_POSTER_DOWNLOAD = True
  self.timer_updPic.stop()
 def VVFYyH(self):
  VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
  picOk = FFCyVu(self.pPath + fName)
  VV3wat = []
  VV3wat.append(FFsLU5("Show Selected Picture"        , "VVIENY"  , picOk))
  VV3wat.append(FFsLU5("Export Selected Picture"        , "VV9oi3" , picOk))
  VV3wat.append(FFsLU5("Set Selected Picture as a Poster for a Local Media" , "VVFrce", picOk))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Cache details"       , "VVkieu"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Help (Keys)"        , "help"     ))
  FFLFTC(self, self.VVrAZ5, title=self.Title, VV3wat=VV3wat)
 def VVrAZ5(self, item=None):
  if item is not None:
   if   item == "VVIENY"   : self.VVIENY()
   elif item == "VV9oi3"   : self.VV9oi3()
   elif item == "VVFrce"  : self.VVFrce()
   elif item == "VVkieu"  : self.VVkieu()
   elif item == "help"     : FFw2rR(self, "_help_servBr", "Server Browser (Keys)")
 def VVPr1F(self):
  self.VV6A99.VVrqBw(self.VVBGsZ)
  self.VV6A99.VVDFgE()
  self.isInPlayer = True
 def VVLrXf(self):
  self.VV6A99.VVrqBw(self.VVBGsZ)
  self.VV6A99.VVyogT()
 def VVmIuN(self, url):
  span = iSearch(r".+\.(png|jpg|jpeg)", url, IGNORECASE)
  if span:
   ext = span.group(1)
  else:
   ext = "jpg"
   for ex in (".jpg", ".png", ".jpeg"):
    if ex in url.lower():
     ext = ex[1:]
     break
  ext = ext.lower()
  if ext == "jpeg": ext = "jpg"
  return "%s.%s" % (FFbhOc(url), ext)
 def VV35bc(self):
  for colList in self.VV6A99.VVrrm9():
   VV1wIO = colList[self.nameCol]
   url  = colList[self.picCol]
   desc = colList[self.descCol]
   fName = VVfbmn = ""
   if url:
    tmpFile = self.VVmIuN(url)
    if FFCyVu(self.pPath + tmpFile):
     fName = tmpFile
    else:
     VVfbmn = url
     self.totPosterUrls += 1
   self.VVGape.append((VV1wIO, self.descTxt, desc, fName, VVfbmn))
  self.VVbKuB = len(self.VVGape)
  self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
  self.VVjT0n()
  self.VVLckG(True)
  for ndx, (VV1wIO, subj, desc, fName, VVfbmn) in enumerate(self.VVGape):
   if VVfbmn and not fName:
    self.postersNdxLst.append(ndx)
  CCUYzx.CANCEL_POSTER_DOWNLOAD = False
  try: self.timer_updPic_conn = self.timer_updPic.timeout.connect(self.VVyKPA)
  except: self.timer_updPic.callback.append(self.VVyKPA)
  self.timer_updPic.start(50, False)
 def VVffim(self):
  if self.postersNdxLst and self.totThreads < 8:
   iThread(name="ajp_DnldPic", target=self.VVZvfo).start()
 def VVZvfo(self):
  try:
   if CCUYzx.CANCEL_POSTER_DOWNLOAD: return
   self.totThreads += 1
   ndx = self.postersNdxLst[0]
   self.postersNdxLst.pop(0)
   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
   if VVfbmn and not fName:
    if CCUYzx.CANCEL_POSTER_DOWNLOAD: return
    VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
    fName = self.VVmIuN(VVfbmn)
    if not fName in self.VV1tA1:
     self.VV1tA1.add(fName)
     path, err = FFx9uM(VVfbmn, fName, timeout=2, VVzHui=True, VVf6G8=False)
     if path:
      if CCUYzx.CANCEL_POSTER_DOWNLOAD:
       FFwgGB(path)
       return
      cmd = CCvjVs.VVQ9GP(path, 500)
      cmd += FFb2oQ("mv -f '%s' '%s'" % (path, self.pPath + fName))
      FFpwZS(cmd)
    if CCUYzx.CANCEL_POSTER_DOWNLOAD: return
    self.totDownloads += 1
    self.VVGape[ndx] = (VV1wIO, subj, desc, fName, "-")
   self.totThreads -= 1
  except:
   pass
 def VVyKPA(self):
  if self.postersNdxLst:
   if self.totThreads < 8:
    iThread(name="ajp_DnldPic", target=self.VVZvfo).start()
   txt = VVYjI5 + "   >> Downloading %d/%d ..." % (self.totDownloads, self.totPosterUrls)
  else:
   txt = ""
  self["myTitle"].setText("  %s%s" % (self.Title, txt))
  last = self.VVbKuB
  f1 = self.VVSmMg * self.VVg3d5
  f2 = f1 + self.VVg3d5
  if f1 > last: f1 = last
  if f2 > last: f2 = last
  row = col = remain = 0
  for ndx in range(f1, f2):
   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
   if fName and VVfbmn == "-":
    path = self.pPath + fName
    if FFCyVu(path):
     self.VVGape[ndx] = (VV1wIO, subj, desc, fName, "")
     pic, lbl = self.VVwbpA(row, col)
     self.VVaJVd(ndx, row, col, pic, path, reset=True)
     if ndx == self.VVBGsZ and self.VVLEOv:
      self.VVTrjr()
   if VVfbmn and not fName:
    remain += 1
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
  if not txt:
   self.VV1tA1 = set()
   FFOKt0(self, 2000, self.timer_updPic.stop)
 def VVe4Ro(self):
  self.VVaFRk()
  f1, f2 = self.VVS7BN()
  row = col = 0
  for ndx in range(f1, f2):
   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[ndx]
   pic, lbl = self.VVwbpA(row, col)
   self.VVExY8(lbl, VV1wIO)
   self.VVaJVd(ndx, row, col, pic, self.pPath + fName)
   self.VVcG7K = row
   self.VVGCBk = col
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
 def VVHvUS(self):
  VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
  self.VVkhlj(VV1wIO, "%s : %s" % (subj, desc) if desc else "")
 def VVIENY(self):
  VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
  if fName and FFCyVu(self.pPath + fName) : CCf8zb.VVjnMn(self, self.pPath + fName)
  else          : FF28n1(self, "File not found", 1500)
 def VV9oi3(self):
  title = "Copy Poster/PIcon"
  VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
  if fName:
   dstPath = FFriZ7()
   dstF = dstPath + (FFOu5Y(VV1wIO) + os.path.splitext(fName)[1] if VV1wIO else fName)
   if FFpwZS("cp -f '%s' '%s'" % (self.pPath + fName, dstF)):
    FFipXT(self, "File copied to:\n\n%s" % dstF, title=title)
   else:
    FFdw58(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstPath), title=title)
  else:
   FFdw58(self, "No Poster/PIcon found", title=title)
 def VVFrce(self):
  self.session.openWithCallback(self.VV8Nqe, BF(CClYaF, VV1gDA="movies", VV1pbK=CFG.MovieDownloadPath.getValue()))
 def VV8Nqe(self, path):
  if path:
   title = "Set Selected Picture as a Poster for a Local Media"
   VV1wIO, subj, desc, fName, VVfbmn = self.VVGape[self.VVBGsZ]
   if fName:
    srcF = self.pPath + fName
    dstF = "%s%s" % (os.path.splitext(path)[0], os.path.splitext(srcF)[1])
    if FFpwZS("cp -f '%s' '%s'" % (srcF, dstF)):
     FFipXT(self, "File copied to:\n\n%s" % dstF, title=title)
    else:
     FFdw58(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (fName, dstF), title=title)
    CCG2jh.VVp7lg(dstF)
   else:
    FFdw58(self, "No Poster/PIcon found", title=title)
 @FFOAKH("Calculating ...")
 def VVkieu(self):
  txt = "\n"
  totSize = 0
  for path in ("Live/", "VOD/", "Series/", "M3U/"):
   path = "%sPosters/%s" % (FF0cqc(), path)
   size = "Dir. not found !"
   if VVmJwX(path):
    size = FFTKR0("find '%s' ! -type d -print0 2> /dev/null | xargs -0 ls -lsa 2> /dev/null | awk '{sum+=$6;} END {print sum;}'" % path)
    if size.isdigit():
     size = int(size)
     totSize += size
     size = CClYaF.VV99gM(size)
   txt += "%s\n    %s\n\n" % (FFjt5L(path, VVFuwR), size)
  mainPath = "%sPosters" % FF0cqc()
  totFiles = FFTKR0("find '%s' ! -type d | wc -l" % mainPath)
  totFTxt = " (%s file%s)" % (totFiles, FFcacr(int(totFiles))) if totFiles.isdigit() else ""
  txt += "%s\n    %s\n\n" % (FFjt5L("Total space used by Posters/PIcons%s:" % totFTxt, VV1fx4), CClYaF.VV99gM(totSize))
  mountPath = CClYaF.VVuTcL(mainPath)
  if VVmJwX(mountPath):
   total, used, free, avail, err = CClYaF.VVdlF7(mountPath)
   total, used, free, avail = [CClYaF.VV99gM(x) for x in (total, used, free, avail)]
   txt += "%s\n" % SEP
   txt += FFjt5L("Media Space:\n", VVIH76)
   txt += "    Media Path\t: %s\n" % FFjt5L(mountPath, VVZtfx)
   txt += "    Total Size\t: %s\n" % total
   txt += "    Used Size\t: %s\n" % used
   txt += "    Free Size\t: %s\n" % free
   if free != avail: txt += "    Available\t: %s" % avail
  FF4lCP(self, txt, title="Cache Used Size", height=1000)
class CCG2jh(Screen, CCsyCY):
 def __init__(self, session, title, lst):
  self.skin, self.VVfOli = FFiNEe(VVpLGo, 1870, 1030, 50, 20, 20, "#06112233", "#06112233", 50, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":2, "cols":6, "picR":0.90, "lblR":0.10, "w1R":0.85, "w2R":0.15, "gapX":30, "gapY":30, "percBar":1})
  self.session   = session
  self.Title    = title
  self.VVGape    = lst
  self.VV295u   = -1
  FFZMxC(self, self.Title)
  CCsyCY.__init__(self)
  FFBep1(self,
  {
   "ok" : self.VVfmN9 ,
   "cancel": self.close   ,
   "menu" : self.VV1ER9,
   "info" : self.VVO0RC
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  FFWgBS(self)
  self.VVCHVq(cursor="swap", sbSldBg="#00777777")
  for i in range(4):
   FFZ0AC(self["myPiconInf%s" % i], "#0a001122")
  self.VVjIcM()
 def VVjIcM(self):
  self.VVbKuB = len(self.VVGape)
  self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
  self.VVLckG(True)
  self.VVMypQ(VVwb7n=False)
 def VVe4Ro(self):
  self.VVaFRk()
  f1, f2 = self.VVS7BN()
  mPath = CFG.MovieDownloadPath.getValue()
  row = col = 0
  for ndx in range(f1, f2):
   path, movie, poster = self.VVGape[ndx]
   movie = os.path.join(mPath, path, movie)
   poster = os.path.join(mPath, path, poster)
   pic, lbl = self.VVwbpA(row, col)
   self.VVExY8(lbl, os.path.splitext(os.path.basename(movie))[0])
   self.VVaJVd(ndx, row, col, pic, poster)
   d = CCzUSd.VV0NUN(CCzUSd.VVc5Po(FFbhOc(movie)))
   if d:
    self.VV3wsR(row, col, int(round(100.0 * d["pos"] / d["dur"])))
   self.VVcG7K = row
   self.VVGCBk = col
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
 def VVAoNk(self, ndx=-1):
  if ndx == -1:
   ndx = self.VVBGsZ
  path, movie, poster = self.VVGape[ndx]
  path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
  path = os.path.join(path, movie)
  if poster:
   poster = os.path.join(os.path.dirname(path), poster)
  return path, poster
 def VVHvUS(self):
  path, poster = self.VVAoNk()
  self.VVkhlj(os.path.splitext(os.path.basename(path))[0], os.path.dirname(path))
 def VV1ER9(self):
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  cur = False
  if fPath:
   for ndx, (path, movie, poster) in enumerate(self.VVGape):
    if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
     cur = True
     break
  path, poster = self.VVAoNk()
  c1, c2, c3 = VVJEMb, VVZtfx , VVFuwR
  VV3wat = []
  VV3wat.append((c1 + "Find a movie ..."   , "VVIwcG"  ))
  VV3wat.append(FFsLU5("Go to Current Movie" , "VVMypQ", cur, c1 ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Add Selected Movie to Bouquet", "VV9nO90"))
  VV3wat.append(("Add All Movies to Bouquet" , "VV9nO91"))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Show Poster" , "VVIENY" , poster))
  VV3wat.append(FFsLU5("Export Poster", "VV9oi3", poster))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Change Poster (locate manually) ..." , "VVTwlc"  ))
  VV3wat.append((c3 + "Change Poster (Download)"   , "VVmM4L" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Help (Keys)", "help"))
  FFLFTC(self, self.VVnk8m, width=900, title=self.Title, VV3wat=VV3wat)
 def VVnk8m(self, item=None):
  if item is not None:
   if   item == "VVIwcG"  : self.VVIwcG()
   elif item == "VVMypQ"    : self.VVMypQ()
   elif item == "VV9nO90": self.VV9nO9(False)
   elif item == "VV9nO91": self.VV9nO9(True)
   elif item == "VV9oi3"    : self.VV9oi3()
   elif item == "VVIENY"    : self.VVIENY()
   elif item == "VVTwlc"  : self.VVTwlc()
   elif item == "VVmM4L"  : self.VVmM4L()
   elif item == "help"      : FFw2rR(self, "_help_movBr", "Movies Browser (Keys)")
 def VVIwcG(self):
  VVAkuK = []
  for ndx, (path, movie, poster) in enumerate(self.VVGape):
   path = os.path.join(CFG.MovieDownloadPath.getValue(), path)
   VVAkuK.append((os.path.splitext(movie)[0], path, str(ndx)))
  VVAkuK.sort(key=lambda x: x[0].lower())
  VVu1YM = ("Select" , self.VV4pgN, [])
  header  = ("Name" , "Path", "NDX.")
  widths  = (60  , 40 , 0  )
  FFUQ0v(self, None, title="Select Movie", width=1800, height=1000, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVSLOq=CFG.lastFindMovie)
 def VV4pgN(self, VV6A99, title, txt, colList):
  self.VVdLxd(int(colList[2].strip()))
  VV6A99.cancel()
 def VVMypQ(self, VVwb7n=True):
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  if fPath:
   for ndx, (path, movie, poster) in enumerate(self.VVGape):
    if fPath == os.path.join(CFG.MovieDownloadPath.getValue(), path, movie):
     self.VVdLxd(ndx)
     return
  if VVwb7n:
   FF28n1(self, "Not found", 1000)
 def VVfmN9(self):
  self.VV295u = self.VVBGsZ
  VVPxk5 = self.VVgxBr()
  CCqWM2.VVHc02(self.session, VVdxwH=False, VVaHNe=VVPxk5, zapFnc=self.VVgxBr, cbFnc=self.VV2Akw)
 def VV2Akw(self):
  Len = len(self.VVGape)
  mPath = CFG.MovieDownloadPath.getValue()
  self.VVGape = [(path, movie, poster) for path, movie, poster in self.VVGape if FFCyVu(os.path.join(mPath, path, movie))]
  if Len != len(self.VVGape):
   self.VVjIcM()
  else:
   self.VVdLxd(self.VV295u)
 def VVgxBr(self, val=0):
  ndx = self.VV295u + val
  if   ndx > self.VVbKuB -1: ndx = 0
  elif ndx < 0     : ndx = self.VVbKuB - 1
  self.VV295u = ndx
  path, poster = self.VVAoNk(ndx)
  VVPxk5 = "%s:%s%s" % (CFG.iptvAddToBouquetRefType.getValue(), "0:" * 9, path)
  return VVPxk5
 def VVO0RC(self):
  lst = []
  path, poster = self.VVAoNk()
  size = FFXhoc(path)
  lst.append(("Media Path", path))
  if size > -1: lst.append(("Media Size", CClYaF.VV99gM(size)))
  lst.append(("Poster Path", poster))
  size = FFXhoc(poster)
  if size > -1: lst.append(("Poster Size", CClYaF.VV99gM(size)))
  d = CCzUSd.VV0NUN(CCzUSd.VVc5Po(FFbhOc(path)))
  if d:
   lst.append(("Duration", FFFHEC(d["dur"] / 90000.0)))
   lst.append(("Watched", FFTS4w(d["w"])))
   lst.append(("Resume Position", FFFHEC(d["pos"] / 90000.0)))
  bg="#11001122"
  FFUQ0v(self, None, title="Media File Information", VVGape=lst, VV3cHe=(20, 80), VVwdmN=30, VVKDPJ=1, VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVLf28=0)
 def VVIENY(self):
  path, poster = self.VVAoNk()
  if FFCyVu(poster): CCf8zb.VVjnMn(self, poster)
  else     : FF28n1(self, "No Poster", 1500)
 def VV9oi3(self):
  title = "Copy Poster"
  path, poster = self.VVAoNk()
  if poster:
   dstPath = FFriZ7()
   dstF = os.path.join(dstPath, os.path.basename(poster))
   if FFpwZS("cp -f '%s' '%s'" % (poster, dstF)):
    FFipXT(self, "File copied to:\n\n%s" % dstF, title=title)
   else:
    FFdw58(self, "Cannot copy the file:\n%s\n\nTo:\n%s" % (poster, dstPath), title=title)
  else:
   FF28n1(self, "No Poster", 1500)
 def VVTwlc(self):
  path, poster = self.VVAoNk()
  sDir = FFoWxR(os.path.dirname(path))
  self.session.openWithCallback(BF(self.VVlrDJ, sDir, path), BF(CClYaF, VV1gDA="poster", VV1pbK=sDir))
 def VVfSsn(self, VV7tND, txt, ref, ndx):
  CCf8zb.VVjnMn(self, VVPq2Z=ref)
 def VVlrDJ(self, sDir, path, pPath=None):
  if pPath:
   newPath = sDir + os.path.splitext(os.path.basename(path))[0] + os.path.splitext(pPath)[1].lower()
   if   pPath == newPath : FF28n1(self, "No change", 1000)
   elif FFCyVu(newPath): FFRMYv(self, BF(self.VV6MfM, pPath, newPath), "Overwrite exiting file ?\n\n%s" % os.path.basename(newPath), title="Change Poster")
   else     : self.VV6MfM(pPath, newPath)
 def VV6MfM(self, pPath, newPath):
  if FFpwZS("cp -f '%s' '%s'" % (pPath, newPath)):
   path, movie, poster = self.VVGape[self.VVBGsZ]
   self.VVGape[self.VVBGsZ] = (path, movie, os.path.basename(newPath))
   FFimQ3(self, BF(self.VVLckG, True))
   CCG2jh.VVp7lg(newPath)
  else:
   FF28n1(self, "Cannot copy file.", 1000)
 def VVmM4L(self):
  path, poster = self.VVAoNk()
  evName = os.path.splitext(os.path.basename(path))[0]
  dstP = os.path.splitext(path)[0] + ".jpg"
  self.session.openWithCallback(BF(self.VVHrM7, dstP), CChtNF, dstP=dstP, evName=evName)
 def VVHrM7(self, dstP, pPath=None):
  if pPath:
   path, movie, poster = self.VVGape[self.VVBGsZ]
   self.VVGape[self.VVBGsZ] = (path, movie, os.path.basename(dstP))
   FFimQ3(self, BF(self.VVLckG, True))
 def VV9nO9(self, isAll):
  pathLst = []
  if isAll:
   for ndx, (path, movie, poster) in enumerate(self.VVGape):
    path = os.path.join(CFG.MovieDownloadPath.getValue(), path, movie)
    pathLst.append(path)
  else:
   path, poster = self.VVAoNk()
   pathLst = [path]
  picker = CCMvE7(self, self, "Add to Bouquet", BF(self.VVZXrb, pathLst))
 def VVZXrb(self, pathLst):
  return CCMvE7.VVvoK9(pathLst)
 @staticmethod
 def VVp7lg(path):
  if path.endswith(".png"):
   fileNoExt = path[:-4]
   jpgF = fileNoExt + ".jpg"
   if FFCyVu(jpgF):
    c = 1
    newF = "%s_%d.jpg" % (fileNoExt, c)
    while FFCyVu(newF):
     c += 1
     newF = "%s_%d.jpg" % (fileNoExt, c)
    FFpwZS("mv -f '%s' '%s'" % (jpgF, newF))
 @staticmethod
 @FFOAKH()
 def VV7hTj(SELF):
  eLst = CCHmnm.VViatp()["mov"]
  mPath = CFG.MovieDownloadPath.getValue()
  lst = []
  for (Dir, dirs, files) in os.walk(mPath):
   for f in files:
    if os.path.splitext(f)[1].lstrip(".").lower() in eLst:
     path = os.path.join(Dir, f)
     poster = ""
     for ext in ("jpg", "png"):
      pic = "%s.%s" % (os.path.splitext(path)[0], ext)
      if FFCyVu(pic):
       poster = os.path.basename(pic)
       break
     lst.append((os.path.dirname(path).replace(mPath, ""), os.path.basename(path), poster))
  title = "Movies Browser"
  lst.sort(key=lambda x: x[1].lower())
  if lst: SELF.session.open(CCG2jh, title, lst)
  else  : FFdw58(SELF, "No movies found in:\n\n%s\n\nYou can change the path from settings." % mPath, title=title)
class CCjThi(Screen, CCsyCY):
 def __init__(self, session, bName, lst):
  self.skin, self.VVfOli = FFiNEe(VVpLGo, 1750, 1040, 50, 3, 3, "#22003344", "#22001122", 45, VVeFSs=40, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":4, "cols":6, "picR":0.75, "lblR":0.25, "w1R":0.80, "w2R":0.20, "gapX":15, "gapY":15})
  self.session   = session
  self.Title    = bName
  self.VVGape    = lst
  self.pPath    = CCafIt.VVjkKT()
  self.VVbKuB   = 0
  self.VVpQCY  = True
  self.VVyzvh  = False
  FFZMxC(self, self.Title)
  FFRLNq(self["keyRed"] , "OK = Zap")
  FFRLNq(self["keyGreen"] , "Current Channel")
  FFRLNq(self["keyBlue"] , "Preview")
  CCsyCY.__init__(self, CFG.transpColorChannels)
  FFBep1(self,
  {
   "ok"  : BF(self.VVGQg3, True),
   "cancel" : self.VVfXzC      ,
   "menu"  : self.VVLbBy   ,
   "info"  : self.VVU4wr    ,
   "red"  : self.VVfXzC      ,
   "green"  : BF(self.VVUesd, True)  ,
   "blue"  : BF(self.VVGQg3, False)
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  if self.VVpQCY:
   force = True
   self.VVpQCY = False
   FF6W0I(self)
   FFWgBS(self)
   FFZ0AC(self["keyRed"], "#0a333333")
   self.VVCHVq()
  elif self.VVyzvh:
   self.VVyzvh = False
   return
  else:
   pName, srvLst = CCjThi.VVdAdw()
   if srvLst and not srvLst == self.VVGape:
    force = True
    self.Title = pName
    self["myTitle"].setText("  %s  " % self.Title)
    self.VVGape = srvLst
   else:
    force = False
  self.VVbKuB = len(self.VVGape)
  self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
  self.VVLckG(force)
  self.VVUesd()
 def VVLbBy(self):
  VV3wat = []
  VV3wat.append(("Find Name (sorted list)" , "findSrt"  ))
  VV3wat.append(("Find Name (as listed)" , "findNoSrt"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Change Background Color" , "VVA2WD"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Help (Keys)", "help"))
  FFLFTC(self, self.VV2vBb, title="Options", VV3wat=VV3wat)
 def VV2vBb(self, item=None):
  if item:
   if   item == "findSrt"    : self.VViYJb(True)
   elif item == "findNoSrt"   : self.VViYJb(False)
   elif item == "VVA2WD": self.VVA2WD()
   elif item == "help"     : FFw2rR(self, "_help_srvcBr", "Services Browser (Keys)")
 def VViYJb(self, isSort):
  VV3wat = []
  for ndx, item in enumerate(self.VVGape):
   VV3wat.append((item[1], ndx))
  if isSort:
   VV3wat.sort(key=lambda x: x[0].lower())
  FFLFTC(self, self.VVl51x, title="Find Name", VV3wat=VV3wat, width=1300)
 def VVl51x(self, ndx=None):
  if ndx is not None:
   self.VVdLxd(ndx)
 def VVU4wr(self):
  VVPxk5, VV1wIO = self.VVGape[self.VVBGsZ]
  txt  = "Service Name\t: %s\n" % VV1wIO
  txt += "Referrence\t: %s" % VVPxk5
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvVii, params=(VVPxk5, VV1wIO, txt))
  self.VVyzvh = True
 def VVfXzC(self):
  if self.shown: self.close()
  else   : self.show()
 def VVGQg3(self, isExit):
  try:
   if self.shown:
    chUrl = self.VVGape[self.VVBGsZ][0]
    if isExit:
     self.VV4kOk(chUrl)
    else:
     FFnfiC(self.session, chUrl)
     FFSqRh(self, "Cancel to go back")
   else:
    self.show()
  except:
   pass
 @FFOAKH("Starting ...")
 def VV4kOk(self, chUrl):
  FFnfiC(self.session, chUrl, VV9rup=True)
  self.close()
 def VVUesd(self, VVwb7n=False):
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  err = ""
  if serv:
   curRef = serv.toString()
   for ndx, item in enumerate(self.VVGape):
    if curRef == item[0]:
     self.VVdLxd(ndx)
     return ndx
   else:
    err = "Not found"
  else:
   err = "No active service"
  if VVwb7n and err:
   FF28n1(self, err, 500)
  return -1
 def VVe4Ro(self):
  self.VVaFRk()
  f1, f2 = self.VVS7BN()
  row = col = 0
  for ndx in range(f1, f2):
   ref, name = self.VVGape[ndx]
   pic, lbl = self.VVwbpA(row, col)
   self.VVExY8(lbl, name)
   path = CCafIt.VVXjFJ(self.pPath, ref, name)
   self.VVaJVd(ndx, row, col, pic, path)
   self.VVcG7K = row
   self.VVGCBk = col
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
 def VVHvUS(self):
  ref, name = self.VVGape[self.VVBGsZ]
  span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", ref)
  if span: ref = span.group(1)
  self.VVkhlj(name, ref)
 @staticmethod
 def VVZhZh():
  VVPxk5 = refName = rootRef = rootName = ""
  inBouquet = False
  VVCy6c = InfoBar.instance
  if VVCy6c:
   csel = VVCy6c.servicelist
   if csel:
    currSel  = csel.getCurrentSelection()
    rootRef  = csel.getRoot().toString()
    VVPxk5  = currSel.toString()
    rootName = FFCjjv(rootRef)
    refName  = FFCjjv(VVPxk5)
    inBouquet = csel.inBouquet()
    if   inBouquet        : rootSrc = "Favourites"
    elif "(satellitePosition == " in rootRef : rootSrc = "Satellites"
    elif "name:Current transponder" in rootRef : rootSrc = "Transponder"
    elif "(provider == " in rootRef    : rootSrc = "Provider"
    else          : rootSrc = "ALL"
  return VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc
 @staticmethod
 def VVdAdw(VVPxk5="", refName="", rootRef="", rootName="", inBouquet=False):
  VVPxk5, rootRef = VVPxk5.strip(), rootRef.strip()
  if not VVPxk5 and not rootRef:
   VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc = CCjThi.VVZhZh()
   VVPxk5, rootRef = VVPxk5.strip(), rootRef.strip()
  pName, srvLst = "", []
  if VVPxk5 and rootRef:
   if   VVPxk5.startswith("1:7:") : ref, name = VVPxk5, refName
   elif rootRef.startswith("1:7:") : ref, name = rootRef, rootName
   else       : return "", []
   srvLst = FFZcDI(eServiceReference(ref))
   pName = name or "No-Name"
   if not inBouquet: srvLst.sort(key=lambda x: x[1].lower())
  else:
   srvLst = CCMvE7.VVqZTI()
   pName  = CCMvE7.VVCWrE() or "ALL (Group)"
  return pName, srvLst
 @staticmethod
 def VVJNjY(SELF, cbFnc=None):
  pName, srvLst = CCjThi.VVdAdw()
  if srvLst: SELF.session.openWithCallback(cbFnc, CCjThi, pName, srvLst)
  else  : FFdw58(SELF, "No services found in:\n\n%s" % pName, title="Channels Browser")
class CCFZr4(Screen, CCsyCY):
 def __init__(self, session, title, lst):
  self.skin, self.VVfOli = FFiNEe(VVpLGo, 1600, 1000, 50, 20, 20, "#2200202a", "#11202020", 45, VVeFSs=40, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":4, "cols":5, "picR":0.65, "lblR":0.35, "w1R":0.85, "w2R":0.15, "bGap":8, "gapX":25, "gapY":25, "mGap":8, "lblTr":1, "picBgTr":1})
  self.session   = session
  self.Title    = title
  self.VVGape    = CCFZr4.VV9Oyz(lst)
  self.VVbKuB   = 0
  self.useOrigSize  = False
  self.firstTime   = True
  FFZMxC(self, self.Title)
  FFRLNq(self["keyRed"] , "Remove Plugins")
  FFRLNq(self["keyGreen"] , "Download New Plugins")
  FFRLNq(self["keyYellow"], "Package Info.")
  FFRLNq(self["keyBlue"] , "Plugins Group")
  CCsyCY.__init__(self)
  FFBep1(self,
  {
   "ok"  : self.VVTZ6U   ,
   "cancel" : self.close    ,
   "menu"  : self.VVicIL ,
   "info"  : self.VVfIeu  ,
   "red"  : BF(self.VVAGF7, False),
   "green"  : BF(self.VVAGF7, True),
   "yellow" : self.VVtLaF ,
   "blue"  : self.VV0oxQ
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  FFWgBS(self)
  self.VVCHVq(shade="yes", cursor="")
  self.VVjkVK([("", "#22000a0b")] * 4)
  self.VV92tg()
 def VV92tg(self):
  self.VVbKuB = len(self.VVGape)
  self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
  self.VVLckG(True)
 def VVFnIO(self):
  lst = CCFZr4.VVEjtP(PluginDescriptor.WHERE_PLUGINMENU)
  if lst:
   lst = CCFZr4.VV9Oyz(lst)
   if lst != self.VVGape:
    self.VVGape = lst
    self.VV92tg()
  else:
   self.close()
 def VVAGF7(self, isInstall):
  FF28n1(self, "Processing ...")
  try:
   from Screens.PluginBrowser import PluginDownloadBrowser as pb
   if isInstall:
    self.session.openWithCallback(self.VVFnIO, pb, pb.DOWNLOAD, self.firstTime)
    self.firstTime = False
   else:
    self.session.openWithCallback(self.VVFnIO, pb, pb.REMOVE)
  except:
   try:
    from Screens.PluginBrowser import PluginAction as pa
    if hasattr(pa, "DOWNLOAD") and hasattr(pa, "REMOVE"):
     self.session.openWithCallback(self.VVFnIO, pa, pa.DOWNLOAD if isInstall else pa.REMOVE)
    else:
     self.session.openWithCallback(self.VVFnIO, pa, pa.MODE_INSTALL if isInstall else pa.MODE_REMOVE)
   except:
    try:
     from Plugins.SystemPlugins.SoftwareManager.plugin import PluginManager as pb
     self.session.openWithCallback(self.VVFnIO, pb)
    except Exception as e:
     FFdw58(self, 'Cannot open "Extensions Management" !', title=self.Title)
  FF28n1(self)
 def VVTZ6U(self):
  name, desc = self.VVxIzw(self.VVBGsZ)
  if name == VVh9hj and "VVaWs8" in globals() and VVaWs8:
   FF28n1(self, "Already running.", 500)
  else:
   try:
    p = self.VVGape[self.VVBGsZ]
    p(session=self.session)
   except:
    FFdw58(self, "Cannot start from here !", title="Error in : %s" % name)
 def VVfIeu(self):
  def VVJi7Q(key, val):
   return key + "\t: " + str(val) + "\n"
  p = self.VVGape[self.VVBGsZ]
  txt = ""
  try:
   txt += VVJi7Q("Path"  , p.path  )
   txt += VVJi7Q("Description" , p.description )
   txt += VVJi7Q("Icon"  , p.iconstr  )
   txt += VVJi7Q("Wakeup Fnc" , p.wakeupfnc )
   txt += VVJi7Q("NeedsRestart", p.needsRestart)
   txt += VVJi7Q("Internal" , p.internal )
   txt += VVJi7Q("Weight"  , p.weight  )
  except:
   pass
  name, desc = self.VVxIzw(self.VVBGsZ)
  if txt : FF4lCP(self, txt, title=name)
  else : FFdw58(self, "Could not read plugin info.", title=name)
 @FFOAKH()
 def VVtLaF(self):
  p = self.VVGape[self.VVBGsZ]
  name, desc = self.VVxIzw(self.VVBGsZ)
  path = p.path
  pkg, err = CCeSkW.VVV8mM(path)
  if pkg : CCeSkW.VVLFsP(self, pkg, name)
  else : FFjADj(self, err, 1000)
 def VVicIL(self):
  path = self.VVGape[self.VVBGsZ].path
  VV3wat = []
  txt = "Open Plugin Path in File Manager"
  VV3wat.append(FFsLU5("Open Plugin Path in File Manager", "inFileMan", VVmJwX(path)))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Use Original Icon Size", "setOrigSize"))
  FFLFTC(self, self.VVVZEm, title="Plugins Group", VV3wat=VV3wat)
 def VVVZEm(self, item=None):
  if item:
   if item == "inFileMan":
    self.session.open(CClYaF, mode=CClYaF.VVQTL1, VV1pbK=self.VVGape[self.VVBGsZ].path)
   elif item == "setOrigSize":
    self.useOrigSize = True
    self.VVLckG(True)
 def VV0oxQ(self):
  FFLFTC(self, self.VVOvCr, title="Plugins Group", VV3wat=CCFZr4.VVq7at(True, True), width=700, VVU8mZ=True)
 def VVOvCr(self, item=None):
  if item:
   title, where, ndx = item
   self["myTitle"].setText("  %s (%s)" % (self.Title, title))
   lst = CCFZr4.VVEjtP(where)
   if lst:
    self.VVGape = CCFZr4.VV9Oyz(lst)
    self.VVSmMg = self.curCol = self.curRow = self.VVBGsZ = 0
    self.VVbKuB = len(self.VVGape)
    self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
    self.VVLckG(True)
   else:
    FFdw58(self, "Not found !", title=self.Title)
 def VVe4Ro(self):
  self.VVaFRk()
  f1, f2 = self.VVS7BN()
  row = col = 0
  for ndx in range(f1, f2):
   name, desc = self.VVxIzw(ndx)
   pic, lbl = self.VVwbpA(row, col)
   self.VVExY8(lbl, name)
   iconOk = False
   pngSz = None
   if self.VVGape[ndx].icon:
    try:
     pngSz = self.VVGape[ndx].icon.size()
     pic.instance.setScale(1)
     pic.instance.setPixmap(self.VVGape[ndx].icon)
     pic.show()
     iconOk = True
    except:
     pass
   if not iconOk:
    icons = []
    path = self.VVGape[ndx].path
    if VVmJwX(path):
     for f in ("iconfhd.png", "iconhd.png", "icon.png"):
      icons.append(os.path.join(path, f))
    icons.append(resolveFilename(SCOPE_CURRENT_SKIN, "icons/plugin.png"))
    icons.append(VVIp2p + "plugin.png")
    for path in icons:
     pixMap = FFBFPY(pic, path)
     if pixMap:
      pngSz = pixMap.size()
      break
   if self.useOrigSize and pngSz:
    try:
     boxSz = pic.instance.size()
     VVzIFK = pic.instance.position()
     pngW, pngH = pngSz.width(), pngSz.height()
     boxW, boxH = boxSz.width(), boxSz.height()
     if boxW > pngW and boxH > pngH:
      pic.instance.resize(pngSz)
      pic.instance.move(ePoint(VVzIFK.x() + (boxW - pngW) // 2, VVzIFK.y() + (boxH - pngH) // 2))
    except:
     pass
   self.VVcG7K = row
   self.VVGCBk = col
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
 def VVxIzw(self, ndx):
  name = str(self.VVGape[ndx].name).strip()
  desc = str(self.VVGape[ndx].description).strip().replace("\n", " >> ")
  if not name or name == "Plugin":
   name = desc or FFxtW5(self.VVGape[ndx].path)
  return name, desc
 def VVHvUS(self):
  name, desc = self.VVxIzw(self.VVBGsZ)
  self.VVkhlj(name, desc)
 @staticmethod
 def VVq7at(isMenu=False, addTot=False):
  lst =[("Plugin Menu"   , PluginDescriptor.WHERE_PLUGINMENU    )
   , ("Audio Menu"    , PluginDescriptor.WHERE_AUDIOMENU    )
   , ("Auto-Start Menu"  , PluginDescriptor.WHERE_AUTOSTART    )
   , ("Channel Context Menu" , PluginDescriptor.WHERE_CHANNEL_CONTEXT_MENU )
   , ("Event Info"    , PluginDescriptor.WHERE_EVENTINFO    )
   , ("Extensions Menu"  , PluginDescriptor.WHERE_EXTENSIONSMENU   )
   , ("File Scan"    , PluginDescriptor.WHERE_FILESCAN    )
   , ("Main Menu"    , PluginDescriptor.WHERE_MAINMENU    )
   , ("Menu"     , PluginDescriptor.WHERE_MENU     )
   , ("Movie List"    , PluginDescriptor.WHERE_MOVIELIST    )
   , ("Network Configuration" , PluginDescriptor.WHERE_NETWORKCONFIG_READ  )
   , ("Network Setup"   , PluginDescriptor.WHERE_NETWORKSETUP   )
   , ("Session Start"   , PluginDescriptor.WHERE_SESSIONSTART   )
   , ("Software Manager"  , PluginDescriptor.WHERE_SOFTWAREMANAGER  )
   , ("Teletext"    , PluginDescriptor.WHERE_TELETEXT    )
   , ("Wizard"     , PluginDescriptor.WHERE_WIZARD     )]
  if addTot:
   for ndx, item in enumerate(lst):
    tot = len(CCFZr4.VVEjtP(item[1]))
    lst[ndx] = ("%s   %s(%d)" % (lst[ndx][0], VVA4XU, tot), lst[ndx][1])
  if isMenu: lst.insert(1, VVAL3j)
  else  : lst.sort(key=lambda x: x[0].lower())
  return lst
 @staticmethod
 def VVEjtP(where):
  try: return iPlugins.getPlugins(where)
  except: return []
 @staticmethod
 def VV9Oyz(lst):
  tmp = []
  for item in lst:
   name = str(item.name).strip()
   if not name or name == "Plugin":
    name = str(item.description).strip() or FFxtW5(item.path)
   tmp.append((name, item))
  tmp.sort(key=lambda x: x[0].lower())
  lst = []
  for nm, obj in tmp:
   lst.append(obj)
  return lst
 @staticmethod
 def VVsCNi(session):
  title = "Plugins Browser"
  lst = CCFZr4.VVEjtP(PluginDescriptor.WHERE_PLUGINMENU)
  if lst : session.open(CCFZr4, title, lst)
  else : FFzcnp(session, "No plugins found !", title=title)
class CCRlkm(Screen, CCsyCY):
 VV9Ij0  = "Custom Menu"
 VVPNMN = "ajpanel_menu.xml"
 VVJK42  = {}
 def __init__(self, session, subFile="", subName="", picpath="", startItem=0):
  self.session  = session
  self.VVPxk5Patt = r"^((?:[A-Fa-f0-9]+(?::|_)){9}(?:[A-Fa-f0-9]+))(.*)"
  self.startItem  = startItem
  self.def_cursor_fg = "#11ffccaa"
  self.def_cursor_bg = "#11442244"
  self.def_title_fg = "#00ffffaa"
  self.def_title_bg = "#0cff0011"
  self.def_body_bg = "#0c001122"
  self.moveCM_data = None
  self.moveCM_win  = None
  self.VVUKLC = {"title": self.VV9Ij0, "mode": "list", "width": -1, "height": -1, "fg": "#00ffffff", "bg": self.def_body_bg, "font_size": 30, "align_items": 0, "title_fg": self.def_title_fg, "title_font_size": 50, "cursor_fg": self.def_cursor_fg, "cursor_bg": self.def_cursor_bg, "line_gap": 0.15, "box_gap": 0, "picpath": picpath, "lst": []}
  for k in ("title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg", "shade", "cursor"):
   self.VVUKLC[k] = ""
  if subFile:
   self.filePath = subFile
  else:
   self.filePath = CCRlkm.VVGHsh()
   CCRlkm.VVJK42 = {}
  self.subName = subName
  self.err  = self.VVCW1G(subName)
  self.Title  = self.VVUKLC["title"]
  self.isGrid, self.isStretch, cols, rows = self.VV2KRi(self.VVUKLC["mode"])
  titleBg = self.VVUKLC["title_bg"] or self.def_title_bg
  bodyBg = self.VVUKLC["bg"] if self.VVRmDl(self.VVUKLC["bg"]) else self.def_body_bg
  cursC = self.VVUKLC["cursor"] if self.VVRmDl(self.VVUKLC["cursor"]) else ""
  bGap = self.VVUKLC["box_gap"]
  lblFR = FFjFSv(self.VVUKLC["font_size"], 10, 50, 0.4, 0.8)
  w, h, VVllEU, VVSZWt, VVpeQE, textFg, VVgbF2 = self.VVUKLC["width"], self.VVUKLC["height"], self.VVUKLC["title_font_size"], 15, 15, self.VVUKLC["fg"], self.VVUKLC["font_size"]
  if self.isGrid : self.skin, self.VVfOli = FFiNEe(VVpLGo, w, h, VVllEU, VVSZWt, VVpeQE, titleBg, bodyBg, VVgbF2, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":rows, "cols":cols, "picR":0.65, "lblR":0.35, "lblFR":lblFR, "w1R":0.80, "w2R":0.20, "trC":"", "bGap":bGap, "gapX":22, "gapY":22, "mGap":15, "lblFg":textFg, "lblTr":1, "picBgTr":1, "upSBar":True})
  else   : self.skin, self.VVfOli = FFiNEe(VVWp3I   , w, h, VVllEU, VVSZWt, VVpeQE, titleBg, bodyBg, VVgbF2, VV0Ay7=2, VVptue=self.VVUKLC["line_gap"])
  self.VVGape = self.VVoCYy() if self.VVUKLC["lst"] else []
  FFZMxC(self, title=self.Title)
  if self.isGrid:
   CCsyCY.__init__(self)
  else:
   self["myMenu"] = MenuList(self.VVGape, True, eListboxPythonMultiContent)
   self["myMenu"].l.setFont(0, gFont(VVNhAq, self.VVfOli["VVgbF2"]))
   FFHlAU(self, {})
  FFBep1(self,
  {
   "ok" : self.VVPr1F ,
   "cancel": self.cancel ,
   "menu" : self.VVWI8i ,
   "info" : self.VVN5Mh
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  if self.err:
   CCwnHL.VVBfGR(self, os.path.basename(self.filePath), self.err, title=self.VVUKLC["title"])
   self.close()
   return
  space = "  "
  if self.isGrid:
   self.VVCHVq(shade=self.VVUKLC["shade"], cursor=self.VVUKLC["cursor"])
   self.VVbKuB = len(self.VVGape)
   self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
   self.VVLckG(True)
   if self.startItem > 0:
    self.VVdLxd(min(self.startItem, len(self.VVGape) - 1))
  else:
   offset = {0: 20, 1: 0, 2: -20}.get(self.VVUKLC["align_items"])
   FF2GM8(self, offset=offset)
   if self.VVUKLC["align_items"] == 2:
    obj = self["keyInfo"].instance
    pos = obj.position()
    obj.move(ePoint(10, pos.y()))
    space = str(u"\u2007")
   self["myTitle"].instance.setHAlign(self.VVUKLC["align_items"])
   self["myMenu"].instance.setTransparent(True)
   FFGUI5(self["myMenu"], self.VVUKLC["fg"])
   FF4IPF(self["myMenu"], fg=self.VVUKLC["cursor_fg"], bg=self.VVUKLC["cursor_bg"])
   try:
    self["myMenu"].instance.setHAlign(self.VVUKLC["align_items"])
   except:
    pass
   if self.startItem > 0:
    self["myMenu"].moveToIndex(min(self.startItem, len(self.VVGape) - 1))
  self["myTitle"].setText("%s%s%s" % (space, self.Title, space))
  self.VVBRHT()
 def onExit(self):
  self.VVaQtC()
 def VVBRHT(self):
  wp = CCRlkm.VVY2v0(self["myWP"], self.VVUKLC["bg"])
  if wp: self["myWP"].show()
  else : self["myWP"].hide()
  if not wp:
   FFZ0AC(self["myBody"], self.VVUKLC["bg"] if self.VVRmDl(self.VVUKLC["bg"]) else self.def_body_bg)
  self["myTitle"].instance.setTransparent(False)
  FFGUI5(self["myTitle"], self.VVUKLC["title_fg"] or self.def_title_fg)
  if self.VVUKLC["title_bg"]: FFZ0AC(self["myTitle"], self.VVUKLC["title_bg"])
  else      : self["myTitle"].instance.setTransparent(True)
  self["myTitle"].instance.invalidate()
  if self.isGrid:
   fg1, fg2, bg = "#0088ff88", "#00aaaaaa", "#11000a0b"
   self.VVjkVK(((self.VVUKLC["title1_fg"] or fg1, self.VVUKLC["title1_bg"] or bg)
         , (self.VVUKLC["title2_fg"] or fg2, self.VVUKLC["title2_bg"] or bg)
         , (self.VVUKLC["num_fg"]   or fg2, self.VVUKLC["num_bg"]  or bg)
         , (self.VVUKLC["num_fg"]   or fg2, self.VVUKLC["num_bg"]  or bg) ))
   if wp:
    for i, bg in enumerate((self.VVUKLC["title1_bg"], self.VVUKLC["title2_bg"], self.VVUKLC["num_bg"], self.VVUKLC["num_bg"])):
     self["myPiconInf%d" % i].instance.setTransparent(False if bg else True)
     self["myPiconInf%d" % i].instance.invalidate()
 def VVPr1F(self):
  if self.moveCM_data:
   self.VVxqJP()
  else:
   txt, ref, itemDict = self.VV7JdF()
   fnc = BF(self.VVSTO4, txt, ref, itemDict)
   if "ask" in itemDict:
    FFRMYv(self, fnc, itemDict.get("ask") or "Continue ?", title=txt)
   else:
    fnc()
 def cancel(self):
  if self.moveCM_data:
   self.VVaQtC()
  else:
   FFIFeD()
   self.close()
 def VVWI8i(self, title="Options", mode=0):
  c1, c2, c3, c4, c5 = VVFuwR, VVZtfx, VVJEMb, VVz22H, VVIH76
  isGrid, _, _, _ = self.VV2KRi(self.VVUKLC["mode"])
  VV3wat = []
  if mode == 0:
   if self.moveCM_data:
    VV3wat.append(("Move to current position"    , "movGo" ))
    VV3wat.append(("Cancel Move"       , "movNot" ))
   else:
    VV3wat.append((c1 + "Change Current Icon (File Path)" , "icnFil" ))
    VV3wat.append((c1 + "Change Current Icon (Base64)" , "icnB64" ))
    VV3wat.append((c1 + "Reset Current Icon (to Default)" , "icnDef" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c2 + "Main Title"      , "ttl"  ))
    if isGrid:
     VV3wat.append((c2 + "Information Title-1"   , "ttl1" ))
     VV3wat.append((c2 + "Information Title-2"   , "ttl2" ))
     VV3wat.append((c2 + "Scroll Page Number"   , "pg"  ))
     VV3wat.append(VVAL3j)
     VV3wat.append((c3 + "Shade"      , "gShad" ))
     VV3wat.append((c3 + "Shade Gap"     , "bGap" ))
     VV3wat.append((c3 + "Cursor"      , "gCurs" ))
    else:
     VV3wat.append(VVAL3j)
     VV3wat.append((c3 + "Cursor"      , "lCurs" ))
    VV3wat.append((c3 + "Background Color/Wallpaper"  , "wpMnu" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Clear Cached Picture Files"  , "cach" ))
    VV3wat.append(FFsLU5("Delete Current Item"  , "del"  , isGrid, c4))
    VV3wat.append(VVAL3j)
    VV3wat.append(FFsLU5("Move Selected Item"   , "movGo" , isGrid and not self.subName, c5))
    VV3wat.append((c5 + "Change Current Menu Pictures Path", "pPath" ))
    VV3wat.append(FFsLU5("Insert Menu XML File"   , "impX" , not self.subName, c5))
   FFLFTC(self, self.VVsyNv, width=800, height=1050, title="Options", VV3wat=VV3wat, VVU8mZ=True, VVwltY="#0a111111", VVkxBG="#0a111111")
  else:
   if mode == 2:
    VV3wat.append(("Change Wallpaper (File Path)" , "wpFil" ))
    VV3wat.append(("Change Wallpaper (Base64)" , "wpB64" ))
    VV3wat.append(("Change to a Color"   , "wpCol" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset Wallpaper"   , "wpRm" ))
   elif mode == 3:
    VV3wat.append(("Change Picture (File Path)" , "shFil" ))
    VV3wat.append(("Change Picture (Base64)"  , "shB64" ))
    VV3wat.append(("Change Picture to default" , "shDef" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Remove Shade"   , "shRm" ))
   elif mode == 4:
    VV3wat.append(("Change Picture (File Path))" , "crsFil" ))
    VV3wat.append(("Change Picture (Base64)"  , "crsB64" ))
    VV3wat.append(("Change Color"     , "crsCol" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset to Default"  , "crsRm" ))
   elif mode == 5:
    VV3wat.append(("Change Text Color"   , "lColF" ))
    VV3wat.append(("Change Background Color"  , "lColB" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset to Default"  , "lRm"  ))
   elif mode == 6:
    VV3wat.append(("Change Text Color"   , "ttlF" ))
    VV3wat.append(("Change Background Color"  , "ttlB" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset Text Color"  , "ttlRf" ))
    VV3wat.append((c4 + "Reset Background Color" , "ttlRb" ))
   elif mode == 7:
    VV3wat.append(("Change Text Color"   , "ttl1F" ))
    VV3wat.append(("Change Background Color"  , "ttl1B" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset Text Color"  , "ttl1Rf" ))
    VV3wat.append((c4 + "Reset Background Color" , "ttl1Rb" ))
   elif mode == 8:
    VV3wat.append(("Change Text Color"   , "ttl2F" ))
    VV3wat.append(("Change Background Color"  , "ttl2B" ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset Text Color"  , "ttl2Rf" ))
    VV3wat.append((c4 + "Reset Background Color" , "ttl2Rb" ))
   elif mode == 9:
    VV3wat.append(("Change Text Color"   , "pgF"  ))
    VV3wat.append(("Change Background Color"  , "pgB"  ))
    VV3wat.append(VVAL3j)
    VV3wat.append((c4 + "Reset Text Color"  , "pgRf" ))
    VV3wat.append((c4 + "Reset Background Color" , "pgRb" ))
   elif mode == 100:
    for i in range(0, 110, 10):
     VV3wat.append((str(i)      , "bGap%d" % i))
   else:
    return
   FFLFTC(self, self.VVsyNv, title=title, width=700, VV3wat=VV3wat, VVU8mZ=True, VVwltY="#0a222222", VVkxBG="#0a222222")
 def VVsyNv(self, item=None):
  if item:
   title, ref, ndx = item
   if   ref == "icnFil": self.VVo0po(title, 1, False)
   elif ref == "icnB64": self.VVo0po(title, 1, True )
   elif ref == "icnDef": self.VVLz8f(title, 1, False, "")
   elif ref == "wpMnu" : self.VVWI8i(title, 2)
   elif ref == "wpFil" : self.VVo0po(title, 2, False)
   elif ref == "wpB64" : self.VVo0po(title, 2, True )
   elif ref == "wpCol" : self.VVaWfn(title , 2)
   elif ref == "wpRm" : self.VVLz8f(title, 2, False, "")
   elif ref == "gShad" : self.VVWI8i(title, 3)
   elif ref == "shFil" : self.VVo0po(title, 3, False)
   elif ref == "shB64" : self.VVo0po(title, 3, True )
   elif ref == "shDef" : self.VVLz8f(title, 3, False, "yes")
   elif ref == "shRm" : self.VVLz8f(title, 3, False, "")
   elif ref == "gCurs" : self.VVWI8i(title, 4)
   elif ref == "crsFil": self.VVo0po(title, 4, False)
   elif ref == "crsB64": self.VVo0po(title, 4, True )
   elif ref == "crsCol": self.VVaWfn(title , 4)
   elif ref == "crsRm" : self.VVLz8f(title, 4, False, "")
   elif ref == "lCurs" : self.VVWI8i(title, 5)
   elif ref == "lColF" : self.VVaWfn(title , 50)
   elif ref == "lColB" : self.VVaWfn(title , 51)
   elif ref == "lRm" : self.VVLz8f(title, 51, False, "")
   elif ref == "ttl" : self.VVWI8i(title, 6)
   elif ref == "ttlF" : self.VVaWfn(title , 60)
   elif ref == "ttlB" : self.VVaWfn(title , 61)
   elif ref == "ttlRf" : self.VVLz8f(title, 60, False, "")
   elif ref == "ttlRb" : self.VVLz8f(title, 61, False, "")
   elif ref == "ttl1" : self.VVWI8i(title, 7)
   elif ref == "ttl1F" : self.VVaWfn(title , 70)
   elif ref == "ttl1B" : self.VVaWfn(title , 71)
   elif ref == "ttl1Rf": self.VVLz8f(title, 70, False, "")
   elif ref == "ttl1Rb": self.VVLz8f(title, 71, False, "")
   elif ref == "ttl2" : self.VVWI8i(title, 8)
   elif ref == "ttl2F" : self.VVaWfn(title , 80)
   elif ref == "ttl2B" : self.VVaWfn(title , 81)
   elif ref == "ttl2Rf": self.VVLz8f(title, 80, False, "")
   elif ref == "ttl2Rb": self.VVLz8f(title, 81, False, "")
   elif ref == "pg" : self.VVWI8i(title, 9)
   elif ref == "pgF" : self.VVaWfn(title , 90)
   elif ref == "pgB" : self.VVaWfn(title , 91)
   elif ref == "pgRf" : self.VVLz8f(title, 90, False, "")
   elif ref == "pgRb" : self.VVLz8f(title, 91, False, "")
   elif ref == "bGap"   : self.VVWI8i(title, 100)
   elif ref.startswith("bGap") : self.VVJHn2(title, mainAttr=("box_gap", ref[4:]))
   elif ref == "cach" : FFRMYv(self, self.VV3fXu, "Continue ?", title=title)
   elif ref == "del" : FFRMYv(self, BF(self.VVJHn2, title, delItem=True), "Continue ?", title=title)
   elif ref == "movGo" : self.VVxqJP()
   elif ref == "movNot": self.VVaQtC()
   elif ref == "pPath" : self.session.openWithCallback(BF(self.VV71eW, title), BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=self.VVELQH(), width=1200, height=840, pickTitleBG="#11221122", pickBodyBG="#11221122", VVoCB2="#0a552255"))
   elif ref == "impX" : self.session.openWithCallback(BF(self.VVM6Mb, title), BF(CClYaF, VV1gDA="custMnu", VV1pbK=self.VVZZAW()))
 def VVxqJP(self):
  title = "Move Selected Item"
  curPos = self.VV6pYY()
  if not self.moveCM_data:
   self.moveCM_data = self.VVJHn2(title, getItem=True)
   pos = self.instance.position()
   x, y = pos.x(), pos.y()
   self.moveCM_win = CChMGW.VVNLfa(self.session, "Move cursor and click OK", 35, shadW=2, bg="#00880000", x=x, y=y+20)
   FFIGbj(self.moveCM_win, 0)
  else:
   oldNdx, elem = self.moveCM_data
   newNdx, _ = self.VVJHn2(title, getItem=True)
   if oldNdx == newNdx:
    FF28n1(self, "Try another position", 1000)
   else:
    self.VVaQtC()
    self.VVdLxd(newNdx)
    self.VVJHn2(title, moveItem=(oldNdx, newNdx, elem))
 def VVaQtC(self):
  if self.moveCM_win:
   self.session.deleteDialog(self.moveCM_win)
  self.moveCM_data = self.moveCM_win = None
 def VVELQH(self):
  picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
  if   picP: return picP
  elif xmlP: return xmlP
  else  : return CCRlkm.VVcQrm()
 def VVZZAW(self):
  picP, xmlP = CFG.lastCustMenuPicDir.getValue(), CFG.lastCustMenuXmlDir.getValue()
  if   xmlP: return xmlP
  elif picP: return picP
  else  : return CCRlkm.VVcQrm()
 def VVM6Mb(self, title, path=None):
  if path:
   FFjt1c(CFG.lastCustMenuXmlDir, os.path.dirname(path))
   err = ""
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0 and elem.tag == "ajp_menu":
      mName = FFwW5m(elem, "title") or CCRlkm.VV9Ij0
      icon, err = self.VViDaF(elem, "icon", False)
      if not err:
       fName = os.path.basename(path)
       if not mName:
        err = "No menu name in:\n\n%s" % fName
       elif fName == CCRlkm.VVPNMN or fName in CCRlkm.VVJK42.keys():
        err = "File is already used:\n\n%s" % fName
       else:
        el = iElem.Element("item")
        el.set("name", mName)
        if icon:
         el.set("icon", icon)
        el.text = path
        el.tail = "\n\n\t"
        self.VVJHn2(title, newElem=el)
     else:
      err = "Invalid Custom Menu file.\n\nCannot get menu name."
     break
   except Exception as e:
    err = "Invalid Custom Menu file.\n\n%s" % str(e)
   if err:
    FFdw58(self, err, title=title)
 def VVv79T(self, mode):
  return {  1: "icon"
    , 2: "bg"
    , 3: "shade"
    , 4: "cursor"
    , 50: "cursor_fg" , 51: "cursor_bg"
    , 60: "title_fg" , 61: "title_bg"
    , 70: "title1_fg" , 71: "title1_bg"
    , 80: "title2_fg" , 81: "title2_bg"
    , 90: "num_fg"  , 91: "num_bg"
    }.get(mode, "")
 def VVaWfn(self, title, mode):
  attr  = self.VVv79T(mode)
  isBg  = False if attr.endswith("fg") else True
  fg = self.VVUKLC[attr.replace("bg", "fg")]
  bg = self.VVUKLC[attr.replace("fg", "bg")]
  fg = fg if self.VVRmDl(fg) else "#00ffffff"
  bg = bg if self.VVRmDl(bg) else "#00000040"
  self.session.openWithCallback(BF(self.VVLdXS, title, mode), CC1FS2, defFG=fg, defBG=bg, onlyBG=True, isBgMode=isBg)
 def VVLdXS(self, title, mode, fg, bg):
  if fg or bg:
   attr  = self.VVv79T(mode)
   self.VVLz8f(title, mode, False, fg if attr.endswith("fg") else bg)
 def VVo0po(self, title, mode, isB64):
  self.session.openWithCallback(BF(self.VVev7c, title, mode, isB64), CClYaF, VV1gDA="poster", VV1pbK=self.VVELQH())
 def VVev7c(self, title, mode, isB64, path=None):
  if path:
   FFjt1c(CFG.lastCustMenuPicDir, os.path.dirname(path))
   err = self.VVr3Yq(path)
   if err : FFdw58(self, err, title=title)
   else : self.VVLz8f(title, mode, isB64, path)
 def VVr3Yq(self, path):
  fName = os.path.basename(path)
  try:
   p = LoadPixmap(path)
   if not p:
    return "Unloadable picture file:\n\n%s" % fName
  except Exception as e:
   return "Unloadable picture file:\n\n%s\n\nError : %s" % (fName, str(e))
  return ""
 @FFOAKH()
 def VVLz8f(self, title, mode, isB64, path):
  try:
   pathTxt = path
   if isB64 and path:
    ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
    with open(path, "rb") as f:
     pathTxt = str("data:image/%s;base64,%s" % (ext, b64encode(f.read()).decode()))
   isSubmenu = self.subName and (os.path.basename(self.filePath) != os.path.basename(self.subName))
   mainAttr = childAttr = None
   elemID  = parent = ""
   if mode > 1:
    attr = self.VVv79T(mode)
    if isSubmenu: childAttr, elemID = (attr, pathTxt), FFbhOc(self.subName)
    else  : mainAttr = (attr, pathTxt)
   else:
    childAttr=("icon", pathTxt)
    if isSubmenu:
     elemID = self.VVZRrs()
     parent = self.subName
   self.VVJHn2(title, mainAttr=mainAttr, childAttr=childAttr, elemID=elemID, parent=parent)
  except Exception as e:
   FFdw58(self, str(e), title=title)
 def VV71eW(self, title, path):
  if path:
   FFjt1c(CFG.lastCustMenuPicDir, path)
   self.VVJHn2(title, picpath=path)
 def VVJHn2(self, title, newElem=None, delItem=False, getItem=False, moveItem=None, picpath="", mainAttr=None, childAttr=None, elemID="", parent=""):
  try:
   head = ""
   xTxt = FFYVq0(self.filePath, encLst="UTF-8")
   ndx = xTxt.find("<ajp_menu")
   if ndx > 0:
    head = xTxt[:ndx]
    xTxt = xTxt[ndx:]
   tree = iElem.ElementTree(iElem.fromstring(xTxt, parser=iElem.XMLParser(target=CCYrUm.CC9usG())))
   elemID = elemID or self.VVZRrs()
   root = tree.getroot()
   parents = {c:p for p in tree.iter( ) for c in p}
   toSave = False
   if mainAttr:
    att, val = mainAttr
    if val: root.set(att, val)
    else  : root.attrib.pop(att, None)
    toSave = True
   elif picpath:
    toSave = True
    root.set("picpath", picpath)
    p = FFwW5m(root, "cursor")
    if p.startswith("/"): root.set("cursor", os.path.basename(p))
    p = FFwW5m(root, "shade")
    if p.startswith("/"): root.set("shade", os.path.basename(p))
    for ndx, elem in enumerate(tree.iter()):
     p = FFwW5m(elem, "icon")
     if p and not self.VVYNQo(p): elem.set("icon", os.path.basename(p))
     p = FFwW5m(elem, "bg")
     if p and not self.VVYNQo(p): elem.set("bg", os.path.basename(p))
   elif moveItem:
    oldNdx, newNdx, newElem = moveItem
    if oldNdx != newNdx:
     toSave = True
     for ndx, elem in enumerate(root):
      if ndx == oldNdx:
       elRoot = parents.get(elem, None)
       if elRoot is not None: elRoot.remove(elem)
       break
     root.insert(newNdx, newElem)
   else:
    if not newElem is None or getItem: iterator = root
    else        : iterator = tree.iter()
    for ndx, elem in enumerate(iterator):
     if self.VVP7EP(elem, elemID):
      toSave = True
      if not newElem is None:
       root.insert(ndx, newElem)
      elif delItem:
       elRoot = parents.get(elem, None)
       if elRoot is not None: elRoot.remove(elem)
       else      : toSave = False
      elif getItem:
       return ndx, elem
      elif childAttr:
       if parent and parent != FFwW5m(parents[elem], "title"):
        continue
       att, val = childAttr
       if val: elem.set(att, val)
       else  : elem.attrib.pop(att, None)
      else:
       toSave = False
      break
    else:
     FFdw58(self, "Current element not found.", title=title)
     return
   if toSave:
    self.VVAYtY(root)
    with open(self.filePath, "w") as f:
     fTxt = str(iElem.tostring(root, encoding="UTF-8").decode())
     line1 = "<?xml version='1.0' encoding='UTF-8'?>\n"
     if fTxt.startswith(line1):
      fTxt = fTxt[len(line1):]
     f.write("%s%s" % (head, fTxt))
    if mainAttr or childAttr: att, val = (mainAttr or childAttr)
    else     : att = val = ""
    if picpath or delItem or not newElem is None or att == "box_gap":
     if delItem:
      txt, ref, itemDict = self.VV7JdF()
      fPath, isMain = self.VV7TrL(ref)
      if fPath:
       fName = os.path.basename(fPath)
       if fName in CCRlkm.VVJK42.keys():
        CCRlkm.VVJK42.pop(fName)
     self.close(self.session, self.filePath, self.subName, self.VV6pYY())
    elif att:
     self.VVb8YI(att, val)
   else:
    FFjADj(self, "No change", 800)
  except Exception as e:
   FFdw58(self, str(e), title=title)
 def VVb8YI(self, att, val):
  if self.VVYNQo(val):
   bg, err = self.VVBhHX(val)
   if bg: val = bg
   else : return
  if att == "icon":
   self.VVZXCy(val)
   if self.isGrid : self.VVe4Ro()
   else   : self["myMenu"].setList(self.VVGape)
  else:
   self.VVUKLC[att] = val
   if att in ("bg", "title_fg", "title_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
    self.VVBRHT()
   elif att in ("shade"):
    self.VVGEkC(val)
   elif att in ("cursor"):
    self.VVrs4x(val)
   elif att in ("cursor_fg", "cursor_bg"):
    if   val == ""   : FF4IPF(self["myMenu"], fg=self.def_cursor_fg, bg=val or self.def_cursor_bg)
    elif att == "cursor_fg" : FF4IPF(self["myMenu"], fg=val or self.def_cursor_fg)
    elif att == "cursor_bg" : FF4IPF(self["myMenu"], bg=val or self.def_cursor_bg)
    self["myMenu"].instance.invalidate()
 def VVP7EP(self, elem, compId):
  if   elem.tag == "submenu" : name = FFwW5m(elem, "title")
  elif elem.tag == "item"  : name = FFwW5m(elem, "name")
  else      : name = ""
  return name and compId == FFbhOc(name)
 def VVZRrs(self):
  txt, ref, itemDict = self.VV7JdF()
  return itemDict.get("id", "")
 def VV6pYY(self):
  if self.isGrid : txt, info, ndx, icon = self.VVGape[self.VVBGsZ]
  else   : ndx = self["myMenu"].l.getCurrentSelectionIndex()
  return ndx
 def VV7JdF(self):
  return self.VVUKLC["lst"][self.VV6pYY()]
 def VVZXCy(self, path):
  txt, ref, itemDict = self.VV7JdF()
  itemDict["icon"] = path
  self.VVUKLC["lst"][self.VV6pYY()] = (txt, ref, itemDict)
  self.VVGape = self.VVoCYy()
 def VVN5Mh(self):
  txt, ref, itemDict = self.VV7JdF()
  info = itemDict.get("info", "")
  ask  = itemDict.get("ask", "Continue ?") if "ask" in itemDict else ""
  icon = itemDict.get("icon", "")
  tag  = itemDict["tag"]
  fPath, isMain = self.VV7TrL(ref)
  c1 = VVFuwR
  if   self.VVYNQo(ref)   : act1, act2 = "Base64 Image", ref[:60] + " ..."
  elif fPath       : act1, act2 = "External Menu File", fPath
  elif tag == "submenu"    : act1, act2 = "Submenu", ref
  elif ref.startswith("ajp_")   : act1, act2 = "AJPanel Option", ref
  elif iMatch(self.VVPxk5Patt, ref) : act1, act2 = "Play a channel", ref
  elif ref.startswith("/"):
   fExt = os.path.splitext(ref)[1]
   if fExt: fExt = fExt[1:]
   isMedia = fExt in CCHmnm.VViatp()["mov"] or fExt in CCHmnm.VViatp()["mus"]
   isPic = fExt in CCHmnm.VViatp()["pic"]
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", ref, IGNORECASE)
   if span     : act1, act2 = "Execute a Script file", ref
   elif isMedia   : act1, act2 = "Play Media File", ref
   elif isPic    : act1, act2 = "View Picture File", ref
   elif os.path.isdir(ref) : act1, act2 = "Open in File Manager", ref
   elif os.path.isfile(ref): act1, act2 = "Find in File Manager", ref
   else     : act1, act2 = "", ref
  else      : act1, act2 = "Run Command%s" % ("s" if "\n" in ref else ""), ref
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, c1), str(y))
  act = (FFjt5L(act1, VVJEMb, c1) if act1 else FFjt5L("Path not found", VVz22H, c1))
  s1 = ""
  if info: s1 += ttl("Description", info)
  if icon:
   if self.VVYNQo(icon): icon = icon[:60] + " ..."
   s1 += ttl("Custom Icon", icon)
  s1 += ttl("Action (%s)" % act, VVA4XU + act2)
  s1 += ttl("Source File:", self.filePath)
  FF4lCP(self, s1, title=txt)
 def VVoCYy(self):
  menuW = self.VVfOli["width"] - self.VVfOli["VVSZWt"] * 2
  lineH = self.VVfOli["bodyLineH"]
  align = {0: LEFT, 1: CENTER, 2: RIGHT}.get(self.VVUKLC["align_items"])
  gap  = lineH // 8
  pPath = CCafIt.VVjkKT()
  resPath = lambda icn: "%s%s.png" % (VVIp2p, icn)
  VV3wat = []
  for ndx, (txt, ref, itemDict) in enumerate(self.VVUKLC["lst"]):
   if itemDict["tag"] == "separator":
    if self.isGrid:
     continue
    left = 0
    txt, ref, icon = VVo7S9 + SEP, None, None
    isSep = True
   else:
    isSep = False
    icon = itemDict.get("icon", "")
    if not icon:
     fPath, isMain = self.VV7TrL(ref)
     if itemDict["tag"] == "submenu":
      isGrid, isStretch, cols, rows = self.VV2KRi(itemDict.get("mode", ""))
      icon = resPath("menug" if isGrid else "menu")
     elif fPath:
      icon = resPath("menux")
     elif iMatch(self.VVPxk5Patt, ref):
      span = iSearch(self.VVPxk5Patt, ref)
      for ext in ("png", "jpg"):
       picon = "%s%s.%s" % (pPath, span.group(1).rstrip(":_").replace(":", "_").upper(), ext)
       if FFCyVu(picon):
        icon = picon
        break
      else:
       icon = resPath("tv")
     elif ref.startswith("/"):
      fExt = os.path.splitext(ref)[1]
      fExt = fExt[1:] if fExt else fExt
      extLst = CCHmnm.VViatp()
      span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", ref, IGNORECASE)
      if span:
       icon = resPath("scr")
      elif fExt in extLst["mov"] or fExt in extLst["mus"]:
       pathNoExt = os.path.join(os.path.dirname(ref), os.path.join(os.path.dirname(ref), os.path.basename(ref)[:-(len(fExt) + 1)]))
       for ext in ("png", "jpg"):
        poster = "%s.%s" % (pathNoExt, ext)
        if FFCyVu(poster):
         icon = poster
         break
       else:
        icon = resPath("mov" if fExt in extLst["mov"] else "mus")
      elif fExt in extLst["pic"]  : icon = ref if FFCyVu(ref) else resPath("pic")
      elif os.path.isdir(ref)   : icon = resPath("dir")
      elif os.path.isfile(ref)  :
       s = txt.lower()
       if s.startswith("about") : icon = resPath("info")
       else      : icon = resPath("fil")
      else       : icon = resPath("err")
     elif ref.startswith("ajp_")   : icon = resPath("ajp2")
     elif txt.lower().startswith("about"): icon = resPath("info")
     elif "wget" in ref     : icon = resPath("wget")
     else:
      icon = resPath("teln")
   if self.isGrid:
    info = itemDict.get("info", "") or txt
    VV3wat.append((txt, info, ndx, icon))
   else:
    if   isSep   : x = 0
    elif align == LEFT : x = gap + lineH + lineH // 3
    elif align == CENTER: x = 0
    else    : x = -lineH - gap
    tableRow = [ None if isSep else ndx ]
    tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, x, 0, menuW, lineH, 0, align | RT_VALIGN_CENTER, txt))
    png = FFmNfu(icon)
    if png:
     sz = png.size()
     pngW, pngH = sz.width(), sz.height()
     w = h = lineH - 4
     if pngW == pngH: x, y = 0, 2
     else: x, y, w, h = self.VVF7W0(pngW, pngH, lineH - 4, lineH - 4)
     if align == RIGHT:
      x = menuW - w - gap
     if not self.isGrid:
      tableRow.append(CCnES5.VVmxDV(gap+x, y, w, h, png))
    VV3wat.append(tableRow)
  if not self.isGrid:
   FFIFeD()
  return VV3wat
 def VV2KRi(self, mode):
  isGrid, isStretch, cols, rows = False, True, 5, 4
  span = iSearch(r"^grid(\d)?(?:_(\d)x(\d))?", mode, IGNORECASE)
  if span:
   isGrid = True
   isStretch = span.group(1) != "1"
   if span.group(2) : cols = FFsRWN(int(span.group(2)), 3, 9)
   if span.group(3) : rows = FFsRWN(int(span.group(3)), 3, 6)
  return isGrid, isStretch, cols, rows
 def VVe4Ro(self):
  self.VVaFRk()
  f1, f2 = self.VVS7BN()
  row = col = 0
  for ndx in range(f1, f2):
   txt, _, _, icon = self.VVGape[ndx]
   pic, lbl = self.VVwbpA(row, col)
   self.VVExY8(lbl, txt)
   png = FFBFPY(pic, icon)
   if png:
    boxX, boxY = self.VVzIFK[(row, col)]
    pngSz = png.size()
    pngW, pngH = pngSz.width(), pngSz.height()
    if not self.isStretch and self.VVP8y1 > pngW and self.VVIgWJ > pngH:
     pic.instance.resize(pngSz)
     pic.instance.move(ePoint(boxX + (self.VVP8y1 - pngW) // 2, boxY + (self.VVIgWJ - pngH) // 2))
    else:
     x, y, w, h = self.VVF7W0(pngW, pngH, self.VVP8y1, self.VVIgWJ)
     pic.instance.resize(eSize(*(w, h)))
     pic.instance.move(ePoint(boxX + (self.VVP8y1 - w) // 2, boxY + (self.VVIgWJ - h) // 2))
   self.VVcG7K = row
   self.VVGCBk = col
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
 def VVHvUS(self):
  txt, info, ndx, icon = self.VVGape[self.VVBGsZ]
  self.VVkhlj(txt, info)
 @FFOAKH()
 def VVSTO4(self, txt, ref, itemDict):
  tag = itemDict["tag"]
  fPath, isMain = self.VV7TrL(ref)
  isAbout = txt.lower().startswith("about")
  if fPath:
   if FFCyVu(fPath):
    self.session.openWithCallback(CCRlkm.VVgQDN, CCRlkm, subFile=fPath, subName=ref)
   else:
    FFdw58(self, "Custom Menu file not found:\n\n%s" % fPath, title=txt)
    return
  elif tag == "submenu":
   self.session.openWithCallback(CCRlkm.VVgQDN, CCRlkm, subFile=self.filePath, subName=ref, picpath=self.VVUKLC["picpath"])
  elif iMatch(self.VVPxk5Patt, ref):
   span = iSearch(self.VVPxk5Patt, ref)
   VVu06s = span.group(1).replace("_", ":").upper() + span.group(2)
   CCqWM2.VVHc02(self.session, VVaHNe=VVu06s)
  elif ref.startswith("/"):
   path = ref
   fExt = os.path.splitext(path)[1]
   if fExt: fExt = fExt[1:]
   if not FFCyVu(path):
    FFdw58(self, "Path Not found:\n\n%s" % path, title=txt)
    return
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", path, IGNORECASE)
   if span:
    path = span.group(1)
    if FFCyVu(path) : self.session.open(CCtzVm, VVGd7m=path, VV6TEx=True)
    else    : FF8Wsn(self, path, title=txt)
   elif fExt in CCHmnm.VViatp()["mov"] or fExt in CCHmnm.VViatp()["mus"]:
    CClYaF.VVTWR0(self, path)
   elif fExt in CCHmnm.VViatp()["pic"]:
    CCf8zb.VVjnMn(self, ref)
   elif os.path.isdir(path):
    self.session.open(CClYaF, mode=CClYaF.VV4Ihm, VVHYTc=path)
   elif os.path.isfile(path):
    if isAbout:
     if CClYaF.VVgIOw(path) : FFdw58(self, "Cannot view binary file:\n\n%s" % path, title=txt)
     else        : self.VVy39X(txt, FFYVq0(path))
    else:
     self.session.open(CClYaF, mode=CClYaF.VV4Ihm, VVHYTc=path)
   else:
    FFdw58(self, "Cannot handle path:\n\n%s" % path, title=txt)
  elif ref.startswith("ajp_"):
   s = ref[4:]
   if   s == "fman" : self.session.open(CClYaF)
   elif s == "iptv" : self.session.open(CCkEI5)
   elif s == "movie" : CCG2jh.VV7hTj(self)
   elif s == "chan" : self.session.open(CCYrUm)
   elif s == "chanBr" : CCjThi.VVJNjY(self)
   elif s == "bouq" : self.session.open(CCLSIv)
   elif s == "picon" : self.session.open(CCafIt)
   elif s == "epg"  : self.session.open(CC5TsO)
   elif s == "xmltv" : CCDJgl(self)
   elif s == "term" : self.session.open(CCtzVm)
   elif s == "soft" : self.session.open(CCid3A)
   elif s == "plugin" : self.session.open(CCeSkW)
   elif s == "plugBr" : CCFZr4.VVsCNi(self.session)
   elif s == "bakup" : self.session.open(CCxSED)
   elif s == "date" : self.session.open(CCbQCK)
   elif s == "net"  : self.session.open(CCJIaP)
   elif s == "info" : self.session.open(CC674y)
   elif s == "inet" : self.session.open(CCoFdR)
   else    : FFdw58(self, "Option not found in %s" % VVh9hj, title=txt)
  elif isAbout:
   self.VVy39X(txt, ref)
  else:
   if len(ref) > 20000 : FFdw58(self, "The script exceeds 20,000 characters !\n\nMove the script to a script file.", title=txt)
   else    : self.session.open(CCtzVm, VVGd7m=ref, VVOuqa="Running Multiple Commands ..." if "\n" in ref else "", VV6TEx=True)
 def VVy39X(self, title, txt):
  FF4lCP(self, txt.strip()[:60000], title=title, VVwdmN=30, width=1600, height=1000, titleBg="#11331144", VVemyB="#11440044")
 def VVCW1G(self, subName):
  try:
   tree = iElem.parse(self.filePath)
  except Exception as e:
   return str(e)
  root = newRoot = tree.getroot()
  self.tmpOtherFiles = []
  for ndx, elem in enumerate(tree.iter()):
   tag = elem.tag
   if tag in ("ajp_menu", "submenu"):
    err = self.VV54Ub(elem)
    if err:
     return err
    if tag == "submenu" and FFwW5m(elem, "title") == subName:
     newRoot = elem
  txt = "Repeated custom menu file in : %s\nMenu File : %s"
  lst = [elem for elem, count in iCounter((f, el) for f, el in self.tmpOtherFiles).items() if count > 1]
  if lst:
   return txt % lst[0]
  else:
   curF = os.path.basename(self.filePath)
   for mnuF, mnuName in self.tmpOtherFiles:
    if mnuF in CCRlkm.VVJK42:
     tmpF, tmpName = CCRlkm.VVJK42[mnuF]
     if tmpF != curF:
      return txt % (mnuName, mnuF)
    else:
     CCRlkm.VVJK42[mnuF] = (curF, mnuName)
  self.VVUKLC["title"] = (FFwW5m(newRoot, "title") or self.VV9Ij0)
  self.VVUKLC["mode"]  = FFwW5m(newRoot, "mode").lower()
  self.VVUKLC["picpath"] = FFwW5m(newRoot, "picpath") or self.VVUKLC["picpath"]
  isGrid, _, _, _ = self.VV2KRi(self.VVUKLC["mode"])
  if isGrid:
   self.VVYMoP("width", newRoot, 600, 1920, "1600")
   self.VVYMoP("height", newRoot, 600, 1080, "900")
  else:
   self.VVYMoP("width", newRoot, 500, 1920, "800")
   self.VVYMoP("height", newRoot, 400, 1080, "1000")
  self.VVYMoP("font_size", newRoot, 10, 50)
  self.VVYMoP("title_font_size", newRoot, 20, 50)
  val = FFwW5m(newRoot, "line_gap")
  if val.isdigit():
   val = FFsRWN(int(val), 0, 100)
   self.VVUKLC["line_gap"] = FFjFSv(val, 0, 100, 0.15, 2)
  val = FFwW5m(newRoot, "box_gap")
  if val.isdigit():
   val = FFsRWN(int(val), 0, 100)
   self.VVUKLC["box_gap"] = FFjFSv(val, 0, 100, 0, 30)
  v = newRoot.attrib.get("align_items", "left")
  if   v == "left" : self.VVUKLC["align_items"] = 0
  elif v == "center" : self.VVUKLC["align_items"] = 1
  elif v == "right" : self.VVUKLC["align_items"] = 2
  bg, err = self.VViDaF(newRoot, "bg", True)
  if   bg : self.VVUKLC["bg"] = bg
  elif err: return err
  if isGrid:
   bg, err = self.VViDaF(newRoot, "cursor", True)
   if   bg : self.VVUKLC["cursor"] = bg
   elif err: return err
   if FFwW5m(newRoot, "shade").lower() == "yes":
    self.VVUKLC["shade"] = "yes"
   else:
    bg, err = self.VViDaF(newRoot, "shade", False)
    if   bg : self.VVUKLC["shade"] = bg
    elif err: return err
  for attr in ("fg", "title_fg", "title_bg", "cursor_fg", "cursor_bg", "title1_fg", "title1_bg", "title2_fg", "title2_bg", "num_fg", "num_bg"):
   self.VV6H1w(attr, newRoot)
  for elem in newRoot:
   itemDict = {"tag": elem.tag}
   if "ask" in elem.attrib  : itemDict["ask"] = FFwW5m(elem, "ask")
   if "info" in elem.attrib : itemDict["info"] = FFwW5m(elem, "info")
   name = ""
   if elem.tag == "submenu":
    name = FFwW5m(elem, "title")
    itemDict["mode"] = FFwW5m(elem, "mode")
    self.VVUKLC["lst"].append((name, name, itemDict))
   elif elem.tag == "item":
    name = FFwW5m(elem, "name")
    action = FFax4p(elem)
    action = "\n".join(list(map(str.strip, action.split("\n"))))
    self.VVUKLC["lst"].append((name, action, itemDict))
   elif elem.tag == "separator":
    self.VVUKLC["lst"].append(("", "", itemDict))
   bg, err = self.VViDaF(elem, "icon", False)
   if   bg : itemDict["icon"] = bg
   elif err: return err
   itemDict["id"] = FFbhOc(name)
 def VV54Ub(self, elem):
  mainName = FFwW5m(elem, "title") or FFwW5m(elem, "name") or elem.tag
  curIsSep = False
  nameLst = set()
  tot = 0
  curName = ""
  for ndx, elem in enumerate(elem):
   tag = elem.tag
   if tag == "ajp_menu":
    curIsSep = False
    titl  = curName = FFwW5m(elem, "title")
    if not titl : return "No Main Title in : %s" % tag
    else  : nameLst.add(titl.lower())
   elif tag == "submenu":
    tot += 1
    curIsSep = False
    titl = curName = FFwW5m(elem, "title")
    if   not titl    : return "Found submenu with no title."
    elif titl.lower() in nameLst: return "Duplicate submenu title : %s" % titl
    else      : nameLst.add(titl.lower())
   elif tag == "item":
    tot += 1
    curIsSep = False
    name = curName = FFwW5m(elem, "name")
    action = FFax4p(elem)
    if   not name : return "Found menu item with no name."
    elif not action : return "No action for : %s" % name
    fPath, isMain = self.VV7TrL(action)
    if fPath:
     curName = FFjt5L(curName, VVZtfx)
     if   isMain : return "Do not use the main custom file in : %s\n%s" % (curName, fPath)
     else  : self.tmpOtherFiles.append((os.path.basename(fPath), curName))
   elif tag == "separator":
    tName = curName or mainName
    if   ndx == 0 : return "Cannot use Separator as first menu item in : %s" % tName
    elif curIsSep : return "Consecutive Separators are not allowed after : %s" % tName
    else   : curIsSep = True
   else:
    return "Unknown Tag : %s" % tag
  tName = curName or mainName
  if   tot == 0: return "No menu items found in : %s" % tName
  elif curIsSep: return "Cannot use Separator as last menu item after : %s" % tName
  else   : return ""
 def VVYMoP(self, dItem, elem, Min, Max, default=""):
  if dItem in self.VVUKLC:
   val = elem.attrib.get(dItem, default)
   if val.isdigit():
    self.VVUKLC[dItem] =  FFsRWN(int(val), Min, Max)
 def VV6H1w(self, dItem, elem):
  if dItem in self.VVUKLC:
   val = elem.attrib.get(dItem, "")
   if val and self.VVRmDl(val):
    self.VVUKLC[dItem] = val
    return True
  return False
 def VViDaF(self, elem, attr, canColor):
  bg, err = self.VVygHh(elem, attr, canColor)
  if err:
   c1, c2, c3, c4 = VVZtfx, VV1fx4, VVYjI5, VVo7S9
   val = FFwW5m(elem, attr)
   txt  = FFjt5L(err, c3) + "\n\n"
   txt += "Check : %s\n" % FFjt5L(self.VVUKLC["title"], c1)
   txt += '%s="%s"' % (FFjt5L(attr, c2), FFjt5L(val if len(val) < 80 else val[:80] + " ...", c4))
   return "", txt
  else:
   return bg, err
 def VVygHh(self, elem, attr, canColor):
  c1, c2, c3 = VVZtfx, VV1fx4, VVz22H
  val = FFwW5m(elem, attr)
  if not val:
   return "", ""
  elif canColor and self.VVRmDl(val):
   self.VV6H1w(attr, elem)
   return "", ""
  elif val.endswith((".jpg", ".png")):
   if not val.startswith("/"):
    val = os.path.join(self.VVUKLC["picpath"], val)
   fName = os.path.basename(val)
   fil, ext = os.path.splitext(fName)
   if ext == ".png" and fil in ("ajp", "dnld", "ajp2", "pic", "mov", "tv") and not FFCyVu(val):
    val = VVIp2p + fName
   return val, ""
  elif self.VVYNQo(val):
   return self.VVBhHX(val)
  else:
   if canColor : txt = "Value must be a color,"
   else  : txt = "Picture files must be a"
   return "", "%s jpg, png or Base64 format." % txt
 def VVBhHX(self, b64):
  span = iSearch(r"data:image\/(.+);base64,(.+)", b64)
  if span:
   cacheDir = CCRlkm.VVlOtF()
   ext, b64 = span.groups()
   pFile = "%s%s.%s" % (cacheDir, FFbhOc(b64), ext.replace("jpeg", "jpg"))
   if FFCyVu(pFile):
    return pFile, ""
   else:
    if not FFpwZS("mkdir -p '%s'" % cacheDir):
     return "", "Cannot create icons directory:\n%s" % FFjt5L(cacheDir, c1)
    try:
     with open(pFile, "wb") as f:
      f.write(b64decode(b64))
    except Exception as e:
     FFwgGB(pFile)
     return "", "Cannot convert Base64 picture file.\n%s" % str(e)
    try:
     png = LoadPixmap(pFile)
     if png:
      return pFile, ""
     else:
      FFwgGB(pFile)
      return "", "Unloadable picture file (or invalid jpg/png format)"
    except Exception as e:
     FFwgGB(pFile)
     return "", "Unloadable picture file.:\n%s" % str(e)
  else:
   return "",
 def VV7TrL(self, path):
  fName = os.path.basename(path)
  if fName.startswith(CCRlkm.VVPNMN[:-4]):
   isMain = fName == CCRlkm.VVPNMN
   if path.startswith("/") : fPath = path
   else     : fPath = CCRlkm.VVcQrm() + fName
   return fPath, isMain
  else:
   return "", False
 def VVRmDl(self, c):
  return bool(iMatch(r"^#[A-Fa-f0-9]{6}$|^#[A-Fa-f0-9]{8}$", c))
 def VVYNQo(self, txt):
  return bool(iMatch(r"data:image\/.+;base64,.+", txt))
 def VV3fXu(self):
  lst = FF3xOt(r"find '%s' -type f \( -name '*.png' -o -name '*.jpg' \)" % CCRlkm.VVlOtF())
  tot = 0
  for f in lst:
   if iMatch(r"(.+_ajp_.+|.+[A-Fa-f0-9]{32})\.(?:png|jpg)$", f):
    tot += 1
    FFwgGB(f)
  if tot > 0 : FF1mVE(self, "%s deleted" % tot, 2000)
  else  : FF28n1(self, "No cached files", 1000)
 @staticmethod
 def VVY2v0(pixMap, path, toPng=False):
  newPath = CC6u6z.VVQuYE(pixMap, path, toPng=toPng)
  inst = pixMap.instance
  inst.setScale(1)
  if FFCyVu(newPath):
   inst.setAlphatest(0)
   FFBFPY(pixMap, newPath)
   return newPath
  elif FFCyVu(path):
   inst.setAlphatest(1)
   FFBFPY(pixMap, path)
   return path
  else:
   return ""
 @staticmethod
 def VVcQrm():
  return FFoWxR(CFG.customMenuPath.getValue())
 @staticmethod
 def VVGHsh():
  return CCRlkm.VVcQrm() + CCRlkm.VVPNMN
 @staticmethod
 def VVlOtF():
  return CCRlkm.VVcQrm() + "ajpanel_menu/"
 @staticmethod
 def VVRqTG():
  return str(u"\u00A4")
 @staticmethod
 def VVazeJ():
  path = CCRlkm.VVGHsh()
  cmTitle = CCRlkm.VV9Ij0
  mrk = CCRlkm.VVRqTG()
  if FFCyVu(path):
   try:
    for ndx, (event, elem) in enumerate(iElem.iterparse(path, events=("start", ))):
     if ndx == 0 and elem.tag == "ajp_menu":
      cmTitle = FFwW5m(elem, "title") or CCRlkm.VV9Ij0
     break
   except:
    pass
  return "%s %s %s" % (mrk, cmTitle, mrk)
 def VVAYtY(self, tree, space="\t", level=0):
  if isinstance(tree, iElem.ElementTree): tree = tree.getroot()
  if not len(tree): return
  indents = ["\n" + level * space]
  def VVZwiy(elem, level):
   chLevel = level + 1
   try:
    chInd = indents[chLevel]
   except IndexError:
    chInd = indents[level] + space
    indents.append(chInd)
   if not elem.text or not elem.text.strip() : elem.text = chInd
   for ch in elem:
    if len(ch)        : VVZwiy(ch, chLevel)
    if not ch.tail or not ch.tail.strip() : ch.tail = chInd
    if len(ch)        : ch.tail = "\n" + chInd
   if not ch.tail.strip()      : ch.tail = indents[level]
  VVZwiy(tree, 0)
 @staticmethod
 def VVEYRT(SELF, VV1rS5=False):
  if VV1rS5: fnc, session = FF2JFr, SELF
  else    : fnc, session = FFimQ3 , SELF.session
  path = CCRlkm.VVGHsh()
  Dir = os.path.dirname(path)
  fil = os.path.basename(path)
  if not VVmJwX(Dir) : FFzcnp(session, "%s\n\nPlease change %s path in Settings." % (Dir, FFjt5L("Custom Menu", VVFuwR)), title="Custom Menu path not found")
  elif FFCyVu(path) : fnc(SELF, BF(session.openWithCallback, CCRlkm.VVgQDN, CCRlkm), title="Loading ...")
  else     : FFRMYv(session, BF(fnc, SELF, BF(CCRlkm.VVoOWy, session, Dir, fil)), "Try a sample file ?\n\n%s" % path, title="Custom Menu file not found", VV1rS5=True)
 @staticmethod
 def VVoOWy(session, Dir, fil):
  if FFpwZS("cp -f '%s%s' '%s'" % (VVIp2p, fil, Dir)):
   session.openWithCallback(CCRlkm.VVgQDN, CCRlkm)
  else:
   FFzcnp(session, "Cannot copy template file to backup directory.", title=CCRlkm.VV9Ij0)
 @staticmethod
 def VVgQDN(session=None, subFile="", subName="", startItem=0):
  if session and (subFile or subName):
   FFIElK(BF(session.openWithCallback, CCRlkm.VVgQDN, CCRlkm, subFile=subFile, subName=subName, startItem=startItem))
class CC9hzi(Screen):
 def __init__(self, session, title="", csel=None, VVPxk5="", servName="", isFind=False):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, 700, 800, 50, 40, 30, "#22000033", "#22000011", 30)
  self.session     = session
  self.csel      = csel
  self.VVPxk5     = VVPxk5
  self.servName     = servName
  self.findTxt     = servName
  self.isFindMode     = isFind
  self.VVpEX8  = 0
  self.VVZnnj = 1
  self.VVL0yl  = 2
  VV3wat = []
  VV3wat.append(("Find in All Service (from filter)" , "VVe3Fh" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Find in All (Manual Entry)"   , "VV8w6L"    ))
  VV3wat.append(("Find in TV"       , "VV3AjF"    ))
  VV3wat.append(("Find in Radio"      , "VVqK0C"   ))
  if self.VVNi5y():
   VV3wat.append(VVAL3j)
   VV3wat.append(("Hide Channel: %s" % self.servName , "VVmk6k"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Zap History"       , "zapH"      ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("IPTV Tools"       , "iptv"      ))
  VV3wat.append(("PIcons Tools"       , "PIconsTools"     ))
  VV3wat.append(("Services/Channels Tools"    , "ChannelsTools"    ))
  VV3wat.append(("EPG Tools"       , "epgTools"     ))
  FFZMxC(self, VV3wat=VV3wat, title=title)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"])
  FF2GM8(self)
  if self.isFindMode:
   self.VVdb3C(self.VVGuCn())
 def VVPr1F(self):
  item = FFTmHZ(self)
  if item is not None:
   if   item == "VV8w6L"    : self.VV8w6L()
   elif item == "VVe3Fh" : self.VVe3Fh()
   elif item == "VV3AjF"    : self.VV3AjF()
   elif item == "VVqK0C"   : self.VVqK0C()
   elif item == "VVmk6k"   : self.VVmk6k()
   elif item == "zapH"       : self.session.open(CCiCTh)
   elif item == "iptv"       : self.session.open(CCkEI5)
   elif item == "PIconsTools"     : self.session.open(CCafIt)
   elif item == "ChannelsTools"    : self.session.open(CCYrUm)
   elif item == "epgTools"      : self.session.open(CC5TsO)
   if item in ("iptv", "PIconsTools", "ChannelsTools"):
    self.close()
 def VV3AjF(self) : self.VVdb3C(self.VVpEX8)
 def VVqK0C(self) : self.VVdb3C(self.VVZnnj)
 def VV8w6L(self) : self.VVdb3C(self.VVL0yl)
 def VVdb3C(self, mode):
  title = "Find %s Service" % ("TV", "Radio", "All")[mode]
  FF4z45(self, BF(self.VViXQo, mode), defaultText=self.findTxt, title=title, message="Enter Name:")
 def VVe3Fh(self):
  filterObj = CCoErY(self)
  filterObj.VVVPGN(self.VVbyGX)
 def VVbyGX(self, item):
  self.VViXQo(self.VVL0yl, item)
 def VVNi5y(self):
  if self.servName.strip() == ""      : return False
  if self.VVPxk5.strip()  == ""      : return False
  if self.VVPxk5.startswith("1:7:1:0:0:0:0:0:0:0:") : return False
  if FFUPnc(self.VVPxk5)        : return False
  return True
 @FFOAKH("Searching ...")
 def VViXQo(self, mode, VV8RqF):
  if VV8RqF:
   VV8RqF = VV8RqF.strip()
  if VV8RqF:
   self.findTxt = VV8RqF
   CFG.lastFindContextFind.setValue(VV8RqF)
   if   mode == self.VVpEX8  : titlTxt, servTypes = "TV"  , service_types_tv
   elif mode == self.VVZnnj : titlTxt, servTypes = "Radio"  , service_types_radio
   else          : titlTxt, servTypes = "All" , "1:7:"
   title = 'Find %s : "%s"' % (titlTxt, VV8RqF)
   if len(title) > 55:
    title = title[:55] + ".."
   VVAkuK = self.VV4W5L(VV8RqF, servTypes)
   if self.isFindMode or mode == self.VVL0yl:
    VVAkuK += self.VVUmsF(VV8RqF)
   if VVAkuK:
    VVAkuK.sort(key=lambda x: x[0].lower())
    VVu8qI = self.VVZP6Z
    VVu1YM  = ("Zap"   , self.VVKluW    , [])
    VVwSzI = ("Current Service", self.VV0bf5 , [])
    VVScQz = ("Options"  , self.VVC8BZ , [])
    VV2ytr = (""    , self.VV7N77 , [])
    header   = ("Name" , "Type", "Ref.", "Sat.", "Freq." , "Pol.", "FEC" , "SR" , "Bouq")
    widths   = (38  , 17 , 0  , 10 , 10  , 7  , 8  , 10 , 0.01 )
    VVLIqP  = (LEFT  , CENTER, LEFT  , CENTER, CENTER , CENTER, CENTER, CENTER, CENTER)
    FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVwSzI=VVwSzI, VVScQz=VVScQz, VV2ytr=VV2ytr, VVSLOq=CFG.lastFindContextFind)
   else:
    self.VVdb3C(self.VVGuCn())
    FFipXT(self, "Not found", title=title)
  elif self.isFindMode:
   self.close()
  else:
   self.findTxt = self.servName
 def VV4W5L(self, VV8RqF, servTypes):
  VVGape = CCYrUm.VV3FRU(servTypes)
  VVAkuK = []
  if VVGape:
   VVY1oT, VVvwHc = FF07Sg()
   tp = CC3Z54()
   words, asPrefix = CCoErY.VVPBNm(VV8RqF)
   colorYellow  = CCuTnL.VVsAua(VV1fx4)
   colorWhite  = CCuTnL.VVsAua(VVwdUw)
   for s in VVGape:
    name = s[1]
    for word in words:
     ok = False
     tName = name.lower()
     if asPrefix:
      if tName.startswith(word):
       ok = True
     elif word in tName:
      ok = True
     if ok:
      VVPxk5 = s[0]
      if VVPxk5.count(":") > 8:
       if asPrefix:
        name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, count=1, flags=IGNORECASE)
       else:
        name = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (colorYellow, colorWhite), name, flags=IGNORECASE)
       sat = FFec0y(VVPxk5, False)
       STYPE  = VVPxk5.split(":")[2]
       sTypeInt = int(STYPE, 16)
       if sTypeInt in VVY1oT:
        STYPE = VVvwHc[sTypeInt]
       freq, pol, fec, sr, syst = tp.VVFGvS(VVPxk5)
       if not "-S" in syst:
        sat = syst
       VVAkuK.append((name, STYPE, VVPxk5, sat, freq, pol, fec, sr, ""))
  return VVAkuK
 def VVUmsF(self, VV8RqF):
  VV8RqF = VV8RqF.lower()
  VVAkuK = []
  colorYellow  = CCuTnL.VVsAua(VV1fx4)
  colorWhite  = CCuTnL.VVsAua(VVwdUw)
  for b in CCMvE7.VVnZ35():
   VVY5Mx  = b[0]
   VVHCXP  = b[1].toString()
   VVKETx = eServiceReference(VVHCXP)
   VVlGGv = FFZcDI(VVKETx)
   for service in VVlGGv:
    VVPxk5  = service[0]
    if FFUPnc(VVPxk5):
     servName = service[1]
     if VV8RqF in servName.lower():
      servName = iSub(r"(%s)" % iEscape(VV8RqF), r"%s\1%s" % (colorYellow, colorWhite), servName, flags=IGNORECASE)
      VVAkuK.append((servName, "IPTV", VVPxk5, "-", "-", "-", "-", "-", VVY5Mx))
  return VVAkuK
 def VVGuCn(self):
  mode = CCLSIv.VVK7hm(default=-1)
  return self.VVL0yl if mode == -1 else mode
 def VVZP6Z(self, VV6A99):
  self.close()
  VV6A99.cancel()
 def VVKluW(self, VV6A99, title, txt, colList):
  FFnfiC(VV6A99.session, colList[2], checkParentalControl=True)
 def VV0bf5(self, VV6A99, title, txt, colList):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(VV6A99)
  if VVPxk5:
   VV6A99.VVn5CC(2, FFtCD7(VVPxk5, VVfaDB, VV1wIO), True)
 def VVC8BZ(self, VV6A99, title, txt, colList):
  servName = colList[0]
  mSel = CCzSCo(self, VV6A99)
  VV3wat, cbFncDict = CCYrUm.VVuGRo(self, VV6A99, servName, 2)
  mSel.VV9VR2(VV3wat, cbFncDict)
 def VV7N77(self, VV6A99, title, txt, colList):
  Name, Type, Ref, Sat, Freq, Pol, FEC, SR, Bouq = colList
  Name = FFzBfi(Name)
  txt  = ""
  txt += "Name\t: %s\n" % Name
  txt += "Type\t: %s\n" % Type
  if Bouq: txt += "Bouquet\t: %s" % Bouq
  if Sat != "-": txt += "Tuner\t: %s" % " ".join((Sat, Freq, Pol, FEC, SR))
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVFOKm, params=(Ref, Name, txt))
 def VVmk6k(self):
  FFRMYv(self, self.VV2mMQ, 'Hide "%s" ?' % self.servName, title="Hide Channel")
 def VV2mMQ(self):
  ret = FFz2bQ(self.VVPxk5, True)
  if ret:
   self.VVPKGW()
   self.close()
  else:
   FF28n1(self, "Cannot change state" , 1000)
 def VVPKGW(self):
  if self.csel:
   self.csel.servicelist.removeCurrent()
  try: CCiCTh.VVCZJa(self.VVPxk5)
  except: CCiCTh.VVScph()
  if self.VVPxk5.count(":") > 8:
   servRef = self.session.nav.getCurrentlyPlayingServiceReference()
   if servRef and self.VVPxk5 in servRef.toString():
    self.session.nav.stopService()
    if self.csel:
     serviceRef = self.csel.servicelist.getCurrent()
     if serviceRef:
      FFqb3C(self.session, serviceRef)
 @staticmethod
 def VV3xGy():
  global VVjIJk
  try:
   VVjIJk      = ChannelContextMenu.__init__
   ChannelContextMenu.__init__   = CC9hzi.VViu8s
   ChannelContextMenu.VVmUFM = CC9hzi.VVmUFM
  except:
   pass
 @staticmethod
 def VViu8s(SELF, session, csel):
  from Components.ChoiceList import ChoiceEntryComponent
  VVjIJk(SELF, session, csel)
  if CFG.showInChannelListMenu.getValue():
   for ndx, title in enumerate(("Channels Browser", "Find", "Bouquet Editor", "Channels Tools")):
    title = "%s - %s" % (VVh9hj, title)
    SELF["menu"].list.insert(ndx, ChoiceEntryComponent(key=" ", text=(title , BF(SELF.VVmUFM, csel, ndx, title))))
 @staticmethod
 def VVmUFM(SELF, csel, mode, title):
  try:
   currSel  = csel.getCurrentSelection()
   VVPxk5  = currSel.toString()
   refName  = FFCjjv(VVPxk5)
  except:
   VVPxk5 = refName = ""
  if   mode == 0: CCjThi.VVJNjY(SELF, SELF.close)
  elif mode == 2: SELF.session.openWithCallback(SELF.close, CCLSIv)
  else    : SELF.session.openWithCallback(SELF.close, CC9hzi, title=title, csel=csel, VVPxk5=VVPxk5, servName=refName, isFind=True if mode == 1 else False)
class CCiCTh(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVlrZA, 10, 10, 30, 0, 0, "#22004455", "#00ff0000", 30)
  self.session = session
  self.Title  = "Zap History"
  FFZMxC(self)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVgFJe()
 def cancel(self, VV6A99):
  VV6A99.cancel()
  self.close()
 def VVgFJe(self):
  VVCy6c = InfoBar.instance
  VVAkuK = []
  if VVCy6c:
   VVFp6v = VVCy6c.servicelist
   if VVFp6v:
    VVY1oT, VVvwHc = FF07Sg()
    for serv in VVFp6v.history:
     VVPxk5 = serv[-1].toString()
     VV1wIO = FFCjjv(VVPxk5)
     path = serv[-1].getPath()
     isLocal = path and path.startswith("/")
     isIptv = FFUPnc(VVPxk5)
     isSRel = FFHgaY(VVPxk5)
     sat = "-" if isIptv and not isSRel or isLocal else FFec0y(VVPxk5, True)
     if isIptv : STYPE = "Stream Relay" if isSRel else "IPTV"
     elif isLocal: STYPE = "Local Media"
     else:
      STYPE  = VVPxk5.split(":")[2]
      sTypeInt = int(STYPE, 16)
      if sTypeInt in VVY1oT:
       STYPE = VVvwHc[sTypeInt]
     VVAkuK.append((VV1wIO, sat, STYPE, VVPxk5))
  if VVAkuK:
   VVu8qI = self.cancel
   VVu1YM  = ("Zap"   , self.VVqQxm   , [])
   VVScQz = ("Clear History" , self.VVpAc2   , [])
   VV2ytr = (""    , self.VVh7mT , [])
   header   = ("Service Name", "Satellite" , "Type" , "Ref. Code" )
   widths   = (41    , 41   , 18  , 0    )
   VVLIqP  = (LEFT    , LEFT   , CENTER , LEFT   )
   FFUQ0v(self, None, title=self.Title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVScQz=VVScQz, VV2ytr=VV2ytr)
  else:
   FFipXT(self, "Empty", title=self.Title)
   self.close()
 def VVqQxm(self, VV6A99, title, txt, colList):
  FFnfiC(VV6A99.session, colList[3], checkParentalControl=True)
  self.cancel(VV6A99)
 def VVpAc2(self, VV6A99, title, txt, colList):
  FFRMYv(self, BF(self.VVPFI3, VV6A99), "Clear Zap History ?", title=self.Title)
 def VVPFI3(self, VV6A99):
  CCiCTh.VVScph()
  self.cancel(VV6A99)
 def VVh7mT(self, VV6A99, title, txt, colList):
  VV1wIO = colList[0]
  VVPxk5 = colList[3]
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvVii, params=(VVPxk5, VV1wIO, txt))
 @staticmethod
 def VVScph():
  inst = InfoBar.instance
  csel = inst and inst.servicelist
  if csel:
   csel.history  = []
   csel.history_pos = 0
 @staticmethod
 def VVCZJa(VVPxk5):
  if not VVPxk5: return
  servRef = eServiceReference(VVPxk5)
  VVCy6c = InfoBar.instance
  if VVCy6c:
   VVFp6v = VVCy6c.servicelist
   if VVFp6v:
    hList = VVFp6v.history
    newList = []
    for rec in hList:
     for servRef in rec:
      if VVPxk5 in servRef.toString():
       break
     else:
      newList.append(rec)
    if newList:
     oldLen = len(hList)
     newLen = len(newList)
     diff = oldLen - newLen
     if not diff == 0:
      pos = VVFp6v.history_pos - diff
      if pos > newLen -1 : pos = newLen - 1
      if pos < 0   : pos = 0
      VVFp6v.history  = newList
      VVFp6v.history_pos = pos
class CCLSIv(Screen):
 def __init__(self, session, VVPxk5="", servName=""):
  self.skin, self.VVfOli = FFiNEe(VVlrZA, 10, 10, 30, 0, 0, "#ff000000", "#ff000000", 30)
  self.session = session
  self.Title  = "Bouquet Editor"
  self.pPath  = CCafIt.VVjkKT()
  self.bTables = []
  FFZMxC(self)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVfqM2()
 def VVTEDg(self, tbl, bName, bRef):
  self.bTables.append(tbl)
  tbl.bouqName = bName
  tbl.bouqRef  = bRef
  self.VVHUOx(tbl)
 def VVfqM2(self):
  rootStr = CCLSIv.VVfejw()
  rows = self.VVp5FP(rootStr)
  if rows :
   self.VVYUTb(self, "Main Bouquets List", rootStr, rows)
   VVPxk5, refName, rootRef, rootName, inBouquet, rootSrc = CCjThi.VVZhZh()
   if not self.bTables[-1].VVPkdw({3:VVPxk5}):
    self.bTables[-1].VVPkdw({3:rootRef})
  else:
   FFdw58(self, "No bouquets Found !", title=self.Title)
   self.close()
 def VVj39p(self):
  self.bTables[-1].cancel()
  if len(self.bTables) > 0: del self.bTables[-1]
  if not len(self.bTables): self.close()
 def VVp5FP(self, bRef=None):
  blkLst = CCLSIv.VVr4pQ()
  rows = []
  for ndx, row in enumerate(FFZcDI(eServiceReference(bRef), mode=1), start=1):
   ref, name, flags = row
   fTxt, fColor = CCLSIv.VVB9xW(flags)
   lck = "1" if CCLSIv.VVAxzM(ref, blkLst) > -1 else ""
   rows.append((str(ndx), "", fColor + name, ref, fTxt, str(flags), lck))
  return rows
 def VVYUTb(self, selfObj, bName, bRef, rows):
  totTbl = len(self.bTables)
  title = {0:"Main Bouquets List", 1:"%s %s" % (FFjt5L("Fav: ", VVA4XU), bName), 2:"%s %s" % (FFjt5L("Sub: ", VVA4XU), bName)}.get(totTbl, bName)
  bg  = {0:"#11002233", 1:"#0a112222"}.get(totTbl, "#0a131111")
  VVu8qI = self.VVhPrS
  VVlJfJ = self.VVeypG
  VV2ytr = (""     , self.VV4svQ   , [])
  VVu1YM  = ("Enter Bouquet"  , self.VVLGpY  , [])
  VVwWmA = ("Delete"    , self.VVm2gX  , [])
  VVwSzI = ("Bouquets Importer" , self.VVgLtE , [])
  VVScQz = ("Options"   , self.VVLGUd  , [])
  VV4QTJ = ("Move Here"   , self.VVUTuK  , [])
  VVoGCy  = (1, self.VVVbFn, None)
  widths  = (12   , 7   , 81 , 0  , 0   , 0   , 0   )
  VVLIqP = (CENTER  , CENTER , LEFT , LEFT , LEFT  , CENTER , CENTER )
  tbl = FFUQ0v(self, None, title=title, VVGape=rows, VVLIqP=VVLIqP, width=1500, height=1000, VV3cHe=widths, VVwdmN=28, VVp4wm=False, VV2ytr=VV2ytr, VVu1YM=VVu1YM, VVu8qI=VVu8qI, VVlJfJ=VVlJfJ, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVHPI7=True, VVMfsO=2, VVoGCy=VVoGCy, VVSLOq=CFG.lastFindServices
     , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#0a005566", VVLf28=0, VVX9AA="#11330000")
  tbl.VVIOX6(BF(self.VVeypG, tbl))
  self.VVTEDg(tbl, bName, bRef)
 def VVvQmZ(self, VV6A99, mutableList, tot, jumpDict=None):
  if tot:
   if mutableList:
    mutableList.flushChanges()
   FFfpyJ()
   rows = self.VVp5FP(VV6A99.bouqRef)
   if rows:
    VV6A99.VVW3QY()
    VV6A99.VVMqQ9(rows, isSort=False, VVDpzd=BF(self.VVQHvw, jumpDict))
   else:
    self.VVj39p()
    totTbl = len(self.bTables)
    FF28n1(self.bTables[-1] if totTbl > 0 else self, "Empty List !", 1500)
  else:
   FFjADj(VV6A99, "No change !", 1500)
 def VVQHvw(self, jumpDict, VV6A99, title, txt, colList):
  if jumpDict:
   VV6A99.VVPkdw(jumpDict)
 def VVeypG(self, VV6A99):
  VV6A99["keyRed"].hide()
  VV6A99["keyBlue"].hide()
  if VV6A99.VVXWPu:
   if VV6A99.VVc5NH() > 0:
    VV6A99["keyRed"].show()
    VV6A99["keyBlue"].show()
  else:
   VV6A99["keyRed"].show()
  self.VVHUOx(VV6A99)
 def VVHUOx(self, VV6A99):
  if len(self.bTables) == 1 and not VV6A99.VViNen():
   VV6A99.VVsd6P()
  else:
   VV6A99.VVucBj()
 def VV4svQ(self, VV6A99, title, txt, colList):
  c1, c2, c3 = VV1fx4, VVGCYL, VVz22H
  ttl = lambda x, y, color=c1: "%s:\n%s\n\n" % (FFjt5L(x, color), y) if y else ""
  num, picon, name, ref, rem, flags, lck = colList
  path = CCLSIv.VVijn5(ref, mode=1)
  txt  = ttl("Name"    , name)
  txt += ttl("Bouquet File"  , path if path.startswith("/") else "")
  txt += ttl("Parent Bouquet"  , VV6A99.bouqName, c2)
  txt += ttl("Parent Bouquet File", CCLSIv.VVijn5(VV6A99.bouqRef, mode=1), c2)
  txt += ttl("Ref."    , ref, c3) if VVBvqf else ""
  txt += ttl("Remarks"   , rem, c3) if VVBvqf else ""
  path = CCafIt.VVXjFJ(self.pPath, ref, name)
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVnSfp, params=(txt, path))
 @FFOAKH(par=1)
 def VVLGpY(self, VV6A99, title, txt, colList):
  maxLev = 2
  num, picon, name, ref, rem, flags, lck = colList
  flags = CCLSIv.VVzO8e(ref)
  if FFWpih(ref):
   if len(self.bTables) <= maxLev:
    rows = self.VVp5FP(ref)
    if rows : self.VVYUTb(VV6A99, name, ref, rows)
    else : FFjADj(VV6A99, "Empty list !", 1500)
   else:
    FFdw58(self, "Maximum Level of Recursive Bouquets (%d) !" % maxLev, title=self.Title)
  elif flags & 64:
   FFjADj(VV6A99, "Cannot play markers", 500)
  else:
   FFnfiC(self.session, ref)
   FFSqRh(self, "Cancel to go back to table")
 def VVhPrS(self, VV6A99):
  self.VVj39p()
 def VVLGUd(self, VV6A99, title, txt, colList):
  VV3wat = []
  iMulSel = VV6A99.VViNen()
  sortItem = ("Sort", )
  if iMulSel:
   tot = VV6A99.VVc5NH()
   if tot > 1: sortItem = ("Sort", "sort")
   isSel = tot > 0
   bTxt = "Bouquet%s" % FFcacr(tot)
  else:
   isSel = True
   bTxt = "Bouquet"
  inMain = len(self.bTables) == 1
  okToMain = False
  if not inMain:
   for ref in self.VVqtFh(VV6A99):
    if not FFWpih(ref) and not ref.startswith("1:64:"): break
   else:
    okToMain = True
  totDel = len(self.VV8yZz())
  c1, c2, c3, c4 = VVGCYL, VVJEMb, VVFuwR, VVz22H
  VV3wat.append(FFsLU5("Rename"   , "renm" , not iMulSel, c1))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Add Marker"  , "mrkr" , not iMulSel, c2))
  VV3wat.append(FFsLU5("Add Empty Bouquet", "addBouq" , not iMulSel and inMain, c2))
  if totDel:
   VV3wat.append(VVAL3j)
   VV3wat.append((c4 + 'Delete %d Unused ".del" Bouquets File%s' % (totDel, FFcacr(totDel)), "unused"))
  if inMain:
   VVwltY, VVkxBG = "#22001122", "#22000a15"
   VV3wat.append(VVAL3j)
   VV3wat.append(FFsLU5("Hide %s" % bTxt , "hidOn" , isSel, c3))
   VV3wat.append(FFsLU5("Unhide %s" % bTxt , "hidOff" , isSel, c3))
   VV3wat.append(VVAL3j)
   VV3wat.append(FFsLU5("Protect %s" % bTxt , "lckOn" , isSel, c3))
   VV3wat.append(FFsLU5("Unprotect %s" % bTxt , "lckOff" , isSel, c3))
   VV3wat.append(VVAL3j)
   VV3wat.append(FFsLU5("Save Selected %s to M3U File" % bTxt , "toM3u", isSel, c2))
   VV3wat.append((c1 + "Fix Local Media Path (ALL Bouquets)"   , "fixMed"))
   VV3wat.append((c1 + "Set Local Media PIcons (ALL Bouquets)"  , "fixPic"))
  else:
   VVwltY, VVkxBG = "#2200120a", "#2200120a"
  VV3wat.append(VVAL3j)
  VV3wat.append(sortItem)
  VV3wat.append(FFsLU5("Copy to Main Bouquets List" , "toMain", okToMain))
  VV3wat.append(FFsLU5("Copy to a Bouquet"   , "toBouq", isSel))
  cbFncDict = { "renm" : BF(self.VVHRA8  , VV6A99)
     , "fixMed" : BF(self.VVXlR3, VV6A99)
     , "fixPic" : BF(self.VV33rr, VV6A99)
     , "toM3u" : BF(self.VVDCMj , VV6A99)
     , "mrkr" : BF(self.VVieMk , VV6A99)
     , "addBouq" : BF(self.VVItvG, VV6A99)
     , "unused" : BF(self.VVwhHo , VV6A99)
     , "hidOn" : BF(self.VVy2T1  , VV6A99, True)
     , "hidOff" : BF(self.VVy2T1  , VV6A99, False)
     , "lckOn" : BF(self.VVIhnB  , VV6A99, True)
     , "lckOff" : BF(self.VVIhnB  , VV6A99, False)
     , "sort" : BF(self.VVjtwy  , VV6A99)
     , "toMain" : BF(self.VVwYG1 , VV6A99)
     , "toBouq" : BF(self.VVjC5X , VV6A99) }
  mSel = CCzSCo(self, VV6A99)
  mSel.VV9VR2(VV3wat, cbFncDict, height=1000, VVwltY=VVwltY, VVkxBG=VVkxBG, VVptue=0.08)
 def VVm2gX(self, VV6A99, title, txt, colList):
  txt, totSel = "", 0
  if VV6A99.VViNen():
   totSel = VV6A99.VVc5NH()
   if totSel:
    txt = "Delete %s item%s" % (FFjt5L(totSel, VV1fx4), FFcacr(totSel))
  else:
   num, picon, name, ref, rem, flags, lck = colList
   txt = "Delete : %s" % FFjt5L(name, VV1fx4)
  if txt:
   FFRMYv(self, BF(self.VV5FTI, VV6A99), "%s\n\nContinue ?" % txt, title=self.Title)
 def VVgLtE(self, VV6A99, title, txt, colList):
  CC9xd9.VVtXW3(self, cbFnc=BF(self.VVssKp, VV6A99))
 def VVssKp(self, VV6A99):
  self.VVvQmZ(VV6A99, None, 1)
 @FFOAKH(par=1)
 def VV5FTI(self, VV6A99):
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  if mutableList is not None:
   tot = 0
   for ref in lst:
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.removeService(serv):
     tot += 1
     bFile = CCMvE7.VV896q(ref)
     if bFile:
      bFile = VVQe79 + bFile
      FFpwZS("rm -f '%s' '%s.del'" % (bFile, bFile))
   self.VVvQmZ(VV6A99, mutableList, tot)
 @FFOAKH(par=1)
 def VVUTuK(self, VV6A99, title, txt, colList):
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  if mutableList is not None:
   curNdx = VV6A99.VVGTqU()
   if curNdx <= VV6A99.VV6LTe(): lst = reversed(lst)
   else             : curNdx -= 1
   tot = 0
   for ref in lst:
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.moveService(serv, curNdx):
     tot += 1
   self.VVvQmZ(VV6A99, mutableList, tot)
 @FFOAKH(par=1)
 def VVjtwy(self, VV6A99):
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  if mutableList is not None:
   nmlst = VV6A99.VVf3uT(2)
   lst = list(zip(nmlst, lst))
   lst.sort(key=lambda x: x[0].lower())
   curNdx = VV6A99.VV6LTe()
   tot = 0
   for name, ref in reversed(lst):
    serv = eServiceReference(ref)
    if serv.valid() and not mutableList.moveService(serv, curNdx):
     tot += 1
   self.VVvQmZ(VV6A99, mutableList, tot)
 def VVHRA8(self, VV6A99, item=None):
  name = VV6A99.VV5crm()[2]
  FF4z45(self, BF(self.VV75RP, VV6A99), defaultText=name, title="Rename", message="Enter new name")
 def VV75RP(self, VV6A99, name):
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  if name and csel and mutableList:
   name = name.strip()
   if name:
    ref = VV6A99.VV5crm()[3]
    if FFWpih(ref):
     CCMvE7.VV3r6m(ref, name)
    else:
     serv = eServiceReference(ref)
     if serv.valid():
      serv.setName(name)
      mutableList.removeService(serv)
      mutableList.addService(serv)
      mutableList.moveService(serv, VV6A99.VVGTqU())
    self.VVvQmZ(VV6A99, mutableList, 1)
 def VVXlR3(self, VV6A99):
  title = "Fix Media Path (for All Bouquets)"
  newP = FFoWxR(CFG.MovieDownloadPath.getValue())
  txt = FFjt5L("/media/.../movie/", VV1fx4)
  FFRMYv(self, BF(FFimQ3, VV6A99, BF(self.VVDy4R, title, newP)), "Change Media path (%s) to:\n\n%s" % (txt, newP), title=title)
 def VVDy4R(self, title, newP):
  totF = totRepl = 0
  for path in CCMvE7.VVHtVA():
   txt = FFYVq0(path)
   exp = iCompile(r"(\/media\/.+\/movie\/)", IGNORECASE)
   lst = set()
   for Str in exp.findall(txt):
    if Str != newP:
     lst.add(Str)
   save = False
   for Str in lst:
    txt, tot = exp.subn(newP, txt)
    totRepl += tot
    save = True
   if save:
    totF += 1
    with open(path, "w") as f:
     f.write(txt)
  if totF or totRepl:
   txt  = "Total Files\t: %s\n"  % totF
   txt += "Total Fixes\t: %s\n"  % totRepl
   FF4lCP(self, txt, title=title)
   FFfpyJ()
  else:
   FFipXT(self, "All OK (no changes).", title=title)
 def VV33rr(self, VV6A99):
  title = "Fix Movies PIcons"
  if FFayeZ("ffmpeg"):
   FFRMYv(self, BF(self.VVVbNG, VV6A99, title), "Set PIcons to local media services (from posters) ?", title=title)
  else:
   FFRMYv(self, BF(CCkEI5.VVGS56, self), '"FFmpeg" is required for this process.\n\nInstall FFmpeg ?', title=title)
 @FFOAKH(par=1)
 def VVVbNG(self, VV6A99, title):
  lst = []
  for bPath in CCMvE7.VVHtVA():
   txt = FFYVq0(bPath)
   exp = iCompile(r"#SERVICE\s+((?:[a-f0-9]+:){10})(\/.+):(.+)", IGNORECASE)
   piconPath = CCafIt.VVjkKT()
   for ref, path, VV1wIO in exp.findall(txt):
    for ext in ("jpg", "png"):
     poster = "%s.%s" % (os.path.splitext(path)[0], ext)
     picon = piconPath + ref.strip(":").replace(":", "_").upper() + ".png"
     if FFCyVu(poster) and not FFCyVu(picon):
      lst.append((poster, picon))
  if len(lst) :
   CCh3tv.VV7Nf4(self
       , VVixvy  = BF(self.VVcuCj, title, lst)
       , VVbYwR = BF(self.VVcbYf, title, len(lst)))
  else:
   FFipXT(self, "Nothing to fix", title=title)
 def VVcuCj(self, title, lst, VVXyP6):
  VVXyP6.VVq8NF(len(lst))
  VVXyP6.VVNc18 = 0
  for poster, picon in lst:
   if not VVXyP6 or VVXyP6.isCancelled: return
   VVXyP6.VVxtQs(1)
   if FFpwZS("cp -f '%s' '%s'" % (poster, picon)):
    if FFpwZS(CCvjVs.VVQ9GP(picon)):
     if not VVXyP6 or VVXyP6.isCancelled: return
     VVXyP6.VVNc18 += 1
    else:
     FFwgGB(picon)
 def VVcbYf(self, title, tot, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  FFipXT(self, "Added PIcons = %s" % VVNc18, title=title)
 @FFOAKH(par=1)
 def VVDCMj(self, VV6A99):
  if VV6A99.VVXWPu : rows = VV6A99.VVbF9W()
  else        : rows = [VV6A99.VV5crm()]
  bName = rows[0][2]
  outF = "%s%s_%s.m3u" % (FF7BT0(), FFOu5Y(bName), FFjTQe())
  totCh = toB = 0
  with open(outF, "w") as f:
   f.write("#EXTM3U\n")
   for num, picon, name, ref, rem, flags, lck in rows:
    if ref and name and rem == "Directory":
     for chR, chNm, chFlags in FFZcDI(eServiceReference(ref), mode=1):
      if chR and chNm:
       chR = chR.replace(":" + chNm, "").strip()
       span = iSearch(r'^((?:[A-Fa-f0-9]+:){10})(.*)', chR, IGNORECASE)
       if span:
        totCh += 1
        ref, url = span.groups()
        url = FFXarh(url)
        url = url or ref
        if FFHgaY(url):
         url = ref + url
        f.write('#EXTINF:-1 group-title="%s",%s\n' % (name, chNm))
        f.write("%s\n" % url)
  title = "Save to M3U File"
  if totCh:
   totB = len(rows)
   FFipXT(self, "Exported %s Channel%s (from %s Bouquet%s) to:\n\n%s" % (totCh, FFcacr(totCh), totB, FFcacr(totB), outF), title=title)
  else:
   FFdw58(self, "Nothing to save.", title=title)
   FFwgGB(outF)
 @FFOAKH(par=1)
 def VVieMk(self, VV6A99):
  name = "%s Marker %s" % ("=" * 7, "=" * 7)
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  if mutableList is not None:
   curServ = eServiceReference(VV6A99.VV5crm()[3])
   cnt = tot = 0
   while mutableList:
    serv = eServiceReference("1:64:%d:0:0:0:0:0:0:0::%s" % (cnt, name))
    if curServ and curServ.valid():
     if not mutableList.addService(serv, curServ):
      csel.servicelist.addService(serv, True)
      tot += 1
      break
    elif not mutableList.addService(serv):
     csel.servicelist.addService(serv, True)
     tot += 1
     break
    cnt += 1
   self.VVvQmZ(VV6A99, mutableList, tot)
 def VVItvG(self, VV6A99):
  names = VV6A99.VVrc5p(2)
  name = "Bouquet-1"
  num = 0
  while name in names:
   num += 1
   name = "Bouquet-%s" % num
  FF4z45(self, BF(self.VVnrOk, VV6A99), defaultText=name, title="New Bouquet", message="Enter Bouquet name")
 def VVnrOk(self, VV6A99, name=None):
  if name and name.strip():
   self.VVDERP(VV6A99, name.strip())
 @FFOAKH(par=1)
 def VVDERP(self, VV6A99, bName):
  CCMvE7.VVCROO(bName)
  self.VVvQmZ(VV6A99, None, 1, jumpDict={2:bName})
 def VV8yZz(self):
  lst = []
  for fil in os.listdir(VVQe79):
   if fil.endswith(".tv.del") or fil.endswith(".radio.del"):
    lst.append(fil)
  return lst
 def VVwhHo(self, VV6A99):
  lst = self.VV8yZz()
  for fil in lst:
   FFwgGB(VVQe79 + fil)
  VV6A99.VV6fGE("Done")
 def VVqtFh(self, VV6A99):
  if VV6A99.VVXWPu : return VV6A99.VVf3uT(3)
  else        : return [VV6A99.VV5crm()[3]]
 def VVwYG1(self, VV6A99):
  dstFile = "bouquets.%s" % ("tv" if CCLSIv.VVK7hm() == 0 else "radio")
  self.VV5QCD(VV6A99, "Main Bouquets List", dstFile, True)
 def VVjC5X(self, VV6A99):
  bRows = CCMvE7.VVBTuE()
  lst = self.VVqtFh(VV6A99)
  VV3wat = []
  for name, ref in bRows:
   if not ref in lst:
    VV3wat.append((name, ref))
  if VV3wat : FFLFTC(self,  BF(self.VVJQSX, VV6A99), VV3wat=VV3wat, width=1100, height=900, VVwltY="#22220000", VVkxBG="#22110000", title="Destination Bouquet", VVU8mZ=True)
  else  : FF28n1(VV6A99, "No bouquets left !", 1000)
 def VVJQSX(self, VV6A99, item=None):
  if item:
   bName, bRef, ndx = item
   dstFile = CCMvE7.VV896q(bRef)
   self.VV5QCD(VV6A99, bName, dstFile)
 @FFOAKH(par=1)
 def VV5QCD(self, VV6A99, bName, dstFile, mainToo=False):
  lst = self.VVqtFh(VV6A99)
  tot = 0
  for ref in lst:
   ok = CCMvE7.VVsEnx(ref, dstFile)
   if ok:
    tot += 1
  self.VVvQmZ(VV6A99, None, tot)
  if mainToo:
   rootStr = CCLSIv.VVfejw()
   rows = self.VVp5FP(rootStr)
   self.bTables[0].VVMqQ9(rows)
  ttl = lambda x, y: "%s:\n%s\n\n" % (FFjt5L(x, VVFuwR), y)
  txt  = ttl("Source Bouquet"  , VV6A99.bouqName)
  txt += ttl("Destination Bouquet", bName)
  txt += ttl("Copied Services" , tot)
  FF4lCP(VV6A99, txt, title="Copy Services")
 @FFOAKH(par=1)
 def VVy2T1(self, VV6A99, isHide):
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  mode = CCLSIv.VVK7hm()
  path = VVQe79 + "bouquets.%s" % ("tv" if mode==0 else "radio")
  if FFCyVu(path):
   tot = 0
   lines = list(map(str.strip, FFL19l(path)))
   for ref in lst:
    if FFWpih(ref):
     ref = "#SERVICE " + ref
     nrm = ref.replace("1:519:", "1:7:")
     hid = ref.replace("1:7:"  , "1:519:")
     if isHide: r1, r2 = nrm, hid
     else  : r1, r2 = hid, nrm
     if r1 in lines:
      ndx = lines.index(r1)
      lines[ndx] = r2
      tot += 1
   if tot:
    with open(path, "w") as f:
     for line in lines:
      f.write("%s\n" % line)
    self.VVvQmZ(VV6A99, None, tot)
 @FFOAKH(par=1)
 def VVIhnB(self, VV6A99, isLck):
  lst, mutableList, csel, bServ = self.VV20TR(VV6A99)
  blkLst = CCLSIv.VVr4pQ()
  tot = 0
  for ref in lst:
   if FFWpih(ref):
    ndx = CCLSIv.VVAxzM(ref, blkLst)
    if isLck:
     if ndx == -1:
      ref = ref.replace("1:519:", "1:0:").replace("1:7:", "1:0:")
      blkLst.append(ref)
      tot += 1
    else:
     if ndx > -1:
      blkLst[ndx] = ""
      tot += 1
  if tot:
   with open(VV3W4d, "w") as f:
    for line in blkLst:
     if line.strip():
      f.write("%s\n" % line)
   from Components.ParentalControl import parentalControl
   parentalControl.open()
   self.VVvQmZ(VV6A99, None, tot)
 def VV20TR(self, VV6A99, bServ=None):
  lst = self.VVqtFh(VV6A99)
  mutableList = csel = None
  VVCy6c = InfoBar.instance
  if VVCy6c:
   csel = VVCy6c.servicelist
   if csel:
    if not bServ:
     bServ = eServiceReference(VV6A99.bouqRef)
    if bServ.valid():
     mutableList = csel.getMutableList(bServ)
  return lst, mutableList, csel, bServ
 def VVVbFn(self, colList):
  num, picon, name, ref, rem, flags, lck = colList
  png = lambda x: "%s%s.png" % (VVIp2p, x)
  if   rem == "Marker"   : return png("mrk1")
  elif rem == "Numbered Marker" : return png("mrk2")
  elif rem == "Group"    : return png("grp")
  elif FFWpih(ref):
   if   lck == "1" and rem == "Invisible" : return png("dirLckInvis")
   elif lck == "1"       : return png("dirLck")
   elif rem == "Invisible"     : return png("dirInvis")
   else         : return png("dir1")
  else:
   return CCafIt.VVXjFJ(self.pPath, ref, name)
 @staticmethod
 def VVB9xW(flag):
  t = c = ""
  try:
   if   flag & eServiceReference.isInvisible  : t, c = "Invisible"  , "#f#00ff7722#"
   elif flag & eServiceReference.isNumberedMarker : t, c = "Numbered Marker" , "#f#00ffffaa#"
   elif flag & eServiceReference.isGroup   : t, c = "Group"   , "#f#00bbffbb#"
   elif flag & eServiceReference.isMarker   : t, c = "Marker"   , "#f#00ffffaa#"
   elif flag & eServiceReference.isDirectory  : t, c = "Directory"  , ""
  except:
   pass
  return t, c
 @staticmethod
 def VVijn5(ref, mode=0):
  path = ""
  serv = eServiceReference(ref)
  if serv.valid():
   path = serv.getPath()
   if path and not VVBvqf:
    path = iSub(r"[&?]mode=.+end=", r"", path, flags=IGNORECASE)
   if mode == 1:
    span = iSearch(r'FROM\s+BOUQUET\s+"(.+)"\s+ORDER\s+BY\s+bouquet', path, IGNORECASE)
    if span:
     path = VVQe79 + span.group(1)
  return path
 @staticmethod
 def VVzO8e(ref):
  path = ""
  serv = eServiceReference(ref)
  if serv.valid():
   return serv.flags
  return -1
 @staticmethod
 def VVK7hm(default=0):
  VVCy6c = InfoBar.instance
  if VVCy6c:
   csel = VVCy6c.servicelist
   if csel:
    return csel.mode
  return default
 @staticmethod
 def VVfejw():
  VVCy6c = InfoBar.instance
  if VVCy6c:
   csel = VVCy6c.servicelist
   if csel:
    return csel.bouquet_rootstr
  return ""
 @staticmethod
 def VVr4pQ():
  return FFL19l(VV3W4d) if FFCyVu(VV3W4d) else []
 @staticmethod
 def VVAxzM(ref, lst=None):
  if not lst:
   lst = CCLSIv.VVr4pQ()
  if FFWpih(ref):
   ref1 = ref.replace("1:7:", "1:0:")
   ref2 = ref.replace("1:519:", "1:0:")
   if   ref1 in lst: return lst.index(ref1)
   elif ref2 in lst: return lst.index(ref2)
  return -1
class CCafIt(Screen, CCsyCY, CCa36K):
 VVwy9X   = 0
 VVMHWR  = 1
 VVQzY6  = 2
 VVxUTE  = 3
 VVmvJo  = 4
 VVR4LO  = 5
 VV6Rs1  = 6
 VV2tBs = 7
 VVKBzs = 8
 VV8XEV = 9
 VVEXya = 10
 VVfxSo  = 11
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVujxw, 1800, 950, 30, 0, 0, "#22201000", "#33000000", 30, VVeFSs=40, VV0Ay7=2, VVt3Ak=20, VVUuJZ={"rows":4, "cols":7, "picR":0.75, "lblR":0.25, "w1R":0.45, "w2R":0.55, "gapX":10, "gapY":10})
  self.session   = session
  self.Title    = "PIcons Tools"
  self.pPath    = CCafIt.VVjkKT()
  self.curChanName  = ""
  self.curChanFile  = ""
  self.curChanIndex  = -1
  self.curChanRefCode  = 0
  self.curChanIptvRef  = ""
  self.VVGape    = []
  self.nsList    = set()
  self.lastSortCol  = 0
  self.lastMode   = 0
  self.lastWords   = ['']
  self.lastAsPrefix  = False
  self.lastTimeStamp  = 0
  self.lastSTypeList  = []
  self.lastFind   = ""
  self.filterTitle  = ""
  self.firstTime   = True
  self.rTypeLst   = set()
  FFZMxC(self, self.Title)
  FFRLNq(self["keyRed"] , "OK = Zap")
  FFRLNq(self["keyYellow"], "Page Options")
  FFRLNq(self["keyBlue"] , "Filter")
  CCsyCY.__init__(self, CFG.transpColorPicons)
  CCa36K.__init__(self)
  FFBep1(self,
  {
   "ok"  : self.VVFWp4     ,
   "green"  : self.VVRX2k    ,
   "yellow" : self.VVb3d0     ,
   "blue"  : self.VVfmub     ,
   "menu"  : self.VVEzGg     ,
   "info"  : self.VVz0Rw    ,
   "cancel" : self.close
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  if self.firstTime:
   self.firstTime = False
   FF6W0I(self)
   FFWgBS(self)
   FFZ0AC(self["keyRed"], "#0a333333")
   self.VVCHVq()
   self.VVJf8n("Loading ...", mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, VVpQCY=True)
  else:
   self.VV4l5c()
   self.VVHvUS()
 def VVEzGg(self):
  if not self.VV6wbi:
   c1, c2 = VVSGsk, VVJEMb
   VV3wat = []
   VV3wat.append(("Statistics"          , "VVoNnq"    ))
   VV3wat.append(VVAL3j)
   VV3wat.append((c1 + "Suggest PIcons for Current Channel"   , "VVitxh"   ))
   VV3wat.append((c2 + "Set to Current Channel (copy file)"   , "VVWg3p_file"  ))
   VV3wat.append((c2 + "Set to Current Channel (as SymLink)"   , "VVWg3p_link"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Export Current File Names List"     , "VVDZB5" ))
   VV3wat.append(CCafIt.VVdmZZ())
   VV3wat.append(VVAL3j)
   c, cond = VVyFI2, self.filterTitle == "PIcons without Channels"
   VV3wat.append(FFsLU5("Move Unused PIcons to a Directory", "VVkeuU" , cond, c ))
   VV3wat.append(FFsLU5("DELETE Unused PIcons"    , "VVGnGr" , cond, c ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Delete Broken PIcons SymLinks (in PIcons Directory)" , "VVtFSa"  ))
   VV3wat.append(VVAL3j)
   VV3wat += CCafIt.VVC3jQ()
   VV3wat.append(VVAL3j)
   VV3wat.append(("Change Poster/Picon Transparency Color"    , "VVA2WD" ))
   VV3wat.append(("Keys Help"           , "VVOz5Q"    ))
   FFLFTC(self, self.VVeDfm, width=1100, height=1050, title=self.Title, VV3wat=VV3wat, VVwltY="#22001020", VVkxBG="#22001020")
 def VVeDfm(self, item=None):
  if item is not None:
   if   item == "VVoNnq"    : self.VVoNnq()
   elif item == "VVitxh"   : self.VVitxh()
   elif item == "VVWg3p_file"  : self.VVWg3p(0)
   elif item == "VVWg3p_link"  : self.VVWg3p(1)
   elif item == "VVDZB5"  : self.VVDZB5()
   elif item == "VVZxA1"  : CCafIt.VVZxA1(self)
   elif item == "VVkeuU"   : self.VVkeuU()
   elif item == "VVGnGr"  : self.VVGnGr()
   elif item == "VVtFSa"  : self.VVtFSa()
   elif item == "VVS8ig"  : CCafIt.VVS8ig(self)
   elif item == "findPiconBrokenSymLinks" : CCafIt.VVqb9O(self, True)
   elif item == "FindAllBrokenSymLinks" : CCafIt.VVqb9O(self, False)
   elif item == "VVA2WD" : self.VVA2WD()
   elif item == "VVOz5Q"     : FFw2rR(self, "_help_picons", "PIcons Tools (Keys Help)")
 def VVb3d0(self):
  if not self.VV6wbi:
   VV3wat = []
   VV3wat.append(("Go to First PIcon"  , "VVPhaY"  ))
   VV3wat.append(("Go to Last PIcon"   , "VVGc2k"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Sort by Channel Name"     , "sortByChan" ))
   VV3wat.append(("Sort by File Name"  , "sortByFile" ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Find from File List .." , "VVPBn1" ))
   FFLFTC(self, self.VVf9YF, title=self.Title, VV3wat=VV3wat)
 def VVf9YF(self, item=None):
  if item is not None:
   if   item == "VVPhaY"   : self.VVPhaY()
   elif item == "VVGc2k"   : self.VVGc2k()
   elif item == "sortByChan"  : self.VVc6bm(2)
   elif item == "sortByFile"  : self.VVc6bm(0)
   elif item == "VVPBn1"  : self.VVPBn1()
 def VVPBn1(self):
  VV3wat = []
  for item in self.VVGape:
   VV3wat.append((item[0], item[0]))
  FFLFTC(self, self.VVf9l1, title='PIcons ".png" Files', VV3wat=VV3wat, VVU8mZ=True)
 def VVf9l1(self, item=None):
  if item:
   txt, ref, ndx = item
   self.VVdLxd(ndx)
 def VVFWp4(self):
  if not self.VV6wbi and self["keyRed"].getVisible():
   filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
   if VVPxk5:
    CCqWM2.VVHc02(self.session, VVaHNe=VVPxk5)
 def VVRX2k(self):
  if self["keyGreen"].getVisible():
   self.VVdLxd(self.curChanIndex)
 def VVc6bm(self, col):
  reverseSort = self.lastSortCol == col
  self.lastSortCol = col
  self.VVJf8n("Sorting ...", mode=self.lastMode, words=self.lastWords, asPrefix=self.lastAsPrefix, reverseSort=reverseSort)
 def VVWg3p(self, mode):
  title = "Change Current Channel PIcon"
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  curChF = "%s%s.png" % (self.pPath, VVPxk5.replace(":", "_"))
  if VVPxk5:
   filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
   selPiconF = "%s%s"  % (self.pPath, filName)
   if not curChF == selPiconF:
    if FFCyVu(curChF):
     VV3wat = []
     VV3wat.append(("Overwrite current PIcon"    ,  "overwrite" ))
     VV3wat.append(('Rename current PIcon to ".bak.png"' ,  "backup" ))
     FFLFTC(self, BF(self.VVvHw6, mode, curChF, selPiconF), VV3wat=VV3wat, title="Current Channel PIcon (already exists)")
    else:
     self.VVvHw6(mode, curChF, selPiconF, "overwrite")
   else:
    FFdw58(self, "Cannot change PIcon to itself !", title=title)
  else:
   FFdw58(self, "Could not read current channel info. !", title=title)
 def VVvHw6(self, mode, curChF, selPiconF, item=None):
  if item is not None:
   cmd  = ""
   if item == "backup" : cmd += "mv -f '%s' '%s';" % (curChF, curChF + ".bak.png")
   else    : cmd += "rm -f '%s';" % curChF
   if mode == 0: cmd += "cp -f '%s' '%s'" % (selPiconF, curChF)
   else  : cmd += "ln -sf '%s' '%s'" % (selPiconF, curChF)
   FFpwZS(cmd)
   self.VVJf8n("PIcon Changed.\nRefreshing ...", goToFirst=False)
 def VVkeuU(self):
  defDir = FFoWxR(CCafIt.VVjkKT() + "picons_backup")
  FFpwZS("mkdir '%s'" % defDir)
  self.session.openWithCallback(BF(self.VV7yXU, defDir), BF(CClYaF
         , mode=CClYaF.VV9N82, VV1pbK=CCafIt.VVjkKT()))
 def VV7yXU(self, defDir, path):
  if len(path) > 0:
   title = "Move Unused PIcons"
   if path == CCafIt.VVjkKT():
    FFdw58(self, "Cannot move to same directory !", title=title)
   else:
    if not FFoWxR(path) == FFoWxR(defDir):
     self.VVLp78(defDir)
    FFRMYv(self, BF(self.VVJ3ic, title, defDir, path), "Move %d files to:\n\n%s" % (len(self.VVGape), path), title=title)
  else:
   self.VVLp78(defDir)
 @FFOAKH("Moving Files ...")
 def VVJ3ic(self, title, defDir, toPath):
  if not iMove:
   self.VVLp78(defDir)
   FFdw58(self, "Module not found:\n\nshutil", title=title)
   return
  toPath = FFoWxR(toPath)
  pPath = CCafIt.VVjkKT()
  err  = ""
  totOK = 0
  for fName, fType, VV1wIO, sat, inDB in self.VVGape:
   if fName:
    fName += ".png"
    From = "%s%s" % (pPath, fName)
    try:
     iMove(From, "%s%s" % (toPath, fName))
     totOK +=1
    except Exception as e:
     err  = "\nError while moving the file:\n   %s\n\n" % From
     err += "Error:\n   %s" % str(e)
     break
  txt  = "Files\t: %d\n" % len(self.VVGape)
  txt += "Moved\t: %d\n" % totOK
  txt += err
  FF4lCP(self, txt, title=title, VVemyB="#22330000" if err else "#22002020")
  if totOK > 0:
   self.VVBwh5("all")
 def VVLp78(self, defDir):
  try:
   os.rmdir(defDir)
  except:
   pass
 def VVGnGr(self):
  title = "Delete Unused PIcons"
  tot = len(self.VVGape)
  FFRMYv(self, BF(self.VVxSQo, title), "Delete %s unused PIcon file%s ?" % (tot, FFcacr(tot)), title=title)
 @FFOAKH("Deleting Files ...")
 def VVxSQo(self, title):
  pPath = CCafIt.VVjkKT()
  totErr = 0
  for fName, fType, VV1wIO, sat, inDB in self.VVGape:
   if fName:
    fName = "%s%s.png" % (pPath, fName)
    try:
     os.remove(fName)
    except:
     totErr += 1
  tot = len(self.VVGape)
  txt  = "Found\t: %d\n"  % tot
  txt += "Deleted\t: %d\n" % (tot - totErr)
  if totErr:
   txt += "Errors\t: %s" % FFjt5L(totErr, VVz22H)
  FF4lCP(self, txt, title=title)
 def VVtFSa(self):
  lines = FF3xOt("find -L '%s' -type l -print" % self.pPath)
  if lines:
   tot = len(lines)
   FFRMYv(self, BF(self.VVRV0F, lines), "\n".join(lines), title="Delete %d Broken SymLink%s ?" % (tot, FFcacr(tot)), VVAgUy=True)
  else:
   FFipXT(self, "No broken SymLinks in:\n\n%s" % self.pPath)
 def VVRV0F(self, fList):
  FFpwZS("find -L '%s' -type l -delete" % self.pPath)
  FFipXT(self, "Files deleted:\n\n%s" % "\n".join(fList), title=self.Title)
 @FFOAKH()
 def VVz0Rw(self):
  if self.VV6wbi:
   return
  txt = ""
  filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
  if filName:
   path = self.pPath + filName
   txt += FFjt5L("PIcon Directory:\n", VVGCYL)
   txt += "  Path\t: %s\n"  % self.pPath
   target = FFtu2k(self.pPath)
   if target:
    txt += "  Target\t: %s\n" % target
   txt += "\n"
   target = FFtu2k(path)
   txt += FFjt5L("PIcon File:\n", VVGCYL)
   if target:
    txt += "  SymLink\t: %s\n"   % filName
    txt += "  Target File\t: %s\n" % (os.path.dirname(target) + "/" + os.path.basename(target))
   else:
    txt += "  File\t: %s\n" % filName
   txt += "\n"
   slLst = []
   if not os.path.islink(FFVc4H(path)):
    OrigRealPath = os.path.realpath(path)
    for fName in os.listdir(self.pPath):
     fPath = os.path.join(self.pPath, fName)
     if os.path.islink(FFVc4H(fPath)):
      fRealPath = os.path.realpath(fPath)
      if fRealPath == OrigRealPath:
       slLst.append(fRealPath)
    if slLst:
     tot = len(slLst)
     txt += FFjt5L("Found %d SymLink%s to this file from:\n" % (tot, FFcacr(tot)), VVGCYL)
     for fPath in slLst:
      txt += "  %s\n" % FFjt5L(fPath, VVA4XU)
     txt += "\n"
   if VV1wIO:
    txt += FFjt5L("Channel:\n", VVGCYL)
    if VVPxk5:
     txt += "  Reference\t: %s\n" % (VVPxk5)
    txt += "  Channel\t: %s\n" % FFjt5L(VV1wIO, VVSGsk)
    if sat and not sat == "IPTV":
     txt += "  Satellite\t: %s" % sat
   elif not slLst:
    txt += FFjt5L("Remarks:\n", VVGCYL)
    txt += "  %s\n" % FFjt5L("Unused", VVz22H)
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVga62, title="Picon Info", params=(VVPxk5, VV1wIO, txt, self.pPath + filName))
 def VVaWmO(self):
  fName = VVPxk5 = VV1wIO = sat = inDB = ""
  if self.VVBGsZ > -1 and self.VVBGsZ < self.VVbKuB:
   fName, fType, VV1wIO, sat, inDB = self.VVGape[self.VVBGsZ]
   if fName.count("_") > 8 : VVPxk5 = fName.replace("_", ":").upper()
   else     : VVPxk5 = ""
   fName += ".png"
   sat  = FFR9yH(sat)
  return fName, VVPxk5, VV1wIO, sat, inDB
 def VV4l5c(self):
  vLst = ("myPiconF", "myPiconBG", "myPiconPic")
  for v in vLst: self[v].hide()
  self["keyGreen"].hide()
  self.curChanName = ""
  self.curChanFile = ""
  self.curChanIndex = -1
  self.curChanRefCode = ""
  self.curChanIptvRef = ""
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  if VVPxk5:
   self.curChanRefCode = VVPxk5
   self.curChanName = VV1wIO
   self.curChanIptvRef = VVfaDB
   path = CCafIt.VVXjFJ(self.pPath, VVPxk5, VV1wIO)
   if path:
    self.curChanFile = os.path.splitext(os.path.basename(path))[0]
    if FFBFPY(self["myPiconPic"], path):
     for v in vLst: self[v].show()
    for ndx, item in enumerate(self.VVGape):
     if item[0] == self.curChanFile:
      self.curChanIndex = ndx
      if self.curChanFile.startswith(os.path.splitext(VVPxk5)[0].replace(":", "_")) : txt = "Current Service"
      else                   : txt = "Current PIcon"
      self["keyGreen"].show()
      self["keyGreen"].setText(txt)
      break
 def VVHvUS(self):
  title = "  " + self.Title
  if self.filterTitle:
   title += "  ..  Filter = " + self.filterTitle
  if len(title) > 65:
   title = title[:65] + ".."
  self["myTitle"].setText(title)
  tabLft = " " * 4
  filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
  fNum = "Num. : %d / %d" % (self.VVBGsZ + 1, self.VVbKuB)
  page = "Page: %d / %d"  % (self.VVSmMg + 1, self.VVUeUp)
  self["myPiconInf0"].setText(FFjt5L("%s%s%s%s" % (tabLft, fNum, " " * 12, page), VVGCYL))
  self["myPiconInf1"].setText("%sFile : %s" % (tabLft, filName))
  self["myPiconInf2"].setText("%sRef. : %s" % (tabLft, self.VVaWmO()[1]))
  if self.curChanIptvRef : typ = "Stream Relay" if FFHgaY(self.curChanIptvRef) else "IPTV"
  else     : typ = "Current Ch."
  self["myPiconInf3"].setText("%s%s : %s" % (tabLft, typ, FFjt5L(self.curChanName, VV1fx4)))
  self["myPiconInf4"].setText("%sFile : %s\n" % (tabLft, (self.curChanFile + ".png")))
  self["myPiconInf5"].setText("%sRef. : %s" % (tabLft, self.curChanRefCode))
  filName, VVPxk5, VV1wIO, sat, inDB = self.VVaWmO()
  if inDB and not sat == "IPTV" : self["keyRed"].show()
  else       : self["keyRed"].hide()
 @FFOAKH()
 def VVoNnq(self):
  VVY1oT, VVvwHc = FF07Sg()
  sTypeNameDict = {}
  for key, val in VVvwHc.items():
   sTypeNameDict[key] = 0
  totUsedFiles = 0
  totUsedLinks = 0
  totSymLinks  = 0
  totInDB   = 0
  totNoRefCode = 0
  totNoSType  = 0
  sTypeDict  = {}
  for fName, fType, VV1wIO, sat, inDB in self.VVGape:
   if VV1wIO:
    if fType == 0 : totUsedFiles += 1
    else   : totUsedLinks += 1
   if fType == 1:
    totSymLinks += 1
   if inDB == 1:
    totInDB += 1
   span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
   if span:
    stNum = int(span.group(1), 16)
    if stNum in VVvwHc: sTypeDict[VVvwHc[stNum]] = sTypeDict.get(VVvwHc[stNum], 0) + 1
    else     : totNoSType += 1
   else:
    totNoRefCode += 1
  totBrokSL = FFTKR0("find -L '%s' -type l -print | wc -l" % self.pPath)
  VVAkuK = []
  c = "#b#11003333#"
  VVAkuK.append((c + "PIcons" , "%d\tUsed = %s" % (self.VVbKuB, totUsedFiles + totUsedLinks)))
  VVAkuK.append((c + "Files" , "%d\tUsed = %s" % (self.VVbKuB - totSymLinks, totUsedFiles)))
  VVAkuK.append((c + "SymLinks" , "%d\tUsed = %s" % (totSymLinks, totUsedLinks)))
  c = "#b#11004040#"
  VVAkuK.append((c + "In Database (lamedb)"  , str(totInDB)))
  VVAkuK.append((c + "Not In Database (lamedb)" , str(self.VVbKuB - totInDB)))
  VVAkuK.append((c + "Satellites"    , str(len(self.nsList))))
  VVAkuK.append((c + "Broken SymLinks"   , str(totBrokSL)))
  if totNoRefCode : VVAkuK.append((c + "File name is not a Reference Code" , str(totNoRefCode)))
  if totNoSType : VVAkuK.append((c + "Unknown Service Type"    , str(totNoSType)))
  s = "Service Type "
  if sTypeDict:
   sTypeRows = []
   for key, val in sTypeDict.items():
    sTypeRows.append(("Service Type (%s)" % key, str(val)))
   sTypeRows.sort(key=lambda x: x[0].lower())
   VVAkuK.extend(sTypeRows)
  FFUQ0v(self, None, title=self.Title, VVGape=VVAkuK, VVwdmN=28, VVJKqd="#00003333", VVbcr0="#00222222")
 def VVDZB5(self):
  if self.filterTitle:
   txt = FFfCtV(self.filterTitle, r"_")
   txt = "FilteredBy_%s_" % FFMYNg(txt, "_")
  else:
   txt = "All_"
  path = "%sPIconsList_%s%s.txt" % (FFeAlZ(), txt, FFjTQe())
  with open(path, "w") as f:
   for fName, fType, VV1wIO, sat, inDB in self.VVGape:
    f.write("%s%s.png\n" % (self.pPath, fName))
  FFipXT(self, "List exported to file:\n\n%s" % path, title=self.Title)
 def VVfmub(self):
  if not self.VV6wbi:
   VV3wat = []
   VV3wat.append(("All"        , "all"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Used by Channels"     , "used" ))
   VV3wat.append(("Unused PIcons"     , "unused" ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("PIcons Files (no SymLinks)"  , "pFiles" ))
   VV3wat.append(("SymLinks to PIcons"    , "pLinks" ))
   VV3wat.append(("PIcons Files Targeted by SymLinks", "pTargets"))
   VV3wat.append(("By Files Date ..."    , "pDate" ))
   VV3wat.append(("By Service Type ..."    , "servType"))
   if self.rTypeLst:
    VV3wat.append(("Reference Type ..."   , "rType" ))
   if self.nsList:
    VV3wat.append(FF0bQE("Satellites (Reference in PIcon name)"))
    satsHex = list(self.nsList)
    satsHex.sort()
    for sHex in satsHex:
     val = int(sHex, 16)
     if val > 0:
      sat = FFS0T2(val)
      VV3wat.append((sat, "__s__" + sHex + "__sat__" + sat))
   filterObj = CCoErY(self)
   filterObj.VVywN2(VV3wat, self.nsList, self.VVp3gu)
 def VVp3gu(self, item=None):
  if item is not None:
   self.VVBwh5(item)
 def VVBwh5(self, item=None):
   if   item == "all"    : mode, words, self.filterTitle = self.VVwy9X   , ""  , ""
   elif item == "used"    : mode, words, self.filterTitle = self.VVMHWR   , ""  , "PIcons with Channels"
   elif item == "unused"   : mode, words, self.filterTitle = self.VVQzY6  , ""  , "PIcons without Channels"
   elif item == "pFiles"   : mode, words, self.filterTitle = self.VVxUTE  , ""  , "PIcons Files"
   elif item == "pLinks"   : mode, words, self.filterTitle = self.VVmvJo  , ""  , "SymLinks"
   elif item == "pTargets"   : mode, words, self.filterTitle = self.VVR4LO  , ""  , "Targets"
   elif item == "pDate"   : mode, words, self.filterTitle = self.VV8XEV , ""  , "Date"
   elif item == "servType"   : mode, words, self.filterTitle = self.VVEXya , ""  , "Service Type"
   elif item == "rType"   : mode, words, self.filterTitle = self.VVfxSo  , ""  , "Reference Type"
   elif item.startswith("__s__") : mode, words, self.filterTitle = self.VV6Rs1   , item[5:].split("__sat__")[0] , item[5:].split("__sat__")[1]
   elif item.startswith("__w__") : mode, words, self.filterTitle = self.VV2tBs , item[5:] , item[5:]
   else       : return
   asPrefix = self.lastAsPrefix
   if mode == self.VVR4LO:
    words = []
    pngFiles = self.pPath + "*.png"
    lines = FF3xOt("find %s -type l | while read -r FILE; do if [ -L \"$FILE\" ] && [ -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=$10=\"\";print}' | xargs; fi; done" % pngFiles)
    if lines:
     for f in lines:
      fName = FFxtW5(f)
      if fName.endswith(".png"):
       fName = fName[:-4]
       words.append(fName)
    if not words:
     FF28n1(self, "Not found", 1000)
     return
   elif mode == self.VV8XEV:
    self.VVbdHZ(mode)
    return
   elif mode == self.VVEXya:
    self.VVyBU7(mode)
    return
   elif mode == self.VVfxSo:
    err = self.VV1EaD(mode, self.filterTitle)
    if err: FF28n1(self, "No valid Reference Type", 1000)
    return
   elif mode == self.VVKBzs:
    return
   else:
    words, asPrefix = CCoErY.VVPBNm(words)
   if not words and mode in (self.VV6Rs1, self.VV2tBs):
    FF28n1(self, "Incorrect filter", 2000)
   elif not self.lastMode == mode or not self.lastWords == words or not self.lastAsPrefix == asPrefix:
    self.VVJf8n("Filtering ...", mode=mode, words=words, asPrefix=asPrefix)
 def VVbdHZ(self, mode):
  VV3wat = []
  VV3wat.append(("Today"   , "today" ))
  VV3wat.append(("Since Yesterday" , "yest" ))
  VV3wat.append(("Since 7 days"  , "week" ))
  FFLFTC(self, BF(self.VVtVEv, mode), VV3wat=VV3wat, title="Filter by Added/Modified Date")
 def VVtVEv(self, mode, item=None):
  if item:
   if   item == "today": stamp, self.filterTitle = FFZVA0(0) , "Today"
   elif item == "yest" : stamp, self.filterTitle = FFZVA0(-1), "Yesterday"
   elif item == "week" : stamp, self.filterTitle = FFZVA0(-7), "Last 7 Days"
   self.filterTitle = "File Date (%s)" % self.filterTitle
   if not self.lastMode == mode or not self.lastTimeStamp == stamp:
    self.VVJf8n("Filtering ...", mode=mode, timeStamp=stamp)
 def VV1EaD(self, mode, title):
  FFLFTC(self, BF(self.VVd5SW, mode), VV3wat=[(x,x) for x in sorted(list(self.rTypeLst))], width=400, title=title)
 def VVd5SW(self, mode, rt=None):
  if rt and (mode, [rt]) != (self.lastMode, self.lastWords):
   self.VVJf8n("Filtering ...", mode=mode, words=[rt])
 def VVyBU7(self, mode):
  VVY1oT, VVvwHc = FF07Sg()
  lst = set()
  for key, val in VVvwHc.items():
   lst.add(val)
  VV3wat = []
  for item in lst:
   VV3wat.append((item, item))
  VV3wat.sort(key=lambda x: x[0])
  FFLFTC(self, BF(self.VVdDA1, mode), VV3wat=VV3wat, title="Filter by Service Type")
 def VVdDA1(self, mode, item=None):
  if item:
   VVY1oT, VVvwHc = FF07Sg()
   sTypeList = []
   for key, val in VVvwHc.items():
    if item == val:
     self.filterTitle = val
     sTypeList.append(("%01x" % key).upper())
   if not self.lastMode == mode or not self.lastSTypeList == sTypeList:
    self.VVJf8n("Filtering ...", mode=mode, sTypeList=sTypeList)
 def VVitxh(self):
  CCh3tv.VV7Nf4(self
      , VVixvy  = self.VVNBsa
      , VVbYwR = self.VVDSFM)
 def VVNBsa(self, VVXyP6):
  VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVXNWJ, VVXwzE=False, VV49Lf=False)
  files = []
  words = []
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  VVXyP6.VVNc18 = []
  VVXyP6.VVq8NF(len(VVHj48))
  if VVHj48:
   curCh = self.VVBgSG(self.curChanName)
   for VVPxk5 in VVHj48:
    if not VVXyP6 or VVXyP6.isCancelled: return
    VVXyP6.VVxtQs(1, True)
    VV1wIO, sat, inDB = VVHj48.get(VVPxk5, ("", "", 0))
    ratio = CCafIt.VV8e0X(VV1wIO.lower(), curCh)
    if ratio > 50:
     allPath, fName, VVy4K7, pList = CCafIt.VV6Tzh(VVPxk5.replace("_", ":"), self.curChanName, addSimilar=True)
     if pList:
      for f in pList:
       f = FFxtW5(f)
       fil = f.replace(".png", "")
       if not VVXyP6 or VVXyP6.isCancelled: return
       if not fil in VVXyP6.VVNc18:
        VVXyP6.VVNc18.append(fil)
 def VVDSFM(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if VVNc18 : self.VVJf8n("Loading ...", mode=self.VVKBzs, words=VVNc18)
  else   : FF28n1(self, "Not found", 2000)
 @FFOAKH(tNdx=1)
 def VVJf8n(self, wTxt, mode=0, words=None, asPrefix=False, reverseSort=False, VVpQCY=False, goToFirst=True, timeStamp=None, sTypeList=None):
  if not self.VV8nAD(VVpQCY):
   return
  self.VV6wbi = True
  VV49Lf = True if VVpQCY else False
  VVHj48, err = CCYrUm.VVJud0(self, CCYrUm.VVXNWJ, VVXwzE=False, VV49Lf=VV49Lf)
  if err:
   self.close()
  VVf1kq = self.VVKwNf()
  tList = []
  for fName, fType in CCafIt.VVq4T1(self.pPath):
   fName = fName[:-4]
   namSp = ""
   if fName.count("_") > 8 and VVHj48:
    if fName in VVHj48:
     VV1wIO, sat, inDB = VVHj48.get(fName)
     VV1wIO = VV1wIO or "?"
     namSp = fName.split("_")[6].zfill(8)[:4]
     if VVpQCY and namSp: self.nsList.add(namSp)
    elif fName in VVf1kq:
     VV1wIO = VVf1kq.get(fName) or "?"
     sat, inDB = "IPTV", 1
    else:
     VV1wIO, sat, inDB = "", "", 0
    if VVpQCY:
     span = iSearch(r"^([a-f0-9]+)(?:_[a-f0-9]+){9}", fName, IGNORECASE)
     if span: self.rTypeLst.add(span.group(1))
   else:
    VV1wIO, sat, inDB = "", "", 0
   entry = (fName, fType, VV1wIO, sat, inDB)
   isAdd = False
   if mode == self.VVwy9X              : isAdd = True
   elif mode == self.VVMHWR  and VV1wIO         : isAdd = True
   elif mode == self.VVQzY6 and not VV1wIO        : isAdd = True
   elif mode == self.VVxUTE  and fType == 0        : isAdd = True
   elif mode == self.VVmvJo  and fType == 1        : isAdd = True
   elif mode == self.VVR4LO  and fName in words       : isAdd = True
   elif mode == self.VVKBzs and fName in words       : isAdd = True
   elif mode == self.VV6Rs1  and namSp.lower() == words[0]    : isAdd = True
   elif mode == self.VV2tBs:
    if asPrefix:
     if any(VV1wIO.lower().startswith(x) for x in words)       : isAdd = True
    elif any(x in VV1wIO.lower() for x in words)         : isAdd = True
   elif mode == self.VV8XEV:
    try:
     if os.stat("%s%s.png" % (self.pPath, fName)).st_ctime >= timeStamp   : isAdd = True
    except:
     pass
   elif mode == self.VVEXya:
    span = iSearch(r"(?:[A-Fa-f0-9]+_){2}([A-Fa-f0-9]+)(?:_[A-Fa-f0-9]+){7}", fName, IGNORECASE)
    if span and span.group(1) in sTypeList           : isAdd = True
   elif mode == self.VVfxSo:
    if iMatch(r"^(%s(?:_[a-f0-9]+){9})" % words[0], fName, IGNORECASE)    : isAdd = True
   if isAdd:
    tList.append(entry)
  if tList:
   self.VVGape   = list(tList)
   tList    = None
   self.lastMode  = mode
   self.lastWords  = words
   self.lastAsPrefix = asPrefix
   self.lastTimeStamp = timeStamp
   self.lastSTypeList = sTypeList
  else:
   self.VV6wbi = False
   FFjADj(self, "Not found", 1000)
   return
  self.VVGape.sort(key=lambda x: x[self.lastSortCol], reverse=reverseSort)
  self.VV4l5c()
  self.VVbKuB = len(self.VVGape)
  self.VVUeUp = int(self.VVbKuB / self.VVg3d5) + (self.VVbKuB % self.VVg3d5 > 0)
  if goToFirst:
   self.VVSmMg = 0
   self.curRow  = 0
   self.curCol  = 0
   self.VVBGsZ = 0
   self.VVcG7K = 0
   self.VVGCBk = 0
  self.VV6wbi = False
  self.VVLckG(True)
 def VV8nAD(self, VVpQCY):
  if FFCyVu(self.pPath):
   for fName, fType in CCafIt.VVq4T1(self.pPath):
    if fName:
     return True
   if VVpQCY : FFdw58(self, 'No ".png" files in path:\n\n%s' % self.pPath, title=self.Title)
   else   : FF28n1(self, "Not found", 1000)
  else:
   FFdw58(self, "PIcons path not found.\n\n%s" % self.pPath)
  if VVpQCY:
   self.close()
  return False
 def VVKwNf(self):
  VVAkuK = {}
  files  = CCkEI5.VVjMS6()
  if files:
   for path in files:
    txt = FFYVq0(path)
    list = iFindall(r"#SERVICE\s+([A-Fa-f0-9]+:0:(?:[A-Fa-f0-9]+[:]){8}).+\n#DESCRIPTION\s+(.+)", txt, IGNORECASE)
    if list:
     for item in list:
      VVPxk5 = item[0].upper().replace(":", "_").strip("_")
      VVAkuK[VVPxk5] = item[1]
  return VVAkuK
 def VVe4Ro(self):
  self.VVaFRk()
  f1, f2 = self.VVS7BN()
  row = col = 0
  for ndx in range(f1, f2):
   fName, fType, VV1wIO, sat, inDB = self.VVGape[ndx]
   fName = self.VVGape[ndx][0]
   path  = self.pPath + fName + ".png"
   VVPxk5  = fName.replace("_", ":").upper()
   pic, lbl = self.VVwbpA(row, col)
   ok = self.VVaJVd(ndx, row, col, pic, path)
   if ok   : color = VVSGsk if inDB else ""
   elif not VV1wIO : color = ""
   else   : color = VVcPtB
   self.VVExY8(lbl, VV1wIO or "-", color)
   self.VVcG7K = row
   self.VVGCBk = col
   col += 1
   if col > (self.VVsHeH - 1):
    col = 0
    row += 1
 @staticmethod
 def VV8e0X(s1, s2):
  row = -1
  rows, cols, dist = len(s1) + 1, len(s2) + 1, []
  for i in range(rows): dist.append([0.] * cols)
  for i in range(1, rows):
   for j in range(1,cols): dist[i][0], dist[0][j] = i, j
  for col in range(1, cols):
   for row in range(1, rows):
    cost = 0 if s1[row-1] == s2[col-1] else 2
    dist[row][col] = min(dist[row-1][col] + 1, dist[row][col-1] + 1, dist[row-1][col-1] + cost)
  return int( ( ( len(s1) + len(s2) ) - dist[row][col] ) / ( len(s1) + len(s2) ) * 100 ) if row != -1 else 0
 @staticmethod
 def VVdmZZ():
  return ("Export Current Channel PIcon File", "VVZxA1")
 @staticmethod
 def VVC3jQ():
  VV3wat = []
  VV3wat.append(("Find SymLinks (to PIcon Directory)"   , "VVS8ig"  ))
  VV3wat.append(("Find Broken SymLinks (to PIcon Directory)" , "findPiconBrokenSymLinks" ))
  VV3wat.append(("Find all Broken SymLinks"      , "FindAllBrokenSymLinks" ))
  return VV3wat
 @staticmethod
 def VVZxA1(SELF):
  png, path = CCafIt.VV81vh(CC3rDi(SELF.session).VVXbok)
  if path : CCafIt.VVqLQB(SELF, png, path)
  else : FFdw58(SELF, "No PIcon found for current channel in:\n\n%s" % CCafIt.VVjkKT())
 @staticmethod
 def VVS8ig(SELF):
  if VV1fx4:
   sed1 = FFSPDv("->", VV1fx4)
   sed2 = FFSPDv("picon", VVz22H)
   sed3 = r"| sed 's/... Broken Link/\\t\\%s&\%s/gI'" % (VVcPtB, VVwdUw)
  else:
   sed1 = sed2 = sed3 = ""
  grep = "| grep -i 'picon'"
  FFXD60(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then BROK='... Broken Link'; else BROK=''; fi; ls -l \"$FILE\" 2> /dev/null | sed \"s/$/${BROK}/\" | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; done %s %s %s" % (FF5W9s(1), grep, sed1, sed2, sed3))
 @staticmethod
 def VVqb9O(SELF, isPIcon):
  sed1 = FFSPDv("->", VVcPtB)
  if isPIcon:
   grep = "| grep -i 'picon'"
   sed2 = FFSPDv("picon", VVz22H)
  else:
   grep = "| grep -v /proc | grep -v /run | grep -v /etc/rcS.d"
   sed2 = ""
  FFXD60(SELF, "find / %s -type l %s | while read -r FILE; do if [ -L \"$FILE\" ] && [ ! -e \"$FILE\" ]; then ls -l \"$FILE\" 2> /dev/null | awk '{$1=$2=$3=$4=$5=$6=$7=$8=\"\";print}' | xargs; fi; done %s %s" % (FF5W9s(1), grep, sed1, sed2))
 @staticmethod
 def VVqLQB(SELF, png, path):
  dest = FFriZ7()
  andTxt = "echo -e 'PIcon file copied to:\n\n%s%s' %s" % (dest, png, FFSPDv("%s%s" % (dest, png), VVSGsk))
  errTxt = "Could not copy PIcon file!"
  orTxt = "echo -e '%s' %s" % (errTxt, FFSPDv(errTxt, VVYjI5))
  cmd = "cp -f '%s' '%s' &> /dev/null && %s || %s" % (path, dest, andTxt, orTxt)
  FFZQVC(SELF, cmd)
 @staticmethod
 def VVq4T1(path):
  for f in os.listdir(path):
   if f.endswith(".png"):
    p = path + f
    if os.path.islink(FFVc4H(p)) and os.path.exists(p) : yield f , 1
    elif os.path.isfile(p)          : yield f , 0
 @staticmethod
 def VVjkKT():
  return FFoWxR(CFG.PIconsPath.getValue())
 @staticmethod
 def VV81vh(VVPxk5, VV1wIO=""):
  if FFUPnc(VVPxk5):
   VVPxk5, VVZcRP, VV57TX, VVfaDB = CC3rDi.VVGg6H(VVPxk5)
  allPath, fName, VVy4K7, pList = CCafIt.VV6Tzh(VVPxk5, VV1wIO)
  if pList:
   if VVy4K7 : return fName, VVy4K7
   else   : return fName, pList[0]
  else:
   return "", ""
 @staticmethod
 def VVXjFJ(pPath, VVPxk5, VV1wIO):
  span = iSearch(r"^((?:[a-f0-9]+:){9}(?:[a-f0-9]+))", VVPxk5.strip(), IGNORECASE)
  if span:
   exts = ("png", "jpg")
   VVPxk5 = span.group(1).replace(":", "_")
   tPath = "%s%s." % (pPath, VVPxk5)
   for ext in exts:
    path = tPath + ext
    if FFCyVu(path):
     return path
   refParts = VVPxk5.split("_", 1)
   for rType in CCkEI5.VV5LSJ():
    if not rType == refParts[0]:
     for ext in exts:
      path = "%s%s_%s.%s" %  (pPath, rType, refParts[1], ext)
      if FFCyVu(path):
       return path
   VV1wIO = FFzBfi(VV1wIO)
   VV1wIO1 = VV1wIO.replace(" ", "")
   for name in (VV1wIO, VV1wIO.lower(), VV1wIO.upper(), VV1wIO1.lower(), VV1wIO1.upper()):
    for ext in exts:
     path = "%s%s.%s" % (pPath, name, ext)
     if FFCyVu(path):
      return path
  return ""
 @staticmethod
 def VV6Tzh(VVPxk5, VV1wIO, addSimilar=False):
  allPath = fName = VVy4K7 = pList = None
  if VVPxk5.count(":") > 8:
   VVPxk5 = VVPxk5.rstrip(":")
   fName = VVPxk5.strip()
   fName = fName.rstrip(":")
   fName = VVPxk5.replace(":", "_") + ".png"
   allPath = CCafIt.VVjkKT()
   pList = []
   lst = FFkzic(allPath, "*_" + "_".join(fName.split("_")[3:]))
   if lst:
    pList += lst
   if VV1wIO:
    pList.extend(CCafIt.VVKnlA(FFzBfi(VV1wIO), addSimilar=addSimilar))
   VVy4K7 = ""
   if pList:
    for item in pList:
     if fName == FFxtW5(item):
      VVy4K7 = item
    pList.sort()
  return allPath, fName, VVy4K7, pList
 @staticmethod
 def VVKnlA(VV1wIO, addSimilar=False):
  lst  = []
  pPath = CCafIt.VVjkKT()
  if VVmJwX(pPath):
   VV1wIO = VV1wIO.lower()
   exts = ("png", "jpg")
   fLst = os.listdir(pPath)
   if addSimilar:
    for s in ("sd", "hd", "hd+", "fhd", "fhd+", "4k", "tv"):
     VV1wIO = VV1wIO.replace(s, "")
    VV1wIO = VV1wIO.strip()
    for x in fLst:
     tName = x[:-4].lower()
     if (VV1wIO in tName or tName in VV1wIO) and x[-3:] in exts:
      lst.append(x)
   else:
    lst = [x for x in fLst if VV1wIO == x[:-4].lower() and x[-3:] in exts]
  return lst
class CCOZ3M():
 def __init__(self):
  self.VVS566()
 def VVS566(self):
  noService = "No data"
  self.VV8Jvc = ""
  self.VVM9tN  = noService
  self.VVlbWC = 0
  self.VVJVEp  = noService
  self.VVFl8C = 0
  self.VVFMtk  = "-"
  self.VVek6Y = 0
  self.VVH03T  = ""
  self.serviceName = ""
  self.infoAvailable = False
  self.VVo5l5  = None
 def VVAo5r(self, service):
  self.VVS566()
  if service:
   feinfo = service.frontendInfo()
   if feinfo:
    self.infoAvailable = True
    frontEndStatus = feinfo.getFrontendStatus()
    if frontEndStatus:
     self.VVo5l5 = frontEndStatus
     self.VVJima()
   info = service.info()
   if info:
    self.serviceName = info.getName()
 def VVJima(self):
  if self.VVo5l5:
   val = self.VVo5l5.get("tuner_signal_quality_db", 0x12345678)
   if val is not None and val != 0x12345678: self.VV8Jvc = "%3.02f dB" % (val / 100.0)
   else         : self.VV8Jvc = ""
   val = self.VVo5l5.get("tuner_signal_quality", 0) * 100 / 65536
   self.VVlbWC = int(val)
   self.VVM9tN  = "%d%%" % val
   val = self.VVo5l5.get("tuner_signal_power" , 0) * 100 / 65536
   self.VVFl8C = int(val)
   self.VVJVEp  = "%d%%" % val
   val = self.VVo5l5.get("tuner_bit_error_rate", 0)
   if not val:
    val = 0
   self.VVFMtk  = "%d" % val
   val = int(val * 100 / 500)
   self.VVek6Y = min(500, val)
   val = self.VVo5l5.get("tuner_locked", 0)
   if val == 1 : self.VVH03T = "Locked"
   else  : self.VVH03T = "Not locked"
 def VVSwl4(self)   : return self.VV8Jvc
 def VVlX6a(self)   : return self.VVM9tN
 def VVRpcw(self)  : return self.VVlbWC
 def VVr4Yo(self)   : return self.VVJVEp
 def VVX9tR(self)  : return self.VVFl8C
 def VVU8EL(self)   : return self.VVFMtk
 def VVZwV4(self)  : return self.VVek6Y
 def VVO1mH(self)   : return self.VVH03T
 def VVvVTk(self) : return self.serviceName
class CC3Z54():
 def __init__(self):
  self.sat1 = self.sat2 = self.freq = self.sr = self.syst = self.inv = self.pol = self.fec    = ""
  self.mod = self.rolof = self.pil = self.plsMod = self.plsCod = self.iStId = self.t2PlId = self.t2PId = ""
  self.data  = None
  self.namespace = ""
  self.txMedia = ""
  self.D_POL  = {0:"Horizontal" , 1:"Vartical" , 2:"Left" , 3:"Right"}
  self.D_SYS_S = {0:"DVB-S", 1:"DVB-S2"}
  self.D_SYS_T = {0:"DVB-T", 1:"DVB-T2"}
  self.D_SYS_C = {0:"DVB-C", 1:"DVB-C2", 2:"DVB-C3", 3:"ATSC"}
  self.D_PIL_INV = {0:"Off" , 1:"On" , 2:"Auto"}
  self.D_PLS_MOD = {0:"Root" , 1:"Gold" , 2:"Combo" , 3:"Unknown"}
  self.D_ROLOF = {0:"35%" , 1:"25%" , 2:"20%" , 3:"Auto"}
  self.D_MOD  = {0:"Auto" , 1:"QPSK" , 2:"8PSK" , 3:"QAM16" , 4:"16APSK", 5:"32APSK"}
  self.D_FEC  = {0:"Auto" , 1:"1/2" , 2:"2/3" , 3:"3/4" , 4:"5/6" , 5:"7/8", 6:"8/9", 7:"3/5", 8:"4/5", 9:"9/10", 10:"6/7", 15:"None"}
  self.FREQ  = "frequency"
  self.SR   = "symbol_rate"
  self.POL  = "polarization"
  self.FEC  = "fec_inner"
  self.ORPOS  = "orbital_position"
  self.SYST  = "system"
  self.INV  = "inversion"
 def VVH3lH(self, VVPxk5):
  self.data = None
  if not VVPxk5: return
  self.namespace = FFARk6(VVPxk5)
  if   self.namespace.startswith("EEEE") : self.txMedia, syst = "DVB-T", self.D_SYS_T
  elif self.namespace.startswith("FFFF") : self.txMedia, syst = "DVB-C", self.D_SYS_C
  else         : self.txMedia, syst = "DVB-S", self.D_SYS_S
  servRef = eServiceReference(VVPxk5)
  if servRef:
   info = eServiceCenter.getInstance().info(servRef)
   if info:
    self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
    if self.data:
     self.sat1  = self.VVBvvD(self.ORPOS  , mod=1   )
     self.sat2  = self.VVBvvD(self.ORPOS  , mod=2   )
     self.freq  = self.VVBvvD(self.FREQ  , mod=3   )
     self.sr   = self.VVBvvD(self.SR   , mod=4   )
     self.inv  = self.VVBvvD(self.INV  , self.D_PIL_INV)
     self.pol  = self.VVBvvD(self.POL  , self.D_POL )
     self.fec  = self.VVBvvD(self.FEC  , self.D_FEC )
     self.syst  = self.VVBvvD(self.SYST  , syst   )
     if "S2" in self.syst:
      self.mod = self.VVBvvD("modulation" , self.D_MOD )
      self.rolof = self.VVBvvD("rolloff"  , self.D_ROLOF )
      self.pil = self.VVBvvD("pilot"   , self.D_PIL_INV)
      self.plsMod = self.VVBvvD("pls_mode"  , self.D_PLS_MOD)
      self.plsCod = self.VVBvvD("pls_code"  )
      self.iStId = self.VVBvvD("is_id"   )
      self.t2PlId = self.VVBvvD("t2mi_plp_id" )
      self.t2PId = self.VVBvvD("t2mi_pid"  )
 def VVBvvD(self, key, valDict=None, mod=0):
  val = self.data.get(key, "?")
  if   val in ("?", -1) : return ""
  elif valDict   : return valDict.get(val, str(val))
  elif mod == 1   : return FFS0T2(val)
  elif mod == 2   : return FFycBE(val)
  elif mod == 3   : return str(int(val) // 1000)
  elif mod == 4   : return str(int(val) // 1000)
  else     : return str(val)
 def VVQh97(self, refLst):
  for VVPxk5 in refLst:
   self.VVH3lH(VVPxk5)
   if self.data: break
  txt = ""
  if self.data:
   def VVJi7Q(subj, val):
    if val : return "%s\t: %s\n" % (subj, val)
    else : return ""
   if self.txMedia == "DVB-S":
    txt += VVJi7Q("System"   , self.syst)
    txt += VVJi7Q("Satellite"  , self.sat2)
    txt += VVJi7Q("Frequency"  , self.freq)
    txt += VVJi7Q("Inversion"  , self.inv)
    txt += VVJi7Q("Symbol Rate"  , self.sr)
    txt += VVJi7Q("Polarization" , self.pol)
    txt += VVJi7Q("FEC"    , self.fec)
    if "S2" in self.syst:
     txt += VVJi7Q("Modulation" , self.mod)
     txt += VVJi7Q("Roll-Off" , self.rolof)
     txt += VVJi7Q("Pilot"  , self.pil)
     txt += VVJi7Q("Input Stream", self.iStId)
     txt += VVJi7Q("T2MI PLP ID" , self.t2PlId)
     txt += VVJi7Q("T2MI PID" , self.t2PId)
     txt += VVJi7Q("PLS Mode" , self.plsMod)
     txt += VVJi7Q("PLS Code" , self.plsCod)
   else:
    txt += VVJi7Q("System"   , self.txMedia)
    txt += VVJi7Q("Frequency"  , self.freq)
  return txt, self.namespace
 def VVsDkA(self, refLst, maxLen=0, nonTxt="-"):
  for VVPxk5 in refLst:
   self.VVH3lH(VVPxk5)
   if self.data: break
  if self.data:
   if self.txMedia == "DVB-S":
    txt1, txt2, txt3 = ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip(), "  ", self.sat2.strip()
    len1, len2, len3 = len(txt1), 2, len(txt3)
    if maxLen and (len1 + len2 + len3 > maxLen):
     txt3 = txt3[:maxLen - len1 - len2] + ".."
    return (txt1 + txt2 + (FFjt5L(txt3, VVZtfx) if txt3 else "")).strip()
   else:
    return "Freq = %s  (%s)" % (self.freq, FFjt5L(self.txMedia, VVZtfx))
  elif nonTxt : return FFjt5L(nonTxt, VVyFI2)
  else  : return ""
 def VVNNi3(self, VVPxk5):
  self.VVH3lH(VVPxk5)
  if self.data:
   if all((self.pol[:1], self.fec, self.sr)): return ("%s %s %s %s" % (self.freq, self.pol[:1], self.fec, self.sr)).strip()
   else          : return ("Freq=%s" % self.freq).strip()
  else           : return ""
 def VVFGvS(self, VVPxk5):
  if VVPxk5 and VVPxk5.count(":") > 8: servRef = eServiceReference(VVPxk5)
  else         : servRef = None
  self.data = None
  if servRef:
   info = eServiceCenter.getInstance().info(servRef)
   if info:
    self.data = info.getInfoObject(servRef, iServiceInformation.sTransponderData)
    if self.data:
     self.namespace = FFARk6(VVPxk5)
     if   self.namespace.startswith("EEEE") : isSat, syst = False, self.VVBvvD(self.SYST, self.D_SYS_T)
     elif self.namespace.startswith("FFFF") : isSat, syst = False, self.VVBvvD(self.SYST, self.D_SYS_C)
     else         : isSat, syst = True , self.VVBvvD(self.SYST, self.D_SYS_S)
     freq = self.VVBvvD(self.FREQ , mod=3  )
     if isSat:
      pol = self.VVBvvD(self.POL , self.D_POL)
      fec = self.VVBvvD(self.FEC , self.D_FEC)
      sr = self.VVBvvD(self.SR  , mod=4  )
      return freq, pol[:1], fec, sr, syst
     else:
      return freq, "-", "-", "-", syst
  return "-", "-", "-", "-", ""
 def VVoQfv(self, VVPxk5):
  self.data = None
  self.VVH3lH(VVPxk5)
  if self.data and self.freq : return True
  else      : return False
class CCyMCP():
 def __init__(self, VVv0AW, path, VVbYwR=None, VVPhQC=-1):
  self.VVv0AW  = VVv0AW
  self.origFile   = path
  self.Title    = "File Editor: " + FFxtW5(path)
  self.VVbYwR  = VVbYwR
  self.tmpFile   = "/tmp/ajp_edit"
  self.fileChanged  = False
  self.fileSaved   = False
  self.insertMode   = 0
  self.lastLineNum  = -1
  self.editorTable  = None
  self.starterRow   = VVPhQC
  if FFpwZS("cp -f '%s' '%s'" % (self.origFile, self.tmpFile)):
   self.VVYlGN(self.VVv0AW)
  else:
   FFdw58(self.VVv0AW, "Error while preparing edit!")
 @FFOAKH("Loading file ...", par=1)
 def VVYlGN(self, wObj):
  VVAkuK = self.VVIh43()
  VVwSzI = ("Save Changes" , self.VVZyGq   , [])
  VVu1YM  = ("Edit Line"  , self.VVM4gv    , [])
  VV2ytr = (""    , self.VVlDhI   , [])
  VVScQz = ("Options"  , self.VV5LSQ  , [])
  VV4QTJ = ("Go to Line No." , self.VVZff7   , [])
  VVCOpO = (""    , self.VVmoPp , [])
  VVu8qI = self.VVuYnO
  VV2x9J  = self.VV5L35
  header   = ("Line No." , " Text" )
  widths   = (8   , 92  )
  VVLIqP  = (CENTER  , LEFT  )
  bg    = "#0a001111"
  self.editorTable = FFUQ0v(self.VVv0AW, None, title=self.Title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, width=1600, height=1000, VVwdmN=26, VViWgK=True, VVwSzI=VVwSzI, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVu8qI=VVu8qI, VV2x9J=VV2x9J, VVCOpO=VVCOpO, VVHPI7=True, VVMfsO=1, VVSLOq=CFG.lastFindEditor
        , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06334444", VVbcr0="#00222222", VVX9AA="#06333322")
 def VV5L35(self, VV6A99):
  VV6A99.VVucBj()
 def VVlDhI(self, VV6A99, title, txt, colList):
  txt = "File\t: %s\n%s" % (self.origFile, txt)
  FF4lCP(self.VVv0AW, txt, title=title)
 def VV5LSQ(self, VV6A99, title, txt, colList):
  c1, c2, c3 = VVJEMb, VVFuwR, VVz22H
  isMulti = VV6A99.VVXWPu
  tot  = VV6A99.VVc5NH()
  lineNum = int(colList[0])
  totRows = VV6A99.VVbyOe()
  isPaste = not isMulti and VVLtQt and len(VVLtQt) > 0
  isSel = not isMulti or tot > 0
  selTxt =  ("Selected " if isMulti else "", FFcacr(tot))
  VV3wat = []
  VV3wat.append(FFsLU5("Insert Empty Line (before line-%d)" % lineNum, "ins1" , not isMulti      , c1))
  VV3wat.append(FFsLU5("Insert Empty Line (after line-%d)"  % lineNum, "ins2" , not isMulti and lineNum == totRows, c1))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Copy %sLine%s to Clipboard" % selTxt , "VVwsNz" , isSel  , c2))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Insert lines from clipboard"   , "paste2"   , isPaste , c2))
  VV3wat.append(FFsLU5("Paste from clipboard (overwrite line)", "paste1"   , isPaste , c2))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Delete %sLine%s" % selTxt, "del", isSel, c3))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Find & Replace" , "repl", not isMulti ))
  cbFncDict = { "ins1"   : BF(self.VVyOTA, "sed -i '%d i %s' '%s'" % (lineNum, "", self.tmpFile))
     , "ins2"   : BF(self.VVVvCv, lineNum)
     , "VVwsNz" : self.VVwsNz
     , "paste1"   : BF(FFimQ3, self.editorTable, BF(self.VVkoCz, lineNum, "\n".join(VVLtQt), 1))
     , "paste2"   : BF(FFimQ3, self.editorTable, BF(self.VVkoCz, lineNum, "\n".join(VVLtQt), 2))
     , "del"    : BF(FFimQ3, self.editorTable, self.VVLtpg)
     , "repl"   : BF(self.VVARU6, title) }
  mSel = CCzSCo(self.VVv0AW, VV6A99, setsOk=True)
  mSel.VV9VR2(VV3wat, cbFncDict, width=750, height=1000)
 def VVARU6(self, title):
  fnd = CFG.lastFindRepl_fnd.getValue()
  rpl = CFG.lastFindRepl_rpl.getValue()
  lst = [(" Find", fnd, str(len(fnd))), (" Replace with", rpl, str(len(rpl)))]
  bg = "#11101010"
  VVu1YM  = ("Change" , BF(self.VVRHwg, title, lst) , [])
  VVwSzI = ("Start" , BF(self.VViopn, title)  , [])
  header  = (" Subject", " Text" , "Len.")
  widths  = (20   , 70  , 10 )
  VVLIqP = (LEFT   , LEFT  , CENTER)
  FFUQ0v(self.VVv0AW, None, title=title, VVGape=lst, header=header, VVLIqP=VVLIqP, VV3cHe=widths, width=1200, VVwdmN=30, VViWgK=True, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVKDPJ=2
    , VVwltY=bg, VVkxBG=bg, VVemyB=bg, VVJKqd="#06224455", VVbcr0="#0a303030")
 def VVRHwg(self, Title, lst, VV6A99, title, txt, colList):
  title = VV6A99.VVeE40(0)
  ndx = VV6A99.VVGTqU()
  txt = CFG.lastFindRepl_fnd.getValue() if ndx == 0 else CFG.lastFindRepl_rpl.getValue()
  FF4z45(self.VVv0AW, BF(self.VVialY, VV6A99, ndx), title=title, defaultText=txt, message="New entry")
 def VVialY(self, VV6A99, ndx, newTxt=None):
  if newTxt:
   if ndx == 0 : FFjt1c(CFG.lastFindRepl_fnd, newTxt)
   else  : FFjt1c(CFG.lastFindRepl_rpl, newTxt)
   VV6A99.VVFKAn({1:newTxt, 2:len(newTxt)})
 def VViopn(self, Title, VV6A99, title, txt, colList):
  fnd = CFG.lastFindRepl_fnd.getValue()
  rpl = CFG.lastFindRepl_rpl.getValue()
  if len(fnd) > 0:
   txt = FFYVq0(self.tmpFile)
   tot = txt.count(fnd)
   if tot > 0:
    FFRMYv(self.VVv0AW, BF(self.VVPDLq, VV6A99, fnd, rpl), "Replace %d occurrences ?" % tot, title=Title)
   else:
    FF28n1(VV6A99, "Not found in file !", 1000)
    VV6A99.VVrqBw(0)
  else:
   FF28n1(VV6A99, "Nothing to find", 1000)
 @FFOAKH("Replacing ...", par=1)
 def VVPDLq(self, VV6A99, fnd, rpl):
  txt = FFYVq0(self.tmpFile)
  txt = txt.replace(fnd, rpl)
  with open(self.tmpFile, "w") as f:
   f.write(txt)
  VV6A99.cancel()
  self.fileChanged = True
  self.editorTable.VVsd6P()
  VVAkuK = self.VVIh43()
  self.editorTable.VVMqQ9(VVAkuK)
 def VVZff7(self, VV6A99, title, txt, colList):
  totRows = self.editorTable.VVn1uo()
  lineNum = self.editorTable.VVGTqU() + 1 if self.lastLineNum == -1 else self.lastLineNum
  FF4z45(self.VVv0AW, BF(self.VV2cxV, lineNum, totRows), title="Go to Line Num (1 - %d)" % totRows, defaultText="%d" % lineNum, message="Enter Line Number")
 def VV2cxV(self, lineNum, totRows, VVRD20):
  if VVRD20:
   VVRD20 = VVRD20.strip()
   if VVRD20.isdigit():
    num = FFsRWN(int(VVRD20) - 1, 0, totRows - 1)
    self.editorTable.VVrqBw(num)
    self.lastLineNum = num + 1
   else:
    FF28n1(self.editorTable, "Incorrect number", 1500)
 def VVmoPp(self, VV6A99, title, txt, colList):
  if   self.starterRow > -1: VV6A99.VVrqBw(self.starterRow)
  elif self.insertMode == 1: VV6A99.VV5Kmd()
  elif self.insertMode == 2: VV6A99.VVMjPT()
  self.insertMode = 0
  self.starterRow = -1
 def VVVvCv(self, lineNum):
  if lineNum == self.editorTable.VVbyOe():
   self.insertMode = 1
   self.VVyOTA("echo '' >> '%s'" % self.tmpFile)
  else:
   self.insertMode = 2
   self.VVyOTA("sed -i '%d i %s' '%s'" % (lineNum + 1, "", self.tmpFile))
 def VVwsNz(self):
  global VVLtQt
  isMulti = self.editorTable.VVXWPu
  if isMulti : VVLtQt = self.editorTable.VVf3uT(1, isStrip=False)
  else  : VVLtQt = [self.editorTable.VVeE40(1, isStrip=False)]
  FF1mVE(self.editorTable, "Copied to clipboard", 800)
 def VVZyGq(self, VV6A99, title, txt, colList):
  if self.fileChanged:
   if FFj2hO(self.origFile):
    if FFpwZS("cp -f '%s' '%s'" % (self.tmpFile, self.origFile)):
     FF1mVE(VV6A99, "Saved", 800)
     self.fileSaved   = True
     self.fileChanged = False
     VV6A99.VVucBj()
    else:
     FFdw58(self.VVv0AW, "Cannot save file!")
   else:
    FFdw58(self.VVv0AW, "Cannot create backup copy of original file!")
 def VVuYnO(self, VV6A99):
  if self.fileChanged:
   FFRMYv(self.VVv0AW, BF(self.VVJeP1, VV6A99), "Cancel changes ?")
  else:
   FFpwZS("cp -f '%s' '%s'" % (self.tmpFile, self.origFile))
   self.VVJeP1(VV6A99)
 def VVJeP1(self, VV6A99):
  VV6A99.cancel()
  FFwgGB(self.tmpFile)
  if self.VVbYwR:
   self.VVbYwR(self.fileSaved)
 def VVM4gv(self, VV6A99, title, txt, colList):
  lineNum = int(VV6A99.VVeE40(0))
  lineTxt = VV6A99.VVeE40(1, isStrip=False)
  message = VVwdUw + "ORIGINAL TEXT:\n" + VVA4XU + lineTxt
  FF4z45(self.VVv0AW, BF(self.VVSnhm, lineNum), title="File Line", defaultText=lineTxt, message=message)
 def VVSnhm(self, lineNum, VVRD20):
  if not VVRD20 is None:
   if self.editorTable.VVbyOe() <= 1:
    self.VVyOTA("echo %s > '%s'" % (VVRD20, self.tmpFile))
   else:
    self.VVkoCz(lineNum, VVRD20, 1)
 def VVkoCz(self, lineNum, newTxt, mode):
  self.editorTable.VVoNlW("Saving ...")
  lines = FFL19l(self.tmpFile)
  with open(self.tmpFile, "w") as f:
   for ndx, line in enumerate(lines, start=1):
    if lineNum == ndx:
     if   mode == 1: line = newTxt
     elif mode == 2: f.write(newTxt + "\n")
    f.write(line + "\n")
  self.fileChanged = True
  self.editorTable.VVsd6P()
  VVAkuK = self.VVIh43()
  self.editorTable.VVMqQ9(VVAkuK)
 def VVLtpg(self):
  isMulti = self.editorTable.VVXWPu
  if isMulti : lst = self.editorTable.VVf3uT(0)
  else  : lst = [self.editorTable.VVeE40(0)]
  self.editorTable.VVW3QY()
  lines = FFL19l(self.tmpFile)
  with open(self.tmpFile, "w") as f:
   for ndx, line in enumerate(lines, start=1):
    if not str(ndx) in lst:
     f.write(line + "\n")
  self.fileChanged = True
  self.editorTable.VVsd6P()
  VVAkuK = self.VVIh43()
  self.editorTable.VVMqQ9(VVAkuK)
 def VVyOTA(self, cmd):
  FF4iwG(cmd, self.VVHHQq)
  self.fileChanged = True
  self.editorTable.VVsd6P()
 def VVHHQq(self, result, retval):
  VVAkuK = self.VVIh43()
  self.editorTable.VVMqQ9(VVAkuK)
 def VVIh43(self):
  if FFCyVu(self.tmpFile):
   lines = FFL19l(self.tmpFile)
   VVAkuK = []
   if lines:
    for ndx, line in enumerate(lines, start=1):
     VVAkuK.append((str(ndx), line))
   if not VVAkuK:
    VVAkuK.append((str(1), ""))
   return VVAkuK
  else:
   FF8Wsn(self.VVv0AW, self.tmpFile)
class CCoErY():
 def __init__(self, VVv0AW, VVwltY="#22003344", VVkxBG="#22002233"):
  self.VVv0AW = VVv0AW
  self.VV3wat  = []
  self.satList  = []
  self.VVwltY  = VVwltY
  self.VVkxBG   = VVkxBG
 def VVVPGN(self, VVbYwR):
  self.VV3wat = []
  VV3wat, VV0mqE = CCoErY.VVHRan(self.VVv0AW, False, True)
  if VV3wat:
   self.VV3wat += VV3wat
   self.VVIAhz(VVbYwR, VV0mqE)
 def VVmRCa(self, mode, VV6A99, satCol, VVbYwR, inFilterFnc=None):
  VV6A99.VVoNlW("Loading Filters ...")
  self.VV3wat = []
  self.VV3wat.append(("All Services" , "all"))
  if mode == 1:
   self.VV3wat.append(VVAL3j)
   self.VV3wat.append(("Parental Control", "parentalControl" ))
   self.VV3wat.append(("Hidden Services" , "hiddenServices" ))
   self.VV3wat.append(VVAL3j)
   self.VV3wat.append(("Radio Services", "radio"))
   if CCYrUm.VVWp6i() or FFCyVu(VVl57H):
    self.VV3wat.append(("Stream Relay Services", "streamRelay"))
  elif mode == 2:
   self.VV3wat.append(VVAL3j)
   self.VV3wat.append(("Selected Transponder"  , "selectedTP" ))
   self.VV3wat.append(("Channels with no Transponder", "emptyTP"  ))
  self.VVEqow(VV6A99, satCol)
  VV3wat, VV0mqE = CCoErY.VVHRan(self.VVv0AW, True, False)
  if VV3wat:
   VV3wat.insert(0, FF0bQE("Custom Words"))
   self.VV3wat += VV3wat
  VV6A99.VVrmMb()
  self.VVIAhz(VVbYwR, VV0mqE, inFilterFnc)
 def VVywN2(self, VV3wat, sats, VVbYwR, inFilterFnc=None):
  self.VV3wat = VV3wat
  VV3wat, VV0mqE = CCoErY.VVHRan(self.VVv0AW, True, False)
  if VV3wat:
   self.VV3wat.append(FF0bQE("Custom Words"))
   self.VV3wat += VV3wat
  self.VVIAhz(VVbYwR, VV0mqE, inFilterFnc)
 def VVIAhz(self, VVbYwR, VV0mqE, inFilterFnc=None):
  VVwJOl  = ("Filter in Filter", inFilterFnc) if inFilterFnc else None
  VVB4pu = ("Edit Filter"  , BF(self.VViwOH, VV0mqE))
  VVaTeF  = ("Filter Help"  , BF(self.VVJ1xY, VV0mqE))
  FFLFTC(self.VVv0AW, BF(self.VVVWaX, VVbYwR), VV3wat=self.VV3wat, title="Select Filter", VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVaTeF=VVaTeF, VVlaGv=True, VVwltY=self.VVwltY, VVkxBG=self.VVkxBG)
 def VVVWaX(self, VVbYwR, item):
  if item:
   VVbYwR(item)
 def VViwOH(self, VV0mqE, selectionObj, sel):
  if FFCyVu(VV0mqE) : CCyMCP(self.VVv0AW, VV0mqE, VVbYwR=None)
  else       : FF8Wsn(self.VVv0AW, VV0mqE)
  selectionObj.cancel()
 def VVJ1xY(self, VV0mqE, selectionObj, sel):
  FFw2rR(self.VVv0AW, "_help_service_filter", "Service Filter")
 def VVEqow(self, VV6A99, satColNum):
  if not self.satList:
   satList = VV6A99.VVrc5p(satColNum)
   if satList:
    satList = set(satList)
    satList = list(satList)
    if satList:
     sats = []
     for ndx, sat in enumerate(satList):
      if not sat.strip() == "":
       self.satList.append((FFR9yH(sat), "__s__" + sat))
     self.satList.sort(key=lambda x: x[0])
     self.satList.insert(0, FF0bQE("Satellites"))
  if self.VV3wat:
   self.VV3wat += self.satList
 @staticmethod
 def VVHRan(SELF, addTag, VVwb7n):
  FFzcnD()
  fileName  = "ajpanel_services_filter"
  VV0mqE = FF0cqc() + fileName
  VV3wat  = []
  if not FFCyVu(VV0mqE):
   FFpwZS("cp -f '%s' '%s'" % (VVIp2p + fileName, VV0mqE))
  fileFound = False
  if FFCyVu(VV0mqE):
   fileFound = True
   lines = FFL19l(VV0mqE)
   if lines:
    for line in lines:
     line = line.strip()
     if line and not line.startswith("#"):
      if "#" in line:
       line = line.split("#")[0].strip()
      if "," in line:
       lst = list(map(str.strip, line.split(",")))
       lst = list(filter(None, lst))
       if lst: line = ",".join(lst)
       else  : line = ""
      if line:
       if addTag: VV3wat.append((line, "__w__" + line))
       else  : VV3wat.append((line, line))
  if VVwb7n:
   if   not fileFound : FF8Wsn(SELF, VV0mqE)
   elif not VV3wat : FFNICS(SELF, VV0mqE)
  return VV3wat, VV0mqE
 @staticmethod
 def VVPBNm(txt):
  txt = txt.strip()
  lst = []
  prefix = False
  if "," in txt:
   lst = list(map(str.strip, txt.split(",")))
   lst = list(filter(None, lst))
   if lst and len(lst) > 1 and lst[0] == "^":
    lst = lst[1:]
    prefix = True
  else:
   txt = txt.strip()
   if txt:
    if len(txt) > 1 and txt.startswith("^"):
     txt = txt[1:]
     prefix = True
    lst = [txt]
  return tuple(map(str.lower, lst)), prefix
class CCzSCo():
 def __init__(self, VVv0AW, VV6A99, addSep=True, setsOk=False, setsRed=False, setsGreen=False, setsYellow=False, setsBlue=False):
  self.VVv0AW = VVv0AW
  self.VV6A99 = VV6A99
  self.VV6A99.VVcqGs  = setsOk
  self.VV6A99.VVJ6ki  = setsRed
  self.VV6A99.VVGxei = setsGreen
  self.VV6A99.VVez0o = setsYellow
  self.VV6A99.VVMayE = setsBlue
  self.VV3wat = []
  iMulSel = self.VV6A99.VViNen()
  if iMulSel : self.VV3wat.append( ("Disable Multi-Select " , "MultSelDisab" ))
  else  : self.VV3wat.append( ("Enable Multi-Select"  , "multSelEnab"  ))
  tot = self.VV6A99.VVc5NH()
  self.VV3wat.append(    ("Select all"    , "selectAll"  ))
  if iMulSel and tot > 0:
   self.VV3wat.append(   ("Unselect all"    , "unselectAll"  ))
  if addSep:
   self.VV3wat.append(VVAL3j)
 def VV9VR2(self, extraMenu, cbFncDict, width=1000, height=850, VVwltY="#22003344", VVkxBG="#22002233", VVptue=0.15):
  if extraMenu:
   self.VV3wat.extend(extraMenu)
  FFLFTC(self.VVv0AW, BF(self.VVIdPJ, cbFncDict), width=width, height=height, VVptue=VVptue, title="Options", VV3wat=self.VV3wat, VVwltY=VVwltY, VVkxBG=VVkxBG)
 def VVIdPJ(self, cbFncDict, item=None):
  if item:
   if   item == "multSelEnab" : self.VV6A99.VVL66W()
   elif item == "MultSelDisab" : self.VV6A99.VVW3QY()
   elif item == "selectAll" : self.VV6A99.VVtrFZ()
   elif item == "unselectAll" : self.VV6A99.VV3Ezh()
   elif cbFncDict:
    fnc = cbFncDict.get(item)
    if fnc:
     fnc()
class CCbQCK(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVHfYH, 900, 480, 50, 0, 0, "#22660066", "#22330033", 35, VVeFSs=40)
  self.session = session
  FFZMxC(self, title="Date/Time -> Manual Mode")
  FFRLNq(self["keyRed"]  , "Exit")
  FFRLNq(self["keyGreen"]  , "Save")
  FFRLNq(self["keyYellow"] , "Refresh")
  FFRLNq(self["keyBlue"]  , "NTP Mode")
  self["curTime"]  = Label()
  self["yearTitle"] = Label("Year")
  self["monthTitle"] = Label("Month")
  self["dayTitle"] = Label("Day")
  self["gapTitle"] = Label()
  self["hourTitle"] = Label("Hour")
  self["minTitle"] = Label("Min")
  self["secTitle"] = Label("Sec")
  self["year"]  = Label()
  self["month"]  = Label()
  self["day"]   = Label()
  self["gap"]   = Label()
  self["hour"]  = Label()
  self["min"]   = Label()
  self["sec"]   = Label()
  self.index   = 0
  self.list   = [self["year"], self["month"], self["day"], self["hour"], self["min"], self["sec"]]
  self.timer   = eTimer()
  self["gapTitle"].hide()
  self["gap"].hide()
  FFHlAU(self,
  {
   "red" : self.VVf07a  ,
   "green" : self.VVktHt ,
   "yellow": self.VVj2LV  ,
   "blue" : self.VVAo2T   ,
   "up" : self.VVx0di    ,
   "down" : self.VVDBsZ   ,
   "left" : self.VVziFC   ,
   "right" : self.VVLe1s   ,
   "cancel": self.VVf07a
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVj2LV()
  self.VVwhvR()
  FFWgBS(self)
  try: self.timer_conn = self.timer.timeout.connect(self.VVVuVb)
  except: self.timer.callback.append(self.VVVuVb)
  self.timer.start(1000, False)
  self.VVVuVb()
 def onExit(self):
  self.timer.stop()
 def VVf07a(self) : self.close(True)
 def VVut7N(self) : self.close(False)
 def VVAo2T(self):
  self.session.openWithCallback(self.VVU1fm, BF(CCvlWs))
 def VVU1fm(self, VVJ2pQ):
  if VVJ2pQ:
   self.close()
 def VVVuVb(self):
  self["curTime"].setText(str(FFTS4w(iTime())))
 def VVx0di(self):
  self.VVtR6o(1)
 def VVDBsZ(self):
  self.VVtR6o(-1)
 def VVziFC(self):
  self.index -= 1
  if self.index < 0:
   self.index = 5
  self.VVwhvR()
 def VVLe1s(self):
  self.index += 1
  if self.index > 5:
   self.index = 0
  self.VVwhvR()
 def VVtR6o(self, increment):
  year = int(self["year" ].getText())
  month = int(self["month"].getText())
  if   self.index == 0: minVal, maxVal = 2000, 3000
  elif self.index == 1: minVal, maxVal = 1, 12
  elif self.index == 2: minVal, maxVal = 1, self.VV3rkL(month, year)
  elif self.index == 3: minVal, maxVal = 0, 23
  elif self.index == 4: minVal, maxVal = 0, 59
  elif self.index == 5: minVal, maxVal = 0, 59
  val  = int(self.list[self.index].getText()) + increment
  if val < minVal: val = maxVal
  if val > maxVal: val = minVal
  if self.index == 0:
   val = "%04d" % val
  else:
   val = "%02d" % val
  self.list[self.index].setText(val)
  if self.index < 2:
   year = int(self["year" ].getText())
   month = int(self["month"].getText())
   day = int(self["day"].getText())
   monthDays = self.VV3rkL(month, year)
   if day > monthDays:
    self["day"].setText("%02d" % monthDays)
 def VV3rkL(self, month, year):
  MonthList = [31,28,31,30,31,30,31,31,30,31,30,31]
  days = MonthList[month-1]
  if (month == 2) and (self.VVu7Bq(year)):
   days += 1
  return days
 def VVu7Bq(self, year):
  if year % 4 == 0:
   if year % 100 == 0:
    if year % 400 == 0:
     return True
    else:
     return False
   else:
    return True
  else:
   return False
 def VVwhvR(self):
  for obj in self.list:
   FFZ0AC(obj, "#11404040")
  FFZ0AC(self.list[self.index], "#11ff8000")
 def VVj2LV(self):
  year, month, day, hour, minute, second, weekDay, yearDay, dayLight = localtime()
  self["year" ].setText("%04d" % year)
  self["month"].setText("%02d" % month)
  self["day"  ].setText("%02d" % day)
  self["hour" ].setText("%02d" % hour)
  self["min"  ].setText("%02d" % minute)
  self["sec"  ].setText("%02d" % second)
 def VVktHt(self):
  year = int(self["year" ].getText())
  month = self["month"].getText()
  day  = self["day"  ].getText()
  hour = self["hour" ].getText()
  minute = self["min"  ].getText()
  second = self["sec"  ].getText()
  cmd = "date -s '%s-%s-%s %s:%s:%s'" % (year, month, day, hour, minute, second)
  FF4iwG("echo -e 'System Response:\n'; %s" % cmd, self.VVVobm)
 def VVVobm(self, result, retval):
  result = str(result.strip())
  if len(result) == 0 : FFipXT(self, "Nothing returned from the system!")
  else    : FFipXT(self, str(result))
class CCvlWs(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVf2e8, 900, 480, 50, 40, 10, "#22660066", "#22330033", 35, VVeFSs=40)
  self.session = session
  FFZMxC(self, title="Date/Time -> NTP Mode", addLabel=True)
  FFRLNq(self["keyRed"]  , "Exit")
  FFRLNq(self["keyGreen"]  , "Sync")
  FFRLNq(self["keyYellow"] , "Refresh")
  FFRLNq(self["keyBlue"]  , "Manual Mode")
  FFHlAU(self,
  {
   "red" : self.VVf07a   ,
   "green" : self.VVYuW7  ,
   "yellow": self.VVhfAa ,
   "blue" : self.VVocqg  ,
   "cancel": self.VVf07a
  })
  self.VV5YRV()
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FFWgBS(self)
  FFIElK(self.VVTwnW)
 def VVTwnW(self):
  self.VVABcY()
  self.VVFaDd(False)
 def VVf07a(self)  : self.close(True)
 def VVocqg(self) : self.close(False)
 def VV5YRV(self):
  self["myLabel"].setText("Getting NTP time ... ")
 def VVABcY(self):
  self.VVj52G()
  self.VVe3c6()
  self.VViJ8W()
  self.VVZGfm()
 def VVhfAa(self):
  if len(self["keyYellow"].getText()) > 0:
   self.VV5YRV()
   self.VVABcY()
   FFIElK(self.VVTwnW)
 def VVYuW7(self):
  if len(self["keyGreen"].getText()) > 0:
   FFRMYv(self, self.VVo4ln, "Synchronize with Internet Date/Time ?")
 def VVo4ln(self):
  self.VVABcY()
  FFIElK(BF(self.VVFaDd, True))
 def VVj52G(self)  : self["keyRed"].show()
 def VVVpIB(self)  : self["keyGreen"].show()
 def VVfqnf(self) : self["keyYellow"].show()
 def VVP4Uw(self)  : self["keyBlue"].show()
 def VVe3c6(self)  : self["keyGreen"].hide()
 def VViJ8W(self) : self["keyYellow"].hide()
 def VVZGfm(self)  : self["keyBlue"].hide()
 def VVFaDd(self, sync):
  localTime = FFIPdt()
  ok = False
  server_list = ['ntp.iitb.ac.in', 'time.nist.gov', 'time.windows.com', 'pool.ntp.org']
  for server in server_list:
   epoch_time = self.VVsUeC(server)
   if epoch_time is not None:
    ntpTime = FFTS4w(epoch_time)
    time1 = mktime(datetime.strptime(localTime, "%Y-%m-%d %H:%M:%S").timetuple())
    time2 = mktime(datetime.strptime(ntpTime  , "%Y-%m-%d %H:%M:%S").timetuple())
    diff = time1 - time2
    if   diff == 0 : timeDiff = "None"
    elif diff == 1 : timeDiff = "%d second"  % diff
    else   : timeDiff = "%d seconds" % diff
    timeDiff = "Difference\t=  %s" % timeDiff
    if sync:
     FF4iwG("echo -e '\nSystem Response:\n'; date -s '%s'" % ntpTime, BF(self.VVVobm, True))
    else:
     txt = "Local Time\t= %s\nInternet Time\t= %s\n%s\n" % (localTime, ntpTime, timeDiff)
     self["myLabel"].setText(txt)
    ok = True
    break
   else:
    pass
  self.VVfqnf()
  self.VVP4Uw()
  if ok:
   self.VVVpIB()
  else:
   self["myLabel"].setText("Local Time\t= %s\n\nCould not get NTP time !\n" % localTime)
 def VVVobm(self, syncAgain, result, retval):
  result = str(result.strip())
  if   len(result) == 0  : result = "\n\nNothing returned from the system!"
  elif result.count("\n") < 20: result = "\n\n" + result
  try:
   self["myLabel"].setText(result)
   if syncAgain:
    self.VVFaDd(False)
  except:
   pass
 def VVsUeC(self, addr='time.nist.gov'):
  from socket import socket, AF_INET, SOCK_DGRAM
  from struct import unpack as iUnpack
  time1970 = 2208988800
  data  = '\x1b' + 47 * '\0'
  data  = data.encode()
  if CCuqoc.VVSuvZ():
   try:
    client = socket(AF_INET, SOCK_DGRAM)
    client.settimeout(1.0)
    client.sendto(data, (addr, 123))
    data, address = client.recvfrom(1024)
    if data:
     epoch_time = iUnpack('!12I', data)[10]
     epoch_time -= time1970
     return epoch_time
   except:
    pass
  return None
class CCoFdR(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVQrjc, 900, 300, 50, 20, 0, "#22000060", "#22000020", 35)
  self.session  = session
  FFZMxC(self, addLabel=True, addCloser=True)
  self["myTitle"].setText("  Internet Connectivity")
  self["myLabel"].setText("Checking Connection ...")
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FFIElK(self.VVUUii)
 def VVUUii(self):
  if CCuqoc.VVSuvZ() : color, txt = "#22002020", "Internet Connection = Successful."
  else     : color, txt = "#22500000", "Cannot connect (or server is down) !"
  try:
   self["myLabel"].setText("  " + txt)
   FFZ0AC(self["myBody"], color)
   FFZ0AC(self["myLabel"], color)
  except:
   pass
class CCtKqU(Screen):
 VV0DI2 = None
 def __init__(self, session):
  size = CFG.signalSize.getValue()
  screenW = FFrPd1()[0]
  ratio = size / 5.0
  self.skin, self.VVfOli = FFiNEe(VVnhJ8, 650, 320, 26, 20, 20, "#22003040", "#22001122", 25, VVFz5T=ratio)
  self.session   = session
  self["mySNRdB"]   = Label()
  self["mySNR"]   = Label()
  self["myAGC"]   = Label()
  self["myBER"]   = Label()
  self["mySliderSNR"]  = Pixmap()
  self["mySliderAGC"]  = Pixmap()
  self["mySliderBER"]  = Pixmap()
  self["mySliderCovSNR"] = Label()
  self["mySliderCovAGC"] = Label()
  self["mySliderCovBER"] = Label()
  color     = self.VVfOli["VVPTnB"]
  self.sliderSNR   = CCAbWp(self, self["mySliderSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
  self.sliderAGC   = CCAbWp(self, self["mySliderAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
  self.sliderBER   = CCAbWp(self, self["mySliderBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
  self["myTPInfo"]  = Label()
  self.timer    = eTimer()
  self.tunerInfo   = CCOZ3M()
  self.stateCounter  = 0
  self.top    = 0
  self.left    = 0
  self.curPosNum   = CFG.signalPos.getValue()
  self.curSize   = CFG.signalSize.getValue()
  self.tpData    = CC3Z54()
  FFZMxC(self, title="Signal")
  FFHlAU(self,
  {
   "ok"  : self.close      ,
   "up"  : self.VVx0di       ,
   "down"  : self.VVDBsZ      ,
   "left"  : self.VVziFC      ,
   "right"  : self.VVLe1s      ,
   "info"  : self.VVyiuk     ,
   "epg"  : self.VVyiuk     ,
   "menu"  : self.VVOz5Q      ,
   "cancel" : self.close      ,
   "red"  : self.close      ,
   "last"  : BF(self.VVmvbJ, -1)  ,
   "next"  : BF(self.VVmvbJ, 1)  ,
   "pageUp" : BF(self.VVdMXX, True) ,
   "chanUp" : BF(self.VVdMXX, True) ,
   "pageDown" : BF(self.VVdMXX, False) ,
   "chanDown" : BF(self.VVdMXX, False) ,
   "0"   : BF(self.VVmvbJ, 0)  ,
   "1"   : BF(self.VVH1bN, pos=1) ,
   "2"   : BF(self.VVH1bN, pos=2) ,
   "3"   : BF(self.VVH1bN, pos=3) ,
   "4"   : BF(self.VVH1bN, pos=4) ,
   "5"   : BF(self.VVH1bN, pos=5) ,
   "6"   : BF(self.VVH1bN, pos=6) ,
   "7"   : BF(self.VVH1bN, pos=7) ,
   "8"   : BF(self.VVH1bN, pos=8) ,
   "9"   : BF(self.VVH1bN, pos=9) ,
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  if not CCtKqU.VV0DI2:
   CCtKqU.VV0DI2 = self
  self.sliderSNR.VVi3uI()
  self.sliderAGC.VVi3uI()
  self.sliderBER.VVi3uI(isBER=True)
  pos   = self.instance.position()
  self.left = pos.x()
  self.top = pos.y()
  self.VVH1bN()
  self.VVEPh9()
  try: self.timer_conn = self.timer.timeout.connect(self.VVXpZW)
  except: self.timer.callback.append(self.VVXpZW)
  self.timer.start(500, False)
 def VVEPh9(self):
  service = self.session.nav.getCurrentService()
  self.tunerInfo.VVAo5r(service)
  serviceName = self.tunerInfo.VVvVTk()
  if not serviceName   : serviceName = "Signal"
  if len(serviceName) > 25 : serviceName = serviceName[:25] + ".."
  self["myTitle"].setText("  " + serviceName)
  s = CC3rDi(self.session)
  self["myTPInfo"].setText(self.tpData.VVsDkA([s.VVPxk5, s.VVAQqG], maxLen=54))
 def VVXpZW(self):
  s = CC3rDi(self.session)
  self.tunerInfo.VVAo5r(s.servPtr)
  if self.tunerInfo.infoAvailable:
   self["mySNRdB"].setText(self.tunerInfo.VVSwl4())
   self["mySNR"].setText(self.tunerInfo.VVlX6a())
   self["myAGC"].setText(self.tunerInfo.VVr4Yo())
   self["myBER"].setText(self.tunerInfo.VVU8EL())
   self.sliderSNR.VVMjzk(self.tunerInfo.VVRpcw())
   self.sliderAGC.VVMjzk(self.tunerInfo.VVX9tR())
   self.sliderBER.VVMjzk(self.tunerInfo.VVZwV4())
  else:
   self["mySNRdB"].setText("")
   self["mySNR"].setText("?")
   self["myAGC"].setText("?")
   self["myBER"].setText("?")
   self.sliderSNR.VVMjzk(0)
   self.sliderAGC.VVMjzk(0)
   self.sliderBER.VVMjzk(0)
  if self.stateCounter > -1:
   self.stateCounter += 1
   if self.stateCounter > 8:
    self.stateCounter = -1
   else:
    if s.state.startswith("*"):
     FF28n1(self, s.state.replace("*", ""), 1500)
     self.stateCounter = -1
 def VVyiuk(self):
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY)
 def VVOz5Q(self):
  FFw2rR(self, "_help_signal", "Signal Monitor (Keys)")
 def VVx0di(self)  : self.VVH1bN(posMap={7:4, 4:1, 8:5, 5:2, 9:6, 6:3})
 def VVDBsZ(self) : self.VVH1bN(posMap={1:4, 4:7, 2:5, 5:8, 3:6, 6:9})
 def VVziFC(self) : self.VVH1bN(posMap={3:2, 2:1, 6:5, 5:4, 9:8, 8:7})
 def VVLe1s(self) : self.VVH1bN(posMap={1:2, 2:3, 4:5, 5:6, 7:8, 8:9})
 def VVH1bN(self, posMap=None, pos=-1):
  if pos > -1 or posMap:
   if pos > -1:
    self.curPosNum = pos
   elif posMap:
    self.curPosNum = posMap.get(self.curPosNum, self.curPosNum)
   FFjt1c(CFG.signalPos, self.curPosNum)
  scrSize = getDesktop(0).size()
  gapH = gapV = 20
  w  = self.instance.size().width()
  h  = self.instance.size().height()
  left = self.left
  top  = self.top
  bot  = scrSize.height() - h - gapV
  rigth = scrSize.width()  - w - gapH
  if   self.curPosNum == 1: left, top = gapH , gapV
  elif self.curPosNum == 2: left, top = left , gapV
  elif self.curPosNum == 3: left, top = rigth , gapV
  elif self.curPosNum == 4: left, top = gapH , top
  elif self.curPosNum == 5: left, top = left , top
  elif self.curPosNum == 6: left, top = rigth , top
  elif self.curPosNum == 7: left, top = gapH , bot
  elif self.curPosNum == 8: left, top = left , bot
  elif self.curPosNum == 9: left, top = rigth , bot
  else     : left, top = left , top
  self.instance.move(ePoint(left, top))
 def VVmvbJ(self, sizeNum):
  oldSizeNum = CFG.signalSize.getValue()
  if sizeNum == 0:
   sizeNum = 5
  else:
   sizeNum += oldSizeNum
   sizeNum = FFsRWN(sizeNum, 1, 13)
  if not oldSizeNum == sizeNum:
   FFjt1c(CFG.signalSize, sizeNum)
   self.close(True)
 def onExit(self):
  self.timer.stop()
  CCtKqU.VV0DI2 = None
 def VVdMXX(self, isUp):
  FF28n1(self)
  try:
   if isUp : InfoBar.instance.zapDown()
   else : InfoBar.instance.zapUp()
   self.stateCounter = 0
   self.VVEPh9()
  except:
   pass
class CCAbWp(object):
 def __init__(self, SELF, barObj, covObj, minN=0, maxN=100, covColor="#00440000"):
  self.SELF   = SELF
  self.barObj   = barObj
  self.covObj   = covObj
  self.minN   = minN
  self.maxN   = maxN
  self.covColor  = covColor
  self.isColormode = False
 def VVi3uI(self, isBER=False):
  self.barWidth = self.barObj.instance.size().width()
  self.VVeFSs = self.barObj.instance.size().height()
  self.barLeft = self.barObj.getPosition()[0]
  self.barTop  = self.barObj.getPosition()[1]
  if isBER:
   FFZ0AC(self.covObj, "#0aaa0000")
   self.isColormode = True
  else:
   path = VVIp2p +  "bar_sig.png"
   if FFBFPY(self.barObj, path):
    FFZ0AC(self.covObj, self.covColor)
   else:
    FFZ0AC(self.covObj, "#00006688")
    self.isColormode = True
  self.VVMjzk(0)
 def VVMjzk(self, val):
  val  = FFsRWN(val, self.minN, self.maxN)
  width = int(FFjFSv(val, 0, 100, 0, self.barWidth))
  height = int(self.VVeFSs)
  if self.isColormode:
   self.covObj.instance.resize(eSize(*(width, height)))
  else:
   width = int(FFsRWN(self.barWidth - width, 0, self.barWidth))
   top  = int(self.barTop)
   left = int(self.barLeft + self.barWidth - width)
   self.covObj.hide()
   self.covObj.instance.resize(eSize(*(width, height)))
   self.covObj.instance.move(ePoint(left, top))
   self.covObj.show()
class CCh3tv(Screen):
 VVARhl = 0
 VVgJkc  = 1
 VVQJNo = 2
 VVYfDc = 3
 def __init__(self, session, VVLL7M="Processing ...", endTitle="Finishing ...", VVixvy=None, VVIZBP=VVARhl, totBars=1, titleBg="#0a042328", bodyBg="#0a042328", barBg="#0a995533"):
  ratio = self.VVq0XK(VVIZBP)
  if totBars == 1 : h, margT = 150, 20
  else   : h, margT = 200, 15
  self.skin, self.VVfOli = FFiNEe(VVsg3D, 900, h, 30, 20, margT, titleBg, bodyBg, 30, VVFz5T=ratio, VVUuJZ={"totBars":totBars})
  self.session  = session
  self.VVIZBP  = VVIZBP
  self.totBars  = totBars
  self.barBg   = barBg
  self.VVLL7M = VVLL7M
  self.newTitle  = self.VVLL7M
  self.endTitle  = endTitle
  self.VVixvy  = VVixvy
  self.isCancelled = False
  self.isError  = False
  self.maxValue  = 0
  self.maxValue2  = 0
  self.barWidth  = 0
  self.VVeFSs  = 0
  self.counter  = 0
  self.counter2  = 0
  self.VVNc18 = None
  self.timer   = eTimer()
  self.myThread  = None
  FFZMxC(self, title=self.VVLL7M)
  for i in range(1, 3):
   self["myProgFr%s"  % i] = Label()
   self["myProgBG%s"  % i] = Label()
   self["myProgFG%s"  % i] = Label()
   self["myProgVal%s" % i] = Label()
  FFHlAU(self, {"cancel" : self.cancel})
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVP1TC()
  for i in range(1, 3):
   self["myProgVal%s" % i].setText("0%")
  for i in range(1, 3):
   FFZ0AC(self["myProgFG%s" % i], self.barBg)
   size = self["myProgVal%s" % i].instance.size()
   self.barWidth = int(size.width())
   self.VVeFSs = int(size.height())
   self.VVHMlK()
  try: self.timer_conn = self.timer.timeout.connect(self.VVHMlK)
  except: self.timer.callback.append(self.VVHMlK)
  self.timer.start(50, False)
  self.myThread = iThread(name="ajp_progBar", target=BF(self.VVixvy, self))
  self.myThread.start()
 def VVq8NF(self, val):
  self.maxValue = val
 def VVUIH1(self, val):
  self.maxValue2 = val
 def VVSW9b(self, catName):
  self.newTitle = "Found %d    %d/%d %s" % (len(self.VVNc18), self.counter, self.maxValue, catName)
 def VV6j41(self, ev, pic):
  self.newTitle = "Downloading ... Events: %s    PIcons: %s" % (ev, pic)
 def VV0ddK(self, tot):
  self.newTitle = "Downloaded %d    Processed : %d of %d" % (tot, self.counter, self.maxValue)
 def VVYQKA(self, tot, evName):
  self.newTitle = "Translated: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, evName)
 def VVK5RO(self, tot, name):
  self.newTitle = "Added: %d   ... %d/%d >> %s" % (tot, self.counter, self.maxValue, name)
 def VVaks5(self, txt):
  self.newTitle = str(txt)
 def VVxtQs(self, addVal, showFound=False):
  try:
   self.counter += addVal
   if showFound:
    self.newTitle = "Found : %d    .. Processed : %d of %d" % (len(self.VVNc18), self.counter, self.maxValue)
  except:
   pass
 def VVEpLv(self, addVal, totFound):
  try:
   self.counter += addVal
   self.newTitle = "Found : %d    .. Processed : %s of %s" % (totFound, self.counter, self.maxValue)
  except:
   pass
 def VVg2Dw(self, addVal):
  try:
   self.counter2 += addVal
  except:
   pass
 def VV78Id(self, val):
  try:
   self.counter = val
  except:
   pass
 def VVV3RA(self, val):
  try:
   self.counter2 = val
  except:
   pass
 def VVlmol(self):
  self.isError = True
  self.cancel()
 def onExit(self):
  self.timer.stop()
 def cancel(self):
  self.timer.stop()
  self.isCancelled = True
  self.VVsre8(False)
 def VVsre8(self, isDone):
  self.close(isDone, self.VVNc18, self.counter, self.maxValue, self.isError)
 def VVHMlK(self):
  if   self.newTitle  : self["myTitle"].setText("  %s  " % self.newTitle)
  elif self.maxValue > 0 : self["myTitle"].setText("  %s  ( %d of %d ) ..." % (self.VVLL7M, self.counter, self.maxValue))
  if self.maxValue > 0:
   val = FFsRWN(self.counter, 0, self.maxValue)
   width = int(FFjFSv(val, 0, self.maxValue, 0, self.barWidth))
   self["myProgVal1"].setText(str(int(val * 100.0 / self.maxValue)) + "%")
  else:
   width = 0
  self["myProgFG1"].instance.resize(eSize(*(width, self.VVeFSs)))
  if self.maxValue2 > 0:
   val = FFsRWN(self.counter2, 0, self.maxValue2)
   width = int(FFjFSv(val, 0, self.maxValue2, 0, self.barWidth))
   self["myProgVal2"].setText(str(int(val * 100.0 / self.maxValue2)) + "%")
  else:
   width = 0
  self["myProgFG2"].instance.resize(eSize(*(width, self.VVeFSs)))
  if self.myThread and not self.myThread.is_alive():
   self.timer.stop()
   self["myTitle"].setText("  %s  " % self.endTitle)
   self.VVsre8(True)
 def VVP1TC(self):
  if self.totBars == 1:
   self["myProgFr2"].hide()
   self["myProgFG2"].hide()
   self["myProgBG2"].hide()
   self["myProgVal2"].hide()
  scrW = getDesktop(0).size().width()
  winW = self.instance.size().width()
  gap  = 30
  if self.VVIZBP in (self.VVARhl, self.VVgJkc):
   self.instance.move(ePoint(int(scrW - winW - gap), gap))
 def VVq0XK(self, VVIZBP):
  if   VVIZBP == self.VVARhl : return 0.7
  if   VVIZBP == self.VVgJkc : return 0.5
  if   VVIZBP == self.VVQJNo: return 0.5
  else           : return 1
 @staticmethod
 def VV7Nf4(SELF, **kwargs):
  VVbYwR = kwargs.pop("VVbYwR", None)
  SELF.session.openWithCallback(VVbYwR, CCh3tv, **kwargs)
class CCaTk8(object):
 def __init__(self):
  self.VV2ilt = {}
  self.VVHvdg  = {}
  self.VVimES = {}
  self.VVbYwR = {}
  self.VVuiSx = False
  self.VVyCS0  = FFgrjX()
 def VVtIZD(self, cmd, VVbYwR, VVimES=None, VVXgOC=None):
  self.VVuiSx = True
  name = cmd
  i  = 0
  while name in self.VV2ilt:
   name = cmd + '_' + str(i)
   i += 1
  self.VVHvdg[name] = ""
  self.VVimES[name] = VVimES
  self.VVbYwR[name] = VVbYwR
  try:
   from enigma import eConsoleAppContainer
   self.VV2ilt[name] = eConsoleAppContainer()
   if self.VVyCS0:
    self.VV2ilt[name].dataAvail_conn = self.VV2ilt[name].dataAvail.connect(BF(self.VVMUWQ, name))
    self.VV2ilt[name].appClosed_conn = self.VV2ilt[name].appClosed.connect(BF(self.VVQ9iV , name))
   else:
    self.VV2ilt[name].dataAvail.append(BF(self.VVMUWQ, name))
    self.VV2ilt[name].appClosed.append(BF(self.VVQ9iV , name))
  except:
   self.VVuiSx = False
   return False
  if isinstance(cmd, str):
   cmd = [cmd]
  if VVXgOC:
   try:
    self.VV2ilt[name].setCWD(VVXgOC)
   except:
    pass
  retval = self.VV2ilt[name].execute(*cmd)
  if retval:
   self.VVQ9iV(name, retval)
  return True
 def VVMUWQ(self, name, data):
  try:
   data = data.decode("UTF-8")
  except:
   data = "%s%s\n" % ("" if self.VVHvdg[name].endswith("\n") else "\n", FFjt5L("[UN-DECODED STRING]", VVyFI2))
  self.VVHvdg[name] += data
  if self.VVimES[name]:
   self.VVimES[name](data)
 def VVQ9iV(self, name, retval):
  if not self.VVyCS0:
   del self.VV2ilt[name].dataAvail[:]
   del self.VV2ilt[name].appClosed[:]
  del self.VV2ilt[name]
  del self.VVimES[name]
  self.VVuiSx = False
  if self.VVbYwR[name]:
   self.VVbYwR[name](self.VVHvdg[name], retval)
  del self.VVbYwR[name]
 def VVY7lz(self):
  return self.VVuiSx
 def kill(self, name):
  if name in self.VV2ilt:
   self.VV2ilt[name].kill()
 def killAll(self):
  for name in self.VV2ilt:
   self.kill(name)
  self.VVuiSx = False
class CCp90q(Screen):
 def __init__(self, session, title="", VVmbsE=None, VVgoZo=False, VVS7yC=False, VV9qqT=False, VVIk01=False, VVB4JK=False, VV4naX=False, VV47Xm=VVje9A, VVoasw=None, VVtByE=None, VV26L0=None, VV62hm=False, VVwdmN=30, consFont=True, VVl5LQ=True):
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1600, 1000, 50, 40, 20, "#11003040", "#11001122", VVwdmN, VVOde7=consFont)
  self.session   = session
  FFZMxC(self, addScrollLabel=True)
  self.VVgoZo   = VVgoZo
  self.VVS7yC   = VVS7yC
  self.VV9qqT   = VV9qqT
  self.VVIk01  = VVIk01
  self.VVB4JK = VVB4JK
  self.VV4naX = VV4naX
  self.VV47Xm   = VV47Xm
  self.VVoasw = VVoasw
  self.VVtByE = VVtByE
  self.VV26L0  = VV26L0
  self.VV62hm  = VV62hm
  self.VVl5LQ  = VVl5LQ
  self.cmdNum    = 0
  self.VVwZZX  = CCaTk8()
  self.justStarted  = True
  self.dataFound   = False
  self.VVUxFi = "Processing ..."
  if len(title) == 0:
   title = FFGNZA()
  self["myTitle"].setText("  %s" % title)
  if isinstance(VVmbsE, str):
   self.VVmbsE = [VVmbsE]
  else:
   self.VVmbsE = VVmbsE
  if self.VV9qqT or self.VVIk01:
   restartNote = "%s\\\\nGUI WILL RESTART NOW\\\\n%s" % (SEP, SEP)
   self.VVmbsE.append("echo -e '\n%s\n' %s" % (restartNote, FFSPDv(restartNote, VVz22H)))
   if self.VV9qqT : self.VVmbsE.append(CCp90q.VV0los())
   else    : self.VVmbsE.append(CCp90q.VVvDIy())
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH(VVRhqH="console" if self.VVl5LQ else "", maxChars=40000)
  if self.VVB4JK:
   FF28n1(self, self.VVUxFi)
  if self.VV62hm:
   self.VVgi3m("Checking Internet Access ... ")
   if not CCuqoc.VVSuvZ():
    self.VVMZGG("No connection to internet !", True)
    return
  self.VVgi3m(self.VVUxFi)
  allOK = self.VVwZZX.VVtIZD(self.VVmbsE[0], self.VVqL3h, VVimES=self.VVCsHg)
  if not allOK:
   self.VVgi3m()
   self.VVMZGG("Console Problem (in cmd-0) !", True)
 def onExit(self):
  if self.VVwZZX.VVY7lz():
   self.VVwZZX.killAll()
 def VVgi3m(self, altTxt=""):
  if self.VV4naX or self.VV9qqT or self.VVIk01:
   self.VV2pQl(FFGEAF("STARTED", VVA4XU))
   self.VVkvE0(altTxt)
  else:
   self.VV2pQl(altTxt)
  if self.VVgoZo:
   self["myLabel"].VVfu0l()
 def VVMZGG(self, txt="", isErr=False):
  if txt:
   self.VVkvE0("\n%s\n" % (FFjt5L(txt, VVz22H) if isErr else txt))
  if not self.dataFound or self.VV8fBr():
   self.VVgi3m()
   self.VVkvE0("Done.")
  if self.VV4naX and not (self.VV9qqT or self.VVIk01):
   self.VVkvE0("\n%s" % FFGEAF("FINISHED", VVA4XU))
  if self.VVS7yC:
   self["myLabel"].VVfu0l()
  if self.VVB4JK:
   FF28n1(self)
  if self.VVoasw : self.VVoasw()
  if self.VVtByE : self.VVtByE(self)
 def VVkvE0(self, txt) : self["myLabel"].appendText(txt, VV47Xm=self.VV47Xm)
 def VV2pQl(self, txt) : self["myLabel"].setText(txt)
 def VV6VWc(self)  : return FFzBfi(self["myLabel"].getText())
 def VV8fBr(self, txt=""):
  consTxt = self.VV6VWc().strip()
  return not consTxt or consTxt.strip().endswith(self.VVUxFi)
 def VVCsHg(self, txt):
  if len(txt) > 0:
   self.dataFound = True
  if self.justStarted:
   self.justStarted = False
   if self.dataFound and self.VV8fBr():
    self.VVgi3m()
  if self.VV26L0:
   colorWhite = CCuTnL.VVsAua(VVwdUw)
   color  = CCuTnL.VVsAua(self.VV26L0[0])
   words  = self.VV26L0[1:]
   for word in words:
    txt = iSub(r"(%s)" % iEscape(word), r"%s\1%s" % (color, colorWhite), txt, flags=IGNORECASE)
  self.VVkvE0(txt)
  if self.VVgoZo or self.VVS7yC:
   self["myLabel"].VVfu0l()
 def VVqL3h(self, data, retval):
  self.cmdNum += 1
  if self.cmdNum < len(self.VVmbsE):
   allOK = self.VVwZZX.VVtIZD(self.VVmbsE[self.cmdNum], self.VVqL3h, VVimES=self.VVCsHg)
   if not allOK:
    self.VVMZGG("Console Problem (in cmd-%s) !" % self.cmdNum, True)
  else:
   self.VVMZGG()
 @staticmethod
 def VViIAR(isInst=False):
  txt  = "apt-get install -f -y > /dev/null 2>&1;" if isInst else ""
  return "sync; sleep 3; if which systemctl > /dev/null 2>&1; then %s systemctl restart enigma2; else killall -9 enigma2; fi" % txt
 @staticmethod
 def VVvDIy(): return CCp90q.VViIAR()
 @staticmethod
 def VV0los(): return CCp90q.VViIAR(True)
 @staticmethod
 def VV6bHp(SELF):
  from Screens.Standby import TryQuitMainloop
  SELF.session.open(TryQuitMainloop, 3)
class CCtzVm(Screen):
 def __init__(self, session, VVGd7m="", VVOuqa="", VV6TEx=False):
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, 1700, 1000, 40, 20, 20, "#22200010", "#1a000000", 28, VVeFSs=40, VVOde7=True, VV0Ay7=2)
  self.session   = session
  self.VVGd7m   = VVGd7m
  self.VVOuqa   = VVOuqa.strip()
  self.VV6TEx   = VV6TEx
  self.VVK0Cy = FF0cqc() + "ajpanel_terminal.history"
  self.VVXuHn = ""
  self.VVB2xR  = "ls"
  self.VVoEDc   = ">>"
  self.VVXgOC    = FFTKR0("pwd") or "/home/root"
  self.VVwZZX  = CCaTk8()
  self.VV3sPE  = []
  self.VV33tl  = ""
  self.VVNNLQ   = None
  self.VVjMlz   = (VVo7S9, VVMibI,VVSGsk,VV1fx4,VV9nWG,VVcPtB,VVGCYL,VVwdUw)
  self.VVPkpc  = 0
  FFZMxC(self, title="Terminal", addScrollLabel=True)
  FFRLNq(self["keyRed"] , "Stop Process")
  FFRLNq(self["keyGreen"] , "Minimize")
  FFRLNq(self["keyYellow"], "Terminal Options")
  FFRLNq(self["keyBlue"] , "New Command")
  FFBep1(self,
  {
   "ok" : self.VVZ1Ie ,
   "cancel": self.VVhDrW  ,
   "menu" : self.VVcXw8 ,
   "info" : self.VVse0r  ,
   "red" : self.VV4N2S   ,
   "green" : self.VVebLl   ,
   "yellow": self.VVOeUB ,
   "blue" : self.VVWf1a  ,
   "last" : self["myLabel"].VV8AUA ,
   "next" : self["myLabel"].VV7yIn ,
   "0"  : self["myLabel"].VVc4HF  ,
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.VV4N2S)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH(VV7u0U=False, VVRhqH="terminal", addNewLine=False, hideBtns=True)
  self["myLabel"].VVv22o(CFG.terminalTextWrap.getValue())
  FFWgBS(self)
  FF6W0I(self)
  self.VV0wMe(FFTKR0("date"), 5)
  result = FFTKR0("tUSER=$(whoami) || tUSER=""; tHOST=$(hostname) || tHOST=""; echo $tUSER,$tHOST")
  if result and "," in result:
   result = result.replace(",", "@")
   if len(result) < 15:
    self.VVoEDc = "%s: " % result
  self.VVGp1e()
  if VVmJwX(FF0cqc()):
   self.VVECGC()
   if self.VVGd7m:
    self.VVShXV(self.VVGd7m, self.VVOuqa)
  else:
   FFdw58(self, 'Cannot access the path:\n\n%s' % FF0cqc())
   self.close()
 def VVhDrW(self):
  if   self.VVNNLQ     : self.VVebLl()
  elif self.VVwZZX.VVY7lz()  : self.VVCPhp()
  elif self.VV6TEx      : self.close()
  elif CFG.ConfirmTerminalExit.getValue() : FFRMYv(self, self.close, "Exit ?")
  else         : self.close()
 def VVebLl(self):
  if self.VVNNLQ:
   self.session.deleteDialog(self.VVNNLQ)
   self.VVNNLQ = None
   self.show()
  else:
   self.VVNNLQ = CChMGW.VVNLfa(self.session, self.VV33tl, 24, shadW=0, bg="#77000000")
   self.hide()
 def VVECGC(self):
  userFile = CFG.terminalCmdFile.getValue()
  alterFile = FF0cqc() + "ajpanel_cmd"
  templPath = VVIp2p + "ajpanel_cmd_list"
  if   FFCyVu(userFile) : self.VVXuHn = userFile
  elif FFCyVu(alterFile): self.VVXuHn = alterFile
  else:
   if not FFpwZS("cp -f '%s' '%s'" % (templPath, alterFile)):
    FF7ymp("echo -e 'pwd\ncd\ncd /tmp\nls\nls -ls' > '%s'" % alterFile)
   self.VVXuHn = alterFile
 def VV4N2S(self):
  if self.VVNNLQ:
   self.VVebLl()
  elif self.VVwZZX.VVY7lz():
   self.VVwZZX.killAll()
   self.VVYrFJ("Process killed")
   self.VVGp1e()
 def VVCPhp(self):
  if self.VVNNLQ:
   self.VVebLl()
  FF28n1(self, "Terminal is busy", 800)
 def VVYrFJ(self, err):
  txt = self["myLabel"].getText()
  if   txt.endswith("\n\n"): cr = ""
  elif txt.endswith("\n")  : cr = "\n"
  else      : cr = "\n\n"
  self.VV0wMe("%s---(  %s  )---\n" % (cr, err), 4)
 def VVGp1e(self):
  txt = self["myLabel"].getText()
  self.VVPkpc = len(txt)
  if   txt.endswith("\n\n"): cr = ""
  elif txt.endswith("\n")  : cr = "\n"
  else      : cr = "\n\n"
  self.VV0wMe(cr + self.VVoEDc, 1)
  self["keyRed"].hide()
 def VV0wMe(self, txt, mode):
  if   mode == 0 : color = VVwdUw
  elif mode == 1 : color = VV1fx4
  elif mode == 2 : color = VVGCYL
  elif mode == 3 : color = VVwdUw
  elif mode == 4 : color = VVz22H
  elif mode == 5 : color = VVA4XU
  elif mode == 6 : color = VVo7S9
  else   : color = VVwdUw
  txt = iSub(r"\x1B\[0m", CCuTnL.VVsAua(VVwdUw), txt, flags=IGNORECASE)
  for i, c in enumerate(self.VVjMlz):
   txt = iSub(r"\x1B\[[\d\;]*%sm" % i, CCuTnL.VVsAua(c), txt, flags=IGNORECASE)
  txt = iSub(r"\x1B\[(\d{,3};?){,3}m", "", txt, flags=IGNORECASE)
  if not txt.strip() or iMatch(r"^\\c.{8}.*", txt):
   color = ""
  try:
   txt = str(txt)
   oldTxt = self["myLabel"].getText()
   done = False
   if chr(13) in txt:
    pos = oldTxt.rfind(chr(13))
    if pos > self.VVPkpc:
     self["myLabel"].setText(oldTxt[:pos] + txt)
     done = True
   if not done:
    self["myLabel"].setText(oldTxt + color + txt)
   txt = txt.strip().rpartition("\n")[2]
   if txt:
    if len(txt) > 20: txt = "%s .. %s" % (txt[:10], txt[-10:])
    self.VV33tl = color + txt
    if self.VVNNLQ:
     CChMGW.VVr9Gs(self.VVNNLQ, self.VV33tl)
  except:
   pass
 @FFOAKH("Loading History ...")
 def VVZ1Ie(self):
  title = "Command History"
  if not FFCyVu(self.VVK0Cy) or self.VVZCpJ() == "":
   self.VVeI3W("cd /tmp")
   self.VVeI3W("ls")
  VVAkuK = []
  if FFCyVu(self.VVK0Cy):
   lines  = FFL19l(self.VVK0Cy)
   c  = 0
   lNum = len(lines) + 1
   for line in reversed(lines):
    line = line.strip()
    lNum -= 1
    if line and not line.startswith("#"):
     c += 1
     VVAkuK.append((str(c), line, str(lNum)))
   self.VVUwCB(VVAkuK, title, self.VVK0Cy, isHistory=True)
  else:
   FF8Wsn(self, self.VVK0Cy, title=title)
 def VVZCpJ(self):
  lastLine = FFTKR0("grep '.' '%s' | tail -1" % self.VVK0Cy)
  return lastLine.strip()
 def VVeI3W(self, cmd):
  try:
   with open(self.VVK0Cy, "a") as f:
    f.write("%s\n" % cmd)
  except Exception as e:
   FFdw58(self, str(e))
 def VVcXw8(self, VV6A99=None):
  FFimQ3(VV6A99 or self, BF(self.VVaS8y, VV6A99), "Loading Commands ...")
 def VVaS8y(self, VV6A99=None):
  if FFCyVu(self.VVXuHn):
   lines = FFL19l(self.VVXuHn)
   VVAkuK = []
   c  = 0
   lNum = 0
   defColor = ""
   for line in lines:
    line = line.strip()
    lNum += 1
    if line:
     c += 1
     color, line = self.VVdRY8(line)
     if not color.startswith("#f#") and iMatch("^[^a-zA-Z0-9_/]", line):
      color = "#f#00FF8055#" + defColor
     if color:
      if line:
       line = color + line
      else:
       defColor = color
       continue
     elif not line:
      defColor = ""
      continue
     else:
      line = defColor + line
     VVAkuK.append((str(c), line, str(lNum)))
   if VV6A99:
    VV6A99.VVMqQ9(VVAkuK)
    VV6A99.VVrqBw(CFG.lastTerminalCustCmdLineNum.getValue())
   else:
    self.VVUwCB(VVAkuK, "File : %s" % os.path.basename(self.VVXuHn), filePath=self.VVXuHn, isHistory=False)
  else:
   FF8Wsn(self, self.VVXuHn, title="Custom Commands")
 def VVdRY8(self, line):
  found = False
  span = iSearch(r"^\s*\[(.+)?\](.+?#.*)", line)
  if span:
   fgBg, line = span.groups()
   found = True
  else:
   span = iSearch(r"^([^#]+)(#)(.+)\[(.+)?\](.*)", line)
   if span:
    line, sep, txt1, fgBg, txt2 = span.groups()
    txt1 = txt1.strip(" #") if txt1 else ""
    txt2 = txt2.strip(" #") if txt2 else ""
    if   txt1 and txt2 : line += "\t%s %s ... %s" % (sep, txt1, txt2)
    elif txt1 or txt2 : line += "\t%s %s" % (sep, txt1 or txt2)
    found = True
   else:
    span = iSearch(r"^\s*\[(.+)?\](.+)?", line)
    if span:
     fgBg, line = span.groups()
     found = True
  if found:
   fg = bg = color = ""
   line = line.strip() if line else ""
   if fgBg:
    fg, _, bg = fgBg.partition(",")
    fg, bg = fg.strip(" #"), bg.strip(" #")
   c = self.VVPh6j(fg)
   if c: color = "#f#%s#" % c
   c = self.VVPh6j(bg)
   if c: color += "#b#%s#" % c
   return color, line
  return "", line
 def VVPh6j(self, txt):
  if txt:
   Dict = {"black": "000000", "red": "FF0000", "green": "00FF00", "blue": "0000FF", "yellow": "FFFF00", "cyan": "00FFFF", "purple": "FF00FF", "grey": "666666", "gray": "666666", "white": "FFFFFF"}
   tc = "22"
   Len = len(txt)
   color = Dict.get(txt.lower(), "")
   if color:
    return tc + color
   elif Len in (6,8) and iMatch("[a-fA-F0-9]", txt):
    if Len == 6 : return tc + txt
    if Len == 8 : return txt
  return ""
 def VVUwCB(self, VVAkuK, title, filePath=None, isHistory=False):
  if VVAkuK:
   if isHistory: VVwltY = VVkxBG = VVemyB = "#11000020"
   else  : VVwltY = VVkxBG = VVemyB = "#06002020"
   VVu1YM   = ("Send"   , BF(self.VVhugd, isHistory)  , [])
   VVwSzI  = ("Modify & Send" , self.VV3Tdh     , [])
   if isHistory:
    VVwdmN  = CFG.terminalFontSizeHist.getValue()
    VVScQz = ("Clear History" , self.VV9nUL     , [])
    VV4QTJ = None
    VV2ytr = None
   elif filePath:
    VVwdmN  = CFG.terminalFontSizeCmd.getValue()
    VVScQz = ("Options"  , self.VV7d13      , [])
    VV4QTJ = ("Edit File"  , BF(self.VVmsFF, filePath) , [])
    VV2ytr = (""    , self.VVlEf6     , [])
   header  = ("No." , "Commands", "LineNum" )
   widths  = (7  , 93   , 0    )
   VVLIqP = (CENTER , LEFT   , CENTER )
   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, height=1000, VVwdmN=VVwdmN, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VV2ytr=VV2ytr, VVSLOq=CFG.lastFindTerminal, VVHPI7=True, VVMfsO=1
         , VVwltY=VVwltY, VVkxBG=VVkxBG, VVemyB=VVemyB, VVoRat="#00ffffff", VVJKqd="#0a884400")
   if not isHistory:
    VV6A99.VVrqBw(CFG.lastTerminalCustCmdLineNum.getValue())
  else:
   FFRMYv(self, self.VV5K7M, "File is empty:\n\n%s\n\nSelect another file ?" % self.VVXuHn, title=title)
 def VVlEf6(self, VV6A99, title, txt, colList):
  txt  = "%s\n%s\n\n" % (FFjt5L("Command:", VVFuwR), colList[1])
  txt += "%s\n%s\n\n" % (FFjt5L("Line %s in File:" % colList[2], VVFuwR), self.VVXuHn)
  FF4lCP(self, txt, title=title)
 def VV7d13(self, VV6A99, title, txt, colList):
  if VV6A99.VVXWPu:
   totSel = VV6A99.VVc5NH()
   totTxt = str(totSel)
   txt = "Send %s Command%s" % (FFjt5L(totTxt, VVFuwR) if totSel else totTxt, FFcacr(totSel))
   item = (txt, "send") if totSel else (txt,)
  else:
   txt = "Send current line"
   item = (txt, "send")
  CCzSCo(self, VV6A99, setsOk=True, setsBlue=True, setsGreen=True).VV9VR2([item], { "send": BF(self.VVhugd, False, VV6A99, title, txt, colList) })
 def VVOeUB(self):
  VV3wat = []
  VV3wat.append(("Change Custom Commands File" , "chCmdF" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("%s Text Wrapping"     % ("Disable" if self["myLabel"].VViW1R else "Enable"), "wrap" ))
  VV3wat.append(("%s Terminal-Exit Confirmation" % ("Disable" if CFG.ConfirmTerminalExit.getValue() else "Enable"), "togExit"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Commands Table Font Size" , "cmdFntSz" ))
  VV3wat.append(("History Table Font Size" , "histFntSz" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Save Terminal Log File"  , "saveLog" ))
  FFLFTC(self, self.VVKvYu, VV3wat=VV3wat, title="Terminal Options", width=700)
 def VVKvYu(self, item):
  if item:
   if   item == "chCmdF" : self.VV5K7M()
   elif item == "wrap"  : self.VVxyCd()
   elif item == "togExit" : FFjt1c(CFG.ConfirmTerminalExit, not CFG.ConfirmTerminalExit.getValue())
   elif item == "cmdFntSz" : self.VVxWPa(True)
   elif item == "histFntSz": self.VVxWPa(False)
   elif item == "saveLog" : self["myLabel"].VVxeSU()
 def VVxyCd(self):
  self["myLabel"].VVOJVi()
  FFjt1c(CFG.terminalTextWrap, self["myLabel"].VViW1R)
 def VVxWPa(self, isCmdTbl):
  if isCmdTbl : confItem, txt = CFG.terminalFontSizeCmd , "Commands"
  else  : confItem, txt = CFG.terminalFontSizeHist, "History"
  CCJaSw.VV5YpJ(self, confItem, "%s Table Font Size" % txt, cbFnc=BF(FF1mVE, self, "Saved"), isSave=True, width=700)
 def VV5K7M(self):
  title = "Custom Commands File"
  VV3wat = []
  bPath = FF0cqc()
  for fName in sorted(os.listdir(bPath), key=lambda x: x[0].lower()):
   path = os.path.join(bPath, fName)
   if fName.lower().startswith(("ajpanel_cmd", "linuxcommands")) and os.path.isfile(path):
    if path == self.VVXuHn:
     fName = FFjt5L(fName, VVSGsk)
    VV3wat.append((fName, path))
  if VV3wat : FFLFTC(self, BF(self.VVcQf7, title), VV3wat=VV3wat, title=title, VVyRCy=3, VVtboQ="", VVwltY="#11220000", VVkxBG="#11220000")
  else  : FFdw58(self, "No valid files found in:\n\n%s" % bPath, title=title)
 def VVcQf7(self, title, path=None):
  if path:
   oldF = self.VVXuHn
   if CClYaF.VVgIOw(path):
    FFdw58(self, "Incorrect file format:\n\n%s" % path, title=title)
   elif path == self.VVXuHn:
    FF28n1(self, "No change", 1000)
   else:
    self.VVXuHn = path
    FFjt1c(CFG.terminalCmdFile, path)
    FFjt1c(CFG.lastTerminalCustCmdLineNum, 0)
    FF1mVE(self, "Changed")
 def VVhugd(self, isHistory, VV6A99, title, txt, colList):
  if VV6A99.VVXWPu:
   lst = VV6A99.VVf3uT(1)
   curNdx = VV6A99.VV6LTe()
  else:
   lst = [colList[1]]
   curNdx = VV6A99.VVGTqU()
  if not isHistory:
   FFjt1c(CFG.lastTerminalCustCmdLineNum, curNdx)
  self.VV3sPE = lst
  VV6A99.cancel()
  FFIElK(self.VVsnmC)
 def VVsnmC(self):
  if self.VV3sPE:
   cmd = self.VV3sPE[0]
   self.VV3sPE.pop(0)
   if not iMatch("^[a-zA-Z0-9_/]", cmd):
    self.VV0wMe("\n%s\n" % cmd, 6)
    self.VV0wMe(self.VVoEDc, 1)
    self.VVsnmC()
   else:
    self.VVShXV(cmd)
 def VVShXV(self, cmd, VVOuqa=""):
  if self.VVwZZX.VVY7lz():
   self.VVCPhp()
   return
  self["keyRed"].show()
  if cmd.startswith("passwd"):
   self.VV0wMe(cmd, 2)
   self.VV0wMe("\nCannot change passwrod from Console this way. Try using:\n", 4)
   txt = r'echo -e "NEW_PASSWORD\#nNEW_PASSWORD" | passwd'
   for ch in txt:
    if not ch == "#":
     self.VV0wMe(ch, 0)
   self.VV0wMe("\nor\n", 4)
   self.VV0wMe("echo root:NEW_PASSWORD | chpasswd\n", 0)
   self.VVGp1e()
  else:
   cmd = cmd.strip()
   modCmd = cmd
   span = iSearch(r"^(\/.+sh)(\s+#+.*)*$", cmd, IGNORECASE)
   if span:
    modCmd = "sh '%s'" % span.group(1)
    FFpwZS(FFb2oQ("chmod 755 '%s'" % cmd))
    txt = "%s%s\n" % (VVcPtB, cmd)
   elif cmd.endswith((".py", ".pyo", ".pyc")) and os.path.isfile(cmd):
    FFpwZS(FFb2oQ("chmod 755 '%s'" % cmd))
    modCmd = "python%s '%s'" % ("3" if pyVersion[0] >= 3 else "", cmd)
    txt = "%s%s\n" % (VVcPtB, cmd)
   elif "#" in cmd and not "\n" in cmd:
    parts = cmd.split("#")
    left  = VVGCYL + parts[0].strip()
    right = VVo7S9 + "#" + parts[1].strip()
    txt = "%s    %s\n" % (left, right)
   else:
    txt = "%s\n" % cmd
   self.VV0wMe(VVOuqa if VVOuqa else txt, 2)
   lastLine = self.VVZCpJ()
   if not lastLine or not cmd == lastLine:
    self.VVB2xR = cmd
    self.VVeI3W(cmd)
   span = iSearch(r".*cd\s+([\/?\w\.+\~]+)", cmd + ";")
   if span:
    self.VVXgOC = span.group(1)
   allOK = self.VVwZZX.VVtIZD(modCmd, self.VVGdej, VVimES=self.VVfg69, VVXgOC=self.VVXgOC)
   if not allOK:
    FFdw58(self, "Cannot connect to Console!")
   self.VVB2xR = cmd
 def VVfg69(self, data):
  self.VV0wMe(data, 3)
 def VVGdej(self, data, retval):
  if not retval == 0:
   self.VVYrFJ("Exit Code : %d" % retval)
  self.VVGp1e()
  if self.VV3sPE:
   self.VVsnmC()
 def VV3Tdh(self, VV6A99, title, txt, colList):
  if VV6A99.VVOOzr():
   cmd = colList[1]
   self.VVDxAJ(VV6A99, cmd)
 def VV9nUL(self, VV6A99, title, txt, colList):
  FFRMYv(self, BF(self.VVFQ6N, VV6A99), "Reset History File ?", title="Command History")
 def VVFQ6N(self, VV6A99):
  FF7ymp("> '%s'" % self.VVK0Cy)
  VV6A99.cancel()
 def VVmsFF(self, filePath, VV6A99, title, txt, colList):
  rowNum = int(colList[2].strip()) - 1
  if FFCyVu(filePath) : CCyMCP(self, filePath, VVbYwR=BF(self.VVlTnm, VV6A99), VVPhQC=rowNum)
  else     : FF8Wsn(self, filePath)
 def VVlTnm(self, VV6A99, fileChanged):
  if fileChanged:
   VV6A99.cancel()
   FFIElK(self.VVcXw8)
 def VVWf1a(self):
  if self.VVwZZX.VVY7lz():
   self.VVCPhp()
  else:
   self.VVDxAJ(None, "")
 def VVDxAJ(self, VV6A99, cmd):
  if "#" in cmd:
   cmd = cmd.split("#")[0].strip()
  FF4z45(self, BF(self.VVHUbU, VV6A99), title="Terminal", defaultText=cmd, message="Enter Command:")
 def VVHUbU(self, VV6A99, cmd):
  if cmd and len(cmd) > 0:
   self.VVShXV(cmd)
   if VV6A99:
    VV6A99.cancel()
 def VVse0r(self):
  FFw2rR(self, "_help_terminal", "Terminal Help")
class CCn30s(Screen):
 def __init__(self, session, title="", message="", VV47Xm=VVje9A, width=1400, height=900, VViOjF=False, isErr=False, titleBg="#22002020", VVemyB="#22001122", VVwdmN=30, VVllEU=50, resize=True, VVRhqH=""):
  if isErr: titleBg, VVemyB = "#22330000", "#22200000"
  self.skin, self.VVfOli = FFiNEe(VVmSQ6, width, height, VVllEU, 30, 20, titleBg, VVemyB, VVwdmN)
  self.session   = session
  FFZMxC(self, title, addScrollLabel=True)
  self.VV47Xm   = VV47Xm
  self.VViOjF   = VViOjF
  self.resize    = resize
  self.VVRhqH = VVRhqH
  if isinstance(message, list):
   try:
    self.message = "\n".join(message)
   except:
    pass
  self.message = str(message)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myLabel"].VV5kEH(VViOjF=self.VViOjF, VVRhqH=self.VVRhqH)
  self["myLabel"].setText(self.message, self.VV47Xm)
  self.VVvCvc()
 def VVDiQh(self, txt):
  self["myLabel"].appendText(txt)
  self.VVvCvc()
 def VVvCvc(self):
  if self.resize:
   self["myLabel"].VVfu0l()
class CCea0a(Screen):
 def __init__(self, session, txt):
  self.skin, self.VVfOli = FFiNEe(VVoNDw, 1800, 60, 30, 30, 20, "#55000000", "#ff000000", 30)
  self.session  = session
  self.txt   = txt
  self["myWinTitle"] = Label()
  FFZMxC(self, " ", addCloser=True)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  CChMGW.VVr9Gs(self, self.txt)
  self.instance.move(ePoint((getDesktop(0).size().width() - self.instance.size().width()) // 2, 20))
class CCtjms(Screen):
 def __init__(self, session, title="", message=""):
  self.skin, self.VVfOli = FFiNEe(VV5jiO, 1200, 300, 50, 20, 0, "#22330000", "#22200000", 30)
  self.session = session
  FFZMxC(self, title, addLabel=True, addCloser=True)
  self["errPic"] = Pixmap()
  self["myLabel"].setText(message)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FFkDgm(self["errPic"], "err")
class CCtm4v(Screen):
 def __init__(self, session, fnc, title="Processing ...", fntSize=28, bg="#22331133"):
  self.skin, self.VVfOli = FFiNEe(VVoNDw, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVU4ws=False)
  self.session = session
  self.fnc  = fnc
  self.Title  = str(title)
  self.fntSize = fntSize
  self.bg   = bg
  FFZMxC(self, " ")
  self["myWinTitle"] = Label()
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myInfoFrame"].show()
  body = self["myInfoBody"]
  body.show()
  body.setText(self.Title)
  body.instance.setFont(gFont(VVNhAq, self.fntSize))
  FFZ0AC(body, self.bg)
  FF4iwG(":", self.VVxPtx)
 def VVxPtx(self, result, retval):
  self.fnc()
  self.close()
class CC8Nur(Screen):
 def __init__(self, session, title, timeout=1500, fntSize=28, fg="#22ffffaa", bg="#22001100", isRed=False):
  self.skin, self.VVfOli = FFiNEe(VVoNDw, 500, 100, 10, 10, 30, "#FF000000", "#FF000000", 30, VVU4ws=False)
  self.session = session
  self.Title  = str(title)
  self.fntSize = fntSize
  self.fg   = fg
  self.bg   = "#00550000" if isRed else bg
  FFZMxC(self, " ", addCloser=True)
  self["myWinTitle"] = Label()
  self.timer = eTimer()
  try: self.timer_conn = self.timer.timeout.connect(self.close)
  except: self.timer.callback.append(self.close)
  self.timer.start(timeout, True)
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self["myInfoFrame"].show()
  body = self["myInfoBody"]
  body.show()
  body.setText(self.Title)
  body.instance.setFont(gFont(VVNhAq, self.fntSize))
  FF7hy1(body, self.fg, self.bg)
class CCqGqw(Screen):
 def __init__(self, session, txt, fntSize, bg="#FF000000"):
  self.skin, self.VVfOli = FFiNEe(VVoNDw, 1000, 50, 20, 30, 20, bg, bg, fntSize, VVU4ws=False)
  self.session  = session
  self["myWinTitle"] = Label()
  FFZMxC(self, " ", addCloser=True)
class CChMGW():
 def __init__(self, session, txt, timeout=1500, fonSize=24, x=30, y=20):
  self.session = session
  self.win  = CChMGW.VVNLfa(session, txt, fonSize, x=x, y=y)
  self.timer = eTimer()
  try: self.timer_conn = self.timer.timeout.connect(self.VVpxgz)
  except: self.timer.callback.append(self.VVpxgz)
  self.timer.start(timeout, True)
 def VVpxgz(self):
  self.session.deleteDialog(self.win)
 @staticmethod
 def VVNLfa(session, txt, fonSize, shadW=2, shadColor="#440000", bg="#FF000000", x=30, y=20):
  win = session.instantiateDialog(CCqGqw, str(txt).strip(), fonSize, bg=bg)
  win.show()
  FFK4PQ(win["myWinTitle"], shadColor, shadW)
  CChMGW.VVr9Gs(win, txt)
  if x < 0: x = (getDesktop(0).size().width() - win.instance.size().width()) // 2
  if y < 0: y = (getDesktop(0).size().height() - win.instance.size().height()) // 2
  win.instance.move(ePoint(x, y))
  return win
 @staticmethod
 def VVr9Gs(win, txt):
  win["myWinTitle"].setText(str(txt).strip())
  inst = win["myWinTitle"].instance
  w = inst.calculateSize().width() + 30
  h = int(inst.size().height())
  inst.resize(eSize(*(w, h)))
  win.instance.resize(eSize(*(w, h)))
class CCHRcZ():
 VVLHSO    = 0
 VVyzIo  = 1
 VVTaMF   = ""
 VVyEAg    = ""
 VVy3rX   = {}
 VVwbS2    = "ajpDownload"
 def __init__(self, SELF, mode, title, startDnld, VVZcRP=""):
  self.SELF     = SELF
  self.mode     = mode
  self.Title     = title
  self.VV6A99   = None
  self.timer     = eTimer()
  self.VV68m8   = 0
  self.VVfsD9  = 1
  self.VVqBma  = 2
  self.VVf0kA   = 3
  self.VVewiH   = 4
  CCHRcZ.VVyEAg = ""
  VVAkuK = self.VVX0Su()
  if VVAkuK:
   self.VV6A99 = self.VVFWOb(VVAkuK)
  if not VVAkuK and mode == self.VVLHSO:
   self.VVQ5VQ("Download list is empty !")
   self.cancel()
  if mode == self.VVyzIo:
   FFimQ3(self.VV6A99 or self.SELF, BF(self.VVCz4F, startDnld, VVZcRP), title="Checking Server ...")
  self.VVFPJZ(force=True)
  try: self.timer_conn = self.timer.timeout.connect(self.VVFPJZ)
  except: self.timer.callback.append(self.VVFPJZ)
  self.timer.start(1000, False)
 def VVFWOb(self, VVAkuK):
  VVAkuK.sort(key=lambda x: int(x[0]))
  VVu8qI = self.VVAvqF
  VVu1YM  = ("Play"  , self.VVx0TS , [])
  VV2ytr = (""   , self.VVlDhI  , [])
  VVwWmA = ("Stop"  , self.VVSOdJ  , [])
  VVwSzI = ("Resume"  , self.VVr1ws , [])
  VVScQz = ("Options" , self.VVEzGg  , [])
  VV4QTJ = ("Play URL" , self.VV0iZw , [])
  header   = ("No." , "Name" , "Type", "File Size", "Status" , "Progress", "Path", "sizeVal" , "URL" , "decoded-Url" , "oldSize" , "Speed" , "m3u8Log" )
  widths   = (5  , 39  , 8  , 13   , 13   , 11   , 0.01 , 0   , 0.01 , 0    , 0   , 11  , 0   )
  VVLIqP  = (CENTER, LEFT  , CENTER, CENTER  , CENTER , CENTER , LEFT , CENTER , LEFT , LEFT   , CENTER , CENTER , LEFT  )
  return FFUQ0v(self.SELF, None, title=self.Title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVwSzI=VVwSzI, VVScQz=VVScQz, VV4QTJ=VV4QTJ, VVSLOq=CFG.lastFindIptv, VVwltY="#11220022", VVkxBG="#11110011", VVemyB="#11110011", VVJKqd="#00223025", VVbcr0="#0a333333", VVX9AA="#0a400040", VVHPI7=True, VVMfsO=1)
 def VVX0Su(self):
  lines = CCHRcZ.VVXGK6()
  VVAkuK = []
  if lines:
   for ndx, line in enumerate(lines):
    if "," in line:
     parts  = line.split(",", 1)
     left  = parts[0].strip()
     VVZcRP = parts[1].strip()
     if left == "-1" or left.isdigit(): size, m3u8Log = int(left), ""
     else        : size, m3u8Log = -1  , left
     if VVZcRP:
      fName, VV1wIO, url = self.VVQajF(VVZcRP)
      if fName:
       if   FFKxIH(VVZcRP) : sType = "Movie"
       elif FF1BEt(VVZcRP) : sType = "Series"
       else      : sType = ""
       path = self.VVBFa1(VVZcRP, fName)
       if size > -1: sizeTxt = CClYaF.VV99gM(size, mode=4)
       else  : sizeTxt = ""
       status = prog = speed = oldSize = ""
       VVAkuK.append((str(len(VVAkuK) + 1), VV1wIO, sType, sizeTxt, status, prog, path, str(size), url, VVZcRP, oldSize, speed, m3u8Log))
  return VVAkuK
 def VV6wof(self):
  VVAkuK = self.VVX0Su()
  if VVAkuK:
   if self.VV6A99 : self.VV6A99.VVMqQ9(VVAkuK, VV5YRVMsg=False)
   else     : self.VV6A99 = self.VVFWOb(VVAkuK)
  else:
   self.cancel()
 def VVFPJZ(self, force=False):
  if self.VV6A99:
   thrListUrls = self.VV1sva()
   VVAkuK = []
   changed = False
   for ndx, row in enumerate(self.VV6A99.VVrrm9()):
    row = list(map(str.strip, row))
    num, name, typ, fSize, state, progr, path, sizeV, url, VVZcRP, oldSize, speed, m3u8Log = row
    flag = self.VV68m8
    if m3u8Log:
     percent = CCHRcZ.VVlzpX(m3u8Log)
     if percent > -1:
      if percent < 100: flag, progr = self.VVf0kA , "%.2f %%" % percent
      else   : flag, progr = self.VVewiH , "100 %"
     mPath = m3u8Log[:-9]
     curSize = FFXhoc(mPath)
     if curSize > -1:
      fSize = CClYaF.VV99gM(curSize, mode=4)
     try:
      if not oldSize in ("", "0", "-"):
       diff = int(curSize - int(oldSize))
       if diff:
        speed = CClYaF.VV99gM(diff, mode=4) + "/s"
     except:
      pass
    else:
     curSize = FFXhoc(path)
     if curSize > -1:
      if sizeV.isdigit():
       percent = float(curSize) / float(sizeV) * 100.0
       if percent < 100: flag, progr = self.VVf0kA , "%.2f %%" % percent
       else   : flag, progr = self.VVewiH , "100 %"
       try:
        if not oldSize in ("", "0", "-"):
         diff = int(curSize - int(oldSize))
         if diff:
          speed = CClYaF.VV99gM(diff, mode=4) + "/s"
       except:
        pass
    if VVZcRP in thrListUrls:
     flag = self.VVqBma
     if m3u8Log :
      if not speed and not force : flag = self.VVfsD9
      elif curSize == -1   : self.VVZGqS(False)
    elif flag == self.VV68m8  : speed = progr = "-"
    else        : speed = "-"
    color1 = "#f#00FF9999#" if m3u8Log else ""
    if   flag == self.VV68m8  : color2 = "#f#00555555#"
    elif flag == self.VVfsD9 : color2 = "#f#0000FFFF#"
    elif flag == self.VVqBma : color2 = "#f#0000FFFF#"
    elif flag == self.VVf0kA  : color2 = "#f#00FF8000#"
    elif flag == self.VVewiH  : color2 = "#f#0000FF00#"
    else        : color2 = "#f#00AAAAAA#"
    state = self.VV9va5(flag)
    oldSize = str(curSize)
    if [num, name, typ, fSize, state, progr, path, sizeV, url, VVZcRP, oldSize, speed, m3u8Log] != row:
     changed = True
    row[1]  = color1 + name
    row[2]  = color1 + typ
    row[3]  = color1 + fSize
    row[4]  = color2 + state
    row[5]  = color2 + progr
    row[10] = oldSize
    row[11] = speed if not speed.startswith("-") else "-"
    VVAkuK.append(row)
   if changed or force:
    self.VV6A99.VVMqQ9(VVAkuK, VV5YRVMsg=False)
   if CCHRcZ.VVyEAg : title = "%s\t %s%s" % (self.Title, VVYjI5, CCHRcZ.VVyEAg)
   else          : title = self.Title
   if self.VV6A99.VVpVUj().strip() != title:
    self.VV6A99.VV0ZtI(title)
 def VV9va5(self, flag):
  tDict = self.VVKcCc()
  return tDict.get(flag, "?")
 def VVxdi0(self, state):
  for flag, txt in self.VVKcCc().items():
   if txt == state:
    return flag
  return -1
 def VVKcCc(self):
  return { self.VV68m8: "Not started", self.VVfsD9: "Connecting", self.VVqBma: "Downloading", self.VVf0kA: "Stopped", self.VVewiH: "Completed" }
 def VVxIyd(self, title):
  colList = self.VV6A99.VV5crm()
  path = colList[6]
  url  = colList[8]
  if self.VVk3yS() : self.VVQ5VQ("Cannot delete while downloading.")
  else      : FFRMYv(self.SELF, BF(self.VVcgkp, path, url), "Delete ?\n\n%s" % path, title=title)
 def VVcgkp(self, path, url):
  m3u8Log = self.VV6A99.VV5crm()[12]
  if m3u8Log : FFpwZS("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
  else  : FFpwZS("rm -rf '%s'" % path)
  self.VVd1mb(False)
  self.VV6wof()
 def VVd1mb(self, VVwb7n=True):
  if self.VVk3yS():
   FF28n1(self.VV6A99, self.VV9va5(self.VVqBma), 500)
  else:
   colList  = self.VV6A99.VV5crm()
   state  = colList[4]
   VVZcRP = colList[9]
   if self.VVxdi0(state) in (self.VV68m8, self.VVewiH, self.VVf0kA):
    lines = CCHRcZ.VVXGK6()
    newLines = []
    found = False
    for line in lines:
     if CCHRcZ.VV6h6K(VVZcRP, line): found = True
     else            : newLines.append(line)
    if found:
     self.VVdJSh(newLines)
     self.VV6wof()
     FF28n1(self.VV6A99, "Removed.", 1000)
    else:
     FF28n1(self.VV6A99, "Not found.", 1000)
   elif VVwb7n:
    self.VVQ5VQ("Cannot remove partial download !\n\nYou can delete the file (from options).")
 def VV3Qjo(self, flag, title):
  ques = "Only remove from table (no file deletion).\n\nContinue ?"
  FFRMYv(self.SELF, BF(self.VVAkoO, flag), ques, title=title)
 def VVAkoO(self, flag):
  list = []
  for ndx, row in enumerate(self.VV6A99.VVrrm9()):
   state  = row[4].strip()
   VVZcRP = row[9].strip()
   flagVal  = self.VVxdi0(state)
   if   flag == flagVal == self.VVewiH: list.append(VVZcRP)
   elif flag == flagVal == self.VV68m8 : list.append(VVZcRP)
  lines = CCHRcZ.VVXGK6()
  totRem = 0
  newLines = []
  for line in lines:
   if any(x in line for x in list) : totRem += 1
   else       : newLines.append(line)
  if totRem > 0:
   self.VVdJSh(newLines)
   self.VV6wof()
   FF28n1(self.VV6A99, "%d removed." % totRem, 1000)
  else:
   FF28n1(self.VV6A99, "Not found.", 1000)
 def VVQ2Kb(self):
  colList  = self.VV6A99.VV5crm()
  path  = colList[6]
  VVZcRP = colList[9]
  png   = "%s.png" % os.path.splitext(path)[0]
  if FFCyVu(png) : FF28n1(self.VV6A99, "Poster exists", 1500)
  else    : FFimQ3(self.VV6A99, BF(self.VVXbFa, VVZcRP, path, png), title="Checking Server ...")
 def VVXbFa(self, VVZcRP, path, png):
  err = self.VVbwYV(VVZcRP, path, png)
  if err:
   FFdw58(self.SELF, err, title="Poster Download")
 def VVbwYV(self, VVZcRP, path, png):
  epg, evLst, VVfbmn, err = CCvjVs.VVPhf6(VVZcRP)
  if not VVfbmn:
   return "Cannot download poster.\n\nTry downloading it from IPTV the tables."
  ext = os.path.splitext(VVfbmn)[1] or ".png"
  tPath, err = FFx9uM(VVfbmn, "ajp_tmp%s" % ext, timeout=2, VVzHui=True)
  if err:
   return "Cannot download poster !\n\n%s" % err
  else:
   png = "%s%s" % (os.path.splitext(path)[0], ext)
   FFpwZS("mv -f '%s' '%s'" % (tPath, png))
   CCf8zb.VVjnMn(self.SELF, VVPq2Z=png, showGrnMsg="Saved")
   return ""
 def VVlDhI(self, VV6A99, title, txt, colList):
  def VVVuRT(key, val) : return "%s\t: %s\n" % (key, val.strip())
  def VVJi7Q(key, val) : return "\n%s:\n%s\n" % (FFjt5L(key, VVFuwR), val.strip())
  heads  = self.VV6A99.VVeVZB()
  txt = ""
  for i in range(6):
   if i == 3:
    totSize = colList[7].strip()
    curSize = colList[10].strip()
    if totSize and totSize.isdigit(): txt += VVVuRT(heads[i]  , CClYaF.VV99gM(int(totSize), mode=0))
    if curSize and curSize.isdigit(): txt += VVVuRT("Downloaded" , CClYaF.VV99gM(int(curSize), mode=0))
   else:
    txt += VVVuRT(heads[i], colList[i])
  if not "j.php" in colList[9]:
   for i in (6, 8):
    txt += VVJi7Q(heads[i], colList[i])
  FF4lCP(self.SELF, txt, title=title)
 def VVx0TS(self, VV6A99, title, txt, colList):
  path = colList[6].strip()
  m3u8Log = colList[12].strip()
  if m3u8Log:
   path = m3u8Log[:-9]
  if FFCyVu(path) : CClYaF.VVTWR0(self.SELF, path)
  else    : FF28n1(self.VV6A99, "File not found", 1000)
 def VV0iZw(self, VV6A99, title, txt, colList):
  VV1wIO = colList[1].strip()
  path = colList[6].strip()
  tUrl = colList[9].strip()
  tUrl = tUrl.replace(":" + VV1wIO, "")
  tUrl = tUrl.replace(":", "%3a")
  Id  = "555"
  VVPxk5 = CCkEI5.VVpX1r(Id, Id, Id)
  chUrl = "%s%s:%s" % (VVPxk5, tUrl, VV1wIO)
  VVAfO9 = CCvjVs.VVbTkM(path)
  CCqWM2.VVHc02(self.SELF.session, VVaHNe=chUrl, VVAfO9=VVAfO9, VVEBd5=False, VVdxwH=False, VVOOLD=False)
 def VVAvqF(self, VV6A99):
  self.cancel()
 def cancel(self):
  self.timer.stop()
  if self.VV6A99:
   self.VV6A99.cancel()
  del self
 def VVEzGg(self, VV6A99, title, txt, colList):
  c1, c2, c3 = VVIH76, VVz22H, VVFuwR
  path  = colList[6].strip()
  VVZcRP = colList[9].strip()
  resumeTxt = "Disable" if CFG.downloadAutoResume.getValue() else "Enable"
  showMonitor = "Disable" if CFG.downloadMonitor.getValue() else "Enable"
  VV3wat = []
  VV3wat.append((c1 + "Remove current row"       , "VVd1mb" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c1 + 'Remove all "Completed"'      , "remFinished"   ))
  VV3wat.append((c1 + 'Remove all "Not started"'     , "remPending"   ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Delete the file (and remove from list)"  , "VVxIyd"))
  VV3wat.append(VVAL3j)
  VV3wat.append((resumeTxt + " Auto Resume"       , "VVsvWO" ))
  VV3wat.append((showMonitor + " On-screen Download Monitor"  , "toggleMonitor"  ))
  VV3wat.append(VVAL3j)
  cond = FFKxIH(VVZcRP)
  VV3wat.append(FFsLU5("Download Movie Poster %s" % ("(from server)" if cond else "... Movies only"), "VVQ2Kb", cond, c3))
  VV3wat.append(FFsLU5("Open in File Manager", "inFileMan,%s" % path, FFCyVu(path), c3))
  FFLFTC(self.SELF, BF(self.VVZ8HY, VV6A99), VV3wat=VV3wat, title=self.Title, VVU8mZ=True, width=800, VVlaGv=True, VVwltY="#1a001122", VVkxBG="#1a001122")
 def VVZ8HY(self, VV6A99, item=None):
  if item:
   txt, ref, ndx = item
   if   ref == "VVd1mb"  : self.VVd1mb()
   elif ref == "remFinished"   : self.VV3Qjo(self.VVewiH, txt)
   elif ref == "remPending"   : self.VV3Qjo(self.VV68m8, txt)
   elif ref == "VVxIyd" : self.VVxIyd(txt)
   elif ref == "VVQ2Kb"  : self.VVQ2Kb()
   elif ref == "VVsvWO"  : FFjt1c(CFG.downloadAutoResume, not CFG.downloadAutoResume.getValue())
   elif ref == "toggleMonitor"   : FFjt1c(CFG.downloadMonitor, not CFG.downloadMonitor.getValue())
   elif ref.startswith("inFileMan,") :
    path = ref.split(",", 1)[1]
    if VVmJwX(path) : self.SELF.session.open(CClYaF, mode=CClYaF.VV4Ihm, VVHYTc=path)
    else    : FF28n1(VV6A99, "Path not found !", 1500)
 def VVCz4F(self, startDnld, VVZcRP):
  refreshToken = True
  if not VVZcRP:
   VVZcRP = CC3rDi(self.SELF.session).VVZcRP
  else:
   ndx = VVZcRP.find("j.php")
   if ndx > -1:
    url = CC96QG.VVqzuM(VVZcRP)
    if url:
     span = iSearch(r"&.+=", VVZcRP)
     if span : VVZcRP = url + "&" + VVZcRP[ndx + 6:]
     else : VVZcRP = url + VVZcRP[ndx + 5:]
     refreshToken = False
    else:
     self.VVQ5VQ("Could not get download link !\n\nTry again later.")
     return
  for line in CCHRcZ.VVXGK6():
   if CCHRcZ.VV6h6K(VVZcRP, line):
    if self.VV6A99:
     self.VVYJQw(VVZcRP)
     FFIElK(BF(FF28n1, self.VV6A99, "Already listed !", 2000))
    break
  else:
   fnc = self.cancel if self.mode == self.VVyzIo else None
   params = self.VVVwJR(VVZcRP, refreshToken)
   if len(params) == 1:
    self.VVQ5VQ(params[0])
    if fnc:
     fnc()
   elif len(params) == 2:
    resp, VV1wIO = params
    FFRMYv(self.SELF, BF(self.VVB92s, resp, VVZcRP), "Start downloading ?\n\n%s" % VV1wIO, callBack_No=fnc, title="Download (m3u8)")
   else:
    url, fSize, path, resp, resumable = params
    title= "Download : %s" % CClYaF.VV99gM(fSize)
    FFRMYv(self.SELF, BF(self.VVBfeH, VVZcRP, url, fSize, path, resp, startDnld), "Download to\n\n%s" % path, callBack_No=fnc, title=title)
 def VVBfeH(self, VVZcRP, url, fSize, path, resp, startDnld):
  with open(CCHRcZ.VVotCb(), "a") as f:
   f.write("%s,%s\n" % (fSize, VVZcRP))
  self.VV6wof()
  if self.VV6A99:
   self.VV6A99.VVMjPT()
  if startDnld:
   threadName = "%s{%s,Sz,}%s" % (CCHRcZ.VVwbS2, path, VVZcRP)
   self.VVRbSF(threadName, url, VVZcRP, path, resp)
 def VVYJQw(self, VVZcRP):
  if self.VV6A99:
   for ndx, row in enumerate(self.VV6A99.VVrrm9()):
    VVZcRP2 = row[9].strip()
    if VVZcRP == VVZcRP2 and self.VV6A99:
     self.VV6A99.VVrqBw(ndx)
     break
 def VVVwJR(self, VVZcRP, checkExist=True, resumeByte=-1, refreshToken=True):
  fName = ""
  if VVZcRP:
   fName, VV1wIO, url = self.VVQajF(VVZcRP)
  if not fName:
   return ["Cannot process URL parameters !"]
  path = self.VVBFa1(VVZcRP, fName)
  if checkExist and FFCyVu(path):
   return ["File already exists:\n\n%s" % path]
  if refreshToken and "chCode" in VVZcRP:
   url = CC96QG.VVqzuM(VVZcRP)
   if not url:
    return ["Could not get download link from server!"]
  fSize = 0
  resumable = False
  try:
   headers = CCkEI5.VVgoVw()
   if resumeByte > -1:
    headers["Range"] = "bytes=%d-" % resumeByte
   import requests
   resp = requests.get(url, headers=headers, timeout=3, stream=True, verify=True)
   if not resp.ok:
    return ["Err-%d : %s" % (resp.status_code, resp.reason)]
   head = resp.headers
   fSize = head.get("Content-Length", "")
   cType = head.get("Content-Type", "")
   resumable = CCHRcZ.VV5qrn(resp)
  except:
   return ["Could not get file info from server !"]
  if not fSize or not fSize.isdigit():
   return ["Cannot get file size from server !"]
  fSize = int(fSize)
  if not "video" in cType and not "application/octet-stream" in cType:
   if ".m3u8" in resp.url:
    return [resp, VV1wIO]
   elif path and resp.url and fSize:
    pass
   else:
    return ["Cannot download this video !\n\nIncorrect download data (or not allowed by server)."]
  err = CCHRcZ.VVymoR(fSize)
  if err:
   return [err]
  return [url, fSize, path, resp, resumable]
 def VVB92s(self, resp, VVZcRP):
  if not FFayeZ("ffmpeg"):
   FFRMYv(self.SELF, BF(CCkEI5.VVGS56, self.SELF), '"FFmpeg" not found !\n\nInstall FFmpeg ?', title=VV1wIO)
   return
  fName, VV1wIO, url = self.VVQajF(VVZcRP)
  dest = os.path.join(CFG.MovieDownloadPath.getValue(), fName)
  self.m3u8_params = resp, VVZcRP, dest, fName, VV1wIO, url
  rTxt = str(resp.text)
  rUrl = str(resp.url)
  if "#EXT-X-STREAM-INF" in rTxt:
   self.VVMZr7(rTxt, rUrl)
  elif "#EXTINF:" in rTxt:
   if FFCyVu(dest) : FFRMYv(self.SELF, BF(self.VVCo20, rTxt, rUrl), "Overwrite existing file ?\n\n%s" % dest, title=VV1wIO)
   else    : self.VVCo20(rTxt, rUrl)
  else:
   self.VVQ5VQ("Cannot process m3u8 file !")
 def VVMZr7(self, rTxt, rUrl):
  lst   = iFindall(r"RESOLUTION=(\d+x\d+).*\n(.+)", rTxt, IGNORECASE)
  VV3wat = []
  for resol, fPath in lst:
   resol = str(resol).replace("x", " x ")
   fPath = str(fPath)
   fullUrl = CCkEI5.VVyjSu(rUrl, fPath)
   VV3wat.append((resol, fullUrl))
  if VV3wat:
   FFLFTC(self.SELF, self.VVpq1h, VV3wat=VV3wat, title="Resolution", VVU8mZ=True, VVlaGv=True)
  else:
   self.VVQ5VQ("Cannot get Resolutions list from server !")
 def VVpq1h(self, item=None):
  if item:
   txt, resolUrl, ndx = item
   resp, VVZcRP, dest, fName, VV1wIO, url = self.m3u8_params
   resol = txt.replace(" ", "")
   fPath, fExt = os.path.splitext(fName)
   fName = "%s_%s%s" % (fPath, resol, fExt)
   fPath, fExt = os.path.splitext(dest)
   dest = "%s_%s%s" % (fPath, resol, fExt)
   self.m3u8_params = resp, VVZcRP, dest, fName, VV1wIO, url
   if FFCyVu(dest):
    FFRMYv(self.SELF, BF(FFIElK, BF(self.VVObWI, resolUrl)), "Overwrite existing file ?\n\n%s" % dest, title=VV1wIO)
   else:
    FFIElK(BF(self.VVObWI, resolUrl))
 def VVObWI(self, resolUrl):
  resp, txt, err = CC96QG.VVKe8x(resolUrl)
  if err : self.VVQ5VQ(err)
  else : self.VVCo20(txt, resolUrl)
 def VVTuFo(self, logF, VVZcRP):
  found = False
  lines = CCHRcZ.VVXGK6()
  with open(CCHRcZ.VVotCb(), "w") as f:
   for line in lines:
    if CCHRcZ.VV6h6K(VVZcRP, line):
     line = "%s,%s" % (logF, VVZcRP)
     found = True
    f.write(line + "\n")
  if not found:
   with open(CCHRcZ.VVotCb(), "a") as f:
    f.write("%s,%s\n" % (logF, VVZcRP))
  self.VV6wof()
  if self.VV6A99:
   self.VV6A99.VVMjPT()
 def VVCo20(self, rTxt, rUrl):
  resp, VVZcRP, dest, fName, VV1wIO, url = self.m3u8_params
  fName = FFOu5Y(fName)
  dest  = FFOu5Y(dest)
  m3u8File = os.path.join(CFG.MovieDownloadPath.getValue(), "%s.m3u8" % fName)
  with open(m3u8File, "w") as f:
   lines = rTxt.splitlines()
   for line in lines:
    line = line.strip()
    if line.startswith(("#EXTM", "#EXT-")) and not line.startswith("#EXT-X-ENDLIST"):
     f.write(line + "\n")
  lst = iFindall(r"(#EXTINF:.+)\n(.+)", rTxt, IGNORECASE)
  if lst:
   with open(m3u8File, "a") as f:
    for extInf, fPath in lst:
     extInf = str(extInf)
     fPath = str(fPath)
     fPath = CCkEI5.VVyjSu(rUrl, fPath)
     f.write(extInf + "\n")
     f.write(fPath + "\n")
    f.write("#EXT-X-ENDLIST\n")
  else:
   self.VVQ5VQ("Incorrect m3u8 file from server !")
   return
  logF = "%s.log" % m3u8File
  self.VVTuFo(logF, VVZcRP)
  cmd  = "ffmpeg -y -hide_banner -protocol_whitelist file,http,https,tcp,tls,crypto -i '%s' -c copy '%s' > '%s' 2>&1" % (m3u8File, dest, logF)
  cmd += " && %s" % FFb2oQ("rm -f '%s' '%s'" % (m3u8File, logF))
  threadName = "%s{%s,,%s}%s" % (CCHRcZ.VVwbS2, dest, logF, VVZcRP)
  myThread = iThread(name=threadName, target=BF(os.system, cmd))
  myThread.start()
 @staticmethod
 def VVlzpX(dnldLog):
  if FFCyVu(dnldLog):
   dur = CCHRcZ.VVHu70(dnldLog)
   if dur > -1:
    tim = CCHRcZ.VV1Wre(dnldLog)
    if tim > -1:
     return float(tim) / float(dur) * 100
  elif FFCyVu(dnldLog[:-9]):
   return 100
  return -1
 @staticmethod
 def VVHu70(dnldLog):
  lines = FF3xOt("head -n 15 %s" % dnldLog)
  for line in lines:
   span = iSearch(r"Duration:\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
   if span:
    return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
  return -1
 @staticmethod
 def VV1Wre(dnldLog):
  lines = FF3xOt("tail -n 15 %s" % dnldLog)
  for line in reversed(lines):
   span = iSearch(r"time=\s*(\d+):(\d+):(\d+.\d+)\s*", line, IGNORECASE)
   if span:
    return int(span.group(1)) * 3600 + int(span.group(2)) * 60 + float(span.group(3))
  return -1
 def VVBFa1(self, url, fName):
  path = CFG.MovieDownloadPath.getValue()
  if FF1BEt(url):
   span = iSearch(r"(.+)S\d\dE\d\d|(.+)Season_\d{1,2}_\d{1,2}", fName, IGNORECASE)
   if span:
    path1 = path + (span.group(1) or span.group(2)).strip("_(")
    FFpwZS("mkdir '%s'" % path1)
    if VVmJwX(path1):
     return path1 + "/" + fName
  return path + fName
 def VVRbSF(self, threadName, url, VVZcRP, path, resp, isAppend=False):
  totFileSize = int(self.VV6A99.VV5crm()[7])
  threadName = threadName.replace(",Sz,", ",%s," % totFileSize)
  myThread = iThread(name=threadName, target=BF(self.VVHkvh, url, VVZcRP, path, resp, totFileSize, isAppend))
  myThread.start()
 def VVHkvh(self, url, VVZcRP, path, resp, totFileSize, isAppend):
  CCHRcZ.VVyEAg = ""
  totBytes = 0
  try:
   with open(path, "ab" if isAppend else "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
     if FFCyVu(path):
      if chunk:
       try:
        f.write(chunk)
        self.VVQpOu(path)
       except Exception as e:
        CCHRcZ.VVyEAg = str(e)
        return
      if CCHRcZ.VVTaMF == path:
       CCHRcZ.VVTaMF = ""
       return
     else:
      break
  except Exception as e:
   if not self.VVpAqb(path, e):
    return
  if CFG.downloadAutoResume.getValue():
   curSize = FFXhoc(path)
   if curSize > -1 and not curSize == totFileSize:
    params = self.VVVwJR(VVZcRP, checkExist=False, resumeByte=curSize)
    if len(params) > 1:
     url, fSize, path, resp, resumable = params
     if resumable:
      self.VVHkvh(url, VVZcRP, path, resp, totFileSize, True)
 def VVpAqb(self, path, e):
  if "IncompleteRead" in str(e):
   now = iTime()
   cnt, tm = 0, now
   if path in CCHRcZ.VVy3rX:
    cnt, tm = CCHRcZ.VVy3rX[path]
    if cnt > 2 and now > tm + 3:
     self.VVQpOu(path)
     return False
    else:
     iSleep(1)
   self.VVDZip(path, cnt + 1, tm)
  return True
 def VVDZip(self, path, cnt, tm):
  CCHRcZ.VVy3rX[path] = (cnt, tm)
 def VVQpOu(self, path):
  if path in CCHRcZ.VVy3rX: CCHRcZ.VVy3rX.pop(path)
 def VVSOdJ(self, VV6A99, title, txt, colList):
  m3u8Log = colList[12].strip()
  VVZcRP = colList[9].strip()
  if       self.VVE8tj() : FF28n1(self.VV6A99, self.VV9va5(self.VVewiH), 500)
  elif not self.VVk3yS() : FF28n1(self.VV6A99, self.VV9va5(self.VVf0kA), 500)
  elif m3u8Log      : FFRMYv(self.SELF, self.VVZGqS, "This may stop other non-resumable files !\n\nStop anyway ?", title="Stopping non-resumable download")
  else:
   if VVZcRP in self.VV1sva():
    CCHRcZ.VVTaMF = colList[6]
    FF28n1(self.VV6A99, "Stopping ...", 1000)
   else:
    FF28n1(self.VV6A99, "Stopped", 500)
 def VVZGqS(self, withMsg=True):
  if withMsg:
   FF28n1(self.VV6A99, "Stopping ...", 1000)
  FFpwZS("killall -INT ffmpeg")
 def VVr1ws(self, *args):
  if   self.VVE8tj() : FF28n1(self.VV6A99, self.VV9va5(self.VVewiH) , 500)
  elif self.VVk3yS() : FF28n1(self.VV6A99, self.VV9va5(self.VVqBma), 500)
  else:
   resume = False
   m3u8Log = self.VV6A99.VV5crm()[12]
   if m3u8Log:
    if FFCyVu(m3u8Log) : FFRMYv(self.SELF, BF(self.VV2fZj, m3u8Log), "Cannot resume m3u8 type !\n\nDelete file and restart download ?", title="Resume")
    else     : resume = True
   elif self.VVjN99():
    resume = True
   if resume: self.VVGE1C(self.VV6A99)
   else  : FF28n1(self.VV6A99, "Cannot resume !", 500)
 def VV2fZj(self, m3u8Log):
  FFpwZS("rm -f '%s' '%s' '%s'" % (m3u8Log, m3u8Log[:-4], m3u8Log[:-9]))
  self.VVGE1C(self.VV6A99)
 @FFOAKH("Checking Server ...", par=1)
 def VVGE1C(self, tbl):
  colList  = self.VV6A99.VV5crm()
  path  = colList[6]
  size  = colList[7]
  VVZcRP = colList[9]
  if "j.php" in VVZcRP:
   url = CC96QG.VVqzuM(VVZcRP)
   if url:
    VVZcRP = self.VVSHyu(VVZcRP, url)
   else:
    self.VVQ5VQ("Could not get download link !\n\nTry again later.")
    return
  curSize = FFXhoc(path)
  params = self.VVVwJR(VVZcRP, checkExist=False, resumeByte=curSize)
  if len(params) == 1:
   self.VVQ5VQ(params[0])
   return
  elif len(params) == 2:
   self.VVB92s(params[0], VVZcRP)
   return
  url, fSize, path, resp, resumable = params
  if size == "-1":
   VVZcRP = self.VVSHyu(VVZcRP, url, fSize)
  threadName = "%s{%s,Sz,}%s" % (CCHRcZ.VVwbS2, path, VVZcRP)
  if resumable: self.VVRbSF(threadName, url, VVZcRP, path, resp, isAppend=True)
  else  : self.VVQ5VQ("Cannot resume from server !")
 def VVQajF(self, VVZcRP):
  span = iSearch(r"\?ext=(\..{3})", VVZcRP)
  fileExt = CCkEI5.VVZniM(VVZcRP) or (span.group(1) if span else "") or ".mp4"
  fixName = True
  url = fName = VV1wIO = ""
  tUrl = iSub(r"[&?]mode=.+end=", r"", VVZcRP, flags=IGNORECASE)
  span = iSearch(r"(https?:\/\/.+\/(?:movie|series).+\/.+\/)(.+)(:.+)", tUrl, IGNORECASE)
  if span:
   url  = span.group(1)
   fName = span.group(2)
   VV1wIO = span.group(3)
  elif "j.php" in tUrl:
   span = iSearch(r"(.+j.php)(:.+)", tUrl, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = "tmp"
    VV1wIO = span.group(2)
  elif "/play/" in VVZcRP:
   span = iSearch(r"(.+)&mode.+&end=(:.+)", VVZcRP, IGNORECASE)
   if span:
    url = span.group(1)
    VV1wIO = span.group(2)
   span = iSearch(r".+movie.php?.+stream=(.+\..{3,4})&.+", VVZcRP, IGNORECASE)
   if span     : fName = span.group(1)
   elif fileExt == ".php" : fName = ".mkv" if ".mkv" in VVZcRP else ".mp4"
   else     : fName = fileExt
  elif "get_download_link" in VVZcRP:
   span = iSearch(r"(.+)&mode.+chCm=(.+)&end=(:.+)", VVZcRP, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = os.path.basename(span.group(2))
    VV1wIO = span.group(3).replace(":", "_").strip("_")
    fixName = False
  elif "/timeshift/" in VVZcRP:
   span = iSearch(r"(http.+\/timeshift\/.+(\..+)):(.+)(?:\s>>\s(.+))", VVZcRP, IGNORECASE)
   if span:
    url, ext, VV1wIO, movNm = span.groups()
    fName = movNm + (ext or ".ts")
    fixName = False
  else:
   ok = False
   span = iSearch(r"(.+\/(.+.mp4).+m3u8).+:(.+)", VVZcRP, IGNORECASE)
   if span:
    url  = span.group(1)
    fName = span.group(2)
    VV1wIO = span.group(3)
    fixName = False
    ok  = True
   if not ok:
    span = iSearch(r"(.+\/.+m3u8).*:(.+)", VVZcRP, IGNORECASE)
    if span:
     url  = span.group(1)
     VV1wIO = span.group(2)
     fName = VV1wIO + fileExt
     fixName = False
     ok  = True
   if not ok and FFUl6q(VVZcRP):
    span = iSearch(r"(.+)\?\:(.+)", VVZcRP, IGNORECASE)
    if span:
     url  = span.group(1)
     VV1wIO = span.group(2)
     fName = VV1wIO + fileExt
     fixName = False
    else:
     span = iSearch(r"(.+):(.+)", VVZcRP, IGNORECASE)
     if span:
      url  = span.group(1)
      VV1wIO = span.group(2)
      fName = VV1wIO + fileExt
      fixName = False
  if url and fName and VV1wIO:
   if fixName:
    mix  = fName + VV1wIO
    parts = mix.split(":", 1)
    fName = parts[0]
    VV1wIO = parts[1]
    fName = iSub(r"[?]play_token.+", r"", fName, flags=IGNORECASE)
    url += fName
   VV1wIO1 = VV1wIO.replace(" ", "_")
   fName = VV1wIO1 + "_" + fName.lstrip("_")
   fName = FFOu5Y(fName)
   if fName.endswith(".vod"): fName += ".mp4"
   return fName, VV1wIO, url
  else:
   return "", "", ""
 def VVQ5VQ(self, txt):
  FFdw58(self.SELF, txt, title=self.Title)
 def VV1sva(self):
  thrListUrls = []
  for thr in iEnumerate():
   span = iSearch(r"%s(?:{.+})*(.+)" % CCHRcZ.VVwbS2, thr.name, IGNORECASE)
   if span:
    thrListUrls.append(span.group(1))
  return thrListUrls
 def VVk3yS(self):
  VVZcRP = self.VV6A99.VV5crm()[9]
  return VVZcRP in self.VV1sva()
 def VVE8tj(self):
  colList = self.VV6A99.VV5crm()
  path = colList[6]
  size = colList[7]
  m3u8Log = colList[12]
  if m3u8Log:
   return FFCyVu(m3u8Log[:-9]) and not FFCyVu(m3u8Log)
  else:
   if size == "-1" : return False
   else   : return str(FFXhoc(path)) == size
 def VVjN99(self):
  colList = self.VV6A99.VV5crm()
  path = colList[6]
  size = int(colList[7])
  curSize = FFXhoc(path)
  if curSize > -1:
   size -= curSize
  err = CCHRcZ.VVymoR(size)
  if err:
   FFdw58(self.SELF, err, title=self.Title)
   return False
  return True
 def VVdJSh(self, list):
  with open(CCHRcZ.VVotCb(), "w") as f:
   for line in list:
    f.write(line + "\n")
 def VVSHyu(self, VVZcRP, newUrl, newSize=-1):
  found = False
  lines = CCHRcZ.VVXGK6()
  url = VVZcRP
  with open(CCHRcZ.VVotCb(), "w") as f:
   for line in lines:
    if CCHRcZ.VV6h6K(VVZcRP, line):
     parts = line.split(",", 1)
     oldUrl = parts[1].strip()
     if newSize and not newSize == -1: fSize = str(newSize)
     else       : fSize = parts[0]
     ndx = url.find("j.php")
     if ndx > -1:
      url = newUrl + url[ndx + 5:]
     line = "%s,%s" % (fSize, url)
     found = True
    f.write(line + "\n")
  if found:
   self.VV6wof()
  return url
 @staticmethod
 def VVXGK6():
  list = []
  if FFCyVu(CCHRcZ.VVotCb()):
   for line in FFL19l(CCHRcZ.VVotCb()):
    line = line.strip()
    if line:
     list.append(line)
  return list
 @staticmethod
 def VV6h6K(VVZcRP, line):
  span = iSearch(r"(mode=.+end=.+)", VVZcRP, IGNORECASE)
  if span: VVZcRP = span.group(1)
  span = iSearch(r"(mode=.+end=.+)", line, IGNORECASE)
  if span: line = span.group(1)
  return VVZcRP in line
 @staticmethod
 def VVymoR(size, path=""):
  dest = path or CFG.MovieDownloadPath.getValue()
  if VVmJwX(dest):
   total, used, free, avail, err = CClYaF.VVdlF7(dest)
   if avail > size : return ""
   else   : return "No enough space on mount for:\n%s\n\nFile Size = %s\nAvailable Space = %s" % (dest, CClYaF.VV99gM(size), CClYaF.VV99gM(avail))
  else:
   return "Path not found !\n\n%s" % dest
 @staticmethod
 def VVn3G5(SELF):
  tot = CCHRcZ.VVY2Xw()
  if tot:
   FFdw58(SELF, "Cannot change while downloading.", title="")
   return True
  else:
   return False
 @staticmethod
 def VVY2Xw():
  c = 0
  for thr in iEnumerate():
   if thr.name.startswith(CCHRcZ.VVwbS2):
    c += 1
  return c
 @staticmethod
 def VVs4T7():
  lst = []
  for thr in iEnumerate():
   span = iSearch(r"%s(?:{(.+),(.*),(.*)}).+" % CCHRcZ.VVwbS2, thr.name, IGNORECASE)
   if span:
    lst.append((span.group(1), span.group(2), span.group(3)))
  return lst
 @staticmethod
 def VVAbZK():
  return len(CCHRcZ.VVXGK6()) == 0
 @staticmethod
 def VVubE7():
  list = []
  for p in harddiskmanager.getMountedPartitions():
   list.append(p.mountpoint)
  return list
 @staticmethod
 def VVehLC():
  mPoints = CCHRcZ.VVubE7()
  list = []
  for mPath in mPoints:
   if not mPath == "/":
    path = mPath + "/movie/"
    if VVmJwX(path) : return path
    else    : list.append(mPath)
  drives = ("/hdd", "/usb", "/sd")
  for mPath in list:
   if any(x in mPath for x in drives):
    path = mPath + "/movie/"
    FFpwZS("mkdir '%s'" % path)
    if VVmJwX(path):
     return path
  return "/tmp/"
 @staticmethod
 def VVotCb():
  return FF0cqc() + "ajpanel_downloads"
 @staticmethod
 def VVSZMa(SELF, waitMsgObj=None):
  FFimQ3(waitMsgObj or SELF, BF(CCHRcZ.VVb4jU, SELF, CCHRcZ.VVLHSO))
 @staticmethod
 def VVIcV1(SELF):
  CCHRcZ.VVb4jU(SELF, CCHRcZ.VVyzIo, startDnld=True)
 @staticmethod
 def VVXNDk(SELF, url):
  CCHRcZ.VVb4jU(SELF, CCHRcZ.VVyzIo, startDnld=True, VVZcRP=url)
 @staticmethod
 def VVfHMV(SELF):
  added, skipped = CCHRcZ.VVNrGg([CC3rDi(SELF.session).VVZcRP])
  FF1mVE(SELF, "Added", 1000)
 @staticmethod
 def VVNrGg(list):
  added = skipped = 0
  for line in CCHRcZ.VVXGK6():
   for ndx, url in enumerate(list):
    if url and CCHRcZ.VV6h6K(url, line):
     skipped += 1
     list[ndx] = ""
     break
  with open(CCHRcZ.VVotCb(), "a") as f:
   for url in list:
    if url:
     added += 1
     f.write("-1,%s\n" % url)
  return added, skipped
 @staticmethod
 def VVb4jU(SELF, mode, startDnld=False, VVZcRP=""):
  title = "Download Manager"
  if not CCwhE4.VVOJRa(SELF):
   return
  if mode == CCHRcZ.VVLHSO and CCHRcZ.VVAbZK():
   FFdw58(SELF, "Download list is empty !", title=title)
  else:
   inst = CCHRcZ(SELF, mode, title, startDnld=startDnld, VVZcRP=VVZcRP)
 @staticmethod
 def VV5qrn(res):
  if res.status_code == 206:
   return True
  else:
   hResume = res.headers.get("Accept-Ranges" , "")
   if hResume and not hResume == "none":
    return True
  return False
 @staticmethod
 def VVcUJs(url, timeout=3):
  err = ""
  try:
   import requests
   res = requests.get(url, headers=CCkEI5.VVgoVw(), allow_redirects=True, timeout=timeout)
   if res.ok:
    return res, ""
   else:
    if res.status_code == 407: reason = "Proxy Authentication Required"
    if res.status_code == 423: reason = "Access Locked"
    if res.status_code == 521: reason = "Server Is Down"
    else      : reason = "Unknown"
    err = "Err-%d : %s" % (res.status_code, res.reason or reason)
  except Exception as e:
   err = "Error\n" + str(e)[:120]
  return "", err
class CCzCDl():
 def __init__(self, SELF, url, path, title, pbTxt="", cbFnc=None, timeout=3, showRes=True):
  self.SELF  = SELF
  self.url  = url
  self.Path  = path
  self.Title  = title
  self.pbTxt  = pbTxt or "Checking File Size ..."
  self.cbFnc  = cbFnc
  self.timeout = timeout
  self.showRes = showRes
  self.webFile = ""
  self.webSize = ""
  self.err  = ""
  self.done  = False
  Dir = os.path.dirname(path)
  if not VVmJwX(Dir):
   FFdw58(SELF, "Path does not exist:\n\n%s" % Dir, title)
   return
  CCh3tv.VV7Nf4(SELF, titleBg="#22110011", bodyBg="#22110011", barBg="#06117722"
      , VVixvy  = self.VV2VNO
      , VVbYwR = self.VVn5ox)
 def VV2VNO(self, VVXyP6):
  VVXyP6.VVaks5(self.pbTxt)
  fSize = wSize = 0
  err = ""
  try:
   import requests
   resp = requests.get(self.url, headers=CCkEI5.VVgoVw(), timeout=self.timeout, stream=True, verify=True)
   if not resp.ok:
    if resp.reason : self.err = "Err-%d : %s" % (resp.status_code, resp.reason)
    else   : self.err = "Cannot download data from server"
    return
   head  = resp.headers
   cType = head.get("Content-Type", "")
   if "stream" in cType:
    fSize = head.get("Content-Length", "")
    fSize = int(fSize) if fSize.isdigit() else 0
   if not fSize: wSize = wSize = 200 * 1000 * 1000
   self.webFile = FFvTve(head)
  except requests.Timeout as e  : err = "Connection Timeout (> %s sec)" % self.timeout
  except requests.ConnectionError as e: err = "Connection Error"
  except Exception as e    : err = "Error\n" + str(e)[:120]
  if not VVXyP6 or VVXyP6.isCancelled:
   return
  if err:
   self.err = err
   return
  self.webSize = fSize or wSize
  if not self.webSize:
   self.err = "Cannot get size from server !"
   return
  err = CCHRcZ.VVymoR(self.webSize)
  if err:
   self.err = err
   return
  if not VVXyP6 or VVXyP6.isCancelled: return
  VVXyP6.VVq8NF(self.webSize)
  VVXyP6.VVaks5("Downloading (%s) ..." % CClYaF.VV99gM(self.webSize, mode=4))
  totBytes = 0
  try:
   with open(self.Path, "wb") as f:
    for chunk in resp.iter_content(chunk_size=8192):
     if not FFCyVu(self.Path):
      self.err = "Cannot access file:\n\n%s" % self.Path
      return
     if not VVXyP6 or VVXyP6.isCancelled:
      self.err = "Download Cancelled"
      return
     if chunk:
      try:
       f.write(chunk)
       VVXyP6.VVxtQs(len(chunk))
      except:
       self.err = "Cannot write to file:\n\n%s" % self.Path
       return
  except Exception as e:
   self.err = str(e)
 def VVn5ox(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if self.showRes:
   perc = int(100.0 * threadCounter / threadTotal) if threadTotal else 0
   path = self.Path if FFCyVu(self.Path) else ""
   if not VVRI6P:
    if path:
     if self.cbFnc: self.cbFnc(VVRI6P, self.url, self.webFile, self.Path)
     else   : FFdw58(self.SELF, "Download cancelled (at %s%%) in:\n\n%s" % (perc, path) if path else ".", self.Title)
   elif self.err:
    FFdw58(self.SELF, self.err + (" (at %s%%) in:\n\n%s" % (perc, path) if path else ""), self.Title)
   elif self.cbFnc:
    self.cbFnc(VVRI6P, self.url, self.webFile, self.Path)
   else:
    FFipXT(self.SELF, "Successfully downloaded to:\n\n%s" % path, self.Title)
class CCMdqL():
 def __init__(self, SELF):
  self.SELF   = SELF
  self.VVoq1H = False
  self.scrW, self.scrH = FFrPd1()
  self.X, self.Y, self.W, self.H = FFpMtN(self.SELF)
 def VVbIw5(self, x, y): self.SELF.instance.move(ePoint(x, y))
 def VVH0AA(self, w, h): self.SELF.instance.resize(eSize(*(w, h)))
 def VVxy2b(self, fnc=None):
  self.VVbIw5(self.X, self.Y)
  self.VVH0AA(self.W, self.H)
  self.VVoq1H = False
 def VV5HIg(self, up):
  if self.VVoq1H: return
  self.VVoq1H = True
  origY = -(self.Y + self.H) if up else self.scrH
  self.VVbIw5(self.X, origY)
  self.SELF.show()
  self.VVwmLx(up)
 def VVwmLx(self, up):
  try: y = self.SELF.instance.position().y() + (20 if up else -20)
  except: return
  if up and y < self.Y or not up and y > self.Y:
   self.VVbIw5(self.X, y)
   FFIElK(BF(self.VVwmLx, up))
  else:
   self.VVxy2b()
 def VVvj1p(self, up):
  if self.VVoq1H: return
  self.VVoq1H = True
  self.VVMxzh(up)
 def VVMxzh(self, up):
  try: y = self.SELF.instance.position().y() + (-20 if up else 20)
  except: return
  if up and y > -(self.Y + self.H) or not up and y < self.scrH:
   self.VVbIw5(self.X, y)
   FFIElK(BF(self.VVMxzh, up))
  else:
   self.SELF.hide()
   self.VVxy2b()
 def VVOVs9(self):
  if self.VVoq1H: return
  self.VVoq1H = True
  self.VVbstD()
 def VVbstD(self):
  x, y, w, h = FFpMtN(self.SELF)
  x += 70
  w -= 140
  if w > 1:
   self.VVH0AA(w, h)
   self.VVbIw5(x, y)
   FFIElK(self.VVbstD)
  else:
   self.SELF.close()
   self.VVoq1H = False
class CCqWM2(Screen, CChyfE):
 VVyLCv = None
 def __init__(self, session, VVwqHQ=None, VVEBd5=True, VVdxwH=True, VVOOLD=True, VVV4a7=False, VVaHNe="", endRef="", zapFnc=None, VVAfO9="", cbFnc=None, VV1rS5=0):
  self.skin, self.VVfOli = FFiNEe(VVakGB, 1600, 190, 28, 10, 6, "#1100202a", "#1100202a", 24, VV0Ay7=2)
  CChyfE.__init__(self)
  self.session    = session
  self.VVwqHQ  = VVwqHQ
  self.VVEBd5   = VVEBd5
  self.VVdxwH  = VVdxwH
  self.VVOOLD  = VVOOLD
  self.VVV4a7  = VVV4a7
  self.VVaHNe    = VVaHNe
  self.endRef     = endRef
  self.zapFnc     = zapFnc
  self.VVAfO9    = VVAfO9
  self.cbFnc     = cbFnc
  self.VV1rS5   = VV1rS5
  self.Title     = ""
  self.VVArDB    = "Catch-up"
  self.resetMediaTxt   = 'You can restart media with "<" Button'
  self.VVr01a    = eTimer()
  self.VVKh5A    = 250
  self.VVZRZD   = int(CFG.playerTimeout.getValue()) * 1000
  self.VVJnYA   = 0
  self.barWidth    = 0
  self.VVeFSs    = 0
  self.VVU7zm   = False
  self.VV8Ook   = 0
  self.VVv4Yb   = 0
  self.VVGLaR   = CFG.playerJumpMin.getValue()
  self.VVEzCB    = 0
  self.VViSIe    = ""
  self.VVb70o   = 0
  self.VVIzhS  = 0
  self.VVAPQr   = None
  self.VVepQx  = False
  self.VVxrPx    = False
  self.VVWG0C  = ""
  self.VVnkEu   = False
  self.tpData     = CC3Z54()
  self.tunerInfo    = CCOZ3M()
  self.VVU0YF   = None
  self.VVbLh6   = ("", "", 0)
  self.lastPIconPath   = None
  self.animate    = None
  self.firstTime    = True
  FFZMxC(self, "")
  self["myPlayBarF"] = Label()
  self["myPlayBarBG"] = Label()
  self["myPlayBar"] = Label()
  self["myPlayMov"] = Label()
  self["myPlayVal"] = Label()
  self["myPlayPos"] = Label()
  self["myPlaySkp"] = Label()
  self["myPlayMsg"] = Label()
  self["myPlayRem"] = Label()
  self["myPlayDur"] = Label()
  self["myPlaySep"] = Label()
  self["myPlayGrn"] = Label("Refresh")
  self["myPlayJmp"] = Label(self.VVxPj0())
  self["myPlayDat"] = Label("")
  self["myPlayTim"] = Label("")
  self["myPlayRes"] = Label("")
  self["myPlayFps"] = Label()
  self["myPlayAsp"] = Label()
  self["myPlayYel"] = Label("")
  self["myPlayBlu"] = Label("Cut-List")
  self["myPlayTyp"] = Label()
  self["myPlayPic"] = Pixmap()
  for nm in ( "myPlayCc", "myPlayAud", "myPlayDnld", "myPlayRpt"):
   self[nm] = Pixmap()
   self[nm].hide()
  color = self.VVfOli["VVPTnB"]
  nms = ("SNR", "AGC", "BER")
  for nm in nms: self["mySliderTxt%s" % nm] = Label(nm)
  for nm in nms: self["mySliderFrm%s" % nm] = Label()
  for nm in nms: self["mySliderBak%s" % nm] = Label()
  for nm in nms: self["mySliderCov%s" % nm] = Label()
  for nm in nms: self["mySliderPic%s" % nm] = Pixmap()
  self.sliderSNR = CCAbWp(self, self["mySliderPicSNR"], self["mySliderCovSNR"], minN=0, maxN=100, covColor=color)
  self.sliderAGC = CCAbWp(self, self["mySliderPicAGC"], self["mySliderCovAGC"], minN=0, maxN=100, covColor=color)
  self.sliderBER = CCAbWp(self, self["mySliderPicBER"], self["mySliderCovBER"], minN=0, maxN=100, covColor=color)
  FFHlAU(self,
  {
   "ok"  : self.VVPr1F       ,
   "info"  : self.VVyiuk      ,
   "epg"  : self.VVyiuk      ,
   "pvr"  : self.VVOkVn     ,
   "menu"  : self.VVdk84     ,
   "cancel" : self.cancel       ,
   "red"  : self.VVcWzZ    ,
   "green"  : self.VVgKuW  ,
   "blue"  : self.VVea74      ,
   "yellow" : self.VVqe3J ,
   "longPlay" : self.VVRchb    ,
   "play"  : self.VVgu5Z      ,
   "pause"  : self.VVgu5Z      ,
   "playPause" : self.VVgu5Z      ,
   "stop"  : self.VVgu5Z      ,
   "stopLong" : self.VVtCtg     ,
   "powerLong" : self.VVtCtg     ,
   "rewind" : self.VVJup6      ,
   "forward" : self.VVzX0n      ,
   "rewindDm" : self.VVJup6      ,
   "forwardDm" : self.VVzX0n      ,
   "last"  : self.VVrnc2      ,
   "next"  : self.VVmYut      ,
   "left"  : BF(self.VVkvpy, -1)    ,
   "right"  : BF(self.VVkvpy,  1)    ,
   "up"  : BF(self.VVuSeV, True)  ,
   "down"  : BF(self.VVuSeV, False)  ,
   "pageUp" : BF(self.VVuSeV, True)  ,
   "pageDown" : BF(self.VVuSeV, False)  ,
   "chanUp" : BF(self.VVuSeV, True)  ,
   "chanDown" : BF(self.VVuSeV, False)  ,
   "audio"  : BF(self.VVT1cG, True)  ,
   "subtitle" : BF(self.VVT1cG, False)  ,
   "text"  : self.VV8O6K  ,
   "0"   : BF(self.VVmuJn , 10)   ,
   "1"   : BF(self.VVmuJn , 1)   ,
   "2"   : BF(self.VVmuJn , 2)   ,
   "3"   : BF(self.VVmuJn , 3)   ,
   "4"   : BF(self.VVmuJn , 4)   ,
   "5"   : BF(self.VVmuJn , 5)   ,
   "6"   : BF(self.VVmuJn , 6)   ,
   "7"   : BF(self.VVmuJn , 7)   ,
   "8"   : BF(self.VVmuJn , 8)   ,
   "9"   : BF(self.VVmuJn , 9)
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  if self.firstTime:
   self.firstTime = False
   self.VVK5Px()
  else:
   self.VVYWev()
 def VVK5Px(self):
  FF6W0I(self)
  for b in ("myPlayGrn", "myPlayYel", "myPlayBlu"):
   FFK4PQ(self[b], "#000000", 3)
  if not CCqWM2.VVyLCv:
   CCqWM2.VVyLCv = self
  for k, v in {"myPlayCc": "cc1", "myPlayAud": "aud", "myPlayDnld": "dnld", "myPlayRpt": "rpt"}.items():
   FFkDgm(self[k], v)
  self.sliderSNR.VVi3uI()
  self.sliderAGC.VVi3uI()
  self.sliderBER.VVi3uI(isBER=True)
  self.VVZABq()
  self.instance.move(ePoint(40, 40))
  self.VV5s1h(CFG.playerPos.getValue())
  self["myPlayMov"].hide()
  self["myPlaySkp"].hide()
  size = self["myPlayBar"].instance.size()
  self.barWidth = int(size.width())
  self.VVeFSs = int(size.height())
  self["myPlayBar"].instance.resize(eSize(*(1, self.VVeFSs)))
  try: self.VVr01a_conn = self.VVr01a.timeout.connect(self.VVCWQ4)
  except: self.VVr01a.callback.append(self.VVCWQ4)
  self.VVr01a.start(self.VVKh5A, False)
  seekSt, chSt, chStTxt = self.VV7Pt6()
  self.VVCWQ4("" if seekSt == "Playing" else "Checking ...")
  if self.VVaHNe:
   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
   if self.VVaHNe != VVPxk5 + ":" + VV57TX:
    self.VVmqIY(self.VVaHNe, "Starting Service ...")
    return
  if not self.VVwqHQ:
   self.VVZvgO()
 def VVgKuW(self):
  if not self["myPlayGrn"].getVisible():
   return
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  self.VVAPQr = CCfpAm.VVeLpu()
  p = CC96QG()
  valid, ph1, playHost, mode, host, mac, epNum, epId, chCm, catID, stID, query = p.VVGNGo(VVZcRP)
  if "chCode" in VVfaDB and not "deviceMac=" in chCm:
   if CCwhE4.VVOJRa(self):
    self.VVZvgO(True)
  else:
   self.VVCWQ4("Refreshing ...")
   self.VVepQx = True
   FFIElK(BF(CCYrUm.VV0iSP, self.session))
  FFIElK(self.VVZABq)
 def VVKEef(self, VVZcRP):
  data = CCkEI5.VV9F1k(VVZcRP)
  if data and (not self.VVWG0C or data != self.VVWG0C):
   iThread(name="ajp_catchup", target=BF(self.VV13mI, data)).start()
 def VV13mI(self, data):
  uHost, uUser, uPass, uId, VV1wIO = data
  if all([uHost, uUser, uPass, uId]) and CCuqoc.VVSuvZ():
   pList, err = CCkEI5.VVigje("%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass), uId, mode=0)
   if pList:
    self.VVWG0C = data
    self.VVnkEu = True
 def VVZABq(self):
  self.VViSIe = ""
  self.VVWG0C = None
  self.VVnkEu  = False
  self.VVMpAl()
  s = self.VVGrMh()
  if self.VVV4a7:
   self.VVnkEu = True
  elif s._prov in ("Playlist", "Portal") and not FFUl6q(s.VVZcRP):
   FFOKt0(self, 1500, BF(self.VVKEef, s.VVZcRP))
  s.VV1wIO = FFzBfi(s.VV1wIO)
  if s.VVPxk5 or s.VV1wIO: self.Title = s.VV1wIO.replace("\n", " > ")
  else     : self.Title = VVyFI2 + "No Service !"
  self["myTitle"].setText("  " + self.Title + "  ")
  FFZ0AC(self["myTitle"], s._tColor)
  FFZ0AC(self["myBody"], s._tColor)
  for item in ("Pos", "Skp", "Msg", "Rem", "Dur", "Jmp", "Dat", "Tim", "Res", "Fps", "Asp", "Pic", "Typ", "Yel"):
   FFZ0AC(self["myPlay%s" % item], s._tColor)
  FFGUI5(self["myPlayYel"], "#0080dddd" if s.isDvb else "#00cccccc")
  for nm in ("SNR", "AGC", "BER"):
   FFZ0AC(self["mySliderTxt%s" % nm], s._tColor)
  if s._prov == "Others" : self["myPlayGrn"].hide()
  else     : self["myPlayGrn"].show()
  picFile = self.VVAfO9
  if not FFCyVu(picFile):
   if not iMatch(r"^\d*:(0:){9}\/.+", s.VVPxk5):
    picFile = CCvjVs.VVi5vZ(s.VVPxk5)
    if not FFCyVu(picFile):
     picFile = CCvjVs.VVi5vZ(s.VVAQqG)
  if not FFCyVu(picFile):
   fPath, fDir, fName, picFile = CCvjVs.VVSY7D(self)
  if not FFCyVu(picFile):
   pPath = CCafIt.VVjkKT()
   picFile = CCafIt.VVXjFJ(pPath, s.VVPxk5, s.VV1wIO)
  if picFile != self.lastPIconPath:
   self["myPlayTyp"].setText(s.streamType)
   self.lastPIconPath = picFile
   self["myPlayPic"].hide()
   self["myPlayTyp"].show()
   if os.path.isfile(picFile) and FF0TBx(self["myPlayPic"], picFile, VVemyB=s._tColor):
    self["myPlayPic"].show()
    self["myPlayTyp"].hide()
 def VVCWQ4(self, stateTxt="", highlight=False):
  if self.VVZRZD:
   if self.shown:
    self.VVJnYA += self.VVKh5A
    if self.VVJnYA >= self.VVZRZD:
     self.VVD7p5()
   else:
    self.VVJnYA = 0
  now = datetime.now()
  self["myPlayDat"].setText(now.strftime("%Y-%m-%d"))
  self["myPlayTim"].setText(now.strftime("%H:%M:%S"))
  if CCHRcZ.VVY2Xw() : self["myPlayDnld"].show()
  else         : self["myPlayDnld"].hide()
  s = self.VVGrMh()
  tTitle = self.Title
  if s._prov == self.VVArDB and " >> " in s.VV1wIO:
   ch, _, ev = s.VV1wIO.partition(" >> ")
   ch, ev = ch.strip(), ev.strip()
   if ch and ev:
    tTitle, s._evName = ch, ev
  if s._evName:
   s._evName = "    %s    " % FFjt5L(s._evName, VVA4XU)
  self["myTitle"].setText("  %s%s  " % (tTitle, s._evName))
  self["myPlayYel"].setText(s._prov)
  if s._prov == self.VVArDB or self.VVnkEu:
   FF7hy1(self["myPlayYel"], "#00ffffff", "#11a08000", inv=False)
  if s._seekable and s._durVal > 60:
   self["myPlayBlu"].show()
   self["myPlayJmp"].show()
  else:
   self["myPlayBlu"].hide()
   self["myPlayJmp"].hide()
  if s.isDvb or s.VVAQqG:
   self.tunerInfo.VVAo5r(s.servPtr)
   if self.tunerInfo.infoAvailable:
    self.sliderSNR.VVMjzk(self.tunerInfo.VVRpcw())
    self.sliderAGC.VVMjzk(self.tunerInfo.VVX9tR())
    self.sliderBER.VVMjzk(self.tunerInfo.VVZwV4())
  if not self.VVU7zm:
   player = CCkEI5.VV4IKy(s.VVPxk5)
   if player:
    self["myPlaySkp"].show()
    self["myPlaySkp"].setText(VVo7S9 + player)
   else:
    self["myPlaySkp"].hide()
  self["myPlayRes"].setText(s._res)
  self["myPlayFps"].setText(s._fr)
  self["myPlayAsp"].setText(s._ratio)
  self["myPlayPos"].setText(s._posTxt if s._posTxt else "")
  self["myPlayVal"].setText(s._percTxt if s._percTxt else "")
  self["myPlayRem"].setText("-%s" % s._remTxt if s._remTxt else "")
  self["myPlayDur"].setText(s._durTxt if s._durTxt else "")
  if s._durTxt:
   FFZ0AC(self["myPlayBarBG"], "#11000000")
   self["myPlayBarBG"].show()
   self["myPlayBarF"].show()
   self["myPlayBar"].show()
   width = 0
   percent = FFsRWN(s._percVal, 0, 100)
   width = int(FFjFSv(percent, 0, 100, 0, self.barWidth))
   self["myPlayBar"].instance.resize(eSize(*(width, self.VVeFSs)))
  else:
   self["myPlayBarBG"].hide()
   self["myPlayBarF"].hide()
   self["myPlayBar"].hide()
   self["myPlayVal"].setText(">>>>")
   FFZ0AC(self["myPlayBarBG"], s._tColor)
  self.VVk55g()
  if stateTxt:
   if highlight: FFGUI5(self["myPlayMsg"], "#0000ffff")
   else  : FFGUI5(self["myPlayMsg"], "#00ffaa00")
   self["myPlayMsg"].setText(stateTxt)
   self.VVEzCB = iTime()
  if self.VVEzCB and iTime() - self.VVEzCB < 1:
   return
  else:
   self.VVEzCB = 0
   FFGUI5(self["myPlayMsg"], "#00ffaa00")
   self["myPlayMsg"].setText(s._state)
  if s.VVDiQp or s.VVAQqG:
   FFGUI5(self["myPlayMsg"], "#00ffaaff")
   txt = "Stream Relay"
   if len(self.VViSIe) > 1: txt = "%s - %s%s" % (txt, VVwdUw, self.VViSIe)
   self["myPlayMsg"].setText(txt)
  elif s.isDvb:
   FFGUI5(self["myPlayMsg"], "#00aaaaaa")
   self["myPlayMsg"].setText(self.VViSIe)
  stateTxt = ""
  chkResume = False
  seekSt, chSt, chStTxt = self.VV7Pt6()
  if seekSt:
   stateTxt = seekSt
   if s._percVal == 100:
    stateTxt = "End"
    self.VVMpAl()
    if self.VVxrPx:
     self.VVrnc2()
   elif seekSt == "Playing":
    if s._posTxt:
     chkResume = True
    elif chSt == CCo1b7.VVaGf1 and s.isIptv and s.VVPxk5.startswith("1:"):
     stateTxt = seekSt
    else:
     stateTxt = "%sWaiting for state change ..." % (("State: %s - " % chStTxt) if chStTxt else "")
  if chSt == CCo1b7.VVaGf1:
   Id, rt, sIcon = self.VVbLh6
   if (s.uniqueId, s.refType) != (Id, rt):
    sIcon = CCvjVs.VVL5jW()
    self.VVbLh6 = (s.uniqueId, s.refType, sIcon)
    if sIcon > 0:
     FFkDgm(self["myPlayCc"], "cc%s" % sIcon)
     self["myPlayCc"].show()
    else:
     self["myPlayCc"].hide()
    if CCvjVs.VVHlVI(self.session) > 1 : self["myPlayAud"].show()
    else             : self["myPlayAud"].hide()
  if not s._seekable and not s.isIptv:
   return
  if chkResume:
   if not self.VVepQx:
    self.VVb70o = s._posVal
   elif not s._durVal:
    self.VVepQx = False
   else:
    if self.VVb70o > 0:
     move = end = False
     s1 = "." * self.VVIzhS
     stateTxt = ("%s Restoring Posistion %s" % (s1, s1)).strip()
     self.VVIzhS += 1
     diff = abs(s._posVal - self.VVb70o)
     if   diff < 10     : end = True
     elif self.VVIzhS == 1: move = True
     elif self.VVIzhS >= 10:
      if diff > 10:
       move = True
      end = True
     if move and CFG.resumeMovies.getValue() == "off":
      self.VVhB9S(self.VVb70o * 90000.0)
     if end:
      self.VVIzhS = 0
      self.VVepQx = False
      CCfpAm.VVDjVi(self.VVAPQr)
    else:
     self.VVepQx = False
  bufS = self.VVFlpV()
  if bufS:
   stateTxt = bufS
  FFGUI5(self["myPlayMsg"], "#0000ff00" if stateTxt == "Playing" else "#00FF8F5F" )
  self["myPlayMsg"].setText(stateTxt)
 def VVGrMh(self):
  s = CC3rDi(self.session)
  s._state = s.state.replace("*", "") or "No system info"
  s._seekable, s._percVal, s._durVal, s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = CCqWM2.VVVxSJ(self)
  s._VVFzFe = "chCode" in s.VVZcRP
  s._VVoAvc = CCkEI5.VVYuoh(s.VVZcRP)
  s._VVjwdZ = "/timeshift/" in s.VVZcRP
  iptv   = s.isIptv or "http" in s.VVZcRP
  if   s.isDvb  : s._tColor, cat = "#1100102a", "DVB"
  elif s.isLocal  : s._tColor, cat = "#0a401100", "Local Media"
  elif s._VVFzFe : s._tColor, cat = "#1120002a", "Portal"
  elif s.isFtp  : s._tColor, cat = "#11222222", "FTP"
  elif s._VVjwdZ : s._tColor, cat = "#11223322", self.VVArDB
  elif s._VVoAvc : s._tColor, cat = "#11001c1c", "Playlist"
  elif s.VVDiQp  : s._tColor, cat = "#11223344", "S. Relay"
  elif iptv   : s._tColor, cat = "#11113030", "IPTV"
  else    : s._tColor, cat = "#11111111", "Others"
  s._prov = self.VVArDB if self.VVnkEu else (s.prov or cat)
  if (s.isDvb or s.VVAQqG) and not self.VViSIe:
   self.VViSIe = self.tpData.VVsDkA([s.VVPxk5, s.VVAQqG], nonTxt="-")
  valid = (s.isDvb and s.isValid) or s.VVAQqG
  for nm1 in ("Txt", "Frm", "Cov", "Bak", "Pic"):
   for nm2 in ("SNR", "AGC", "BER"):
    if valid: self["mySlider%s%s" % (nm1, nm2)].show()
    else : self["mySlider%s%s" % (nm1, nm2)].hide()
  s._evName = s._evNameNext = ""
  evLst = CC5TsO.VVj18Y(s.VVPxk5)
  if evLst:
   s._evName, evShort, evDesc, genre, PR, evTime, evTimeTxt, evDur, evDurTxt, evEnd, evEndTxt, evPos, evPosTxt, evRem, evRemTxt, evCom, evComTxt = evLst[0]
   if not s._durVal:
    if len(evLst) > 1:
     s._evNameNext = evLst[1][0]
    if evPos >= evDur:
     s._percVal = 100
     percTxt = "%d %%" % s._percVal
    else:
     s._percVal = float(evPos) * 100.0 / float(evDur)
     percTxt = "%.2f %%" % s._percVal
    s._posVal, s._remVal, s._percTxt, s._durTxt, s._posTxt, s._remTxt = evPos, evRem, percTxt, evDurTxt, evPosTxt, evRemTxt
  s._res = CCvjVs.VVZHUt(s.info)
  s._fr, rate = "", FFMzWf(s.info, iServiceInformation.sFrameRate)
  if rate.isdigit() and not rate == "0":
   s._fr = "%d fps" % (int(rate) / 1000)
  s._ratio = CCvjVs.VVNYXU(s.info)
  return s
 @staticmethod
 def VVVxSJ(SELF):
  percVal = durVal = posVal = remVal = seekable = 0
  percTxt = durTxt = posTxt = remTxt = ""
  isEnded = False
  try:
   service = SELF.session.nav.getCurrentService()
   if service:
    pSeek = service.seek()
    if pSeek:
     seekable = pSeek.isCurrentlySeekable()
     durLst  = pSeek.getLength()
     posLst  = pSeek.getPlayPosition()
     if durLst[0] == 0:
      durVal = durLst[1] / 90000.0
      if durVal:
       durTxt = FFFHEC(durVal)
     if posLst[0] == 0:
      posVal = posLst[1] / 90000.0
      posTxt = FFFHEC(posVal)
     if durVal > 0 and posVal > 0:
      remVal = durVal - posVal + 1
      remTxt = FFFHEC(remVal)
     if durVal > 0:
      if round(posVal) >= int(durVal):
       percVal = 100
       percTxt = "%d %%" % percVal
       posVal = durVal
       posTxt = durTxt
       remTxt = ""
      else:
       percVal = float(posVal) * 100.0 / float(durVal)
       percTxt = "%.2f %%" % percVal
  except:
   pass
  return seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt
 def VVdk84(self):
  s = self.VVGrMh()
  VV3wat = []
  c1, c2, c3, c4 = VVyFI2, VVFuwR, VVZtfx, VVJEMb
  VV3wat.append(("Service Info.", "info"))
  VV3wat.append(FFsLU5("Play with ..."   , "playWith", s.VVPxk5 and not s.isDvb , c4))
  VV3wat.append(FFsLU5("Restart Current Service" , "restart" , s.VVPxk5     , c1))
  VV3wat.append(FFsLU5("Stop Current Service"  , "stop" , s.VVPxk5     , c1))
  VV3wat.append(VVAL3j)
  if s._durTxt and s._posTxt:
   VV3wat.append((c2 + "Start Subtitle", "VV0xaU"))
   VV3wat.append(VVAL3j)
  canDownload = s.VVZcRP and s._seekable == 3 and s._durVal > 0
  if canDownload:
   VV3wat.append((c3 + "File Size (on server)", "fileSize"))
  if self.VVdxwH:
   if canDownload:
    VV3wat.append((c3 + "Start Download"  , "dload_cur" ))
    VV3wat.append((c3 + "Add to Download List", "addToDload" ))
  show = not CCHRcZ.VVAbZK()
  VV3wat.append(FFsLU5("Download Manager", "dload_stat", show, c3))
  VV3wat.append(VVAL3j)
  addSep = False
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  if fPath:
   c = VVJEMb
   if not "VVyg7B" in globals():
    VV3wat.append((c + "Open Path in File Manager", "VVKtV9"))
   VV3wat.append((c + "Add to Bouquet"            , "VV51sJ" ))
   VV3wat.append((c + "%s Auto-Repeat" % ("Disable" if self.VVxrPx else "Enable"), "VVMxOs"  ))
   addSep = True
  elif s.isFtp:
   VV3wat.append((c2 + "Add FTP Media to Bouquet", "VVLm66"))
   addSep = True
  if addSep: VV3wat.append(VVAL3j)
  if s.isDvb:
   VV3wat.append((c4 + "Signal Monitor (Red Button)", "sigMon"))
   VV3wat.append(VVAL3j)
  if not "VVaWs8" in globals() and not "VVyXy5" in globals():
   VV3wat.append((c4 + "IPTV Menu", "iptv"))
   VV3wat.append(VVAL3j)
  if self.VVOOLD:
   path, lst, err = CC6F0F.VVjp9r()
   if lst:
    VV3wat.append((c3 + "Movies Resume History", "resume"))
    VV3wat.append(VVAL3j)
  VV3wat.append(("Set Bar Visibility Timeout", "timeout"))
  VV3wat.append(("Set Red Button Action"  , "red" ))
  if CFG.playerPos.getValue() : VV3wat.append(("Move Bar to Bottom" , "botm"))
  else      : VV3wat.append(("Move Bar to Top" , "top" ))
  VVJbOd = self.VVs6QS
  FFLFTC(self, self.VVMq7h, VV3wat=VV3wat, width=650, height=1050, title="Options", VVy8OB=True, VVJbOd=VVJbOd, VVwltY="#22001122", VVkxBG="#11000919")
 def VVMq7h(self, item=None):
  if item:
   if   item == "info"     : self.VVyiuk()
   elif item == "playWith"    : self.VVRchb()
   elif item == "restart"    : self.VVHTNd()
   elif item == "stop"     : self.VVtCtg()
   elif item == "VV0xaU"  : self.VVWBSu()
   elif item == "fileSize"    : CCvjVs.VVnMBE(self)
   elif item == "dload_cur"   : CCHRcZ.VVIcV1(self)
   elif item == "addToDload"   : CCHRcZ.VVfHMV(self)
   elif item == "dload_stat"   : CCHRcZ.VVSZMa(self)
   elif item == "VVKtV9" : self.VVj4vX("VVEAiH")
   elif item == "VV51sJ" : self.VV51sJ()
   elif item == "VVMxOs"  : self.VVMxOs()
   elif item == "VVLm66" : self.VVLm66()
   elif item == "sigMon"    : self.VVctJ7()
   elif item == "iptv"     : self.VVj4vX("VV3NZB")
   elif item == "resume"    : self.VVj4vX("VVmZ3h")
   elif item == "timeout"    : CCJaSw.VV5YpJ(self, CFG.playerTimeout, "Bar Timeout (Seconds)" , isSave=True, width=700, cbFnc=self.VVHjPB)
   elif item == "red"     : CCJaSw.VV5YpJ(self, CFG.playerRedBtn , "Red Button Action"  , isSave=True, width=700)
   elif item == "botm"     : self.VV5s1h(0)
   elif item == "top"     : self.VV5s1h(1)
   elif item == "VVy8OB"    : self.VVHyXT()
 def VVHyXT(self):
  VV3wat = []
  s = self.VVGrMh()
  m2 = s.VVPxk5 and not s.isDvb and FFPCZY(self)
  VV3wat.append(FFsLU5("Stop Current Service"       , "st1" , s.VVPxk5 ))
  VV3wat.append(FFsLU5("Stop Current Service & Close %s" % VVh9hj, "st2" , m2  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Play Last Stopped Channel", "pl", not s.VVPxk5))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Channel Selection", "chS" ))
  VV3wat.append(("Channels Browser" , "chB" ))
  VV3wat.append(("Zap History"  , "zh" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(FFsLU5("Download Poster (for current event)", "ps0", CC5TsO.VVMZqx(self)))
  if VVBvqf:
   VV3wat.append(("Find a poster T", "ps1"))
   VV3wat.append(("Find a poster I", "ps2"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Close %s" % VVh9hj, "end"))
  FFLFTC(self, self.VVeyTi, VV3wat=VV3wat, width=740, title="More Options", VVwltY="#22220000", VVkxBG="#11110000")
 def VVeyTi(self, item=None):
  if item:
   if   item == "st1": self.VVtCtg()
   elif item == "st2": self.VVtCtg(True)
   elif item == "pl" : self.VVM2ZW()
   elif item == "chS": self.VVOkVn()
   elif item == "chB": CCjThi.VVJNjY(self)
   elif item == "zh" : self.session.open(CCiCTh)
   elif item == "ps0": self.session.open(CChtNF)
   elif item == "ps1": self.session.open(CChtNF, mode=1)
   elif item == "ps2": self.session.open(CChtNF, mode=2)
   elif item == "end": FFHxAC(self)
 def VVHjPB(self):
  self.VVZRZD = int(CFG.playerTimeout.getValue()) * 1000
 def VVcWzZ(self):
  v = CFG.playerRedBtn.getValue()
  if  v == "s": self.VVctJ7()
  elif v == "e": self.VVRLgb()
 def VVctJ7(self):
  if self.shown:
   s = CC3rDi(self.session)
   if s.isDvb : self.VVj4vX("VV9RX6")
   else  : self.VVCWQ4("No Signal for Current Service")
 def VVRLgb(self):
  s = self.VVGrMh()
  if not s.isDvb or not s.isValid:
   CCYrUm.VVO7YY(self.session, s.servRef)
  self.close()
 def onExit(self):
  self.VVr01a.stop()
  CCqWM2.VVyLCv = None
  if self.cbFnc: self.cbFnc()
  if self.endRef: FFnfiC(self.session, self.endRef)
 def cancel(self):
  if self.VVU7zm: self.VVMpAl()
  elif self.shown  : self.VVj4vX()
  else    : self.VVXkRr()
 def VVXkRr(self):
  self.animate.VV5HIg(CFG.playerPos.getValue())
 def VVD7p5(self):
  self.animate.VVvj1p(CFG.playerPos.getValue())
 def VVj4vX(self, act=None):
  if act     : self.close(act)
  elif self.VV1rS5: self.animate.VVOVs9()
  else     : self.close()
 def VVs6QS(self, VV7tND, txt, ref, ndx):
  FFw2rR(self, "_help_player", "Player Bar (Keys)")
 def VVHTNd(self):
  self.VVCWQ4("Restarting Service ...")
  FFIElK(BF(CCYrUm.VV0iSP, self.session))
 def VVtCtg(self, end=False):
  self.VVCWQ4("Stopping current service ...")
  FFIElK(BF(self.VVoPnb, end))
 def VVoPnb(self, end):
  fromTbls = self.VVwqHQ or self.zapFnc
  zapped = False
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv:
   path = serv.getPath()
   self.session.nav.stopService()
   self.show()
   self.VVZABq()
   if path.startswith(("/", "http")) or fromTbls:
    zapped = CCYrUm.VVO7YY(self.session, serv)
  if end:
   FFHxAC(self)
  else:
   if fromTbls : self.VVj4vX()
   elif zapped : self.VVZABq()
   else  : self.VVOkVn()
 def VVM2ZW(self):
  rootR, servR = CCYrUm.VVotT7()
  if servR:
   self.VVmqIY(servR, "Playing Last Service ...")
 def VVRchb(self):
  CCkEI5.VVMYQY(self, self.VVGy1Q)
 def VVGy1Q(self, rType=None):
  if rType:
   FFIElK(BF(self.VVBh4l, rType))
 def VVBh4l(self, rType=None):
  serv = self.session.nav.getCurrentlyPlayingServiceReference()
  if serv : FFqb3C(self.session, eServiceReference(rType + ":" + serv.toString().split(":", 1)[1]))
  else : self.VVCWQ4("No active service !")
  self.VVZABq()
 def VV51sJ(self):
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  if fPath: picker = CCMvE7(self, self, "Add Current Movie to a Bouquet", BF(self.VVZXrb, [fPath]))
  else : FF28n1(self, "Path not found !", 1500)
 def VVZXrb(self, pathLst):
  return CCMvE7.VVvoK9(pathLst)
 def VVLm66(self):
  picker = CCMvE7(self, self, "Add FTP Media to Bouquet", self.VV6eYa)
 def VV6eYa(self):
  VV57TX = CC3rDi(self.session).VV57TX
  return CCMvE7.VVvoK9([VV57TX], rType=VVPxk5.split(":", 1)[0])
 def VVMxOs(self):
  ok = False
  if self.VVxrPx:
   self.VVxrPx = False
   txt = "Auto-Repeat OFF"
   ok = True
  else:
   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
   if seekable and durVal > 0:
    if durVal >= 60:
     self.VVxrPx = True
     txt = "Auto-Repeat ON"
     ok = True
    else: txt = "Too short (min = 1 minute)"
   else: txt = "Cannot Auto-Repeat"
  if self.VVxrPx : self["myPlayRpt"].show()
  else    : self["myPlayRpt"].hide()
  self.VVCWQ4(txt, highlight=ok)
 def VV5s1h(self, pos):
  scrSize = getDesktop(0).size()
  scrW = scrSize.width()
  scrH = scrSize.height()
  x  = (scrW - self.instance.size().width()) / 2.0
  if pos == 0 : y = (scrH - self.instance.size().height() - 20)
  else  : y = 20
  self.instance.move(ePoint(int(x), int(y)))
  if not pos == CFG.playerPos.getValue():
   FFjt1c(CFG.playerPos, pos)
  self.animate = CCMdqL(self)
 def VVWBSu(self):
  self.session.openWithCallback(self.VVL63G, CCfpAm, self)
 def VV8O6K(self):
  if self.shown:
   s = self.VVGrMh()
   if s._posTxt and s._durTxt : self.VVWBSu()
   else      : self.VVCWQ4("No duration Info. !")
 def VVL63G(self, reason):
  if reason == "subtCancel":
   return
  self.VVXkRr()
  txt = ""
  if   reason == "subtExit" : pass
  elif reason == "subtCancel" : pass
  elif reason == "subtInval" : txt = "Invalid srt file"
  elif reason == "subtZapUp" : self.VVuSeV(True)
  elif reason == "subtZapDn" : self.VVuSeV(False)
  elif reason == "longPlay" : self.VVRchb()
  elif reason == "pause"  : self.VVgu5Z()
  elif reason == "audio"  : self.VVT1cG(True)
  elif reason == "subtitle" : self.VVT1cG(False)
  else      : txt = reason
  if txt:
   FF28n1(self, txt, 2000)
 def VVPr1F(self):
  if self.VVU7zm:
   self.VVMpAl()
   self.VVhB9S(self.VVv4Yb)
  elif not self.session.nav.getCurrentlyPlayingServiceReference():
   self.VVOkVn()
  elif self.shown:
   if CCfpAm.VVjvxF(self): self.VVWBSu()
   elif self.shown       : self.VVD7p5()
  else:
   self.VVXkRr()
 def VVyiuk(self):
  CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY, VVAfO9=self.VVAfO9, cbFnc=self.VVZABq)
 def VVOkVn(self):
  CCYrUm.VVGvmp()
 def VVgu5Z(self):
  try: InfoBar.instance.playpauseService()
  except: pass
  self.VVCWQ4("Toggling Play/Pause ...")
 def VV4nOY(self):
  try: InfoBar.instance.unPauseService()
  except: pass
 def VVMpAl(self):
  try:
   if self.VVU7zm:
    self.VVU7zm = False
    self["myPlayMov"].hide()
    self["myPlaySkp"].hide()
  except:
   pass
 def VVkvpy(self, direc):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
  if percVal == 100:
   self.VVCWQ4(self.resetMediaTxt)
  elif seekable and durVal > 0:
   if not self.VVU7zm:
    self.VVU7zm = True
    self["myPlayMov"].show()
    self["myPlaySkp"].show()
    self.VV8Ook = posVal + direc * self.VVBGpu()
   else:
    self.VV8Ook += direc * self.VVBGpu()
    self.VV8Ook = FFsRWN(self.VV8Ook, 0, durVal)
   minLeft = self["myPlayBar"].getPosition()[0] - 1
   maxLeft = self["myPlayBarBG"].getPosition()[0] + self["myPlayBarBG"].instance.size().width() - self["myPlayMov"].instance.size().width() + 1
   left = int(FFjFSv(self.VV8Ook, 0, durVal, minLeft, maxLeft))
   self["myPlayMov"].instance.move(ePoint(left, int(self["myPlayMov"].getPosition()[1])))
   self["myPlaySkp"].setText(FFFHEC(self.VV8Ook))
   self.VVv4Yb = self.VV8Ook * 90000.0
 def VVmuJn(self, val):
  if not self.VVGLaR == val:
   self.VVGLaR = val
   self["myPlayJmp"].setText(self.VVxPj0())
   FFjt1c(CFG.playerJumpMin, self.VVGLaR)
  self.VVCWQ4("Changed Seek Time to : %d%s" % (val, self.VVIWzX()))
 def VVxPj0(self):
  return "Seek=%d%s" % (self.VVGLaR, self.VVIWzX())
 def VVIWzX(self) : return "s"   if self.VVGLaR == 10 else "m"
 def VVT6Ma(self): return "sec" if self.VVGLaR == 10 else "min"
 def VVBGpu(self) : return 10    if self.VVGLaR == 10 else self.VVGLaR * 60
 def VV7Pt6(self):
  chSt = chStTxt = ""
  if "VVfaPN_VAL" in globals():
   global VVfaPN_VAL
   chSt = VVfaPN_VAL
   if chSt != CCo1b7.VVaGf1:
    chStTxt = chSt
  seekSt = ""
  try:
   inst = InfoBar.instance
   seekSt = {inst.SEEK_STATE_PAUSE: "PAUSED", inst.SEEK_STATE_EOF: "END", inst.SEEK_STATE_PLAY: "Playing"}.get(inst.seekstate, "")
   if chSt == CCo1b7.VV26Iy:
    seekSt = chSt
  except:
   pass
  return seekSt, chSt, chStTxt
 def VVea74(self):
  self.VVCWQ4("Reading Cut-List ...")
  FFIElK(self.VVG7Sr)
 def VVG7Sr(self):
  s = self.VVGrMh()
  if s._percVal == 100:
   self.VVCWQ4(self.resetMediaTxt)
   return
  cList = self.VV4AOH()
  VV3wat = []
  title = "Cut List"
  src = 0
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  if cList:
   canPreview = True
   for pts, what in cList:
    txt = FFFHEC(int(pts) / 90000.0)
    if   what == 0 : t = "In"
    elif what == 1 : t = "Out"
    elif what == 2 : t = "Mark"
    elif what == 3 : t = "Last"
    else   : t = ""
    if t: txt += "   %s" % t
    VV3wat.append((txt, pts))
  elif self["myPlayBlu"].getVisible():
   if fPath:
    VV3wat = CC6u6z.VVFs8l(fPath)
   elif s.VVZcRP and s.VV1wIO:
    path, headers = CC6u6z.VVmdd5(s.VVZcRP, s.VV1wIO)
    if path:
     VV3wat = CC6u6z.VVFs8l(path, headers)
   if VV3wat:
    title = "Chapters"
   elif s._durVal > 20:
    for i in range(0, 5):
     pts = min(max((s._durVal * 90000 // 4) * i, 5 * 90000), (s._durVal - 10) * 90000.0)
     subj = "   %s" % (("Start", "1st Quarter", "Half way", "3rd Quarter", "End")[i])
     VV3wat.append((FFFHEC(pts / 90000.0) + subj, pts))
   fName, fTxt, VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
   if fName:
    d = CCzUSd.VV0NUN(CCzUSd.VVc5Po(fName))
    if d: VV3wat.append((FFFHEC(d["pos"] / 90000.0) + FFjt5L("   Resume Point", VVFuwR), d["pos"]))
   VV3wat.sort(key=lambda x: x[1])
  if VV3wat:
   wDir = "%s_Chapters/" % fPath
   VV7tND = FFLFTC(self, self.VVh1Cz, VV3wat=VV3wat, title=title, width=1200, VVyRCy=5, VVdrEC=(350, 0), cornerPicFnc=BF(self.VV2ovz, wDir))
   lst = []
   for txt, ref in VV3wat:
    picF, tm = self.VVMuZk(wDir, txt)
    if picF and not FFCyVu(picF):
     lst.append((picF, tm))
   self.VVU0YF = (VV7tND, title, wDir, len(lst), 0, False)
   iThread(name="ajp_chap", target=BF(self.VVfTw0, lst, wDir, fPath)).start()
  else:
   self.VVCWQ4("No Cut-List !")
 def VVh1Cz(self, pts=None):
  self.VVU0YF = None
  if pts:
   self.VVhB9S(pts)
 def VVfTw0(self, lst, wDir, fPath):
  VV7tND, title, wDir, totPics, cnt, done = self.VVU0YF
  if FFpwZS("mkdir -p '%s';" % wDir):
   for picF, tm in lst:
    if not VV7tND:
     break
    cnt += 1
    self.VVU0YF = VV7tND, title, wDir, totPics, cnt, done
    FFpwZS("ffmpeg -hide_banner -ss %s -i '%s' -frames:v 1 -vf scale=350:-1 '%s'" % (tm, fPath, picF))
  self.VVU0YF = VV7tND, title, wDir, totPics, cnt, True
 def VV2ovz(self, wDir, VV7tND, txt, ref, ndx):
  picF, tm = self.VVMuZk(wDir, txt)
  return picF
 def VVMuZk(self, wDir, txt):
  span = iSearch(r"^(\d\d:\d\d:\d\d)", txt)
  if span:
   tm = span.group(1)
   picF = "%s%s.jpg" % (wDir, tm.replace(":", ""))
   return picF, tm
  return "" ,""
 def VVk55g(self):
  if self.VVU0YF:
   try:
    VV7tND, title, wDir, totPics, cnt, done = self.VVU0YF
    if   done   : self.VVU0YF = None
    elif totPics >= cnt : title += FFjt5L("   %s/%s" % (cnt, totPics), VVo7S9)
    if VV7tND:
     VV7tND.FFTmHZ(title)
     txt, ref, ndx = VV7tND.VVnGzV()
     picF, tm = self.VVMuZk(wDir, txt)
     if not VV7tND.VVcOjd() and FFCyVu(picF):
      VV7tND.VVacFr(picF)
   except:
    pass
 def VV4AOH(self):
  try: return InfoBar.instance.cut_list or []
  except: return []
 def VVzX0n(self) : self.VVmtpO(1)
 def VVJup6(self) : self.VVmtpO(-1)
 def VVmtpO(self, direc):
  try:
   seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
   if percVal == 100:
    self.VVCWQ4(self.resetMediaTxt)
   elif durVal > 0:
    maxPts = (durVal - posVal- 10) * 90000.0
    pts = direc * self.VVBGpu() * 90000.0
    pts = min(maxPts, pts)
    self.VV4nOY()
    inst = InfoBar.instance
    inst.doSeekRelative(int(pts))
    inst.hide()
    if   direc > 0 : txt = "Forawrd"
    else   : txt = "Rewind"
    txt += " (%d %s) ..." % (self.VVGLaR, self.VVT6Ma())
    self.VVCWQ4(txt)
  except:
   self.VVCWQ4("Cannot jump")
 def VVhB9S(self, pts, txt=""):
  self.VVCWQ4(txt or "Changing Time ...")
  self.VV4nOY()
  try:
   InfoBar.instance.doSeek(int(pts))
  except:
   pass
 def VVrnc2(self):
  s = self.VVGrMh()
  if s._percVal < 100:
   self.VVhB9S(90000, "Jumping to Start ...")
  else:
   fName, fTxt, s.VV1wIO, VVu06s = CCzUSd.VVwtlp(self.session)
   FFwgGB(CCzUSd.VVc5Po(fName))
   self.VVMpAl()
   self.VVHTNd()
 def VVmYut(self):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
  if seekable and durVal > 20:
   self.VVhB9S((durVal - 10) * 90000.0, "Jumping to end ...")
  else:
   self.VVCWQ4("Movie is too short ...")
 def VVFlpV(self):
  try:
   service = self.session.nav.getCurrentService()
   info = service and service.info()
   if info:
    val = info.getInfo(iServiceInformation.sBuffer)
    if val and val > 0 and not val == 100:
     return "Buffering %d %%" % val
  except:
   pass
  return ""
 def VVuSeV(self, isUp):
  if self.VVEBd5:
   self.VVCWQ4("Starting Service ...")
   FFIElK(BF(self.VVJrr9, isUp))
  else:
   self.VVCWQ4("Zap Disabled !")
 def VVJrr9(self, isUp):
  self.VVMpAl()
  self["myPlayCc"].hide()
  self["myPlayAud"].hide()
  if self.zapFnc:
   VVPxk5 = self.zapFnc(1 if isUp else -1)
   self.VVmqIY(VVPxk5, "")
  elif self.VVwqHQ:
   self.VV56DF(isUp)
  else:
   if "/timeshift/" in CC3rDi(self.session).VVZcRP:
    c1, c2 = VVwdUw, VV1fx4
    self.VVCWQ4(c1 + "To zap, click " + c2 + self.VVArDB + c1 + " then " + c2 + "Play Latest")
   else:
    try:
     if isUp : InfoBar.instance.zapDown()
     else : InfoBar.instance.zapUp()
    except:
     pass
    self.VVZvgO()
    self.VVYWev()
 def VVmqIY(self, chUrl, txt):
  if txt:
   self.VVCWQ4(txt)
   FFIElK(BF(self.VVdQSL, chUrl))
  else:
   self.VVdQSL(chUrl)
 def VVdQSL(self, chUrl):
  FFnfiC(self.session, chUrl)
  self.VVYWev()
 def VVYWev(self):
  self.VVb70o = 0
  self.VVZABq()
 def VV56DF(self, isUp):
  CCkEI5_inatance, VV6A99, mode = self.VVwqHQ
  if isUp : VV6A99.VVIRjv()
  else : VV6A99.VVgexy()
  colList = VV6A99.VV5crm()
  VVAfO9 = ""
  if mode == "localIptv":
   VV1wIO, chUrl = CCkEI5_inatance.VVIHV3(VV6A99, colList)
  elif mode == "localServer":
   VV1wIO, chUrl, VVAfO9 = CCkEI5_inatance.VVJlyo(VV6A99, colList, isUp)
  elif isinstance(mode, int):
   VV1wIO, chUrl, VVAfO9 = CCkEI5_inatance.VVYAch(mode, VV6A99, colList)
  elif any(x in mode for x in ("itv", "vod", "series")):
   VV1wIO, chUrl, VVAfO9 = CCkEI5_inatance.VVsQmE(mode, VV6A99, colList)
  else:
   self.VVCWQ4("Cannot Zap")
   return
  self.VVAfO9 = VVAfO9
  self.VVmqIY(chUrl, "")
 def VVU96j(self, chUrl, endRef="", VVAfO9=""):
  self.endRef = endRef
  self.VVAfO9 = VVAfO9
  self.VVmqIY(chUrl, "Starting Service ..." if chUrl else "")
 def VVZvgO(self, forceRefresh=False):
  try:
   if not forceRefresh:
    seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
    if posTxt:
     return
   VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
   if not self.VVgBJL(VVPxk5, VV1wIO, VVZcRP, VVfaDB):
    return
   if forceRefresh or "j.php" in VVZcRP:
    self.VVCWQ4("Refreshing Portal ...")
    FFIElK(self.VVytqm)
  except:
   pass
 def VVytqm(self):
  self.VVepQx = self.VVIguo(self.session)
 def VVqe3J(self):
  VVPxk5, VVZcRP, VV57TX, VVfaDB, VV1wIO = FFIBUH(self)
  if not VVZcRP or FFUl6q(VVZcRP):
   self.VVCWQ4("Not a Catch-up TV")
   return
  self.VVCWQ4("Checking Catch-up ...")
  uHost = uUser = uPass = streamId = ""
  ok_fnc = None
  if "chCode=" in VVZcRP:
   span = iSearch(r"(http.+)\/(.+)\/(.+)\/(\d+)\?play_token.+", VVZcRP)
   if span: uHost, uUser, uPass, streamId = span.groups()
  else:
   if "/timeshift/" in VVZcRP:
    span = iSearch(r"(.+)\/timeshift\/(.+)\/(.+)\/(.+)\/(.+)\/(\d+)", VVZcRP, IGNORECASE)
    if span:
     uHost, uUser, uPass = span.group(1), span.group(2), span.group(3)
     streamId = span.group(6)
     ndx = VV1wIO.find(" >> ")
     if ndx > -1:
      VV1wIO = VV1wIO[:ndx]
   else:
    uType, uHost, uUser, uPass, streamId, uChName = CCkEI5.VVNeuG(VVZcRP)
  if all([uHost, uUser, uPass, streamId]):
   qUrl = "%s/player_api.php?username=%s&password=%s" % (uHost, uUser, uPass)
   ok_fnc  = BF(self.VVsFe5, VVPxk5, VV1wIO, streamId, uHost, uUser, uPass)
   CCkEI5.VVvSue(self, qUrl, VV1wIO, streamId, ok_fnc, rst_fnc=self.VVZABq)
  else:
   self.VVCWQ4("Cannot process this channel")
 def VVsFe5(self, VVPxk5, VV1wIO, streamId, uHost, uUser, uPass, VV6A99, title, txt, colList):
  pTitle, sTime, dur = colList[4], colList[6], colList[8]
  VV6A99.cancel()
  span = iSearch(r"(\d{4}-\d{2}-\d{2})\s(\d{2}):(\d{2})", sTime)
  if span:
   sTime = span.group(1) + ":" + span.group(2) + "-" + span.group(3)
   chUrl = "%s/timeshift/%s/%s/%s/%s/%s.ts" % (uHost, uUser, uPass, dur, sTime, streamId)
   chUrl = chUrl.replace(":", "%3a")
   chUrl = "%s:%s:%s >> %s" % (VVPxk5, chUrl, VV1wIO, pTitle)
   self.VVmqIY(chUrl, "Changing Program ...")
  else:
   self.VVCWQ4("Incorrect Timestamp !")
 def VVT1cG(self, isAudio):
  aud, sub = CCvjVs.VVHlVI(self.session), CCvjVs.VVbjRo()
  if isAudio:
   if aud < 1:
    self.VVCWQ4("No Audio Tracks")
    return
  else:
   if sub < 1:
    self.VVCWQ4("No Subtitles")
    return
  try:
   inst = InfoBar.instance
   if inst:
    from Screens.AudioSelection import AudioSelection, SubtitleSelection
    if isAudio : self.session.open(AudioSelection, infobar=inst)
    else  : self.session.open(SubtitleSelection, inst)
  except:
   pass
 @staticmethod
 def VVO1c1(session, mode=None):
  if   mode == "VV9RX6"   : FFdXBl(session, reopen=True)
  elif mode == "VV3NZB"  : session.open(CCkEI5)
  elif mode == "VVmZ3h" : session.open(CC6F0F)
  elif mode == "VVEAiH" : session.open(CClYaF, VVAHYe=True)
 @staticmethod
 def VVHc02(session, **kwargs):
  session.openWithCallback(BF(CCqWM2.VVO1c1, session), CCqWM2, **kwargs)
class CC032e(Screen):
 def __init__(self, session, title="", VVsWSA="Continue?", VV4Moq=True, VVAgUy=False):
  self.skin, self.VVfOli = FFiNEe(VVUcno, 1200, 800, 50, 20, 20, "#11221122", "#11221122", 30)
  self.session = session
  self["myLine"] = Label()
  self.VVsWSA = VVsWSA
  self.VVAgUy = VVAgUy
  self.maxHeight = 0
  no  = ("No" , "no" )
  yes = ("Yes", "yes")
  if VV4Moq : VV3wat = [no , yes]
  else   : VV3wat = [yes, no ]
  FFZMxC(self, title, VV3wat=VV3wat, addLabel=True)
  FFHlAU(self,
  {
   "ok" : self.VVPr1F ,
   "cancel": self.cancel ,
   "red" : self.cancel ,
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.maxHeight = self.instance.size().height()
  self["myLabel"].setText("\n%s\n" % self.VVsWSA)
  if self.VVAgUy:
   self["myLabel"].instance.setHAlign(0)
  self.VVRgu6()
  FF4IPF(self["myMenu"], fg="#08ffff00", bg="#08223333")
  try: self["myMenu"].instance.setHAlign(1)
  except: FFzKEr(self["myMenu"], 35)
  FFJmzh(self, self["myMenu"])
 def VVPr1F(self):
  item = self["myMenu"].l.getCurrentSelection()[1]
  if item is not None:
   if   item == "no" : self.close(False)
   elif item == "yes" : self.close(True)
  else:
   self.close(False)
 def cancel(self):
  self.close(False)
 def VVRgu6(self):
  vGap = 60 if CC674y.VV1LWx() else 0
  winW = self.instance.size().width()
  winH = self.instance.size().height()
  labelW = self["myLabel"].instance.size().width()
  labelH = self["myLabel"].instance.size().height()
  textSize= self["myLabel"].instance.calculateSize()
  diff = textSize.height() - labelH + vGap
  winNewH = winH + diff
  if winNewH < winH:
   screenSize = getDesktop(0).size()
   self["myLabel"].instance.resize(eSize(*(labelW, labelH + diff)))
   self.instance.resize(eSize(*(winW, winNewH)))
   self.instance.move(ePoint((screenSize.width() - winW) // 2, (screenSize.height() - winNewH) // 2))
   names = [ "myMenu", "myLine" ]
   for name in names:
    try:
     obj = self[name]
     pos = obj.getPosition()
     obj.instance.move(ePoint(pos[0], pos[1] + diff))
    except:
     pass
class CCUwDo(Screen, CCLAzj):
 def __init__(self, session, title="", VV3wat=None, width=1000, height=850, VVwdmN=30, VVW5y5="", VVyRCy=1, VVptue=0.15, VVy8OB=False, VVOa1G=None, VVJbOd=None, VVHGnw=None, VVwJOl=None, VVB4pu=None, VVaTeF=None, cornerPicFnc=None, VVdrEC=(0, 0), VVU8mZ=False, VVlaGv=False, VVtboQ=None, VVCkuB=True, VVwltY="#22003344", VVkxBG="#22002233", VVoCB2="#08005555"):
  if   VVy8OB and VVJbOd : VV0Ay7 = 2
  elif VVy8OB     : VV0Ay7 = 1
  elif VVJbOd    : VV0Ay7 = 3
  else      : VV0Ay7 = 0
  self.skin, self.VVfOli = FFiNEe(VVWp3I, width, height, 50, 40, 30, VVwltY, VVkxBG, VVwdmN, VVeFSs=40, VVptue=VVptue, VV0Ay7=VV0Ay7, VVdrEC=VVdrEC)
  self.session   = session
  self.VVW5y5   = VVW5y5
  self.VVyRCy   = VVyRCy
  self.VVy8OB    = VVy8OB
  self.VVOa1G   = VVOa1G
  self.VVJbOd   = VVJbOd
  self.VVHGnw   = VVHGnw
  self.VVwJOl  = VVwJOl
  self.VVB4pu  = ("Delete File", BF(self.VV6mkY, VVtboQ)) if not VVtboQ is None else VVB4pu
  self.VVaTeF   = VVaTeF
  self.cornerPicFnc  = cornerPicFnc
  self.VVU8mZ  = VVU8mZ
  self.VVlaGv  = VVlaGv
  self.VVoCB2   = VVoCB2
  self.Title    = title
  FFZMxC(self, title, VV3wat=VV3wat)
  CCLAzj.__init__(self)
  FFHlAU(self,
  {
   "ok"  : self.VVPr1F    ,
   "menu"  : self.VVfcZX   ,
   "cancel" : self.cancel    ,
   "info"  : self.VVGXgk   ,
   "red"  : self.VVnQ7v   ,
   "green"  : self.VVm2cy   ,
   "yellow" : self.VVrlp9   ,
   "blue"  : self.VVg0jV   ,
   "pageUp" : self.VVeXFp ,
   "chanUp" : self.VVeXFp ,
   "pageDown" : self.VVQ0fH  ,
   "chanDown" : self.VVQ0fH  ,
   "0"   : BF(self.VV3WBT, 0) ,
   "1"   : BF(self.VV3WBT, 1) ,
   "2"   : BF(self.VV3WBT, 2) ,
   "3"   : BF(self.VV3WBT, 3) ,
   "4"   : BF(self.VV3WBT, 4) ,
   "5"   : BF(self.VV3WBT, 5) ,
   "6"   : BF(self.VV3WBT, 6) ,
   "7"   : BF(self.VV3WBT, 7) ,
   "8"   : BF(self.VV3WBT, 8) ,
   "9"   : BF(self.VV3WBT, 9)
  })
  if VVCkuB:
   CCKg9B(self, self["myMenu"])
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF4IPF(self["myMenu"], bg=self.VVoCB2)
  FF2GM8(self, VVyRCy=self.VVyRCy)
  FF6W0I(self)
  self.VV004I(self["keyRed"]  , self.VVHGnw )
  self.VV004I(self["keyGreen"] , self.VVwJOl )
  self.VV004I(self["keyYellow"] , self.VVB4pu )
  self.VV004I(self["keyBlue"]  , self.VVaTeF )
  if self.VVW5y5      : self["myBar"].setText("  %s" % self.VVW5y5)
  elif not self["keyRed"].getVisible(): self["myBar"].setText("  OK = Select")
  else        : self["myBar"].setText("")
  FFWgBS(self)
  if self.cornerPicFnc:
   self.VVyR0w(self.VV1WUE)
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
 def VV004I(self, btnObj, btnFnc):
  if btnFnc:
   FFRLNq(btnObj, btnFnc[0])
 def VVyR0w(self, fnc, callFnc=True):
  self["myMenu"].onSelectionChanged.append(fnc)
  if callFnc:
   fnc()
 def VV1WUE(self):
  item = self.VVnGzV()
  if item:
   txt, ref, ndx = item
   picF = self.cornerPicFnc(self, txt, ref, ndx)
   if FFCyVu(picF):
    if self.VVacFr(picF):
     return
  self.VVTOb9()
 def VVoXgh(self, fnc=None):
  self.VVwJOl = fnc
  if fnc : self.VV004I(self["keyGreen"], self.VVwJOl)
  else : self["keyGreen"].hide()
 def VV3WBT(self, digit):
  digit = str(digit)
  VV3wat = self["myMenu"].list
  for ndx, item in enumerate(VV3wat):
   if len(item) == 2:
    span = iSearch(r"^\[(\d)\]\s.+", FFzBfi(item[0]), IGNORECASE)
    if span and span.group(1) == digit:
     self.VVx2yy(ndx)
     self.VVPr1F()
     break
 def VVnGzV(self):
  obj = self["myMenu"].l
  ref = obj.getCurrentSelection()[1]
  if ref is not None:
   txt = obj.getCurrentSelection()[0]
   ndx = obj.getCurrentSelectionIndex()
   return (txt, ref, ndx)
  else:
   return None
 def VVPr1F(self):
  item = self.VVnGzV()
  if item:
   txt, ref, ndx = item
   if self.VVOa1G:
    self.VVOa1G((self, txt, ref, ndx))
   else:
    if self.VVU8mZ: self.close((txt, ref, ndx))
    else     : self.close(ref)
 def VVfcZX(self):
  if self.VVy8OB: self.close("VVy8OB")
 def VVGXgk(self):
  item = self.VVnGzV()
  if self.VVJbOd and item:
   txt, ref, ndx = item
   self.VVJbOd(self, txt, ref, ndx)
 def cancel(self):
  self.close(None)
 def VVnQ7v(self)  : self.VVF95v(self.VVHGnw)
 def VVm2cy(self) : self.VVF95v(self.VVwJOl)
 def VVrlp9(self) : self.VVF95v(self.VVB4pu)
 def VVg0jV(self) : self.VVF95v(self.VVaTeF)
 def VVF95v(self, btnFnc):
  if btnFnc:
   item = self["myMenu"].l.getCurrentSelection()[1]
   fnc = btnFnc[1]
   fnc(self, item)
   if self.VVlaGv:
    self.cancel()
 def VV478W(self):
  ndx = self["myMenu"].getSelectedIndex()
  VV3wat = self["myMenu"].list
  VV3wat.pop(ndx)
  if len(VV3wat) > 0: self["myMenu"].setList(VV3wat)
  else    : self.close()
 def VVKjBW(self, data):
  ndx = self["myMenu"].getSelectedIndex()
  VV3wat = self["myMenu"].list
  VV3wat[ndx] = data
  self["myMenu"].setList(VV3wat)
 def VV6mkY(self, basePath, menuObj, fName):
  FFRMYv(self, BF(self.VVs4p7, basePath + fName), "Delete this file ?\n\n%s" % fName, title=self.Title)
 def VVs4p7(self, path):
  FFwgGB(path)
  if FFCyVu(path) : FF28n1(self, "Not deleted", 1000)
  else    : self.VV478W()
 def VVG6OZ(self):
  return self["myMenu"].list
 def VV35XX(self):
  return [x[1] for x in self["myMenu"].list if len(x) > 1]
 def VVkSNR(self, VV3wat):
  if len(VV3wat) > 0:
   newList = []
   for item in VV3wat:
    newList.append((item, item))
   self["myMenu"].setList(newList)
   FF2GM8(self, VVyRCy=self.VVyRCy)
  else:
   self.close("")
 def FFTmHZ(self, txt):
  self["myTitle"].setText("  %s  " % txt)
 def VVzEkM(self, txt):
  self["myBar"].setText("  %s  " % txt)
 def VV5HD3(self, newRow, isSort=False):
  lst = self["myMenu"].list
  lst.append(newRow)
  if isSort:
   lst.sort(key=lambda x: x[0].lower())
  self["myMenu"].setList(lst)
  FF2GM8(self, VVyRCy=self.VVyRCy)
  for ndx, item in enumerate(self["myMenu"].list):
   if item[1] == newRow[1]:
    self["myMenu"].moveToIndex(ndx)
    break
 def VVT8gV(self, isUp):
  ndx = self["myMenu"].getSelectionIndex()
  if   isUp and ndx > 0         : newIndex = ndx - 1
  elif not isUp and ndx < len(self["myMenu"].list) - 1 : newIndex = ndx + 1
  else             : return None
  newList = self["myMenu"].list
  newList.insert(newIndex, newList.pop(ndx))
  self["myMenu"].moveToIndex(newIndex)
  newList = []
  for item in self["myMenu"].list:
   newList.append(item[0])
  return newList
 def VVx2yy(self, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VVVZJD(self, refTxt):
  for ndx, item in enumerate(self["myMenu"].list):
   if len(item) > 1 and refTxt == item[1]:
    self.VVx2yy(ndx)
    break
 def VVyQ6Y(self, txt):
  for ndx, item in enumerate(self["myMenu"].list):
   if txt == item[0]:
    self.VVx2yy(ndx)
    break
 def VVeXFp(self) : self["myMenu"].moveToIndex(0)
 def VVQ0fH(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
class CCnES5(Screen, CCLAzj):
 def __init__(self, session, title="", width=1600, height=900, VVllEU=50, VViIEz=10, VVYUmm=5, header=None, VVGape=None, VVLIqP=None, VV3cHe=None, VVwdmN=26, VVW5y5="", VVCNdI="", VV8LLn=False, VVpCEu=False, VVlXgq=3000, VViWgK=False, VVp4wm=True, VVb5gJ=None, VVHPI7=False, VViZ3s=0, VVoGCy=None, VVp1bQ=None, VVdrEC=(0, 0), VVu1YM=None, VV2ytr=None, VVdHJK=None, VVwWmA=None, VVwSzI=None, VVScQz=None, VV4QTJ=None, VV2x9J=None, VVCOpO=None, VVu8qI=None, VVlJfJ=None, VVGuQE=None, VVC51D=-1, VVKDPJ=0, VVMfsO=0, VVSLOq=None, VVwltY="#22003344", VVkxBG="#22002233", VVEGV6="#00dddddd", VVemyB="#11002233", VVoRat=None, VVJKqd="#0a444033", VVLf28=1, VVbcr0="#0a555555", VVZrqm="#0affffff", VVX9AA="#11552200", VVrZk6="#0055ff55", VVG9pi="#004488ff"):
  VVpCEu = VVpCEu or VVKDPJ == 1
  barH = 1 if VVpCEu else 40
  self.skin, self.VVfOli = FFiNEe(VVvJlJ, width, height, VVllEU, VViIEz, VVYUmm, VVwltY, VVkxBG, 26, VVeFSs=barH, VV0Ay7=2, VVptue=0.6, VVdrEC=VVdrEC)
  self.session    = session
  self.Title     = title
  self.header     = header
  self.VVGape     = VVGape
  self.VV2BDe    = len(VVGape[0])
  self.VViZ3s   = VViZ3s
  self.VVoGCy    = VVoGCy
  self.VVp1bQ   = VVp1bQ
  self.VVo5oS    = VVp1bQ[0] if VVp1bQ else -1
  self.VV5638 = False
  self.VVHPI7   = VVHPI7
  self.VVw0f2   = 0.01
  self.VVWFVJ   = 0.02
  self.VVdOlT = 0.03
  self.VVrDCa   = 1
  self.VV3cHe = VV3cHe
  self.VVKAGT   = []
  self.VVu1YM   = VVu1YM
  self.VVbfjm   = None
  self.VV2ytr   = VV2ytr
  self.VVwWmA   = VVwWmA
  self.VVwSzI   = VVwSzI
  self.VVScQz  = VVScQz
  self.VV4QTJ   = VV4QTJ
  self.VV2x9J    = VV2x9J
  self.VVCOpO   = VVCOpO
  self.VVDpzd   = None
  self.VVu8qI  = VVu8qI
  self.VVlJfJ   = VVlJfJ
  self.VVdHJK   = VVdHJK
  self.VVC51D    = VVC51D
  self.VVKDPJ   = VVKDPJ
  self.VVMfsO    = VVMfsO
  self.VVLIqP    = VVLIqP
  self.VVj2Pf    = -1
  self.VVGuQE    = VVGuQE
  self.VVwdmN    = FFqCn5(VVwdmN)
  self.VVW5y5    = VVW5y5
  self.VVCNdI    = VVCNdI
  self.VV8LLn    = VV8LLn
  self.VVlXgq     = VVlXgq
  self.VViWgK    = VViWgK
  self.VVp4wm    = VVp4wm
  self.VVb5gJ    = VVb5gJ or {}
  self.VV8c7y    = FFGrBZ(self.VVwdmN, self.VVfOli["VVptue"])
  self.scrollBarWidth   = self.VVfOli["scrollBarW"]
  self.VVwltY    = VVwltY
  self.VVkxBG      = VVkxBG
  self.VVEGV6    = FFRUST(VVEGV6)
  self.VVemyB    = FFRUST(VVemyB)
  self.VVoRat    = VVoRat
  self.VVJKqd    = FFRUST(VVJKqd)
  self.VVLf28   = VVLf28
  self.VVbcr0   = FFRUST(VVbcr0)
  self.VVZrqm    = FFRUST(VVZrqm)
  self.VVX9AA    = FFRUST(VVX9AA)
  self.VVrZk6   = FFRUST(VVrZk6)
  self.VVG9pi  = FFRUST(VVG9pi)
  self.VVXWPu  = False
  self.VVEHSR   = 0
  self.VVH8fj   = FFRUST("#04764354")
  self.VVSLOq  = VVSLOq or CFG.lastFindGeneral
  self.VVcqGs  = False
  self.VVJ6ki  = False
  self.VVGxei  = False
  self.VVez0o = False
  self.VVMayE  = False
  self.VV5FKY = CCnES5.VVmxDV(0, 0, 20, 20, LoadPixmap(VVIp2p + "tick.png"))
  self.VVaqq6 = CCnES5.VVmxDV(0, 0, 1, 1, LoadPixmap(VVIp2p + "tick_1x1.png"))
  FFZMxC(self, title)
  CCLAzj.__init__(self)
  if VVpCEu:
   self["myLine"].hide()
  self["myTableH"] = MenuList([], True, eListboxPythonMultiContent)
  self["myTable"]  = MenuList([], True, eListboxPythonMultiContent)
  self["myTotSel"] = Label("Sel = 0")
  self["myTotSel"].hide()
  FFHlAU(self,
  {
   "ok"  : self.VVDFgE  ,
   "red"  : self.VV1uSG  ,
   "green"  : self.VVZgYJ ,
   "yellow" : self.VVKn4v ,
   "blue"  : self.VVJAg1  ,
   "menu"  : self.VV4lOw ,
   "info"  : self.VVyogT  ,
   "cancel" : self.VV1hTi  ,
   "up"  : self.VVgexy    ,
   "down"  : self.VVIRjv  ,
   "left"  : self.VVLlE3   ,
   "right"  : self.VVSYHQ  ,
   "next"  : self.VVFkgI  ,
   "last"  : self.VVtvpP  ,
   "home"  : self.VVE9rg  ,
   "pageUp" : self.VVE9rg  ,
   "chanUp" : self.VVE9rg  ,
   "end"  : self.VVMjPT  ,
   "pageDown" : self.VVMjPT  ,
   "chanDown" : self.VVMjPT
  })
  CCKg9B(self, self["myTable"], colNum=self.VVMfsO)
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  if self.VVW5y5:
   self.VVO1tN(self.VVW5y5)
  if self.VVKDPJ:
   self["keyMenu"].hide()
   x, y = self["keyMenu"].getPosition()
   self["keyInfo"].instance.move(ePoint(x, y))
  try:
   self.VVpxGx()
  except Exception as e:
   FFdw58(self, str(e), title=self.Title)
   self.close(None)
 def onExit(self):
  self["myTable"].onSelectionChanged = []
 def VVpxGx(self):
  FFWgBS(self)
  self.VV004I(self.VVwWmA , self["keyRed"])
  self.VV004I(self.VVwSzI , self["keyGreen"])
  self.VV004I(self.VVScQz, self["keyYellow"])
  self.VV004I(self.VV4QTJ , self["keyBlue"])
  if self.VVu1YM:
   if   not self["keyRed"].getVisible() : self.VVbfjm = self["keyRed"]
   elif not self["keyBlue"].getVisible() : self.VVbfjm = self["keyBlue"]
   else         : self.VVbfjm = None
   if self.VVbfjm and self.VVu1YM[0]:
    self.VVbfjm.show()
    self.VVbfjm.setText("OK = %s" % self.VVu1YM[0])
    FFZ0AC(self.VVbfjm, "#11000000")
  if self.VVCNdI and not self["keyBlue"].getVisible():
   self["keyBlue"].show()
   self["keyBlue"].setText(self.VVCNdI)
   FFZ0AC(self["keyBlue"], "#11000000")
  self["myTableH"].l.setSelectionClip(eRect(0, 0, 0, 0))
  FFK4PQ(self["myTableH"], "#00555500", 2)
  self["myTableH"].l.setItemHeight(self.VV8c7y)
  self["myTableH"].l.setFont(0, gFont(VVNhAq, self.VVwdmN))
  self["myTable"].l.setItemHeight(self.VV8c7y)
  self["myTable"].l.setFont(0, gFont(VVNhAq, self.VVwdmN))
  try:
   self["myTable"].instance.setScrollbarSliderBorderWidth(0)
  except:
   pass
  w = self["myTable"].instance.size().width()
  h = self["myTable"].instance.size().height()
  pos = self["myTable"].getPosition()
  if self.header and not self.VV8LLn:
   self["myTableH"].instance.resize(eSize(*(w, self.VV8c7y)))
   self["myTable"].instance.move(ePoint(pos[0], pos[1] + self.VV8c7y))
   self["myTable"].instance.resize(eSize(*(w, h - self.VV8c7y)))
  h = self["myTable"].instance.size().height()
  pos = self["myTable"].getPosition()
  part= self["myTable"].instance.size().height() % self.VV8c7y
  half= int(part / 2)
  self["myTable"].instance.resize(eSize(*(w, h - part)))
  self["myTable"].instance.move(ePoint(pos[0], pos[1] + half))
  if self.header:
   pos = self["myTableH"].getPosition()
   self["myTableH"].instance.move(ePoint(pos[0], pos[1] + half))
  menuWidth = self["myTable"].instance.size().width()
  gapX = 0
  if self.VV8c7y * len(self.VVGape) > self["myTable"].instance.size().height():
   menuWidth = menuWidth - int(self.scrollBarWidth) - 5
   gapX = int(self.scrollBarWidth) - 5
  if not self.VV3cHe:
   self.VV3cHe = ([float(100.0 / self.VV2BDe)] * self.VV2BDe)
  self.VVKAGT = list(self.VV3cHe)
  if not self.VVKAGT:
   self.VVKAGT = [menuWidth // self.VV2BDe] * self.VV2BDe
  else:
   for i, item in enumerate(self.VVKAGT):
    self.VVKAGT[i] = int(item * menuWidth / 100)
  if not self.VVLIqP : self.VVLIqP = [LEFT | RT_VALIGN_CENTER] * self.VV2BDe
  else     : self.VVLIqP = [x | RT_VALIGN_CENTER for x in self.VVLIqP]
  half = int(self.VV8c7y / 2.0)
  if self.header : gapY = self["myTableH"].getPosition()[1] + half
  else   : gapY = self["myTable"].getPosition()[1] - half
  self.VVKe51(gapX, gapY)
  self.VVfmej()
  if self.VV2x9J:
   self.VV2x9J(self)
 def VV004I(self, btnFnc, btn):
  if btnFnc : FFRLNq(btn, btnFnc[0])
  else  : FFRLNq(btn, "")
 def VVfmej(self, onlyHeader=False, showProgBar=True, fromRefresh=False):
  if self.header:
   sortedFg = self.VVG9pi if self.VV5638 else self.VVrZk6
   self["myTableH"].setList([self.VVPuKm(0, self.header, self.VVZrqm, self.VVX9AA, None, self.VVX9AA, sortedFg)])
  if onlyHeader:
   return
  tot = len(self.VVGape)
  if showProgBar and tot > self.VVlXgq:
   CCh3tv.VV7Nf4(self, VVLL7M="Loading Table ( %s row%s ) ..." % (tot, FFcacr(tot)), endTitle="Loading channels ...", VVIZBP=CCh3tv.VVgJkc, titleBg="#11222222", bodyBg="#11222222", barBg="#06446677"
       , VVixvy  =  BF(self.VVja0t, True, fromRefresh)
       , VVbYwR = self.VVTs5z )
  else:
   self.VVja0t(False, fromRefresh)
 def VVja0t(self, showProgBar, fromRefresh, VVXyP6=None):
  try:
   if showProgBar:
    VVXyP6.VVq8NF(len(self.VVGape))
   self["myTable"].list = []
   for c, row in enumerate(self.VVGape):
    if showProgBar:
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     VVXyP6.VVxtQs(1)
    self["myTable"].list.append(self.VVPuKm(c, row, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None))
   self.VVGape = []
   self["myTable"].setList(self["myTable"].list)
   if self.VVC51D > -1:
    self["myTable"].moveToIndex(self.VVC51D)
   if self.VVKDPJ and not fromRefresh:
    tableH = self["myTable"].instance.size().height()
    rowsH = self.VV8c7y * len(self["myTable"].list)
    if rowsH < tableH:
     diff = tableH - rowsH
     newH = self.instance.size().height() - diff
     screenSize = getDesktop(0).size()
     width = self.instance.size().width()
     self.instance.resize(eSize(*(width, newH)))
     self.instance.move(ePoint((screenSize.width() - width) // 2, (screenSize.height() - newH) // 2))
     names = [ "keyRed", "keyGreen", "keyYellow", "keyBlue", "myBar", "myLine" ]
     for name in names:
      obj = self[name]
      pos = obj.getPosition()
      obj.instance.move(ePoint(pos[0], pos[1] - diff))
     FF9sDw(self, width, newH)
   if self.VVCOpO:
    self.VVF95v(self.VVCOpO, None)
   if self.VVDpzd:
    self.VVF95v(self.VVDpzd, None)
    self.VVDpzd = None
  except AttributeError as attrErr:
   pass
  except Exception as e:
   try:
    FFdw58(self, str(e), title=self.Title)
    self.close()
   except:
    pass
 def VVTs5z(self, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  if not VVRI6P:
   self.close()
 def VVPuKm(self, keyIndex, columns, VVEGV6, VVemyB, VVoRat, VVJKqd, VVrZk6):
  row = [keyIndex]
  if VVoRat:
   VVoRat = FFRUST(VVoRat)
  posX = 0
  for ndx, entry in enumerate(columns):
   if not VVrZk6:
    textColor = VVEGV6
   elif VVrZk6 and (ndx in self.VVb5gJ and self.VVb5gJ[ndx] == self.VViZ3s) or ndx == self.VViZ3s:
    textColor = VVrZk6
   else:
    textColor = VVEGV6
   while iMatch(r"^\s*#(f|b)#[a-fA-F0-9]{8}#", entry):
    span = iSearch(r"\s*#(.)(#[a-fA-F0-9]{8})#(.*)", entry, IGNORECASE)
    if span:
     c = FFRUST(span.group(2))
     if span.group(1) == "f" : textColor = c
     else     : VVemyB = c
     entry = span.group(3)
   if not self.VViWgK and self.VVLIqP[ndx] & LEFT:
    entry = " " + entry + " "
   row.append(CCnES5.VVNynG(  posX, 0
             , self.VVKAGT[ndx], self.VV8c7y
             , 0
             , self.VVLIqP[ndx]
             , entry
             , textColor
             , VVemyB
             , VVoRat or textColor
             , VVJKqd
             , self.VVLf28
             , self.VVbcr0
             ))
   posX += self.VVKAGT[ndx]
  if not VVrZk6:
   if self.VVoGCy:
    VVzIFKCol, picFnc, pathCol = self.VVoGCy
    if   picFnc : png = picFnc(columns)
    elif pathCol: png = columns[pathCol].strip()
    else  : png = ""
    if png.startswith("/"):
     try:
      pngX = sum(self.VVKAGT[:VVzIFKCol])
      row.append(CCnES5.VVmxDV(pngX+2, VVzIFKCol+2, self.VVKAGT[VVzIFKCol]-4, self.VV8c7y-4, LoadPixmap(png)))
     except:
      pass
   if self.VVp1bQ:
    pCol, vCol, pW, pH = self.VVp1bQ
    perc = int(columns[vCol])
    pX = sum(self.VVKAGT[:pCol])
    w = int(pW / 100.0 * self.VVKAGT[pCol])
    h = int(pH / 100.0 * self.VV8c7y)
    x = pX + (self.VVKAGT[pCol] - w) // 2
    y = (self.VV8c7y - h) // 2
    row.append(CCnES5.VV86Ng(x, y, w, h, perc, 1, FFRUST("#00aaccaa")))
   row.append(self.VVaqq6)
  return row
 def VVyogT(self):
  rowData = self.VV0d86()
  if rowData:
   title, txt, colList = rowData
   if self.VV2ytr:
    fnc  = self.VV2ytr[1]
    params = self.VV2ytr[2]
    fnc(self, title, txt, colList)
   else:
    FF4lCP(self, txt, title)
 def VVDFgE(self):
  if   self.VVXWPu : self.VVTQDs(self.VVGTqU(), mode=2)
  elif self.VVu1YM  : self.VVF95v(self.VVu1YM, None)
  else      : self.VVyogT()
 def VV1uSG(self) : self.VVF95v(self.VVwWmA , self["keyRed"])
 def VVZgYJ(self) : self.VVF95v(self.VVwSzI , self["keyGreen"])
 def VVKn4v(self): self.VVF95v(self.VVScQz , self["keyYellow"])
 def VVJAg1(self) : self.VVF95v(self.VV4QTJ , self["keyBlue"])
 def VVF95v(self, buttonFnc, btnObj):
  if btnObj and not btnObj.getVisible():
   return
  if buttonFnc:
   if len(buttonFnc) > 3 and buttonFnc[3]:
    FF28n1(self, buttonFnc[3])
    FFIElK(BF(self.VV0sfZ, buttonFnc))
   else:
    self.VV0sfZ(buttonFnc)
 def VV0sfZ(self, buttonFnc):
  fnc   = buttonFnc[1]
  params  = buttonFnc[2]
  rowData = self.VV0d86()
  if rowData:
   title, txt, colList = rowData
   if not params : fnc(self, title, txt, colList)
   else   : fnc(self, *params)
 def VVTQDs(self, ndx, mode=0, movDn=True):
  try:  row = self["myTable"].list[ndx]
  except: row = None
  if row:
   isSelected = row[1][10] == self.VVH8fj
   if mode == 0 or (mode == 2 and isSelected):
    bg = self.VVemyB
    if isSelected:
     self.VVEHSR -= 1
   else:
    bg = self.VVH8fj
    if not isSelected:
     self.VVEHSR += 1
   self.VVdus6()
   if isSelected: self["myTable"].list[ndx][-1] = self.VVaqq6
   else   : self["myTable"].list[ndx][-1] = self.VV5FKY
   for col in range(1, len(row)):
    cols = list(row[col])
    if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
     cols[10] = bg
    row[col] = tuple(cols)
   self["myTable"].l.invalidate()
   if movDn and self.VVGTqU() < len(self["myTable"].list) - 1:
    self.VVIRjv()
   if self.VVlJfJ:
    self.VVlJfJ(self)
 def VVdus6(self): self["myTotSel"].setText("Sel = %d" % self.VVEHSR)
 def VVtrFZ(self)  : FFimQ3(self, BF(self.VVuUxo, True ), title="Selecting all ..."  )
 def VV3Ezh(self) : FFimQ3(self, BF(self.VVuUxo, False), title="Unselecting all ...")
 def VVuUxo(self, isSel=True):
  if isSel:
   bg = self.VVH8fj
   self.VVEHSR = len(self["myTable"].list)
   self.VV8lnC(True)
  else:
   bg = self.VVemyB
   self.VVEHSR = 0
  self.VVdus6()
  for ndx, row in enumerate(self["myTable"].list):
   isPainted = row[1][10] == self.VVH8fj
   if (isSel and not isPainted) or (not isSel and isPainted):
    for col in range(1, len(row)):
     cols = list(self["myTable"].list[ndx][col])
     if cols[0] == eListboxPythonMultiContent.TYPE_TEXT:
      cols[10] = bg
     self["myTable"].list[ndx][col] = tuple(cols)
   if isSel: self["myTable"].list[ndx][-1] = self.VV5FKY
   else : self["myTable"].list[ndx][-1] = self.VVaqq6
  self["myTable"].l.invalidate()
  if self.VVlJfJ:
   self.VVlJfJ(self)
 def VV8lnC(self, isOn):
  self.VVXWPu = isOn
  if isOn:
   color = "#01883366"
   self["myTotSel"].show()
   self["keyMenu"].hide()
   if self.VVcqGs and self.VVu1YM and self.VVbfjm:
    self.VVbfjm.setText("OK = Select")
   if self.VVJ6ki and self.VVwWmA: self["keyRed"].hide()
   if self.VVGxei and self.VVwSzI: self["keyGreen"].hide()
   if self.VVez0o and self.VVScQz: self["keyYellow"].hide()
   if self.VVMayE and self.VV4QTJ: self["keyBlue"].hide()
  else:
   color = self.VVwltY
   self["myTotSel"].hide()
   self["keyMenu"].show()
   if self.VVcqGs and self.VVu1YM and self.VVbfjm:
    self.VVbfjm.setText("OK = %s" % self.VVu1YM[0])
   if self.VVJ6ki and self.VVwWmA: self["keyRed"].show()
   if self.VVGxei and self.VVwSzI: self["keyGreen"].show()
   if self.VVez0o and self.VVScQz: self["keyYellow"].show()
   if self.VVMayE and self.VV4QTJ: self["keyBlue"].show()
  FFZ0AC(self["myTitle"], color)
  FFZ0AC(self["myBar"]  , color)
  if self.VVlJfJ:
   self.VVlJfJ(self)
 def VVK7k6(self, ndx):
  w = self.VV3cHe[ndx]
  return VVBvqf > 1 or (w > self.VVrDCa or w == self.VVw0f2 or w == self.VVdOlT) and ndx != self.VVo5oS
 def VV8scN(self, ndx):
  w = self.VV3cHe[ndx]
  return VVBvqf > 1 or (w > self.VVrDCa or w == self.VVdOlT) and ndx != self.VVo5oS
 def VVhSHf(self, ndx):
  w = self.VV3cHe[ndx]
  return VVBvqf > 1 or (w > self.VVrDCa or w == self.VVWFVJ) and ndx != self.VVo5oS and ndx not in self.VVb5gJ.keys()
 def VV0d86(self):
  item = self["myTable"].getCurrent()
  if item:
   colList = []
   txt = ""
   tot = 0
   for i in range(self.VV2BDe):
    colTxt = item[i + 1][7].strip()
    colList.append(colTxt)
    if self.VVK7k6(i):
     tot += 1
     if self.header : name = self.header[i].strip()
     else   : name = "Column-%d" % (i + 1)
     txt += "%s\t: %s\n" % (name, colTxt)
   if tot == 1:
    txt = colList[0]
   rowNum = "Row Number\t: %d of %d" % (item[0] + 1, len(self["myTable"].list))
   return rowNum, txt, colList
  else:
   return None
 def VV1hTi(self):
  if self.VVXWPu:
   self.VVW3QY()
  else:
   if self.VVu8qI : self.VVu8qI(self)
   else     : self.close(None)
 def cancel(self):
  self.close(None)
 def VVpVUj(self):
  return self["myTitle"].getText().strip()
 def VVeVZB(self):
  return self.header
 def VV0ZtI(self, title):
  self.Title = title
  self["myTitle"].setText("  " + title.strip() + "  ")
 def VVO1tN(self, txt):
  self["myBar"].setText("  %s  " % txt)
 def VVVBcI(self, title, color=None):
  self["myBar"].setText("  " + title.strip() + "  ")
  if color:
   FFGUI5(self["myBar"], color)
 def VVoNlW(self, txt):
  FF28n1(self, txt)
 def VV6fGE(self, txt, Time=1000):
  FF28n1(self, txt, Time)
 def VVH7zy(self): self["keyRed"].show()
 def VVeezy(self): self["keyRed"].hide()
 def VVsd6P(self): self["keyGreen"].show()
 def VVucBj(self): self["keyGreen"].hide()
 def VVbpCf(self): self["keyBlue"].show()
 def VVuDSc(self): self["keyBlue"].hide()
 def VVQ7id(self): self["keyYellow"].show()
 def VVAHUl(self): self["keyYellow"].hide()
 def VVOOzr(self): return self["keyGreen"].visible
 def VVrmMb(self):
  FF28n1(self)
 def VVIOX6(self, fnc, callFnc=True):
  self["myTable"].onSelectionChanged.append(fnc)
  if callFnc:
   fnc()
 def VVbyOe(self):
  return len(self["myTable"].list)
 def VVGTqU(self):
  return self["myTable"].l.getCurrentSelectionIndex()
 def VVn1uo(self):
  return len(self["myTable"].list)
 def VViNen(self):
  return self.VVXWPu
 def VVc5NH(self):
  return self.VVEHSR
 def VVL66W(self):
  self.VV8lnC(True)
 def VVW3QY(self):
  self.VV3Ezh()
  self.VV8lnC(False)
 def VV5Kmd(self):
  curRow = self["myTable"].l.getCurrentSelectionIndex()
  self["myTable"].moveToIndex(curRow + 1)
 def VVcAYi(self, colNum):
  if colNum < self.VV2BDe:
   if self.header : subj = self.header[colNum]
   else   : subj = ""
   lst = set()
   for item in self["myTable"].list:
    lst.add(item[colNum + 1][7])
   return subj, str(len(lst))
  else:
   return "", ""
 def VVlPyS(self):
  txt  = "Total Rows\t: %d\n\n" % self.VVbyOe()
  txt += FFGEAF("Total Unique Items", VVz22H)
  for i in range(self.VV2BDe):
   if self.VVK7k6(i):
    name, tot = self.VVcAYi(i)
    txt +=  "%s\t: %s\n" % (name, tot)
  FF4lCP(self, txt)
 def VVeE40(self, colNum, isStrip=True):
  item = self["myTable"].getCurrent()
  if item : return item[colNum + 1][7].strip() if isStrip else item[colNum + 1][7]
  else : return None
 def VV5crm(self):
  return self.VVMADj(self["myTable"].l.getCurrentSelectionIndex())
 def VVMADj(self, rowNdx):
  colList = []
  item = self["myTable"].list[rowNdx]
  if item:
   for i in range(1, self.VV2BDe + 1):
    colList.append(item[i][7].strip())
  return colList
 def VVMqQ9(self, newList, newTitle="", VV5YRVMsg=True, VVDpzd=None, isSort=True):
  fnc = BF(self.VVov9N, newList, newTitle, VV5YRVMsg, VVDpzd, isSort)
  if VV5YRVMsg : FFimQ3(self, fnc, title="Refreshing ...")
  else   : fnc()
 def VVov9N(self, newList, newTitle, VV5YRVMsg, VVDpzd, isSort):
  try: fake = self.VVHPI7
  except: return
  if newTitle:
   self.VV0ZtI(newTitle)
  if newList:
   self.VVGape = newList
   if VVDpzd:
    self.VVDpzd = ("", VVDpzd, [])
   isNum = False
   if self.VVHPI7 and self.VViZ3s == 0:
    isNum = True
   else:
    for cols in self.VVGape:
     if not FFajKn(cols[self.VViZ3s]): break
    else:
     isNum = True
   if isSort:
    patt = r"^\s*#(f|b)#[a-fA-F0-9]{8}#"
    if isNum: self.VVGape.sort(key=lambda x: int(x[self.VViZ3s][12:])  if iMatch(patt, x[0]) else int(x[self.VViZ3s]) , reverse=self.VV5638)
    else : self.VVGape.sort(key=lambda x: x[self.VViZ3s][12:].lower() if iMatch(patt, x[0]) else x[self.VViZ3s].lower() , reverse=self.VV5638)
   self.VVfmej(showProgBar=False, fromRefresh=True)
  else:
   FFdw58(self, "Cannot refresh list", title=self.Title)
   self.cancel()
 def VV1MqZ(self, row, moveCurs=True):
  row = self["myTable"].list.append(self.VVPuKm(self.VVn1uo(), row, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None))
  self["myTable"].l.setList(self["myTable"].list)
  if moveCurs: self.VVMjPT()
 def VVtM2v(self):
  self["myTable"].list.pop(self.VVGTqU())
  if len(self["myTable"].list) > 0: self["myTable"].l.setList(self["myTable"].list)
  else       : self.close()
 def VViSLW(self, data):
  ndx = self.VVGTqU()
  newRow = self.VVPuKm(ndx, data, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None)
  if newRow:
   self["myTable"].list[ndx] = newRow
   self.VVKFLG()
   return True
  else:
   return False
 def VVFKAn(self, tDict):
  ndx = self.VVGTqU()
  for colNum, val in tDict.items():
   txt = str(val)
   if not self.VViWgK and self.VVLIqP[ndx] & LEFT:
    txt = " %s " % txt.strip()
   col = list(self["myTable"].list[ndx][colNum + 1])
   col[7] = txt
   self["myTable"].list[ndx][colNum + 1] = tuple(col)
  self.VVKFLG()
 def VVEOou(self, ndx, data):
  if ndx >=0 and ndx < len(self["myTable"].list):
   newRow = self.VVPuKm(ndx, data, self.VVEGV6, self.VVemyB, self.VVoRat, self.VVJKqd, None)
   if newRow:
    self["myTable"].list[ndx] = newRow
    self.VVKFLG()
 def VVmMYI(self, rowNdx, colNDx, part, val):
  row = self["myTable"].list[rowNdx]
  col = list(row[colNDx + 1])
  if col[0] == eListboxPythonMultiContent.TYPE_TEXT:
   if col[part] != val:
    col[part] = val
    row[colNDx + 1] = tuple(col)
    self["myTable"].list[rowNdx] = row
    self.VVKFLG()
 def VVKFLG(self):
  self["myTable"].l.invalidate()
 def VV8IgX(self, colNum=0):
  for ndx, item in enumerate(self["myTable"].list):
   lst = list(self["myTable"].list[ndx][colNum + 1])
   lst[7] = str(ndx + 1)
   self["myTable"].list[ndx][colNum + 1] = tuple(lst)
  self["myTable"].l.setList(self["myTable"].list)
 def VVn5CC(self, colNum, textToFind, VVwb7n=False):
  for i in range(len(self["myTable"].list)):
   item = self["myTable"].list[i][colNum + 1][7].strip()
   if textToFind in item:
    self["myTable"].moveToIndex(i)
    break
  else:
   if VVwb7n:
    FF28n1(self, "Not found", 1000)
 def VVPkdw(self, colDict, VVwb7n=False):
  for i in range(len(self["myTable"].list)):
   for colNum, txt in colDict.items():
    if not txt == self["myTable"].list[i][colNum + 1][7].strip():
     break
   else:
    self["myTable"].moveToIndex(i)
    return
  if VVwb7n:
   FF28n1(self, "Not found", 1000)
  return False
 def VVrc5p(self, colNum):
  tList = []
  for i in range(len(self["myTable"].list)):
   item = self["myTable"].list[i][colNum + 1][7].strip()
   tList.append(item)
  return tList
 def VVSkYx(self, colNum):
  for i in range(len(self["myTable"].list)):
   if not FFajKn(self["myTable"].list[i][colNum + 1][7].strip()):
    return False
  return True
 def VVf3uT(self, colNum, isStrip=True):
  tList = []
  for ndx, row in enumerate(self["myTable"].list):
   if row[1][10] == self.VVH8fj:
    item = self["myTable"].list[ndx][colNum + 1][7]
    if isStrip: item = item.strip()
    tList.append(item)
  return tList
 def VV6LTe(self):
  if self.VVEHSR:
   for ndx, row in enumerate(self["myTable"].list):
    if row[1][10] == self.VVH8fj:
     return ndx
  return -1
 def VVbF9W(self):
  tList = []
  for ndx, row in enumerate(self["myTable"].list):
   if row[1][10] == self.VVH8fj:
    item = self["myTable"].list[ndx]
    colList = []
    for i in range(1, self.VV2BDe + 1):
     colList.append(item[i][7].strip())
    tList.append(colList)
  return tList
 def VVvlf4(self, ndx):
  row = self["myTable"].list[ndx]
  if row[1][10] == self.VVH8fj : return True
  else        : return False
 def VVrrm9(self):
  for ndx, row in enumerate(self["myTable"].list):
   item = self["myTable"].list[ndx]
   colList = []
   for i in range(1, self.VV2BDe + 1):
    colTxt = item[i][7].strip()
    colList.append(colTxt)
   yield colList
 def VV4lOw(self):
  if self.VVdHJK:
   self.VV0sfZ(self.VVdHJK)
   return
  if not self["keyMenu"].getVisible() or self.VVKDPJ:
   return
  txt  = self.VVSLOq.getValue()
  curRow = self.VVGTqU()
  totRows = len(self["myTable"].list)
  itemOf = lambda cond, p1, p2: (p1, p2) if cond else (p1, )
  VV3wat1, VV0mqE = CCoErY.VVHRan(self, False, False)
  VV3wat = []
  VV3wat.append(itemOf(txt and curRow < totRows - 1 , "Find Next\t\t>"     , "findNext"  ))
  VV3wat.append(itemOf(txt and curRow > 0   , "Find Previous\t\t<"    , "findPrev"  ))
  VV3wat.append(("Find ...\t\t%s" % (FFjt5L(txt, VVGCYL) if txt else ""), "findNew"   ))
  VV3wat.append(itemOf(bool(VV3wat1)    , "Find (from Filter) ..."   , "filter"   ))
  if self.header:
   VV3wat.append(VVAL3j)
   VV3wat.append(("Table Statistcis"            , "tableStat"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append((FFjt5L("Export Table to .html"     , VVz22H) , "VVIOR0" ))
  VV3wat.append((FFjt5L("Export Table to .csv"     , VVz22H) , "VV4tSX" ))
  VV3wat.append((FFjt5L("Export Table to .txt (Tab Separated)", VVz22H) , "VVIDeL" ))
  if self.VVp4wm:
   sList = []
   tot  = 0
   for i in range(self.VV2BDe):
    if self.VVhSHf(i):
     tot += 1
     if self.header : name = self.header[i]
     else   : name = "Column-%d" % (i + 1)
     sList.append(("Sort by : %s" % name, i))
   if tot:
    VV3wat.append(VVAL3j)
    if tot == 1 : VV3wat.append(("Sort", sList[0][1]))
    else  : VV3wat += sList
  VVaTeF = ("Keys Help", self.VV1eoq)
  FFLFTC(self, self.VV0nVg, VV3wat=VV3wat, VVwdmN=28,title=self.VVpVUj(), VVaTeF=VVaTeF)
 def VV0nVg(self, item=None):
  if item is not None:
   if   item == "findNext"  : self.VV5pGB()
   elif item == "findPrev"  : self.VV5pGB(isPrev=True)
   elif item == "findNew"  : self.VVrkXJ()
   elif item == "filter"  : self.VVmqJH()
   elif item == "tableStat" : self.VVlPyS()
   elif item == "VVIOR0": self.VVIOR0()
   elif item == "VV4tSX" : self.VV4tSX()
   elif item == "VVIDeL" : self.VVIDeL()
   else:
    if self.VViZ3s == item: self.VV5638 = not self.VV5638
    else      : self.VViZ3s, self.VV5638 = item, False
    if self.VVHPI7 and self.VViZ3s == 0 or self.VVSkYx(item):
     self["myTable"].list.sort(key=lambda x: int(x[item + 1][7]), reverse=self.VV5638)
    else:
     self["myTable"].list.sort(key=lambda x: x[item + 1][7].lower(), reverse=self.VV5638)
    self["myTable"].l.setList(self["myTable"].list)
    self.VVfmej(onlyHeader=True)
 def VV1eoq(self, VV7tND, path):
  FFw2rR(self, "_help_table", "Table (Keys Help)")
 def VVgexy(self) : self["myTable"].up()
 def VVIRjv(self): self["myTable"].down()
 def VVLlE3(self) : self["myTable"].pageUp()
 def VVSYHQ(self): self["myTable"].pageDown()
 def VVE9rg(self)  : self["myTable"].moveToIndex(0)
 def VVMjPT(self)  : self["myTable"].moveToIndex(len(self["myTable"].list) - 1)
 def VVrqBw(self, rowNdx): self["myTable"].moveToIndex(rowNdx)
 def VVFkgI(self):
  if self.VVSLOq.getValue():
   if self.VVGTqU() == len(self["myTable"].list) - 1 : FF28n1(self, "End reached", 1000)
   else              : self.VV5pGB()
  else:
   FF28n1(self, 'Set "Find" in Menu', 1500)
 def VVtvpP(self):
  if self.VVSLOq.getValue():
   if self.VVGTqU() == 0 : FF28n1(self, "Top reached", 1000)
   else       : self.VV5pGB(isPrev=True)
  else:
   FF28n1(self, 'Set "Find" in Menu', 1500)
 def VVuKIQ(self, txt):
  FFjt1c(self.VVSLOq, txt)
 def VVrkXJ(self):
  FF4z45(self, self.VV2Zcr, title="Find in Table", defaultText=self.VVSLOq.getValue(), message="Enter Text:")
 def VV2Zcr(self, VVRD20):
  if not VVRD20 is None:
   txt = VVRD20.strip()
   self.VVuKIQ(txt)
   if VVRD20: self.VV5pGB(reset=True)
   else  : FF28n1(self, "Nothing to find !", 1500)
 def VVmqJH(self):
  VV3wat, VV0mqE = CCoErY.VVHRan(self, False, False)
  VVB4pu = ("Edit Filter", BF(self.VVpfQ8, VV0mqE))
  if VV3wat : FFLFTC(self, self.VVeuZu, VV3wat=VV3wat, VVB4pu=VVB4pu, title="Find from Filter")
  else  : FF28n1(self, "Filter Error !", 1500)
 def VVeuZu(self, item=None):
  if item is not None:
   txt = item.strip()
   if txt:
    self.VVuKIQ(txt)
    self.VV5pGB(reset=True)
   else:
    FF28n1(self, "No entry !", 1500)
 def VVpfQ8(self, VV0mqE, selectionObj, sel):
  if FFCyVu(VV0mqE) : CCyMCP(self, VV0mqE, VVbYwR=None)
  else       : FF8Wsn(self, VV0mqE)
  selectionObj.cancel()
 def VV5pGB(self, reset=False, isPrev=False):
  curRow = self.VVGTqU()
  totRows = len(self["myTable"].list)
  if   reset : row1, row2, steps = 0, totRows, 1
  elif isPrev : row1, row2, steps = curRow - 1, -1, -1
  else  : row1, row2, steps = curRow + 1, totRows, 1
  tupl, asPrefix = CCoErY.VVPBNm(self.VVSLOq.getValue())
  if tupl:
   for i in range(row1, row2, steps):
    line = self["myTable"].list[i][self.VVMfsO + 1][7]
    line = line.strip().lower()
    if asPrefix:
     if line.startswith(tupl):
      self.VVrqBw(i)
      break
    elif any(x in line for x in tupl):
     self.VVrqBw(i)
     break
   else:
    FF28n1(self, "Not found", 1000)
  else:
   FF28n1(self, "Check your query", 1500)
 @FFOAKH()
 def VVIDeL(self):
  expFile = self.VVjFfb() + ".txt"
  with open(expFile, "w") as f:
   filteredHeader = self.VVQID2()
   if filteredHeader:
    f.write("\t".join(filteredHeader) + "\n")
   for i in range(len(self["myTable"].list)):
    row = self.VVMADj(i)
    newRow = []
    for ndx, col in enumerate(row):
     if self.VV8scN(ndx):
      col = self.VVfO2i(col)
      col = col.replace("\n", " _ ")
      newRow.append(col)
    f.write("\t".join(newRow) + "\n")
  self.VVcBrS(expFile)
 @FFOAKH()
 def VV4tSX(self):
  expFile = self.VVjFfb() + ".csv"
  with open(expFile, "w") as f:
   filteredHeader = self.VVQID2()
   if filteredHeader:
    f.write(",".join(filteredHeader) + "\n")
   pattern = "^[0-9a-fA-F]*$"
   for i in range(len(self["myTable"].list)):
    row = self.VVMADj(i)
    newRow = []
    for ndx, col in enumerate(row):
     if self.VV8scN(ndx):
      if iMatch(pattern, col) : prefix = "'"
      else     : prefix = ""
      col = self.VVfO2i(col)
      col = col.replace(",", ";").replace("\n", " _ ")
      newRow.append(prefix + col)
    f.write(",".join(newRow) + "\n")
  self.VVcBrS(expFile)
 @FFOAKH()
 def VVIOR0(self):
  title = FFzBfi(self.VVpVUj()).replace("\t", "&nbsp;" * 4)
  txt   = '<!DOCTYPE html>\n'
  txt  += '<html>\n'
  txt  += ' <head>\n'
  txt  += ' <meta charset="utf-8">\n'
  txt  += ' <meta name="viewport" content="width=device-width, initial-scale=1.0">\n'
  txt  += ' <TITLE>%s - %s (%s)</TITLE>\n' % (title, VVh9hj, VVJ6zn)
  txt  += ' <style>\n'
  txt  += '  table { font-family: arial, sans-serif; border-collapse: collapse; width: 100%; }\n'
  txt  += '  td,th { border: 1px solid #dddddd; text-align: left; padding: 5px; }\n'
  txt  += '  td { font-size: 0.8em; }\n'
  txt  += '  th { color:#006000; background-color:#FFFFaa; font-size: 1.2em; }\n'
  txt  += '  tr:nth-child(even) { background-color: #f8f8f8; }\n'
  txt  += ' </style>\n'
  txt  += ' </head>\n'
  txt  += ' <body>\n'
  txt  += '  <h2 style="color:#006000;">%s</h2>\n' % title
  txt  += '  <table>\n'
  txt  +=     '#colgroup#'
  txt  += '   <tr>#tableHead#</tr>\n'
  txt2  = '  <table>\n'
  txt2 += ' </body>\n'
  txt2 += '</html>\n'
  tableHead  = ""
  filteredHeader = self.VVQID2()
  if filteredHeader:
   for col in filteredHeader:
    tableHead += '<th>%s</th>' % col
  txt = txt.replace("#tableHead#", tableHead)
  colgroup = ""
  if self.VV3cHe:
   colgroup += '   <colgroup>'
   for ndx, w in enumerate(self.VV3cHe):
    if self.VV8scN(ndx):
     colgroup += '<col style="width: %d%s;" />' % (w, "%")
   colgroup += "</colgroup>\n"
  txt = txt.replace("#colgroup#", colgroup)
  expFile = self.VVjFfb() + ".html"
  with open(expFile, "w") as f:
   f.write(txt)
   for i in range(len(self["myTable"].list)):
    row = self.VVMADj(i)
    newRow = "   <tr>"
    for ndx, col in enumerate(row):
     if self.VV8scN(ndx):
      col = self.VVfO2i(col)
      newRow += '<td>%s</td>' % col
    newRow += "</tr>\n"
    f.write(newRow)
   f.write(txt2)
  self.VVcBrS(expFile)
 def VVQID2(self):
  newRow = []
  if self.header:
   for ndx, col in enumerate(self.header):
    if self.VV8scN(ndx):
     newRow.append(col.strip())
  return newRow
 def VVfO2i(self, col):
  if col.count(":") > 8:
   col = col.replace(":", "_")
   col = col.rstrip("_")
  col = iSub(r"(#.#[a-fA-F0-9]{8}#)" ,"" , col, flags=IGNORECASE)
  return FFzBfi(col)
 def VVjFfb(self):
  fileName = iSub(r"[^0-9a-zA-Z]+", "_", FFzBfi(self.VVpVUj()))
  fileName = fileName.replace("__", "_")
  expFile  = FFeAlZ() + fileName + "_" + FFjTQe()
  return expFile
 def VVcBrS(self, expFile):
  if self.VVGuQE and FFCyVu(expFile):
   self.VVGuQE(self, expFile)
  FFipXT(self, "File exported to:\n\n%s" % expFile, title=self.VVpVUj())
 @staticmethod
 def VVNynG(x, y, w, h, fnt, flg, txt, fg, bg, sFg, sBg, bW, bC):
  return (eListboxPythonMultiContent.TYPE_TEXT, x, y, w, h, fnt, flg, txt, fg, sFg, bg, sBg, bW, bC)
 @staticmethod
 def VVmxDV(x, y, w, h, png, bg=None, bgSel=None):
  typ = eListboxPythonMultiContent.TYPE_PIXMAP_ALPHATEST
  if VVGpHg: return (typ, x, y, w, h, png, bg, bgSel, VVGpHg | CENTER)
  else   : return (typ, x, y, w, h, png, bg, bgSel)
 @staticmethod
 def VV86Ng(x, y, w, h, percent, bW, fg):
  return (eListboxPythonMultiContent.TYPE_PROGRESS, x, y, w, h, int(percent), bW, fg)
class CCWhOL():
 def __init__(self, pixmap, VVAfO9, VVemyB, fncCb_ok, fncCb_fail):
  self.pixmap   = pixmap
  self.picInst  = pixmap.instance
  self.VVAfO9  = VVAfO9
  self.VVemyB  = VVemyB or "#2200002a"
  self.fncCb_ok  = fncCb_ok
  self.fncCb_fail  = fncCb_fail
  self.FFgrjX  = FFgrjX()
  global VV8oe7
  VV8oe7 = True
  self.picInst.setPixmap(None)
 def VVcRk2(self):
  from enigma import ePicLoad
  self.picLoad  = ePicLoad()
  self.picload_conn = None
  if not all((self.pixmap, self.VVAfO9, FFCyVu(self.VVAfO9))):
   return False
  sz = self.picInst.size()
  self.picLoad.setPara((sz.width(), sz.height(), 1, 1, False, 1, self.VVemyB))
  try:
   if self.FFgrjX:
    res = self.picLoad.startDecode(self.VVAfO9, False)
    if res == 0:
     return self.VVnX2S()
    else:
     del self.picLoad
     return False
   else:
    try:
     self.picload_conn = self.picLoad.PictureData.connect(self.VVIvYQ)
    except:
     self.picLoad.PictureData.get().append(self.VVIvYQ)
    res = self.picLoad.startDecode(self.VVAfO9)
    return True if res == 0 else False
  except:
   return False
 def VVIvYQ(self, pInfo=""):
  ok = self.VVnX2S()
 def VVnX2S(self):
  ok = False
  ptr = self.picLoad.getData()
  if ptr is not None:
   try:
    self.picInst.setPixmap(ptr)
    ok = True
   except:
    pass
  del self.picLoad
  self.picload_conn = None
  if ok and self.fncCb_ok   : self.fncCb_ok()
  if not ok and self.fncCb_fail: self.fncCb_fail()
  global VV8oe7
  VV8oe7 = False
  return ok
class CCf8zb(Screen):
 def __init__(self, session, VVPq2Z, title="", showGrnMsg="", fileList=None, VVBGsZ=0, fakePath=None, cbFnc=None, menuFnc=None):
  scrW, scrH = FFrPd1()
  w = 1700
  h = int(min(w * scrH / scrW + 51, 1040))
  self.skin, self.VVfOli = FFiNEe(VVsVfC, w, h, 30, 0, 0, "#22000060", "#2200002a", 30, VV0Ay7=2 if menuFnc else 3)
  self.session  = session
  self.Title   = title
  self["myPic"]  = Pixmap()
  self.VVPq2Z = VVPq2Z
  self.showGrnMsg  = showGrnMsg
  self.fileList  = fileList
  self.VVBGsZ  = VVBGsZ
  self.fakePath  = fakePath
  self.cbFnc   = cbFnc
  self.menuFnc  = menuFnc
  FFZMxC(self)
  FFHlAU(self,
  {
   "ok" : self.VVfXzC    ,
   "red" : self.VVfXzC    ,
   "cancel": self.VVfXzC    ,
   "info" : self.VVWbNl  ,
   "menu" : self.VV7mRc  ,
   "up" : BF(self.VVBvTF, -1),
   "down" : BF(self.VVBvTF,  1),
   "left" : BF(self.VVBvTF, -1),
   "right" : BF(self.VVBvTF,  1)
  })
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  self.VVBB5b()
 def VVfXzC(self):
  if VV8oe7:
   FFDuEn(self)
   FFjADj(self, "Closing ...")
   FFOKt0(self, 1000, self.close)
  else:
   self.close("")
 def VVBB5b(self):
  self.VVkvel()
  if os.path.isfile(self.VVPq2Z) and CCHmnm.VVMyky(self.VVPq2Z) == "pic" and FFXhoc(self.VVPq2Z) > 0:
   if not FF0TBx(self["myPic"], self.VVPq2Z, fncCb_ok=self.VVa9hZ, fncCb_fail=self.VVGGrW):
    self.VVGGrW()
  else:
   self.VVGGrW()
 def VVa9hZ(self):
  if self.showGrnMsg:
   FF1mVE(self, self.showGrnMsg, 1500)
 def VVGGrW(self):
  if not FFkDgm(self["myPic"], "noPic"):
   FFdw58(self, "Cannot view picture file:\n\n%s" % self.VVPq2Z)
   self.close()
 def VVBvTF(self, direc):
  if self.fileList:
   oldNdx = self.VVBGsZ
   self.VVBGsZ += direc
   if direc == -1 and self.VVBGsZ < 0      : self.VVBGsZ = len(self.fileList) - 1
   if direc ==  1 and self.VVBGsZ > len(self.fileList) - 1 : self.VVBGsZ = 0
   if not oldNdx == self.VVBGsZ:
    fName = self.fileList[self.VVBGsZ][1]
    self.VVPq2Z = FFoWxR(os.path.dirname(self.VVPq2Z)) + fName
    self.VVBB5b()
 def onExit(self):
  if self.cbFnc:
   if self.fileList: self.cbFnc(self.VVPq2Z, self.fileList[self.VVBGsZ][0])
   else   : self.cbFnc(self.VVPq2Z)
 def VVWbNl(self):
  txt = "%s:\n  %s" % (FFjt5L("Path", VVFuwR), self.fakePath or self.VVPq2Z)
  size, sizeTxt, resTxt, form, mode = CC6u6z.VV5h28(self.VVPq2Z)
  if any((size, sizeTxt, resTxt, form, mode)):
   txt += "\n\n%s:\n" % FFjt5L("Properties", VVFuwR)
   if sizeTxt: txt += "  File Size\t: %s\n" % sizeTxt
   if resTxt : txt += "  Dimensions\t: %s\n" % resTxt
   if form   : txt += "  Format\t: %s\n"  % form
   if mode   : txt += "  Mode\t: %s\n"   % mode
  FF4lCP(self, txt, title="File Information")
 def VV7mRc(self):
  if self.menuFnc:
   self.menuFnc(self)
 def VVkvel(self):
  if self.fileList: title = "%d/%d : %s" % (self.VVBGsZ + 1, len(self.fileList), self.fileList[self.VVBGsZ][1])
  elif self.Title : title = self.Title
  else   : title = os.path.basename(self.VVPq2Z)
  self["myTitle"].setText("  %s  " % title)
 @staticmethod
 def VVjnMn(SELF, VVPq2Z, **kwargs):
  SELF.session.open(CCf8zb, VVPq2Z, **kwargs)
class CCcV1i(Screen):
 def __init__(self, session, mviFile=None):
  self.skin, self.VVfOli = FFiNEe(VVlrZA, 400, 55, 30, 0, 0, "#22004455", "#00ff0000", 30)
  self.session  = session
  self.mviFile  = mviFile
  FFZMxC(self, "Click Cancel to exit", addCloser=True)
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.curServ = CC3rDi(self.session).servRef
  self.session.nav.stopService()
  if FFpwZS("showiframe %s" % self.mviFile):
   self.instance.move(ePoint(20, 20))
  else:
   self.close(-1)
 def onExit(self):
  if self.curServ:
   self.session.nav.playService(self.curServ, checkParentalControl=False, forceRestart=False)
 @staticmethod
 def VVKb3z(SELF, mviFile):
  SELF.session.openWithCallback(BF(CCcV1i.VVDWvz, SELF), CCcV1i, mviFile)
 @staticmethod
 def VVDWvz(SELF, reason=None):
  if reason == -1: FFdw58(SELF, "Error while viewing mvi file.", title="MVI Viewer")
class CCJaSw(Screen, ConfigListScreen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVibAL, 1400, 1075, 50, 15, 15, "#11201010", "#11101010", 28, VVeFSs=40, VV0Ay7=1, VVptue=0.1)
  self.session  = session
  self.Title   = "%s Settings" % VVh9hj
  FFZMxC(self, title=self.Title)
  FFRLNq(self["keyGreen"], "Save")
  sep = SEP * 3
  lst = []
  lst.append(getConfigListEntry("Show in Main Menu"         , CFG.showInMainMenu   ))
  lst.append(getConfigListEntry("Show in Extensions Menu"        , CFG.showInExtensionMenu  ))
  lst.append(getConfigListEntry("Show in Channel List Context Menu"     , CFG.showInChannelListMenu  ))
  lst.append(getConfigListEntry("Show in Events Info Menu"       , CFG.EventsInfoMenu   ))
  lst.append(getConfigListEntry("Input Type"           , CFG.keyboard     ))
  lst.append(getConfigListEntry("Exit-Button Action (in File Manager and FTP)"  , CFG.FileManagerExit   ))
  lst.append(getConfigListEntry("Player Bar Hotkey"         , CFG.hotkey_signal    ))
  lst.append(getConfigListEntry("Screenshot"           , CFG.screenshotFType   ))
  lst.append(getConfigListEntry("Subtitle Files Encoding Priority"     , CFG.subtDefaultEnc   ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Default IPTV Reference Type (defines the player)" , CFG.iptvAddToBouquetRefType ))
  lst.append(getConfigListEntry("Auto Reset Frozen IPTV Channels"      , CFG.autoResetFrozenIptvChan ))
  lst.append(getConfigListEntry("Skip Adults Channels (from IPTV Server)"    , CFG.hideIptvServerAdultWords ))
  lst.append(getConfigListEntry("Remove IPTV Channel Name Prefix (|EN| , |AR|Drama|)" , CFG.hideIptvServerChannPrefix ))
  lst.append(getConfigListEntry("Portal Servers Connection Timeout (seconds)"   , CFG.portalConnTimeout   ))
  lst.append(getConfigListEntry("IPTV Hosts Files Path (Playlist, Portal, M3U)"  , CFG.iptvHostsMode    ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Auto Resume (Movies)"        , CFG.resumeMovies    ))
  lst.append(getConfigListEntry("Local Movies and IPTV Download Path"     , CFG.MovieDownloadPath   ))
  lst.append(getConfigListEntry("PIcons Path"           , CFG.PIconsPath    ))
  lst.append(getConfigListEntry("Custom Menu Path"         , CFG.customMenuPath   ))
  lst.append(getConfigListEntry(sep             ,         ))
  lst.append(getConfigListEntry("Main Working Path (Backup/Restore/Screenshot/etc.)" , CFG.backupPath    ))
  ConfigListScreen.__init__(self, lst, session)
  self.VVFslJ()
  self.onShown.append(self.VV7OzD)
 def VVFslJ(self):
  kList = {
    "ok" : self.VVPr1F   ,
    "green" : self.VVTUim ,
    "menu" : self.VVhAm1 ,
    "cancel": self.VVMrMS
    }
  kLeft = kRight = None
  try:
   from Components.config import ConfigSubList, KEY_LEFT as kLeft, KEY_RIGHT as kRight
  except:
   try:
    from Components.config import ConfigSubList, ACTIONKEY_LEFT as kLeft, ACTIONKEY_RIGHT as kRight
   except:
    pass
  if not (kLeft == kRight == None):
   kList["left"] = BF(self["config"].handleKey, kLeft)
   kList["right"] = BF(self["config"].handleKey, kRight)
   try:
    kList["chanUp"]  = self["config"].pageUp
    kList["chanDown"] = self["config"].pageDown
   except:
    try:
     kList["chanUp"]  = BF(self["config"].VVfqOq, 0)
     kList["chanDown"] = BF(self["config"].VVfqOq, len(self["config"].list) - 1)
    except:
     pass
   FFHlAU(self, kList, name="config_actions")
  else:
   FFHlAU(self, kList, name="actions")
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FF6W0I(self)
  FF4IPF(self["config"])
  FF2GM8(self, self["config"])
  FFWgBS(self)
  self["config"].onSelectionChanged.append(self.VVmlpt)
  self.VVmlpt()
  FFZ0AC(self["keyRed"], "#11000000")
  self["keyRed"].show()
 def VVmlpt(self):
  cfg = self["config"].getCurrent()[1]
  if isinstance(cfg, ConfigDirectory) and cfg != CFG.subtDefaultEnc: txt = "Change Path"
  else                : txt = "Show Choices"
  self["keyRed"].setText("OK = %s" % txt)
 def VVPr1F(self):
  title, item = self["config"].getCurrent()
  if item:
   if   item == CFG.iptvHostsMode   : self.VV2dbz()
   elif item == CFG.MovieDownloadPath   : self.VVbZOL(item, self["config"].getCurrent()[0])
   elif item == CFG.subtDefaultEnc   : self.VVhA1A()
   elif isinstance(item, ConfigDirectory) : self.VVpWVN(item)
   else         : CCJaSw.VV5YpJ(self, item, title, width=1100)
 @staticmethod
 def VV5YpJ(SELF, confItem, title, lst=None, cbFnc=None, isSave=False, width=800):
  if not lst:
   if   isinstance(confItem, ConfigYesNo)  : lst = [(True, "ON"), (False, "OFF")]
   elif isinstance(confItem, ConfigSelectionNumber):
    lst = confItem.choices.choices
    if not isinstance(lst[0], tuple)  : lst = [(x, x) for x in lst]
   elif isinstance(confItem, ConfigSelection) : lst = confItem.choices.choices
   elif isinstance(confItem, ConfigInteger) : lst = [(x, str(x)) for x in range(confItem.limits[0][0], confItem.limits[0][1] + 1, 1)]
   else          : return
  curNdx = defNdx = -1
  VV3wat = []
  for ndx, item in enumerate(lst):
   if len(item) == 1:
    val, txt = ("dum",SEP)
   else:
    val, txt = item
    if   val == confItem.value : curNdx, txt = ndx, VVGCYL + txt
    elif val == confItem.default: defNdx, txt = ndx, VV1fx4 + txt
   VV3wat.append((txt, val))
  if defNdx == -1: defNdx = curNdx
  VVaTeF  = ("Current", BF(CCJaSw.VVdGKX, curNdx))
  VVB4pu = ("Default", BF(CCJaSw.VVdGKX, defNdx))
  VV7tND = FFLFTC(SELF, BF(CCJaSw.VVgdRW, confItem, cbFnc, isSave), VV3wat=VV3wat, width=width, VVB4pu=VVB4pu, VVaTeF=VVaTeF, title=title, VVwltY="#22221111", VVkxBG="#22110011", VVoCB2="#11550000")
  VV7tND.VVx2yy(curNdx)
 @staticmethod
 def VVgdRW(confItem, cbFnc, isSave, item=None):
  if not item == None:
   confItem.setValue(item)
   if isSave: FFjt1c(confItem, item)
   if cbFnc: cbFnc()
 @staticmethod
 def VVdGKX(ndx, selectionObj, item):
  selectionObj.VVx2yy(ndx)
 @staticmethod
 def VVFUB7(confItem, lst):
  for ndx, item in enumerate(lst):
   if item[0] == confItem.value:
    return ndx
  return -1
 def VVbZOL(self, item, title):
  tot = CCHRcZ.VVY2Xw()
  if tot : FFdw58(self, "Cannot change while downloading.", title=title)
  else : self.VVpWVN(item)
 def VVhA1A(self):
  curEnc = CFG.subtDefaultEnc.getValue()
  lst = CC7ocD.VVZyMn(self, "", curEnc)
  if lst:
   VVB4pu = ("Default", self.VVyHwq)
   VVaTeF  = ("Current", self.VVgGob)
   VV7tND = FFLFTC(self, self.VVN3C2, title="Select Priority Encoding", VV3wat=lst, width=1000, height=1000, VVaTeF=VVaTeF, VVB4pu=VVB4pu, VVwltY="#22220000", VVkxBG="#22220000", VVU8mZ=True)
   VV7tND.VVVZJD(curEnc)
 def VVN3C2(self, item=None):
  if item:
   txt, enc, ndx = item
   CFG.subtDefaultEnc.setValue(enc)
 def VVyHwq(self, VV7tND, item): VV7tND.VVVZJD(VV9iuh)
 def VVgGob(self, VV7tND, item): VV7tND.VVVZJD(CFG.subtDefaultEnc.getValue())
 def VV2dbz(self):
  VV3wat = []
  VV3wat.append(("Auto Find" , "auto"))
  VV3wat.append(("Custom Path" , "cust"))
  FFLFTC(self, self.VVFyRH, VV3wat=VV3wat, title="IPTV Hosts Files Path")
 def VVFyRH(self, item=None):
  if item:
   if item == "auto":
    CFG.iptvHostsMode.setValue(VVSBbs)
   elif item == "cust":
    VVAkuK = self.VVCBk1()
    if VVAkuK : self.VVU2OV(VVAkuK)
    else  : self.session.openWithCallback(self.VVtsPG, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK="/"))
 def VVU2OV(self, VVAkuK):
  VVu8qI = self.VVDwcU
  VVwWmA = ("Remove"  , self.VVE7KC , [])
  VVScQz = ("Add "  , self.VV2ql5, [])
  header   = ("Directory" , "Remarks" )
  widths   = (80   , 20  )
  VVLIqP  = (LEFT   , LEFT  )
  FFUQ0v(self, None, title="IPTV Hosts Search Paths", header=header, VVGape=VVAkuK, width=1200, height=700, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=26, VVu8qI=VVu8qI, VVwWmA=VVwWmA, VVScQz=VVScQz
    , VVwltY="#22220000", VVkxBG="#22110000", VVemyB="#22110011", VVJKqd="#11223025", VVbcr0="#0a333333", VVX9AA="#11400040")
 def VVDwcU(self, VV6A99):
  if CFG.iptvHostsDirs.getValue():
   CFG.iptvHostsMode.setValue(VVoeMl)
  VV6A99.cancel()
 def VVtsPG(self, path):
  if path:
   FFjt1c(CFG.iptvHostsDirs, FFoWxR(path.strip()))
   VVAkuK = self.VVCBk1()
   if VVAkuK : self.VVU2OV(VVAkuK)
   else  : FF28n1(self, "Cannot add dir", 1500)
 def VVnmPl(self):
  lst = CFG.iptvHostsDirs.getValue().split(",")
  lst = list(set(list(map(str.strip, lst))))
  if len(lst) == 0 or len(lst[0]) == 0 or lst[0] == VVSBbs:
   return []
  return lst
 def VVCBk1(self):
  lst = self.VVnmPl()
  if lst:
   VVAkuK = []
   for Dir in lst:
    VVAkuK.append((Dir, "#f#0000ff00#Dir exists" if VVmJwX(Dir) else "#f#00ffa000#Not found"))
   VVAkuK.sort(key=lambda x: x[0].lower())
   return VVAkuK
  else:
   return []
 def VV2ql5(self, VV6A99, title, txt, colList):
  sDir = parent = os.path.abspath(os.path.join(colList[0], os.pardir))
  self.session.openWithCallback(BF(self.VVXVbD, VV6A99)
         , BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=sDir))
 def VVXVbD(self, VV6A99, path):
  if path:
   path = FFoWxR(path.strip())
   if self.VVO7zz(VV6A99, path):
    FF28n1(VV6A99, "Already added", 1500)
   else:
    lst = self.VVnmPl()
    lst.append(path)
    FFjt1c(CFG.iptvHostsDirs, ",".join(lst))
    VVAkuK = self.VVCBk1()
    VV6A99.VVMqQ9(VVAkuK, VVDpzd=BF(self.VV6ZuM, path))
 def VV6ZuM(self, path, VV6A99, title, txt, colList):
  self.VVO7zz(VV6A99, path)
 def VVO7zz(self, VV6A99, path):
  for ndx, row in enumerate(VV6A99.VVrrm9()):
   if row[0].strip() == path.strip():
    VV6A99.VVrqBw(ndx)
    return True
  return False
 def VVE7KC(self, VV6A99, title, txt, colList):
  path = colList[0]
  FFRMYv(self, BF(self.VVUWxc, VV6A99), "Remove this path from list?\n\n%s" % path, title="Remove path from list")
 def VVUWxc(self, VV6A99):
  row = VV6A99.VV5crm()
  path, rem = row[0], row[1]
  VVAkuK = []
  lst = []
  for ndx, row in enumerate(VV6A99.VVrrm9()):
   tPath, tRem = row[0].strip(), row[1].strip()
   if not path == tPath:
    lst.append(tPath)
    VVAkuK.append((tPath, tRem))
  if len(VVAkuK) > 0:
   FFjt1c(CFG.iptvHostsDirs, ",".join(lst))
   VV6A99.VVMqQ9(VVAkuK)
   FF28n1(VV6A99, "Deleted", 1500)
  else:
   FFjt1c(CFG.iptvHostsMode, VVSBbs)
   FFjt1c(CFG.iptvHostsDirs, "")
   VV6A99.cancel()
   FFIElK(BF(FF28n1, self, "Changed to Auto-Find", 1500))
 def VVpWVN(self, configObj):
  sDir = configObj.getValue()
  self.session.openWithCallback(BF(self.VVNRVS, configObj)
         , BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=sDir))
 def VVNRVS(self, configObj, path):
  if len(path) > 0:
   configObj.setValue(path)
 def VVMrMS(self):
  for x in self["config"].list:
   if len(x) == 2 and FFI3NO(x[1]):
    FFRMYv(self, self.VVTUim, "Save Changes ?", callBack_No=self.cancel, title=self.Title)
    break
  else:
   self.cancel()
 def VVTUim(self):
  for x in self["config"].list:
   if len(x) == 2 and FFI3NO(x[1]):
    x[1].save()
  self.VV62UD()
  self.close()
 def cancel(self):
  for x in self["config"].list:
   try:
    x[1].cancel()
   except:
    pass
  self.close()
 def VVhAm1(self):
  c1, c2, c3 = VVz22H, VVJEMb, VVFuwR
  VV3wat = []
  VV3wat.append(("Change Text Color Scheme (fix Transparent Text)", "changeColorScheme" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c1 + "Reset %s Settings" % VVh9hj, "VVUISm"))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Backup %s Settings" % VVh9hj , "VV7sMA"))
  VV3wat.append((c2 + "Restore %s Settings" % VVh9hj, "VV0J44"))
  VV3wat.append(VVAL3j)
  if CFG.checkForUpdateAtStartup.getValue() : txt, ref = "Disable", "disableChkUpdate"
  else          : txt, ref = "Enable", "enableChkUpdate"
  VV3wat.append((c3 + '%s Checking for Update' % txt, ref    ))
  VV3wat.append((c3 + "Reinstall %s" % VVh9hj , "VVf1nm" ))
  VV3wat.append((c3 + "Update %s" % VVh9hj  , "VViYWX"  ))
  FFLFTC(self, self.VVBIPF, VV3wat=VV3wat, title="Config. Options")
 def VVBIPF(self, item=None):
  if item:
   title = "%s Settings" % VVh9hj
   if  item == "changeColorScheme": self.session.open(CCuTnL)
   elif item == "VVUISm"  : FFRMYv(self, BF(self.VVUISm, True), "Clear all settings (including File Manager bookmarks) ?", title=title)
   elif item == "VV7sMA" : self.VV7sMA()
   elif item == "VV0J44" : self.VV0J44()
   elif item == "enableChkUpdate" : FFjt1c(CFG.checkForUpdateAtStartup, True)
   elif item == "disableChkUpdate" : FFjt1c(CFG.checkForUpdateAtStartup, False)
   elif item == "VVf1nm" : self.VV6QXl(True )
   elif item == "VViYWX"  : self.VV6QXl(False)
 def VV7sMA(self):
  path = "%sajpanel_settings_%s" % (FF0cqc(), FFjTQe())
  FF7ymp("grep .%s. %s > %s" % (VVh9hj, VVfBVj, path))
  FFipXT(self, "Saved to file:\n\n%s" % path, title="Export %s Settings" % VVh9hj)
 @FFOAKH("Searching for Settings ...")
 def VV0J44(self):
  title = "Import %s Settings" % VVh9hj
  name  = "ajpanel_settings_"
  files = FF3xOt("find / %s -iname '%s*' | grep %s" % (FF5W9s(1), name, name))
  if files:
   err = CClYaF.VV8isu(files)
   if err:
    FFRMYv(self, BF(self.VVU3uB, title), "No valid settings files found !\n\nLocate Manually ?", title=title)
   else:
    try:
     files = sorted(files, key=lambda t: -os.stat(t).st_mtime)
    except Exception as e:
     FFdw58(self, "Error:\n\n%s" % str(e), title=title)
     return
    VV3wat = []
    for line in files:
     VV3wat.append((line, line))
    FFLFTC(self, BF(self.VV6Pjm, title), title=title, VV3wat=VV3wat, width=1200, VVtboQ="")
  else:
   FFdw58(self, "No settings files found !", title=title)
 def VVU3uB(self, title, path=None):
  sDir = "/"
  for path in (FF0cqc(), "/media/usb/", "/media/hdd/", "/media/"):
   if VVmJwX(path):
    sDir = path
    break
  self.session.openWithCallback(BF(self.VV6Pjm, title), BF(CClYaF, VV1gDA="ajpSet", VV1pbK=sDir))
 def VV6Pjm(self, title, path=None):
  if path:
   if VVmJwX(path):
    lines  = FFL19l(path)
    self.VVUISm()
    for line in lines:
     name, _, val = line.partition("=")
     try:
      confItem = eval(name)
      if confItem is not None:
       if   isinstance(confItem, ConfigInteger)  : val = int(val)
       elif isinstance(confItem, ConfigSelectionNumber): val = int(val)
       elif isinstance(confItem, ConfigYesNo)   : val = { "true": True, "false": False }.get(val.lower())
       if not val is None:
        confItem.setValue(val)
        confItem.save()
     except:
      pass
    FFzcnD(self)
    self.VV62UD()
    FF1mVE(self, "Done", 1500)
   else:
    FF8Wsn(self, path, title=title)
 def VVUISm(self, exit=False):
  for (key, cfg) in CFG.content.items.items():
   cfg.setValue(cfg.default)
  for x in self["config"].list:
   try:
    x[1].save()
   except:
    pass
  FFzcnD()
  self.VV62UD()
  if exit:
   self.close()
 def VV62UD(self):
  configfile.save()
  self.VVUF0w(CFG.showInExtensionMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EXTENSIONSMENU), [FFsfSz(), FFttL1(), FF2aef(), FFQRKB(), FFT9Fx(), FFYbQt(), FFpUEE(), FF2V0Y()])
  self.VVUF0w(CFG.EventsInfoMenu.getValue(), iPlugins.getPlugins(PluginDescriptor.WHERE_EVENTINFO), [ FFxu4x() ])
 @staticmethod
 def VVUF0w(setVal, pluginList, dList):
  try:
   if setVal:
    for item in dList:
     if not item in pluginList:
      iPlugins.addPlugin(item)
   else:
    for item in dList:
     if item in pluginList:
      iPlugins.removePlugin(item)
  except:
   pass
  FF2Wqb()
 @FFOAKH("Checking Server ...")
 def VV6QXl(self, force):
  title = "%s %s (from server)" % ("Reinstall" if force else "Update", VVh9hj)
  curVer, webVer, url, isHigher, err = CCJaSw.VVq06s()
  if   err    : FFdw58(self, err, title)
  elif isHigher or force : FFRMYv(self, BF(self.VVkpNq, webVer, url, title, force), "%s v%s and Restart ?" % ("Reinstall" if force else "Upgrade to", webVer), title=title)
  else     : FFipXT(self, FFjt5L("No update required.", VVSGsk) + "\n\nCurrent Version = v%s\n\nWeb Version = v%s" % (curVer, webVer), title)
 @FFOAKH()
 def VVkpNq(self, webVer, url, title, force):
  fName = "enigma2-plugin-extensions-ajpanel_v%s_all_no_restart.%s" % (webVer, "deb" if FFgrjX() else "ipk")
  path, err = FFx9uM(url + fName, fName, timeout=2)
  if path:
   if force: cmd = FF5sZa(VVj9MD, path)
   else : cmd = FF5sZa(VVD9EU, path)
   if cmd:
    cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'; rm -rf '%s'" % (cmd, path)
    FFbi5l(self, cmd, title=title, VVtByE=self.VVgC9w)
   else:
    FFfone(self, title=title)
  else:
   FFdw58(self, err, title=title)
 def VVgC9w(self, consObj):
  txt = "SUCCESSFUL"
  if txt in consObj.VV6VWc():
   FFDuEn(consObj)
   consObj.VV2pQl(consObj.VV6VWc().replace(txt, FFjt5L(txt, VVSGsk)))
   FF28n1(consObj, "Restarting ...")
   FFOKt0(self, 3000, BF(CCp90q.VV6bHp, self))
 @staticmethod
 def VVq06s():
  url = CCJaSw.VVYs9i()
  curVer = VVJ6zn
  path, err = FFx9uM(url + "version", "ajp_tmp.ver", timeout=2)
  if err or not FFCyVu(path):
   return curVer, "", url, False, "Cannot get version file from server."
  else:
   webVer = FFYVq0(path)
   FFwgGB(path)
   cVer, wVer, isHigher = CCeSkW.VV2PRQ(curVer, webVer)
   return cVer, wVer, url, isHigher, ""
 @staticmethod
 def VVCcoN(): return "https://github.com/AMAJamry/AJPanel"
 @staticmethod
 def VVYs9i(): return "https://raw.githubusercontent.com/AMAJamry/AJPanel/main/"
class CCuTnL(Screen):
 def __init__(self, session):
  self.skin, self.VVfOli = FFiNEe(VVnUU2, 1200, 620, 50, 20, 0, "#22002020", "#22001122", 30)
  self.cursorPos = VVHByN
  self.Title  = "Select Color Scheme (for areas with mixed-color text)"
  self.session = session
  FFZMxC(self, title=self.Title)
  sp = "    "
  self["myColorF"] = Label()
  for i in range(4):
   txt = "\n"
   txt += self.VV5iNL(r"\c00FFFFFF", i) + sp + "WHITE\n"
   txt += self.VV5iNL(r"\c00888888", i) + sp + "GREY\n"
   txt += self.VV5iNL(r"\c005A5A5A", i) + sp + "DARK GREY\n"
   txt += self.VV5iNL(r"\c00FF0000", i) + sp + "RED\n"
   txt += self.VV5iNL(r"\c00FF5000", i) + sp + "ORANGE\n"
   txt += self.VV5iNL(r"\c00FFFF00", i) + sp + "YELLOW\n"
   txt += self.VV5iNL(r"\c00FFFFAA", i) + sp + "B. YELLOW\n"
   txt += self.VV5iNL(r"\c0000FF00", i) + sp + "GREEN\n"
   txt += self.VV5iNL(r"\c000066FF", i) + sp + "BLUE\n"
   txt += self.VV5iNL(r"\c0000FFFF", i) + sp + "CYAN\n"
   txt += self.VV5iNL(r"\c00FA55E7", i) + sp + "PURPLE\n"
   txt += self.VV5iNL(r"\c00FF8F5F", i) + sp + "PEACH\n"
   self["myColor%s" % i] = Label(txt)
  FFHlAU(self,
  {
   "ok" : self.VVPr1F ,
   "green" : self.VVPr1F ,
   "left" : self.VVziFC ,
   "right" : self.VVLe1s ,
   "cancel": self.close
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.VVvOga()
 def VVPr1F(self):
  if self.cursorPos == 0 : txt = "No Colors"
  else     : txt = "Color Scheme-%d" % self.cursorPos
  FFRMYv(self, self.VVnh6o, "Change to : %s" % txt, title=self.Title)
 def VVnh6o(self):
  FFjt1c(CFG.mixedColorScheme, self.cursorPos)
  global VVHByN
  VVHByN = self.cursorPos
  self.VVHizC()
  self.close()
 def VVziFC(self):
  self.cursorPos -= 1
  if self.cursorPos < 0:
   self.cursorPos = 3
  self.VVvOga()
 def VVLe1s(self):
  self.cursorPos += 1
  if self.cursorPos > 3:
   self.cursorPos = 0
  self.VVvOga()
 def VVvOga(self):
  left = []
  for i in range(4):
   left.append(self["myColor%s" % i].getPosition()[0])
  left = left[self.cursorPos] - 4
  top = self["myColor0"].getPosition()[1] - 4
  self.cursorPos
  self["myColorF"].instance.move(ePoint(left, top))
 @staticmethod
 def VV5iNL(color, mode):
  if   mode == 1 : return color
  elif mode == 2 : return color.replace("A", "9").replace("B", "9").replace("C", "9").replace("D", "9").replace("E", "9").replace("F", "9")
  elif mode == 3 : return color.replace("A", ":").replace("B", ";").replace("C", "<").replace("D", "=").replace("E", ">").replace("F", "?")
  else   : return ""
 @staticmethod
 def VVsAua(color):
  if VV1fx4: return "\\" + color
  else    : return ""
 @staticmethod
 def VVHizC():
  global VVo7S9, VVA4XU, VVYjI5, VVyFI2, VVz22H, VVIH76, VV9nWG, VVMibI, VVSGsk, VVJEMb, VV1fx4, VVFuwR, VVGCYL, VVZtfx, VVcPtB, VVwdUw
  VVwdUw   = CCuTnL.VV5iNL(r"\c00FFFFFF", VVHByN)
  VVA4XU    = CCuTnL.VV5iNL(r"\c00888888", VVHByN)
  VVo7S9  = CCuTnL.VV5iNL(r"\c005A5A5A", VVHByN)
  VVMibI    = CCuTnL.VV5iNL(r"\c00FF0000", VVHByN)
  VVYjI5   = CCuTnL.VV5iNL(r"\c00FF5000", VVHByN)
  VVyFI2   = CCuTnL.VV5iNL(r"\c00FFBB66", VVHByN)
  VV1fx4   = CCuTnL.VV5iNL(r"\c00FFFF00", VVHByN)
  VVFuwR = CCuTnL.VV5iNL(r"\c00FFFFAA", VVHByN)
  VVSGsk   = CCuTnL.VV5iNL(r"\c0000FF00", VVHByN)
  VVJEMb  = CCuTnL.VV5iNL(r"\c00AAFFAA", VVHByN)
  VV9nWG    = CCuTnL.VV5iNL(r"\c000066FF", VVHByN)
  VVGCYL    = CCuTnL.VV5iNL(r"\c0000FFFF", VVHByN)
  VVZtfx  = CCuTnL.VV5iNL(r"\c00AAFFFF", VVHByN)  #
  VVcPtB   = CCuTnL.VV5iNL(r"\c00FA55E7", VVHByN)
  VVz22H    = CCuTnL.VV5iNL(r"\c00FF8F5F", VVHByN)
  VVIH76  = CCuTnL.VV5iNL(r"\c00FFC0C0", VVHByN)
CCuTnL.VVHizC()
class CCMvE7():
 VVkelS  = "666"
 VVZ6bs   = "888"
 def __init__(self, SELF, VVOhqh, title, VV00CZ, VVFjhV=""):
  self.SELF     = SELF
  self.VVOhqh   = VVOhqh
  self.Title     = title
  self.VV00CZ   = VV00CZ
  self.VVFjhV    = VVFjhV
  self.VV7tND   = None
  self.VVjO4U()
 def VVjO4U(self):
  VV3wat = CCMvE7.VVlHzq()
  bNames = [x[0] for x in VV3wat if len(x) == 2]
  if VV3wat:
   VVB4pu = ("Create New", BF(self.VVHgG8, bNames))
   self.VV7tND = FFLFTC(self.SELF, self.VV12l2, VV3wat=VV3wat, title=self.Title, VVB4pu=VVB4pu, VVU8mZ=True, VVwltY="#22222233", VVkxBG="#22222233")
  else:
   self.VVHgG8("")
 def VV12l2(self, item):
  if item:
   bName, bRef, ndx = item
   self.VVpiBp(bName, bRef)
  else:
   CCMvE7.VVw0of(self)
 def VVHgG8(self, bNames, selectionObj=None, item=None):
  name = self.VVFjhV
  if not name:
   name = "Bouquet1"
   c = 1
   while name in bNames:
    c += 1
    name = "Bouquet%s" % c
  FF4z45(self.SELF, BF(self.VVR10D), defaultText=name, title="Create New Bouquet", message="Enter Bouquet Name:")
 def VVR10D(self, bName):
  if bName:
   bName = bName.strip()
   if bName:
    if self.VV7tND:
     self.VV7tND.cancel()
    self.VVpiBp(bName, "")
   else:
    FF28n1(self.VV7tND, "Incorrect Bouquet Name !", 2000)
    CCMvE7.VVw0of(self)
 def VVpiBp(self, bName, bRef):
  FFimQ3(self.VVOhqh, BF(self.VVKzWp, bName, bRef), title="Adding Services ...")
 def VVKzWp(self, bName, bRef):
  CCMvE7.VVPJK0(self.SELF, self.Title, bName, bRef, self.VV00CZ())
 @staticmethod
 def VVw0of(classObj):
  del classObj
 @staticmethod
 def VVPJK0(SELF, title, bName, bRef, servRefLst, showRes=True):
  if not servRefLst:
   FFdw58(SELF, "No services to add !", title=title)
   return
  tvBouquetFile = VVQe79 + "bouquets.tv"
  if not FFCyVu(tvBouquetFile):
   FF8Wsn(SELF, tvBouquetFile, title=title)
   return
  if bRef:
   bFile = CCMvE7.VV896q(bRef)
   bPath = VVQe79 + bFile
  else:
   fName = CCkEI5.VVPjQO(bName)
   bFile = "userbouquet.%s.tv" % fName
   bPath = VVQe79 + bFile
   num   = 0
   while FFCyVu(bPath):
    num += 1
    bFile = "userbouquet.%s_%d.tv" % (fName, num)
    bPath = VVQe79 + bFile
   with open(bPath, "w") as f:
    f.write("#NAME %s\n" % bName)
  FFJvhj(bPath)
  with open(bPath, "a") as f:
   for chUrl in servRefLst:
    serv = eServiceReference(chUrl)
    VV1wIO = serv and serv.getName() or ""
    try:
     VV1wIO = VV1wIO.encode("UTF-8", "replace").decode()
    except:
     VV1wIO = FFWEt2(VV1wIO, r"?")
    f.write("#SERVICE %s\n"  % chUrl)
    f.write("#DESCRIPTION %s\n" % VV1wIO)
  if not bRef and FFCyVu(bPath):
   FFJvhj(tvBouquetFile)
   with open(tvBouquetFile, "a") as f:
    f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
  totPicons = 0
  piconPath = CCafIt.VVjkKT()
  for chUrl in servRefLst:
   span = iSearch(r"((?:[A-Fa-f0-9]+:){10})", chUrl.rstrip(":"))
   if span:
    serv = eServiceReference(chUrl)
    if serv:
     picon = piconPath + span.group(1).strip(":").replace(":", "_").upper() + ".png"
     fPath = serv.getPath()
     fNameNoExt = os.path.splitext(serv.getPath())[0]
     for ext in ("png", "jpg", "bmp", "gif", "jpe", "jpeg"):
      poster = "%s.%s" % (fNameNoExt, ext)
      if FFCyVu(poster):
       totPicons += 1
       FFpwZS("cp -f '%s' '%s'" % (poster, picon))
       FFpwZS(CCvjVs.VVQ9GP(picon))
       break
  FFfpyJ()
  if showRes:
   txt  = "Bouquet Name\t\t: %s\n"  % bName
   txt += "Added Services\t\t: %d\n" % len(servRefLst)
   if totPicons:
    txt += "Added PIcons\t\t: %s" % totPicons
   FF4lCP(SELF, txt, title=title)
 @staticmethod
 def VVCROO(bName):
  mode = CCLSIv.VVK7hm(default=-1)
  modeTxt = "tv" if mode == 0 else "radio"
  fName = CCkEI5.VVPjQO(bName)
  bFile = "userbouquet.%s.%s" % (fName, modeTxt)
  num   = 0
  while FFCyVu(VVQe79 + bFile):
   num += 1
   bFile = "userbouquet.%s_%d.%s" % (fName, num, modeTxt)
  with open(VVQe79 + bFile, "w") as f:
   f.write("#NAME %s\n" % bName)
  mainBFile = "%sbouquets.%s" % (VVQe79, modeTxt)
  if FFCyVu(mainBFile):
   FFJvhj(mainBFile)
   with open(mainBFile, "a") as f:
    f.write('#SERVICE 1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet\n' % bFile)
 @staticmethod
 def VV3r6m(ref, bName):
  bFile = CCMvE7.VV896q(ref)
  ok = False
  if bFile:
   bFile = VVQe79 + bFile
   if FFCyVu(bFile):
    lines = FFL19l(bFile, keepends=True)
    with open(bFile, "w") as f:
     for line in lines:
      if line.startswith("#NAME "):
       f.write("#NAME %s\n" % bName)
       ok = True
      else:
       f.write(line)
  return ok
 @staticmethod
 def VVlHzq(mode=2, showTitle=True, prefix="", onlyIptv=False):
  VV3wat = []
  if mode in (0, 2): VV3wat.extend(CCMvE7.VVYHtq(0, showTitle, prefix, onlyIptv))
  if mode in (1, 2): VV3wat.extend(CCMvE7.VVYHtq(1, showTitle, prefix, onlyIptv))
  return VV3wat
 @staticmethod
 def VVYHtq(mode, showTitle, prefix, onlyIptv):
  VV3wat = []
  lst = CCMvE7.VV161E(mode)
  if onlyIptv:
   lst = CCMvE7.VVHwDB(lst)
  if lst:
   if showTitle:
    VV3wat.append(FF0bQE("TV Bouquets" if mode == 0 else "Radio Bouquets"))
   if prefix:
    for item in lst : VV3wat.append((item[0], prefix + item[0]))
   else:
    for item in lst : VV3wat.append((item[0], item[1].toString()))
  return VV3wat
 @staticmethod
 def VVHwDB(lst):
  fLst = CCkEI5.VVjMS6(onlyFileName=True)
  newLst = []
  if fLst:
   for item in lst:
    span = iSearch(r".+(userbouquet\..+\.(tv|radio))", item[1].toString())
    if span and span.group(1) in fLst:
     newLst.append(item)
  return newLst
 @staticmethod
 def VVnZ35():
  lst = CCMvE7.VV161E(0)
  lst.extend(CCMvE7.VV161E(1))
  return lst
 @staticmethod
 def VV161E(mode=0):
  bList = []
  VVCy6c = InfoBar.instance
  VVFp6v = VVCy6c and VVCy6c.servicelist
  if VVFp6v:
   curMode = VVFp6v.mode
   CCMvE7.VVJqMl(VVFp6v, mode)
   bList.extend(VVFp6v.getBouquetList() or [])
   CCMvE7.VVJqMl(VVFp6v, curMode)
  return bList
 @staticmethod
 def VVJqMl(VVFp6v, mode):
  if not mode == VVFp6v.mode:
   if   mode == 0: VVFp6v.setModeTv()
   elif mode == 1: VVFp6v.setModeRadio()
 @staticmethod
 def VVBTuE(isAll=True, onlyMain=False):
  bLst = []
  inst = InfoBar.instance
  if inst:
   csel = inst.servicelist
   if csel:
    root = csel.bouquet_root
    VVX5XV = eServiceCenter.getInstance()
    if onlyMain:
     info = VVX5XV.info(root)
     if info:
      bLst.append((info.getName(root), root.toString()))
    else:
     list = VVX5XV and VVX5XV.list(root)
     if list:
      while True:
       s = list.getNext()
       if not s.valid():
        break
       if isAll or (s.flags & eServiceReference.isDirectory and not s.flags & eServiceReference.isInvisible):
        info = VVX5XV.info(s)
        if info:
         bLst.append((info.getName(s), s.toString()))
  return bLst
 @staticmethod
 def VVHtVA():
  lst = []
  types = ('*.*.tv', '*.*.radio')
  for f in types:
   lst.extend(iGlob(VVQe79 + f))
  return lst
 @staticmethod
 def VV896q(bRef):
  span = iSearch(r'BOUQUET\s+"(.+)"\s+ORDER', bRef, IGNORECASE)
  if span : return span.group(1)
  else : return ""
 @staticmethod
 def VVsEnx(ref, dstFile):
  dstFile = VVQe79 + dstFile
  if FFCyVu(dstFile):
   FFJvhj(dstFile)
   bLine = ""
   VVs2Wm = CCMvE7.VV896q(ref)
   if VVs2Wm:
    span = iSearch(r"\.(.+)\.(tv|radio)", VVs2Wm, IGNORECASE)
    if span:
     fName, fType = span.group(1), span.group(2)
     newName = "userSubBouquet.%s.%s" % (fName, fType)
     num = 0
     while FFCyVu(VVQe79 + newName):
      num += 1
      newName = "userSubBouquet.%s_%d.%s" % (fName, num, fType)
     subFile = VVQe79 + newName
     FFpwZS("cp -f '%s%s' '%s'" % (VVQe79, VVs2Wm, subFile))
     if FFCyVu(subFile):
      bLine = '1:7:1:0:0:0:0:0:0:0:FROM BOUQUET "%s" ORDER BY bouquet' % newName
   else:
    bLine = ref
   if bLine:
    if FFCyVu(dstFile):
     with open(dstFile, "a") as f:
      f.write("#SERVICE %s\n" % bLine)
     return True
  return False
 @staticmethod
 def VVvNtR():
  try:
   fName = CCMvE7.VV896q(InfoBar.instance.servicelist.getRoot().toString())
   path = "%s%s" % (VVQe79, fName)
   if FFCyVu(path):
    return path
  except:
   pass
  return ""
 @staticmethod
 def VVCWrE():
  path = CCMvE7.VVvNtR()
  if path:
   txt = FFYVq0(path, maxSize=300)
   span = iSearch(r"#NAME\s+(.*)", txt, IGNORECASE)
   if span:
    return span.group(1).strip()
  return ""
 @staticmethod
 def VVqZTI(mode=0):
  return FFZcDI(InfoBar.instance.servicelist.getRoot(), mode)
 @staticmethod
 def VVykzu():
  lst = []
  for b in CCMvE7.VVnZ35():
   bName = b[0]
   bRef  = b[1].toString()
   path = VVQe79 + CCMvE7.VV896q(bRef)
   if FFCyVu(path):
    lines = FFL19l(path)
    for line in lines:
     if line.startswith("#SERVICE"):
      if not line.startswith("#SERVICE 1:64:"):
       break
    else:
     if not "userbouquet.favourites." in bRef:
      lst.append((bName, bRef))
  return lst
 @staticmethod
 def VVAZ5l(SID, stripRType):
  if stripRType: return r"(?:[A-Fa-f0-9]+:)((?:[A-Fa-f0-9]+:){2}%s:(?:[A-Fa-f0-9]+:){6})" % SID
  else   : return r"((?:[A-Fa-f0-9]+:){3}%s:(?:[A-Fa-f0-9]+:){6})" % SID
 @staticmethod
 def VVc8iI(SID="", stripRType=False):
  if SID : patt = CCMvE7.VVAZ5l(SID, stripRType)
  else : patt = r"((?:[A-Fa-f0-9]+:){10})"
  lst = []
  for b in CCMvE7.VVnZ35():
   for service in FFZcDI(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append(span.group(1).upper())
  return lst
 @staticmethod
 def VVit2n():
  patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
  lst = []
  for b in CCMvE7.VVnZ35():
   for service in FFZcDI(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append(span.group(1).upper().rstrip(":"))
  return lst
 @staticmethod
 def VVIjNS():
  patt = r"((?:[A-Fa-f0-9]+:){10})http.+"
  lst = []
  for b in CCMvE7.VVnZ35():
   for service in FFZcDI(b[1]):
    span = iSearch(patt, service[0])
    if span:
     lst.append((span.group(1).upper().rstrip(":"), service[1]))
  return lst
 @staticmethod
 def VVIGWw(rType, SID, refLst, startId, startNS):
  for Id in range(max(6, startId), 65535):
   hexId = ("%1x" % Id).upper()
   for NS in range(startNS, 65535):
    hexNS = ("FFF%04x" % NS).upper()
    tRef = "0:1:%s:%s:%s:%s:0:0:0:" % (SID, hexId, hexId, hexNS)
    if not tRef in refLst:
     VVPxk5 = "%s:0:1:%s:%s:%s:%s:0:0:0:" % (rType, SID, hexId, hexId, hexNS)
     if NS < 65535 - 1: NS += 1
     else    : NS, Id = 6, Id + 1
     return VVPxk5, Id, NS
  return "", 0, 0
 @staticmethod
 def VVvoK9(pathLst, rType=""):
  refLst = CCMvE7.VVc8iI(CCMvE7.VVkelS, stripRType=True)
  chUrlLst = []
  startId  = startNS = 0
  rType  = rType or CFG.iptvAddToBouquetRefType.getValue()
  for path in pathLst:
   VVPxk5, startId, startNS = CCMvE7.VVIGWw(rType, CCMvE7.VVkelS, refLst, startId, startNS)
   if VVPxk5:
    VV1wIO = os.path.splitext(os.path.basename(path))[0].replace("-", " ").replace("_", " ").replace(".", " ")
    chUrl = "%s%s:%s" % (VVPxk5, path, VV1wIO)
    chUrlLst.append(chUrl)
   else:
    break
  return chUrlLst
class CClYaF(Screen, CCLAzj):
 VV4Ihm   = 0
 VVQTL1  = 1
 VV9N82  = 2
 VVkJTs = 3
 VVR977  = 4
 VVufQt    = 20
 VVoPwh   = 0
 VVFST7   = 1
 VVoQmo   = 2
 def __init__(self, session, VV1pbK="/", mode=VV4Ihm, VVqlNR="Select", width=1400, height=920, VVwdmN=30, VVwltY="#22001111", VVkxBG="#22000000", pickTitleBG="#11001144", pickBodyBG="#08002244", VVoCB2="#06004444", VVAHYe=False, VVHYTc="", VV1gDA="", VVIC7J=False):
  self.skin, self.VVfOli = FFiNEe(VVWp3I, width, height, 30, 40, 20, VVwltY, VVkxBG, VVwdmN, VVeFSs=40, VV0Ay7=2, VVdrEC=(0, 0))
  self.session   = session
  self.VVwltY   = VVwltY
  self.VVkxBG    = VVkxBG
  self.pickTitleBG  = pickTitleBG
  self.pickBodyBG   = pickBodyBG
  FFZMxC(self)
  FFRLNq(self["keyRed"] , "Exit")
  FFRLNq(self["keyYellow"], "More Options")
  FFRLNq(self["keyBlue"] , "Bookmarks")
  CCLAzj.__init__(self, gapX=10, gapY=10)
  self.VVJcJg  = 1000
  self.mode    = mode
  self.VVqlNR = VVqlNR
  self.VVHYTc   = VVHYTc
  self.VV1gDA  = VV1gDA
  self.VVAHYe   = VVAHYe
  self.VVpP2Y  = None
  self.VVsw6F   = 300
  self.VVoCB2   = VVoCB2
  self.VVJuPG = False
  self.VVIC7J   = VVIC7J
  self.lastViewedPic  = ""
  VV2mDa = None
  if VV1gDA:
   self.mode = self.VVkJTs
   if   VV1gDA == "srt"  : VV2mDa = (r"^.*\.srt$"    , IGNORECASE)
   elif VV1gDA == "ajpSet" : VV2mDa = (r"^.*\/ajpanel_settings_" , 0    )
   elif VV1gDA == "poster" : VV2mDa = (r"^.*\.(jpg|png)$"    , IGNORECASE)
   elif VV1gDA == "pkgCtrl": VV2mDa = (r"^.*\/(control|preinst|prerm|postinst|postrm)$", 0)
   elif VV1gDA == "movies" : VV2mDa = (r"^.*\.(%s)$" % "|".join(CCHmnm.VViatp()["mov"]), IGNORECASE)
   elif VV1gDA == "custMnu": VV2mDa = (r"^.*\/ajpanel_menu.*\.xml$", 0)
   else       : VV2mDa = None
  if self.VVbA0M():
   FFRLNq(self["keyRed"], "Cancel")
  if   self.VVHYTc       : VV1aG0, self.VV1pbK = True , FFx9pN(self.VVHYTc, True) or "/"
  elif self.VVAHYe        : VV1aG0, self.VV1pbK = True , CClYaF.VV4zSS(self)[1] or "/"
  elif self.mode == self.VV4Ihm  : VV1aG0, self.VV1pbK = True , CFG.browserStartPath.getValue()
  elif self.mode == self.VV9N82 : VV1aG0, self.VV1pbK = False, VV1pbK
  elif self.mode == self.VVkJTs : VV1aG0, self.VV1pbK = True , VV1pbK
  elif self.mode == self.VVR977 : VV1aG0, self.VV1pbK = True , VV1pbK
  else           : VV1aG0, self.VV1pbK = True , VV1pbK
  self.VV1pbK = FFoWxR(self.VV1pbK)
  self["myMenu"] = CCHmnm(  directory   = None
         , VV2mDa = VV2mDa
         , VV1aG0   = VV1aG0
         , VVodaQ = True
         , enableWrapAround = True
         , VVVljT   = self.VVfOli["width"]
         , VVwdmN   = self.VVfOli["VVgbF2"]
         , VV8c7y  = self.VVfOli["bodyLineH"] )
  FFHlAU(self,
  {
   "ok"  : self.VVPr1F    ,
   "red"  : self.VVih5U   ,
   "green"  : self.VVzToM  ,
   "yellow" : self.VV8SuT  ,
   "blue"  : self.VVwrew ,
   "menu"  : self.VVrEFW  ,
   "info"  : self.VVRg33  ,
   "cancel" : self.VV59x5    ,
   "fav"  : self.VVkOZB,
   "back"  : self.VV0CD0   ,
   "pageUp" : self.VV0CD0   ,
   "chanUp" : self.VV0CD0   ,
   "pageDown" : self.VV3ycX  ,
   "chanDown" : self.VV3ycX  ,
   "last"  : self.VVE9rg   ,
   "next"  : self.VVMjPT
  })
  CCKg9B(self, self["myMenu"])
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.onExit)
  self["myMenu"].onSelectionChanged.append(self.VVHrZx)
  global VVyg7B
  VVyg7B = True
 def onExit(self):
  self["myMenu"].onSelectionChanged = []
  if self.mode == self.VV4Ihm:
   FFYDZ6("VVyg7B")
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  self.onShown.append(self.VVHrZx)
  FF6W0I(self)
  FF4IPF(self["myMenu"], bg=self.VVoCB2)
  FFWgBS(self)
  self.VVJcJg = self["keyInfo"].getPosition()[0] - 40
  if self.VVbA0M():
   FFRLNq(self["keyGreen"], self.VVqlNR)
   self.VVT9IH(self.VVFST7)
  self.VVHrZx()
  w  = self["myMenu"].instance.size().width()
  h  = self["myMenu"].instance.size().height()
  pos  = self["myMenu"].getPosition()
  part = self["myMenu"].instance.size().height() % self.VVfOli["bodyLineH"]
  half = int(part / 2)
  self["myMenu"].instance.resize(eSize(*(w, h - part)))
  self["myMenu"].instance.move(ePoint(pos[0], pos[1] + half))
  if self.VVqBVd(self.VV1pbK) > self.VVsw6F: FFimQ3(self, self.VV7ESp, title="Changing directory...")
  else              : self.VV7ESp()
 def VV7ESp(self):
  if self.VVHYTc : self.VVPeow(FFoWxR(self.VVHYTc) if os.path.isdir(self.VVHYTc) else self.VVHYTc)
  elif self.VVAHYe : self.VV64Kx(chDir=False)
  else    : self["myMenu"].VVf5s1(self.VV1pbK)
 def VVbA0M(self):
  return self.mode in (self.VV9N82, self.VVkJTs, self.VVR977)
 def VVrqBw(self, rowNdx):
  self["myMenu"].moveToIndex(rowNdx)
 @FFOAKH("Refreshing list ...")
 def VVcPTN(self, moveTo=""):
  isSel = self["myMenu"].VVs0ks()
  if not isSel: self.VVdcm6(False)
  if moveTo: self.VVWh2y(moveTo)
  FF2Wqb()
 def VVFGYD(self, saved):
  if saved: self.VVcPTN()
 def VVqBVd(self, path):
  try:
   return len(os.listdir(path))
  except:
   return 0
 def VVPr1F(self, isUp=False):
  if self.VVJuPG:
   if self.mode == self.VVkJTs and os.path.isdir(self.VV5pAO(self.VVQlTC())):
    FF28n1(self, "Files only", 500)
   elif self["myMenu"].VVRH7p(isUp):
    self.VVoBrJ()
   else:
    FF28n1(self, "Cannot select item", 500)
  elif self["myMenu"].VV2bmH(): self.VVn2Lq()
  else       : self.VVSrgT()
 def VV0CD0(self):
  if self.VVJuPG:
   self.VVPr1F(isUp=True)
  else:
   self["myMenu"].moveToIndex(0)
   if self["myMenu"].VVe2l0():
    self.VVn2Lq()
 def VV3ycX(self):
  if self.VVJuPG:
   self.VVPr1F(isUp=False)
  elif self["myMenu"].VV2bmH() and self["myMenu"].getSelectionIndex() > 0:
   self.VVn2Lq()
 def VVE9rg(self) : self["myMenu"].moveToIndex(0)
 def VVMjPT(self) : self["myMenu"].moveToIndex(len(self["myMenu"].list) - 1)
 def VVn2Lq(self, isDirUp=False):
  if self["myMenu"].VV2bmH():
   if not self["myMenu"].getSelection() is None: path = self["myMenu"].getSelection()[0]
   else          : path = self.VV5pAO(self.VVQlTC())
   if self.VVqBVd(path) > self.VVsw6F : FFimQ3(self, self.VVVknA, title="Changing directory...")
   else           : self.VVVknA()
 def VVVknA(self):
  self["myMenu"].descent()
  self.VVHrZx()
 def VV59x5(self):
  if   self.VVJuPG     : self.VVdcm6(False, True)
  elif CFG.FileManagerExit.getValue() == "e" : self.VVih5U()
  else          : self.VV0CD0()
 def VVih5U(self):
  if FFmZaT(self): reutrn
  if VV8oe7:
   FFDuEn(self)
   FFjADj(self, "Closing ...")
   FFOKt0(self, 1000, self.close)
  else:
   self.close("")
 def VVk14D(self):
  FFw2rR(self, "_help_fman", "File Manager (Keys)")
 def VVzToM(self):
  if self["keyGreen"].getVisible():
   if self.VVIC7J and self.VVJuPG:
    lst = []
    path = self["myMenu"].VVWyCw()
    for row in self["myMenu"].list:
     if row[2][6]:
      lst.append(os.path.join(path, row[0][0]))
    if lst : self.close(lst)
    else : FF28n1(self, "Nothing selected", 500)
   else:
    path = self.VV5pAO(self.VVQlTC())
    isDir = os.path.isdir(path)
    chkFile = False
    if   self.mode == self.VV9N82 : self.close(path)
    elif self.mode == self.VVkJTs : chkFile = True
    elif self.mode == self.VVR977 :
     if isDir: self.close(path)
     else : chkFile = True
    if chkFile:
     if os.path.isfile(path) : self.close(path)
     else     : FF28n1(self, "Cannot access this file", 1000)
 @FFOAKH("Calculating size ...")
 def VVRg33(self):
  path = self.VV5pAO(self.VVQlTC())
  param = self.VViUa8(path)
  if not param:
   FFdw58(self, "Cannot access information !")
   return
  def VVVuRT(key, val, color=""):
   lineTxt = "%s\t: %s\n" % (key, str(val))
   return FFjt5L(lineTxt, color) if color else lineTxt
  c1, c2, c3, c4, c5 = VVIH76, VVFuwR, VVJEMb, VVwdUw, VVZtfx
  path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles = param
  mnt_fs = mnt_typ = ""
  contents = totSize = usedSize = freeSize = availSize = ""
  if typeChar == "d":
   exclude = r"-type d \( -ipath '/media' -o -ipath '/mnt' -o -ipath '*boot*' -o -ipath '*/ba' \) -prune -o"
   result = FFTKR0("totDirs=$(find '%s' %s -type d -print | wc -l); totFiles=$(find '%s' %s ! -type d | wc -l); echo $totDirs','$totFiles" % (path, exclude, path, exclude))
   if iMatch("^[0-9]*,[0-9]*", result):
    parts = result.split(",")
    contents += VVVuRT("Directories" , format(int(parts[0]), ',d'), c4)
    contents += VVVuRT("Files"   , format(int(parts[1]), ',d'), c4)
   if os.path.ismount(path):
    inf = CClYaF.VVR33x().get(FFoWxR(os.path.realpath(path)), "")
    if inf:
     mnt_fs, mnt_typ, isNet = inf
    typeStr += " (Mount)"
    total, used, free, avail, err = CClYaF.VVdlF7(path)
    totSize, usedSize, freeSize, availSize = [CClYaF.VV99gM(x) for x in (total, used, free, avail)]
   else:
    usedSize = CClYaF.VV99gM(FF4oMa(path))
  else:
   usedSize = CClYaF.VV99gM(size)
  if len(path) < 58 : pathTxt = path
  else    : pathTxt = "\n" + path
  pathTxt = pathTxt+ "\n"
  if slBroken : fileTime = self.VVnGz0(path)
  else  : fileTime = self.VV84uw(path)
  txt = ""
  txt += VVVuRT("Path"    , pathTxt, c1)
  txt += VVVuRT("Type"    , typeStr, c2)
  if mnt_fs and mnt_typ:
   txt += VVVuRT("Files System" , mnt_fs, c2)
   txt += VVVuRT("VFS Type"  , mnt_typ, c2)
  if len(slTarget) > 0:
   txt += VVVuRT("Target"   , slTarget)
  if os.path.ismount(path):
   txt += VVVuRT("Total Size"  , "%s" % totSize, c3)
   txt += VVVuRT("Used Size"  , "%s" % usedSize, c3)
   txt += VVVuRT("Free Size"  , "%s" % freeSize, c3)
   if free != avail: txt += VVVuRT("Available Size" , "%s" % availSize, c3)
  else:
   txt += VVVuRT("Size"   , "%s" % usedSize, c3)
  txt += contents
  txt += "\n"
  txt += VVVuRT("Owner"    , owner, c5)
  txt += VVVuRT("Group"    , group, c5)
  txt += VVVuRT("Perm. (User)"  , permUser, c5)
  txt += VVVuRT("Perm. (Group)"  , permGroup, c5)
  txt += VVVuRT("Perm. (Other)"  , permOther, c5)
  if len(permExtra) > 0:
   txt += VVVuRT("Perm. (Ext.)" , permExtra)
  txt += "\n"
  txt += VVVuRT("iNode"    , iNode)
  txt += VVVuRT("Hard Links"   , hLinks)
  txt += fileTime
  if hLinkedFiles:
   txt += "\n%s\nHard Linked Files (files with same iNode)\n%s\n" % (SEP, SEP)
   txt += hLinkedFiles
  txt += self.VVvXL8(path)
  txt += CC6u6z.VVZKCF(path)
  FF4lCP(self, txt, height=1000, titleBg="#22001010", VVemyB="#11000a1a")
 def VViUa8(self, path):
  path = path.strip()
  path = FFVc4H(path)
  result = FFTKR0("FILE='%s'; BROKEN=$(if [ ! -e \"$FILE\" ]; then echo 'yes'; else echo 'no'; fi); LINE=$(ls -lid \"$FILE\" 2> /dev/null); PARAM=$(echo $LINE | awk '{print $1\",\"$2\",\"$3\",\"$4\",\"$5\",\"$6}'); SLINK=$(echo $LINE | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=\"\";print}'  | sed 's/ -> /,/g' | xargs); echo $PARAM','$BROKEN','$SLINK" % path)
  parts = result.split(",")
  if not all(parts):
   return None
  if len(parts) > 7:
   iNode  = parts[0]
   perm  = parts[1]
   hLinks  = parts[2]
   owner  = parts[3]
   group  = parts[4]
   size  = parts[5]
   slBroken = parts[6]
   fName  = parts[7]
   slTarget = ""
   if len(parts) > 8:
    slTarget = parts[8]
   size = int(size)
   def VVjuol(perm, start, end):
    val = perm[start : end]
    p  = { "---": "0" , "--x": "1" , "-w-": "2" , "-wx": "3" , "r--": "4" , "r-x": "5" , "rw-": "6" , "rwx": "7" , "+": "ACL" }
    if val in p : return "%s\t%s" % (val, p[val])
    else  : return val
   permUser = VVjuol(perm, 1, 4)
   permGroup = VVjuol(perm, 4, 7)
   permOther = VVjuol(perm, 7, 10)
   permExtra = VVjuol(perm, 10, 100)
   typeChar = perm[0:1]
   typeStr = {"-":"File", "b":"Block Device File", "c":"Character Device File", "d":"Directory", "e":"External Link", "l":"Symbolic Link", "n":"Network File", "p":"Named Pipe", "s":"Local Socket File"}.get(typeChar, "Unknown")
   if "yes" in slBroken:
    slBroken = True
    typeStr  = "Broken Symlink (target not found)"
   else:
    slBroken = False
   hLinkedFiles = ""
   if typeChar != "d" and int(hLinks) > 1:
    hLinkedFiles = FFQ45w("find / %s -inum %s -print0 2> /dev/null | xargs -0 ls -i 2> /dev/null | grep %s | awk '{$1=\"\"; print $0}' | awk '{$1=$1};1'" % (FF5W9s(0, ["/dev", "/hdd", "/newroot", "/sys/class"]), iNode, iNode))
   return path, typeStr, typeChar, iNode, permUser, permGroup, permOther, permExtra, hLinks, owner, group, size, slTarget, slBroken, hLinkedFiles
  else:
   return None
 def VVvXL8(self, path):
  txt  = ""
  res  = FFTKR0("lsattr -d %s" % path)
  span = iSearch(r"([acdeijstuACDST-]{13})\s", res, IGNORECASE)
  if span:
   res = span.group(1)
   tDict = {"a": "Append only", "c": "Compressed", "d": "No dump", "e": "Extent format", "i": "Immutable", "j": "Data journalling", "s": "Secure deletion (s)", "t": "Tail-merging", "u": "Undeletable", "A": "No atime updates", "C": "No copy on write", "D": "Synchronous directory updates", "S": "Synchronous updates", "T": "Top of directory hierarchy", "h": "Huge file", "E": "Compression error", "I": "Indexed directory", "X": "Compression raw access", "Z": "Compressed dirty file"}
   lst = []
   for key, val in tDict.items():
    if key in res:
     lst.append("%s  ( %s )\n" % (val, key))
   if lst:
    lst.sort()
    for item in lst:
     txt += "    %s" % item
    txt = "\n%s\n%s" % (FFjt5L("File Attributes:", VVcPtB), txt)
  return txt
 def VV84uw(self, path):
  txt = "\n"
  txt += "Access time\t: %s\n" % FFTS4w(os.path.getatime(path))
  txt += "Modified time\t: %s\n" % FFTS4w(os.path.getmtime(path))
  txt += "Change time\t: %s\n" % FFTS4w(os.path.getctime(path))
  return txt
 def VVnGz0(self, path):
  txt = "\n"
  txt += "Access time\t: %s\n" % FFTKR0("stat -c %%x '%s'" % path).replace(".000000000", "")
  txt += "Modified time\t: %s\n" % FFTKR0("stat -c %%y '%s'" % path).replace(".000000000", "")
  txt += "Change time\t: %s\n" % FFTKR0("stat -c %%z '%s'" % path).replace(".000000000", "")
  return txt
 def VV5pAO(self, currentSel):
  currentDir  = self["myMenu"].VVWyCw()
  if currentDir is None:
   path = currentSel
  elif currentSel is None:
   path = currentDir
  else:
   if currentSel == "/":
    path = currentDir
   else:
    if not self["myMenu"].VV2bmH():
     path = currentDir + currentSel
    else:
     if len(currentDir) > len(currentSel):
      path = currentDir
     else:
      path = currentSel
  return str(path)
 def VV21cx(self):
  return self["myMenu"].VVWyCw() or self.VV5pAO(self.VVQlTC())
 def VVQlTC(self):
  sel = self["myMenu"].getSelection()
  if sel : return sel[0]
  else : return None
 def VVHrZx(self):
  path = self.VV5pAO(self.VVQlTC())
  self["myTitle"].setText("  " + path)
  if self["myTitle"].instance:
   textW = self["myTitle"].instance.calculateSize().width()
   if textW > self.VVJcJg:
    length = len(path)
    tmpPath = path[4:]
    for i in range(length, 40, -1):
     self["myTitle"].setText("  .." + tmpPath)
     textW = self["myTitle"].instance.calculateSize().width()
     if textW > self.VVJcJg: tmpPath = tmpPath[1:]
     else       : break
  self.VVzqwr()
  if self.mode == self.VV4Ihm:
   if len(path) > 0: self["keyMenu"].show()
   else   : self["keyMenu"].hide()
  self["keyGreen"].hide()
  if self.VVbA0M():
   if self.VVJuPG:
    if self["myMenu"].VVhxM5() > 0:
     self["keyGreen"].show()
   else:
    if self.mode == self.VVkJTs:
     if os.path.isfile(path):
      self["keyGreen"].show()
    else:
     self["keyGreen"].show()
  FFOKt0(self, 30, self.VVYKse)
 def VVYKse(self):
  path = self.VV5pAO(self.VVQlTC())
  if path != self.lastViewedPic:
   self.VVacFr(path)
   self.lastViewedPic = path
 def VVrEFW(self):
  c1, c2, c3 = VVIH76, VVFuwR, VVZtfx
  totSel = 0
  menuW = 1000
  title = "Options"
  VV3wat= []
  path = self.VV5pAO(self.VVQlTC())
  isLink = os.path.islink(path)
  if self.VVJuPG:
   menuW = 850
   totSel = self["myMenu"].VVhxM5()
   if totSel > 0:
    if iTar:
     txt1 = "Archive to .tar.gz"
     txt2 = " (Preserve Path Structure)"
     title = "Options  (%d item%s)" % (totSel, FFcacr(totSel))
     VV3wat.append((c1 + txt1      , "VVH6Ci1"  ))
     VV3wat.append((c1 + txt1 + txt2    , "VVH6Ci2"  ))
     VV3wat.append(VVAL3j)
    VV3wat.append(("[6] Copy"       , "copyFileOrDir" ))
    VV3wat.append(("[7] Move"       , "moveFileOrDir" ))
    VV3wat.append(("[8] %sDELETE" % VVz22H , "VV49nJ"  ))
   else:
    FF28n1(self, "Nothing selected", 700)
    return
  elif self.VVbA0M():
   VV3wat.append(("Properties", "properties" ))
   VV3wat.append(VVAL3j)
   VV3wat.append((c3 + "Create New Directory (in current directory)" , "createNewDir"))
  else:
   menuW = 1050
   path  = self.VV5pAO(self.VVQlTC())
   isEditable = self["myMenu"].VVK4p4()
   if not FFq2rn(path):
    FFdw58(self, "Cannot access this object.")
    return
   VV3wat.append(("Properties", "properties"))
   if os.path.isdir(path):
    addSep = True
    if FFx9pN(path, True) in (VVUytA, VVhDOZ):
     VV3wat.append(VVAL3j)
     VV3wat.append((c1 + "Show Related Package", "VVKeBf"))
     addSep = False
    if isEditable:
     if addSep:
      VV3wat.append(VVAL3j)
     VV3wat.append((c1 + "Archive/Package Tools", "VVwKHY_dir"))
     addSep = False
   elif os.path.isfile(path):
    selFile = self.VVQlTC()
    isArch = selFile.endswith((".tar", ".gz", ".tar.bz2", "tar.xz", "tar.zst", ".zip", ".rar", ".7z"))
    if not isArch:
     VV3wat.append((c1 + "Archive ...", "VVwKHY_file"))
    isText = False
    txt = ""
    if isArch:
     VV3wat.extend(self.VVEMIT(path, True))
    elif selFile.endswith((".ipk", ".deb")) :
     txt = "Package Tools"
    elif selFile.endswith((".m3u", ".m3u8")):
     VV3wat.extend(self.VVhJGC(True))
    elif selFile.endswith((".sh", ".py", ".pyo", ".pyc")):
     VV3wat.extend(self.VVAEUh(path, True))
     isText = selFile.endswith((".sh", ".py"))
    elif selFile.endswith(".svg"):
     pass
    elif not isLink and selFile.endswith(".tif"):
     VV3wat.append((c2 + "Save as ...", "VVpeV4"))
    elif not isLink and self["myMenu"].VVMyky(path) == "pic":
     VV3wat.append(VVAL3j)
     VV3wat.append((c2 + "Set as PIcon (for current channel)", "VVxzz6" ))
     path = self.VV5pAO(self.VVQlTC())
     VV3wat.append(VVAL3j)
     VV3wat.append((c2 + "Rotate Image", "VVL2ZB"   ))
     VV3wat.append((c2 + "Flip Image" , "VVImxq"   ))
     VV3wat.append((c2 + "Save as ..." , "VVpeV4" ))
     VV3wat.append(VVAL3j)
     VV3wat.append((c2 + "Convert to Base64 String", "VVOiJy" ))
     if FFayeZ("ffmpeg") and selFile.lower().endswith((".jpg", ".png")):
      VV3wat.append((c2 + "Convert to MVI (1280 x 720 )", "VV2if2Hd" ))
      VV3wat.append((c2 + "Convert to MVI (1920 x 1080)", "VV2if2Fhd" ))
    elif selFile.endswith((".py", ".xml", ".txt", ".htm", ".html", ".cfg", ".conf")) or not CClYaF.VVgIOw(path):
     VV3wat.append(VVAL3j)
     VV3wat.append((c2 + "View"     , "textView_def"))
     VV3wat.append((c2 + "View (Select Encoder)" , "textView_enc"))
     VV3wat.append((c2 + "Edit"     , "text_Edit" ))
     isText = True
    elif selFile.endswith(CClYaF.VVI46y(addDot=True)):
     if selFile.endswith(".mvi"):
      if FFayeZ("showiframe"):
       VV3wat.append(VVAL3j)
       VV3wat.append((c2 + "View as Bootlogo (will interrupt the playing service)", "viewAsBootlogo"))
      if FFayeZ("ffmpeg"):
       VV3wat.append((c2 + "Convert to jpg", "mv2jpg"))
       VV3wat.append((c2 + "Convert to png", "mv2png"))
     else:
      VV3wat.append(VVAL3j)
      VV3wat.append((c2 + "Add Media File to a Bouquet"    , "VV2Fo30" ))
      VV3wat.append((c2 + "Add all Media in Directory to a Bouquet" , "VV2Fo31" ))
      VV3wat.append((c2 + "Play with ..."       , "playWith"    ))
    if isText:
     VV3wat.append((c1 + "Save as UTF-8 ..."      , "textSave_encUtf8"))
     VV3wat.append((c1 + "Save as other Encoding ..."    , "textSave_encOthr"))
     VV3wat.append((c1 + "Convert Line-Breaks to Unix Format..." , "VVEDRf" ))
    if len(txt) > 0:
     VV3wat.append(VVAL3j)
     VV3wat.append((c1 + txt, "VVSrgT"))
   VV3wat.append(VVAL3j)
   VV3wat.append(("[4] Create SymLink", "VV6ZhN"))
   if isEditable:
    VV3wat.append(("[5] Rename"      , "VVTxpl" ))
    VV3wat.append(("[6] Copy"       , "copyFileOrDir" ))
    VV3wat.append(("[7] Move"       , "moveFileOrDir" ))
    VV3wat.append(("[8] %sDELETE" % VVz22H , "VVRs0f" ))
    if FFCyVu(path):
     VV3wat.append(VVAL3j)
     perm = oct(os.stat(path).st_mode)[-3:]
     if   perm == "644" : show644, show755, show777 = False, True , True
     elif perm == "755" : show644, show755, show777 = True , False , True
     elif perm == "777" : show644, show755, show777 = True , True , False
     else    : show644, show755, show777 = True , True , True
     chmodTxt = "Change Permissions (from %s to " % perm
     if show644 : VV3wat.append((chmodTxt + "644)", "chmod644"))
     if show755 : VV3wat.append((chmodTxt + "755)", "chmod755"))
     if show777 : VV3wat.append((chmodTxt + "777)", "chmod777"))
   VV3wat.append(VVAL3j)
   VV3wat.append((c3 + "Create New File (in current directory)"  , "createNewFile"))
   VV3wat.append((c3 + "Create New Directory (in current directory)" , "createNewDir" ))
   fPath, fDir, fName = CClYaF.VV4zSS(self)
   if fPath:
    VV3wat.append(VVAL3j)
    VV3wat.append((c2 + "Go to Current Movie Dir", "VV64Kx"))
  FFLFTC(self, self.VVdSby, width=menuW, height=1050, title=title, VV3wat=VV3wat, VVptue=0.01, VVCkuB=False, VVwltY="#00101020", VVkxBG="#00101A2A")
 def VVdSby(self, item=None):
  if item is not None:
   path = self.VV5pAO(self.VVQlTC())
   if   item == "VVH6Ci1"    : self.VVH6Ci(False)
   elif item == "VVH6Ci2"    : self.VVH6Ci(True)
   elif item == "copyFileOrDir"   : self.VVhrqo(False)
   elif item == "moveFileOrDir"   : self.VVhrqo(True)
   elif item == "VV49nJ"    : self.VV49nJ()
   elif item == "properties"    : self.VVRg33()
   elif item == "VVKeBf"  : self.VVKeBf(path)
   elif item == "VVwKHY_dir" : self.VVwKHY(path, True)
   elif item == "VVwKHY_file" : self.VVwKHY(path, False)
   elif item == "VVJf2H"  : self.VVJf2H(path)
   elif item == "VVmefC"  : self.VVmefC(path)
   elif item == "2gz"       : self.VVCQLE(path, "gz")
   elif item == "2xz"       : self.VVCQLE(path, "xz")
   elif item.startswith("extract_")  : self.VVuG0S(path, item)
   elif item.startswith("script_")   : self.VVCNY7(path, item)
   elif item.startswith("m3u_")   : self.VVGWWo(path, item)
   elif item.startswith("textView_def") : FFaOUK(self, path)
   elif item.startswith("textView_enc") : self.VVIS6B(path)
   elif item.startswith("text_Edit")  : CCyMCP(self, path, VVbYwR=self.VVFGYD)
   elif item.startswith("textSave_encUtf8"): self.VVJVpo(path, "Save as UTF-8"   , True)
   elif item.startswith("textSave_encOthr"): self.VVJVpo(path, "Save as Other Encoding", False)
   elif item.startswith("VVEDRf") : self.VVEDRf(path)
   elif item == "viewAsBootlogo"   : self.VVuVqJ(path, True)
   elif item == "mv2jpg"     : self.VV72l5(path, 0)
   elif item == "mv2png"     : self.VV72l5(path, 1)
   elif item == "VV2Fo30" : self.VV2Fo3(path, False)
   elif item == "VV2Fo31" : self.VV2Fo3(path, True)
   elif item == "playWith"     : self.VVi42l(path)
   elif item == "VVxzz6" : self.VVxzz6(path)
   elif item == "VVL2ZB"   : self.VVL2ZB(path)
   elif item == "VVImxq"    : self.VVImxq(path)
   elif item == "VVpeV4" : self.VVpeV4(path)
   elif item == "VV2if2Hd"   : self.VV2if2(path, False)
   elif item == "VV2if2Fhd"   : self.VV2if2(path, True)
   elif item == "VVOiJy"   : self.VVOiJy(path)
   elif item == "VV6ZhN"   : self.VV6ZhN(path)
   elif item == "VVTxpl"   : self.VVTxpl(path)
   elif item == "VVRs0f"   : self.VVRs0f(path)
   elif item == "chmod644"     : self.VVtQrS(path, "644")
   elif item == "chmod755"     : self.VVtQrS(path, "755")
   elif item == "chmod777"     : self.VVtQrS(path, "777")
   elif item == "createNewFile"   : self.VVeGt3(path, True)
   elif item == "createNewDir"    : self.VVeGt3(path, False)
   elif item == "VV64Kx"   : self.VV64Kx()
   elif item == "VVSrgT"    : self.VVSrgT()
 def VVSrgT(self):
  if self.mode == self.VVkJTs and not self.VV1gDA == "poster":
   return
  path = self.VV5pAO(self.VVQlTC())
  if os.path.isfile(path):
   cat = self["myMenu"].VVMyky(path)
   if   cat == "pic"        : self.VVwyCv(path)
   elif cat == "txt"        : FFaOUK(self, path)
   elif cat == "m3u"        : self.VVJ8wl(path)
   elif cat in ("scr", "py")      : self.VVCqHG(path)
   elif cat in ("tar", "rar", "zip", "p7z", "zst") : self.VVbiYO(path)
   elif cat in ("ipk", "deb")      : self.VV8nL2(path)
   elif cat in ("mov", "mus")      : self.VVuVqJ(path)
   elif not CClYaF.VVgIOw(path)  : FFaOUK(self, path)
 @FFOAKH()
 def VVwyCv(self, path):
  VVBGsZ = 0
  curFile = os.path.basename(path)
  lst = []
  for ndx, item in enumerate(self["myMenu"].list):
   if not item[0][1]:
    category = self["myMenu"].VVMyky(item[1][7])
    if category == "pic":
     if curFile == item[1][7]:
      VVBGsZ = len(lst)
     lst.append((ndx, item[1][7]))
  CCf8zb.VVjnMn(self, path, fileList=lst, VVBGsZ=VVBGsZ, cbFnc=self.VVtSUs)
 def VVtSUs(self, path, ndx):
  self["myMenu"].moveToIndex(ndx)
 def VVuVqJ(self, path, asLogo=False):
  if asLogo : CCcV1i.VVKb3z(self, path)
  else  : FFimQ3(self, BF(self.VVTWR0, self, path), title="Playing Media ...")
 def VVwrew(self):
  if self["keyBlue"].getVisible():
   VVGape = self.VV4sOH()
   if VVGape:
    path = self.VV5pAO(self.VVQlTC())
    enableGreenBtn = False if path in self.VV4sOH() else True
    newList = []
    for line in VVGape:
     newList.append((line, line))
    VVHGnw  = ("Delete"    , self.VV3M4h    )
    VVwJOl  = ("Add Current Dir"   , BF(self.VVrbvp, path) ) if enableGreenBtn else None
    VVB4pu = ("Move Up"     , self.VVbkqS    )
    VVaTeF  = ("Move Down"   , self.VVoA0n    )
    self.VVpP2Y = FFLFTC(self, self.VVXwm6, width=1200, title="Bookmarks", VV3wat=newList, VVyRCy=10 ,VVHGnw=VVHGnw, VVwJOl=VVwJOl, VVB4pu=VVB4pu, VVaTeF=VVaTeF, VVwltY="#00000022", VVkxBG="#00000022")
 def VV3M4h(self, VV7tND=None, path=None):
  VVGape = self.VV4sOH()
  if VVGape:
   while path in VVGape:
    VVGape.remove(path)
   self.VVHCxf(VVGape)
  if self.VVpP2Y:
   self.VVpP2Y.VVkSNR(VVGape)
   self.VVpP2Y.VVoXgh(("Add Current Dir", BF(self.VVrbvp, path)))
  else:
   FF28n1(self, "Removed", 800)
  self.VVzqwr()
 def VVrbvp(self, path, VV7tND=None, item=None):
  VVGape = self.VV4sOH()
  if len(VVGape) >= self.VVufQt:
   FFdw58(SELF, "Max bookmarks reached (max=%d)." % self.VVufQt)
  elif not path in VVGape:
   if not os.path.isdir(path):
    path = FFx9pN(path, True)
   newList = [path] + VVGape
   self.VVHCxf(newList)
   if self.VVpP2Y:
    self.VVpP2Y.VVkSNR(newList)
    self.VVpP2Y.VVoXgh()
   else:
    FF28n1(self, "Added", 800)
  self.VVzqwr()
 def VVbkqS(self, selectionObj, path):
  if self.VVpP2Y:
   VVGape = self.VVpP2Y.VVT8gV(True)
   if VVGape:
    self.VVHCxf(VVGape)
 def VVoA0n(self, selectionObj, path):
  if self.VVpP2Y:
   VVGape = self.VVpP2Y.VVT8gV(False)
   if VVGape:
    self.VVHCxf(VVGape)
 def VVXwm6(self, path=None):
  if path:
   path = FFoWxR(path)
   self.VVPGjz(path)
  self.VVHrZx()
 @FFOAKH("Changing directory ...")
 def VVPGjz(self, path):
  self["myMenu"].VVf5s1(path)
  self["myMenu"].moveToIndex(0)
 def VV4sOH(self):
  line = CFG.browserBookmarks.getValue().strip()
  while " ," in line : line.replace(" ,", ",")
  while ", " in line : line.replace(", ", ",")
  if   "," in line : return line.split(",")
  elif len(line) > 0 : return [line]
  else    : return []
 def VV2doE(self):
  return True if VV4sOH() else False
 def VVHCxf(self, VVGape):
  line = ",".join(VVGape)
  FFjt1c(CFG.browserBookmarks, line)
 def VVPeow(self, path):
  if FFCyVu(path):
   fDir  = FFoWxR(os.path.dirname(path))
   if fDir:
    self["myMenu"].VVf5s1(fDir)
   fName = os.path.basename(path)
   for ndx, item in enumerate(self["myMenu"].list):
    if fName == item[0][0]:
     self["myMenu"].moveToIndex(ndx)
     break
  else:
   FF28n1(self, "Not found", 1000)
 def VVWh2y(self, moveTo):
  for ndx, item in enumerate(self["myMenu"].list):
   if moveTo == item[0][0]:
    self["myMenu"].moveToIndex(ndx)
    break
 def VV64Kx(self, chDir=True):
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  self.VVPeow(fPath)
 def VV8SuT(self):
  path = self.VV5pAO(self.VVQlTC())
  isAdd = False if path in self.VV4sOH() else True
  dirTxt = "Selected" if os.path.isdir(path) else "Current"
  c1, c2, c3 = VVGCYL, VVJEMb, VVFuwR
  VV3wat = []
  VV3wat.append(("Find Files ..." , "find"))
  VV3wat.append(("Sort ..."   , "sort"))
  VV3wat.append(VVAL3j)
  if isAdd: VV3wat.append((c1 + "Add %s Dir to Bookmarks"  % dirTxt, "addBM"))
  else : VV3wat.append((c1 + "Remove %s Dir from Bookmarks" % dirTxt, "remBM"))
  VV3wat.append(    (c2 + 'Set %s Dir as "Startup Dir"' % dirTxt, "start"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Keys (Shortcuts)", "help"))
  if self.mode == self.VV4Ihm or self.VVIC7J:
   VV3wat.append(VVAL3j)
   if self.VVJuPG: VV3wat.append( (c3 + "Disable Multi-Select ", "multiOff"))
   else     : VV3wat.append( (c3 + "Enable Multi-Select"  , "multiOn" ))
   VV3wat.append(       (c3 + "Select all"    , "selAll"  ))
  FFLFTC(self, BF(self.VVgNCz, path), width=750, title="More Options", VV3wat=VV3wat, VVwltY="#00221111", VVkxBG="#00221111")
 def VVgNCz(self, path, item):
  if item:
   if   item == "find"  : self.VV66GN(path)
   elif item == "sort"  : self.VVOKeQ()
   elif item == "addBM" : self.VVrbvp(path)
   elif item == "remBM" : self.VV3M4h(None, path)
   elif item == "help"  : self.VVk14D()
   elif item == "start" : self.VVyATn(path)
   elif item == "multiOn" : self.VVdcm6(True)
   elif item == "multiOff" : self.VVdcm6(False)
   elif item == "selAll" : self.VVdcm6(True, True)
 def VVdcm6(self, isOn, isAll=False):
  self.VVJuPG = isOn
  if isAll or not isOn:
   FFimQ3(self, BF(self["myMenu"].VV0y0E, isOn, self.mode, cbFnc=self.VVoBrJ), title="Selecting ..." if isOn else "Unselecting ...")
  if isOn      : color = self.VVoQmo
  elif self.VVbA0M() : color = self.VVFST7
  else      : color = self.VVoPwh
  self.VVT9IH(color)
  self.VVHrZx()
 def VVoBrJ(self):
  self["keyBlue"].setText(self.VV9gXI())
 def VVT9IH(self, mode=0):
  if   mode == self.VVFST7 : titBg, bodBg = self.pickTitleBG, self.pickBodyBG
  elif mode == self.VVoQmo: titBg, bodBg = "#01883366", "#11002233"
  else        : titBg, bodBg = self.VVwltY, self.VVkxBG
  FFZ0AC(self["myTitle"], titBg)
  FFZ0AC(self["myBar"], titBg)
  FFZ0AC(self["myBody"], bodBg)
  FFZ0AC(self["myMenu"], bodBg)
  if self.VVJuPG: bg, txt = "#01883366", self.VV9gXI()
  else     : bg, txt = VVq9cv[3], "Bookmarks"
  FFRLNq(self["keyBlue"], txt)
  FFZ0AC(self["keyBlue"], bg)
  self.VVzqwr()
 def VV9gXI(self):
  return "Selected Items = %d" % self["myMenu"].VVhxM5()
 def VVzqwr(self):
  if self.VV4sOH() or self.VVJuPG: self["keyBlue"].show()
  else            : self["keyBlue"].hide()
 def VV66GN(self, path):
  VV3wat = []
  VV3wat.append(("Find in Current Directory"    , "findCur"  ))
  VV3wat.append(("Find in Current Directory (recursive)" , "findCurR" ))
  VV3wat.append(("Find in all Storage Systems"    , "findAll"  ))
  FFLFTC(self, BF(self.VVqodg, path), width=700, title="Find File/Pattern", VV3wat=VV3wat, VVU8mZ=True, VVlaGv=True, VVwltY="#00221111", VVkxBG="#00221111")
 def VVqodg(self, path, item):
  if item:
   title, item, ndx = item
   if   item == "findCur" : self.VVYU75(0, path, title)
   elif item == "findCurR" : self.VVYU75(1, path, title)
   elif item == "findAll" : self.VVYU75(2, path, title)
 def VVYU75(self, mode, path, title):
  if CFG.lastFileManFindPatt.getValue(): txt = CFG.lastFileManFindPatt.getValue()
  else         : txt = "*.ipk"
  FF4z45(self, BF(self.VVHYs3, mode, path, title), defaultText=txt, title=title, message="Enter Name/Pattern:")
 def VVHYs3(self, mode, path, title, filePatt):
  if filePatt is not None:
   filePatt = filePatt.strip()
   FFjt1c(CFG.lastFileManFindPatt, filePatt)
   badLst = filePatt.replace(" ", "") in ("*.*", "*.", ".*")
   if not filePatt : FF28n1(self, "No entery", 1500)
   elif badLst  : FF28n1(self, "Too many file !", 1500)
   else   : self.VVHQ9b(mode, path, title, filePatt)
 @FFOAKH("Searching ...")
 def VVHQ9b(self, mode, path, title, filePatt):
  lst = FFycDu("find '%s' %s -type f -iname '%s' %s -print 2> /dev/null" % ("/" if mode==2 else path, FF5W9s(0), filePatt, "-maxdepth 1" if mode == 0 else ""))
  if lst:
   err = CClYaF.VV8isu(lst)
   if err:
    FFdw58(self, err)
   else:
    for ndx, path in enumerate(lst):
     lst[ndx] = (os.path.basename(path), os.path.dirname(path))
    lst.sort(key=lambda x: x[0].lower())
    header = ("File", "Directory" )
    widths = (50 , 50   )
    VV2ytr = (""     , self.VVPxbj , [])
    VVwSzI = ("Go to File Location", self.VV9Bbn  , [])
    FFUQ0v(self, None, title="%s : %s" % (title, filePatt), header=header, VVGape=lst, VV3cHe=widths, VVwdmN=26, VV2ytr=VV2ytr, VVwSzI=VVwSzI)
  else:
   FFjADj(self, "Not found !", 2000)
 def VV9Bbn(self, VV6A99, title, txt, colList):
  path = os.path.join(colList[1], colList[0])
  if FFCyVu(path):
   VV6A99.cancel()
   self.VVPeow(path)
  else:
   FF28n1(VV6A99, "Path not found !", 1000)
 def VVPxbj(self, VV6A99, title, txt, colList):
  txt = "%s\n%s\n\n" % (FFjt5L("File:"  , VVFuwR), colList[0])
  txt += "%s\n%s"  % (FFjt5L("Directory:", VVFuwR), FFoWxR(colList[1]))
  FF4lCP(VV6A99, txt, title=title)
 def VVOKeQ(self):
  nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVdj0P()
  VV3wat = []
  VV3wat.append(("Name\t%s" % nameAlpTxt, "nameAlp"))
  VV3wat.append(("Name\t%s" % nameNumTxt, "nameNum"))
  VV3wat.append(("Date\t%s" % dateTxt, "dateAlp"))
  VV3wat.append(("Type\t%s" % typeTxt, "typeAlp"))
  VVaTeF = ("Mix", BF(self.VV4ICR, True))
  FFLFTC(self, BF(self.VV6Mt1, False), VVW5y5=txt, width=650, title="Sort Options", VV3wat=VV3wat, VVaTeF=VVaTeF, VVlaGv=True, VVwltY="#00221111", VVkxBG="#00221111")
 def VV4ICR(self, isMix, VV7tND, item):
  self.VV6Mt1(True, item)
 def VV6Mt1(self, isMix, item):
  if item:
   nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt , dateMode, dateTxt, typeMode, typeTxt, txt = self["myMenu"].VVdj0P()
   if   item == "nameAlp": mode, isNum =  nameAlpMode, False
   elif item == "nameNum": mode, isNum =  nameNumMode, True
   elif item == "dateAlp": mode, isNum =  dateMode , False
   elif item == "typeAlp": mode, isNum =  typeMode , False
   else      : return
   FFimQ3(self, BF(self["myMenu"].VVhNXg, mode, isMix, isNum), title="Sorting ... ")
 def VVkOZB(self):
  path = self.VV5pAO(self.VVQlTC())
  self.VVyATn(path)
 def VVyATn(self, path):
  if not os.path.isdir(path):
   path = FFx9pN(path, True)
  FFjt1c(CFG.browserStartPath, path)
  FF1mVE(self, "Saved as Startup", 1500)
 def VVEMIT(self, path, calledFromMenu):
  color = VVFuwR if calledFromMenu else ""
  VV3wat = []
  if path.endswith(".gz") and not path.endswith(".tar.gz") or path.endswith(".xz") and not path.endswith(".tar.xz"):
   VV3wat.append((color + "Extract Here", "VVe9C1"))
  else:
   if path.endswith(".zst") and not FFayeZ("unzstd"):
    return []
   if calledFromMenu: VV3wat.append(VVAL3j)
   VV3wat.append((color + "List Archived Files", "extract_listFiles"))
   VV3wat.append(VVAL3j)
   VV3wat.append((color + 'Extract to "%s"' % self.VVrERF(os.path.basename(path)) , "extract_toDir"  ))
   VV3wat.append((color + 'Extract to Root Directory "/"  (recommended for plugins)'  , "extract_toRoot"  ))
   VV3wat.append((color + "Extract Here"             , "extract_here"  ))
   if iTar and iZip:
    if path.endswith(".zip"):
     if not calledFromMenu: VV3wat.append(VVAL3j)
     VV3wat.append((color + "Convert .zip to .tar.gz", "VVJf2H" ))
    elif path.endswith(".tar.gz"):
     if not calledFromMenu: VV3wat.append(VVAL3j)
     VV3wat.append((color + "Convert .tar.gz to .zip", "VVmefC" ))
   if path.endswith((".tar.gz", ".tar.xz", ".tar.zst")):
    VV3wat.append(VVAL3j)
    if   path.endswith(".gz"): VV3wat.append((color + "Convert to .tar.xz", "2xz"))
    elif path.endswith(".xz"): VV3wat.append((color + "Convert to .tar.gz", "2gz"))
    elif path.endswith(".zst"):
     cond = FFayeZ("zstd")
     VV3wat.append(FFsLU5("Convert to .tar.gz", "2gz", cond, color))
     VV3wat.append(FFsLU5("Convert to .tar.xz", "2xz", cond, color))
  return VV3wat
 def VVbiYO(self, path):
  title = "Archived File Options"
  VV3wat = self.VVEMIT(path, False)
  if VV3wat : FFLFTC(self, BF(self.VVuG0S, path), title=title, VV3wat=VV3wat, width=1050)
  else  : FFRMYv(self, BF(self.VVQHS8, self), 'Missing "zstd" package.\n\nInstall "zstd" ?')
 @staticmethod
 def VVQHS8(SELF):
  cmd = FF5sZa(VVwFAi, "zstd")
  if cmd : FFbi5l(SELF, cmd, title="Installing zstd")
  else : FFfone(SELF)
 def VVuG0S(self, path, item=None):
  if item is not None:
   if   item == "VVe9C1"         : self.VVe9C1(item, path)
   elif item == "extract_listFiles"        : self.VV1zd9(path)
   elif item == "VVJf2H" and path.endswith(".zip")  : self.VVJf2H(path)
   elif item == "VVmefC" and path.endswith(".tar.gz") : self.VVmefC(path)
   elif item == "2gz"             : self.VVCQLE(path, "gz")
   elif item == "2xz"             : self.VVCQLE(path, "xz")
   elif path.endswith((".zip", ".rar", ".7z"))      : self.VVsCrT(item, path)
   else               : self.VVbl04(item, path)
 def VVrERF(self, path, addSep=False):
  for ext in (".tar.gz", ".tar.xz", ".tar.bz2", ".tar.zst"):
   if path.endswith(ext):
    print(len(ext))
    return path[:-len(ext)]
  return os.path.splitext(path)[0]
 def VV1zd9(self, path):
  ext = os.path.splitext(os.path.basename(path))[1]
  linux_sep = "echo -e %s;" % SEP
  if ext in (".zip", ".rar", ".7z"):
   if   ext == ".zip": mainC, totC, instC = "unzip -l", "tail -n 1 | awk '{ print $2 }'"     , FFMAzK("unzip", "unzip", "Unzip")
   elif ext == ".rar": mainC, totC, instC = "unrar l" , "tail -n 2 | grep -v \"^$\" | awk '{ print $2 }'" , FFMAzK("unrar", "unrar", "Unrar")
   elif ext == ".7z" : mainC, totC, instC = "7za l" , "tail -n 1 | awk '{ print $5 }'"     , FFMAzK("7za", "p7zip", "P7Zip")
   listC = "%s '%s'" % (mainC, path)
   tooMany = "Will only show first and last 100 files..."
   cmd  = linux_sep
   cmd += instC
   cmd += 'if [ "$allOK" -eq "1" ]; then '
   cmd += " TOTF=$(%s | %s);" % (listC, totC)
   cmd += " echo ''; echo 'Archived Files :'$TOTF;"
   cmd +=   linux_sep
   cmd += " if [ $TOTF -gt 300 ]; then"
   cmd += "  echo -e '%s' %s;"  % (tooMany, FFSPDv(tooMany, VV1fx4))
   cmd +=    linux_sep
   cmd += "  %s | head -n 100;" % listC
   cmd += "  echo ''; echo ' ... MANY LINES COME HERE ... '; echo '';"
   cmd += "  echo '';"
   cmd += "  %s | tail -n 100;" % listC
   cmd += " else"
   cmd += "  %s;" % listC
   cmd += " fi;"
   cmd += "fi;"
  else:
   cmd  = "echo -e 'Archive:\n%s\n\n';" % path
   cmd += "totFiles=$(tar -tf '%s' | wc -l);" % path
   cmd += "if (( $totFiles > 300 )); then moreInf='  ... Will list the first 300 only ...'; else moreInf=''; fi;"
   cmd += "echo -e '\n%s\n--- Contents (Total='$totFiles')'$moreInf'\n%s';" % (SEP, SEP)
   cmd += "tar -tf '%s' | head -n300;" % path
   cmd += "if (( $totFiles > 300 )); then echo '\n... Only the first 300 are listed ...'; fi;"
  cmd += "echo '';"
  cmd += linux_sep
  FFXD60(self, cmd)
 @FFOAKH("Extracting ...")
 def VVe9C1(self, item, path):
  title = os.path.basename(path)
  res = FFTKR0("RES=$(%s -dk '%s') && echo ok || echo $RES" % ("gzip" if path.endswith("gz") else "xz", path))
  if res == "ok":
   FFipXT(self, "Extracted File:\n\n%s" % path[:-3], title=title)
   self.VVcPTN()
  else:
   FFdw58(self, "Error:\n\n%s" % res, title=title)
 def VVbl04(self, item, path):
  fName = os.path.basename(path)
  lastP = FFxtW5(self.VVrERF(path))
  parent = FFx9pN(path, False)
  if   item == "extract_toDir" : destP, txt = lastP , " to : %s" % lastP
  elif item == "extract_toRoot" : destP, txt = "/"  , ' to Root Directory ("/")'
  elif item == "extract_here"  : destP, txt = parent, " Here"
  else       : return
  FFRMYv(self, BF(self.VVzvHe, item, path, fName, lastP, parent, destP), "Extract %s ?" % txt, title="File : %s" % fName)
 def VVzvHe(self, item, path, fName, lastP, parent, destP):
  if item == "extract_toDir":
   cmd  = "cd '%s';" % parent
   cmd += FFb2oQ("mkdir '%s'"   % lastP)
   cmd += 'if [ -d "%s" ]; then '  % lastP
   cmd += " tar -xf '%s' -C '%s';" % (path, lastP)
   cmd += "else"
   cmd += " echo -e 'Cannot create directory:\n%s';" % lastP
   cmd += "fi"
   destTxt = " : \n\n%s" % os.path.join(parent, destP)
  elif item == "extract_toRoot":
   cmd  = "cd '%s';" % parent
   cmd += "tar -C / -xf '%s'" % path
   destTxt = ' Root Directory ("/")'
  elif item == "extract_here":
   cmd  = "cd '%s';" % parent
   cmd += "tar -xf '%s'" % path
   destTxt = ": \n\n%s" % os.path.join(parent, destP)
  res = FFQ45w(cmd)
  if res : FF4lCP(self, "Error while extracting:\n\n%s\n\n%s\n\nError:\n\n%s" % (fName, SEP, res), isErr=True)
  else : FFipXT(self, "Successfully Extracted to%s" % destTxt, title=fName)
  self.VVcPTN()
 def VVsCrT(self, item, path):
  fName = os.path.basename(path)
  FFRMYv(self, BF(self.VVV2Ta, item, path, fName), "Extract file ?\n\n%s" % fName)
 def VVV2Ta(self, item, path, fName):
  parent  = FFx9pN(path, False)
  destPath = self.VVrERF(path)
  archCmd  = ""
  if path.endswith(".zip"):
   cmd = FFMAzK("unzip", "unzip", "Unzip")
   if   item == "extract_toDir" : archCmd += " cd '%s'; [ ! -d '%s' ] && mkdir '%s';" % (parent,destPath, destPath)
   elif item == "extract_toRoot": destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += " unzip -o -q '%s' -d '%s' > /dev/null;" % (path, destPath)
  elif path.endswith(".rar"):
   cmd = FFMAzK("unrar", "unrar", "Unrar")
   if   item == "extract_toDir" : destPath = FFoWxR(destPath)
   elif item == "extract_toRoot" : destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += " unrar x -o+ '%s' '%s' > /dev/null;" % (path, destPath)
  elif path.endswith(".7z"):
   cmd = FFMAzK("7za", "p7zip", "P7Zip")
   if   item == "extract_toDir" : destPath = destPath
   elif item == "extract_toRoot" : destPath = "/"
   elif item == "extract_here"  : destPath = parent
   archCmd += "7za x '%s' -o'%s' -y > /dev/null;" % (path, destPath)
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += "echo '';"
  cmd += "echo 'Extracting content ...';"
  cmd +=   archCmd
  cmd += " echo -e 'Done.\n\nExtracted to:\n%s\n' %s;" % (destPath, FFSPDv(destPath, VVSGsk))
  cmd += "fi;"
  FFZQVC(self, cmd, VVoasw=self.VVcPTN)
 def VVCqHG(self, path):
  FFLFTC(self, BF(self.VVCNY7, path), title="File Options", VV3wat=self.VVAEUh(path))
 def VVAEUh(self, path, addSep=False):
  isText = path.endswith((".sh", ".py"))
  c1 = VVFuwR
  VV3wat = []
  if addSep: VV3wat.append(VVAL3j)
  if isText: VV3wat.append((c1 + "View"  , "script_View"  ))
  VV3wat.append((c1 + "Execute in Terminal" , "script_Execute" ))
  if isText: VV3wat.append((c1 + "Edit"  , "script_Edit"  ))
  if VVBvqf:
   VV3wat.append(VVAL3j)
   VV3wat.append((VVYjI5 + "Fix SH", "VVNUmp"))
  return VV3wat
 def VVCNY7(self, path, item=None):
  if item is not None:
   if   item == "script_View"  : FFaOUK(self, path)
   elif item == "script_Execute" : FFRMYv(self, BF(FFimQ3, self, BF(self.session.openWithCallback, self.VVcPTN, CCtzVm, VVGd7m=path)), "Run File ?\n\n%s" % os.path.basename(path))
   elif item == "script_Edit"  : CCyMCP(self, path, VVbYwR=self.VVFGYD)
   elif item == "VVNUmp"  : self.VVNUmp(path)
 def VVNUmp(self, path):
  txt = FFYVq0(path)
  var, ev, scr = txt.partition("eval")
  if ev:
   outF = path + "__.sh"
   var, scr = var.strip(), scr.strip()
   if FF7ymp("%s\necho -e %s > '%s'" % (var, scr, outF)):
    FFipXT(self, "Saved to:\n\n%s" % outF)
    self.VVcPTN()
   else: FFdw58(self, "Converstion Error")
  else: FFdw58(self, "No Eval")
 def VVhJGC(self, addSep=False):
  VV3wat = []
  if addSep:
   VV3wat.append(VVAL3j)
  VV3wat.append((VVFuwR + "Play / Browse Channels", "m3u_Browse" ))
  VV3wat.append((VVFuwR + "Edit"     , "m3u_Edit" ))
  VV3wat.append((VVFuwR + "View"     , "m3u_View" ))
  return VV3wat
 def VVJ8wl(self, path):
  FFLFTC(self, BF(self.VVGWWo, path), title="M3U/M3U8 File Options", VV3wat=self.VVhJGC(), width=550)
 def VVGWWo(self, path, item=None):
  if item is not None:
   if   item == "m3u_Browse" : CCjZbZ(self, CCjZbZ.VVry11, m3uF=path)
   elif item == "m3u_Edit"  : CCyMCP(self, path, VVbYwR=self.VVFGYD)
   elif item == "m3u_View"  : FFaOUK(self, path)
 def VVIS6B(self, path):
  if FFCyVu(path) : FFimQ3(self, BF(CC7ocD.VV9PZW, self, path, BF(self.VVV4zJ, path)), title="Loading Codecs ...")
  else    : FF8Wsn(self, path)
 def VVV4zJ(self, path, item=None):
  if item:
   FFaOUK(self, path, encLst=item)
 def VVJVpo(self, path, title, asUtf8):
  if FFCyVu(path) : FFimQ3(self, BF(CC7ocD.VV9PZW, self, path, BF(self.VV7GCL, path, title, asUtf8), title="Original Encoding"), title="Loading Codecs ...")
  else    : FF8Wsn(self, path)
 def VV7GCL(self, path, title, asUtf8, fromEnc=None):
  if fromEnc:
   if asUtf8: self.VVTVQR(path, title, fromEnc, "UTF-8")
   else  : CC7ocD.VViA40(self, BF(self.VVTVQR, path, title, fromEnc), title="Convert to Encoding")
 def VVTVQR(self, path, title, fromEnc, toEnc):
  if toEnc:
   if not FFCyVu(path):
    FF28n1(self, "Cannot open file", 2000)
    return
   try:
    outFile = "%s_%s%s" % (path, toEnc, os.path.splitext(path)[1])
    with ioOpen(path, "r", encoding=fromEnc) as src:
     BLOCK_1MB = 1048576
     with ioOpen(outFile, "w", encoding=toEnc) as dest:
      while True:
       cont = src.read(BLOCK_1MB)
       if not cont:
        break
       dest.write(cont)
     txt  = FFjt5L("Successful\n\n", VVSGsk)
     txt += FFjt5L("From Encoding (%s):\n" % fromEnc, VV1fx4)
     txt += "%s\n\n" % path
     txt += FFjt5L("To Encoding (%s):\n" % toEnc, VV1fx4)
     txt += "%s\n\n" % outFile
     FF4lCP(self, txt, title=title)
   except:
    FFwgGB(outFile)
    FFdw58(self, 'Cannot encode the file:\n%s\n\nFrom "%s" to "%s"' % (path, fromEnc, toEnc), title=title)
   self.VVcPTN()
 def VVEDRf(self, path):
  title = "File Line-Break Conversion"
  FFRMYv(self, BF(self.VVzzZ9, path, title), "Convert Line-Breaks to Unix for the file:\n\n%s" % path, title=title)
 def VVzzZ9(self, path, title):
  if FFCyVu:
   with open(path, 'rb') as f:
    data = f.read()
   done = False
   if data:
    CRLF, LF, To = b"\r\n", b"\r", b"\n"
    totCRLF = data.count(CRLF)
    totLF = data.count(LF)
    if totCRLF or totLF:
     done = True
     with open(path, 'wb') as f:
      f.write(data.replace(CRLF, To).replace(LF, To))
   if done : txt = "%s\n\n%s" % (FFjt5L("File converted:", VVSGsk), path)
   else : txt = "Nothing to convert in:\n\n%s" % path
   FFipXT(self, txt, title=title)
  else:
   FF8Wsn(self, path, title=title)
 def VVtQrS(self, path, newChmod):
  FFRMYv(self, BF(self.VVArlz, path, newChmod), "Change Permission to %s ?\n\n%s" % (newChmod, os.path.basename(path)))
 def VVArlz(self, path, newChmod):
  cmd = "chmod %s '%s' %s" % (newChmod, path, VV1jg5)
  result = FFTKR0(cmd)
  if result == "Successful" : FFipXT(self, result)
  else      : FFdw58(self, result)
 def VV6ZhN(self, path):
  parent = FFx9pN(path, False)
  self.session.openWithCallback(self.VVDhOg, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=parent, VVqlNR="Create Symlink here"))
 def VVDhOg(self, newPath):
  if len(newPath) > 0:
   target = self.VV5pAO(self.VVQlTC())
   target = FFVc4H(target)
   linkName = FFxtW5(target)
   dotIndex = linkName.find(".")
   if dotIndex > -1:
    linkName = linkName[:dotIndex]
   newPath = FFoWxR(newPath)
   link = newPath + linkName
   if   os.path.islink(FFVc4H(link)) : txt = ""
   elif os.path.ismount(link)     : txt = "MOUNT:"
   elif os.path.isfile(link)     : txt = "FILE:"
   elif os.path.isdir(link)     : txt = "DIRECTORY:"
   else          : txt = ""
   if len(txt) > 0:
    FFdw58(self, "Name already used for %s\n\n%s" % (txt, link))
    return
   txt  = "-> TARGET:\n%s\n\n" % target
   txt += "<- LINK:\n%s"  % link
   FFRMYv(self, BF(self.VVMng9, target, link), "Create Soft Link ?\n\n%s" % txt, VVAgUy=True)
 def VVMng9(self, target, link):
  cmd = 'LINK="%s"; if [ -e "$LINK" ]; then rm "$LINK"; fi; ln -sfv "%s" "%s" &>/dev/null %s' % (link, target, link, VV1jg5)
  result = FFTKR0(cmd)
  if result == "Successful" : FFipXT(self, result)
  else      : FFdw58(self, result)
 def VVTxpl(self, path):
  lastPart = FFxtW5(path)
  FF4z45(self, BF(self.VVhyfF, path), title="Rename", defaultText=lastPart, message="Enter New Name:")
 def VVhyfF(self, path, VVRD20):
  if VVRD20:
   parent = FFx9pN(path, True)
   if os.path.isdir(path):
    path = FFVc4H(path)
   newName = parent + VVRD20
   cmd = "mv '%s' '%s' %s" % (path, newName, VV1jg5)
   if VVRD20:
    if os.path.basename(path) != VVRD20:
     message = "%s\n\nTo:\n\n%s" % (path, newName)
     FFRMYv(self, BF(self.VViAkt, cmd), message, title="Rename file?")
    else:
     FFdw58(self, "Cannot use same name!", title="Rename")
 def VViAkt(self, cmd):
  result = FFTKR0(cmd)
  if "Fail" in result:
   FFdw58(self, result)
  self.VVcPTN()
 def VVH6Ci(self, preserve):
  title="Archive to .tar.gz"
  CCh3tv.VV7Nf4(self, VVLL7M=title, titleBg="#22003344", bodyBg="#22001122"
      , VVixvy  = BF(self.VVdTnh, title, preserve)
      , VVbYwR = BF(self.VVPk1o, title))
 def VVdTnh(self, title, preserve, VVXyP6):
  totSel = self["myMenu"].VVhxM5()
  totOk = totFail = 0
  VVXyP6.VVq8NF(totSel)
  VVXyP6.VVNc18 = ["", totSel, totOk, totFail, ""]
  VVXyP6.VVaks5("Prepareing targz file")
  VVXgOC = self["myMenu"].VVWyCw()
  lastPart = FFxtW5(VVXgOC) or "archive"
  outF = os.path.join(VVXgOC, lastPart + ".tar.gz")
  c = 0
  while FFCyVu(outF):
   c += 1
   outF = os.path.join(VVXgOC, lastPart + "_%d.tar.gz" % c)
  totOk = totFail = 0
  path = ""
  try:
   with iTar.open(outF, mode="w:gz") as tarF:
    for row in self["myMenu"].list:
     if not VVXyP6 or VVXyP6.isCancelled:
      return
     if row[2][6]:
      VVXyP6.VVxtQs(1)
      name  = FFVc4H(row[0][0])
      lastPath = FFxtW5(name)
      path  = os.path.join(VVXgOC, name)
      tarF.add(path, arcname=None if preserve else lastPath)
      totOk += 1
      if VVXyP6:
       VVXyP6.VVNc18 = [outF, totSel, totOk, totFail, path]
       VVXyP6.VVK5RO(totOk, lastPath)
  except:
   totFail += 1
   if VVXyP6:
    VVXyP6.VVNc18 = [outF, totSel, totOk, totFail, path]
 def VVPk1o(self, title, VVRI6P, VVNc18, threadCounter, threadTotal, threadErr):
  outF, totSel, totOk, totFail, path = VVNc18
  txt  = "%s:\n%s\n\n"   % (FFjt5L("Output File", VVSGsk), outF)
  txt += "Total\t: %d\n"  % totSel
  txt += "Archived\t: %d\n" % totOk
  if totFail   : txt += FFjt5L("Failed\t: %d\n" % totFail, VVz22H)
  if not VVRI6P: txt += "%s\n%s" % (FFjt5L("\nCancelled while copying:", VVz22H), path)
  FF4lCP(self, txt, title=title)
  self.VVcPTN()
 @FFOAKH()
 def VVhrqo(self, isMove):
  lst = []
  srcDir = self["myMenu"].VVWyCw()
  totSel = self["myMenu"].VVhxM5()
  if totSel == 0:
   ndx = self["myMenu"].l.getCurrentSelectionIndex()
   row = self["myMenu"].list[ndx]
   lst = [FFxtW5(row[0][0])]
  else:
   for row in self["myMenu"].list:
    if row[2][6]:
     lst.append(FFxtW5(row[0][0]))
  if lst:
   sDir = CFG.lastCopyMoveDir.getValue() or self["myMenu"].VVWyCw()
   self.session.openWithCallback(BF(self.VVPOxl, isMove, lst, srcDir), BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=sDir, VVqlNR="Move to here" if isMove else "Paste here"))
  else:
   FFjADj(self, "Nothing selected", 1500)
 def VVPOxl(self, isMove, lst, srcDir, dstDir):
  if dstDir:
   FFjt1c(CFG.lastCopyMoveDir, dstDir)
   FFimQ3(self, BF(self.session.openWithCallback, self.VVKtUM, CCZCVj, isMove, lst, srcDir, dstDir))
 def VVKtUM(self):
  self.VVcPTN()
 def VV49nJ(self):
  tot = self["myMenu"].VVhxM5()
  FFRMYv(self, self.VVezeB, "Delete %d item%s ?" % (tot, FFcacr(tot)), title="Delete Selection")
 @FFOAKH("Deleting ...", clearMsg=False)
 def VVezeB(self):
  path = self["myMenu"].VVWyCw()
  for row in self["myMenu"].list:
   if row[2][6]:
    FFOzbr(os.path.join(path, row[0][0]))
  FF28n1(self)
  self.VVcPTN()
 def VVRs0f(self, path):
  typ = FFTWKU(path)
  FFRMYv(self, BF(self.VVOGp8, path), "%s\n\nDelete %s ?" % (path, typ), title="Delete %s" % typ)
 @FFOAKH("Deleting ...", clearMsg=False)
 def VVOGp8(self, path):
  FFOzbr(path)
  FF28n1(self)
  self.VVcPTN()
 def VVeGt3(self, path, isFile):
  VVXgOC = self.VV21cx()
  if isFile:
   name = CClYaF.VVVDVC(VVXgOC, "file")
  else:
   fPath, fExt = os.path.splitext(path)
   if fPath and fExt and not VVmJwX(fPath) : name = os.path.basename(fPath)
   else          : name = CClYaF.VVVDVC(VVXgOC, "dir")
  self.VVEcgH(VVXgOC, name, isFile)
 def VVEcgH(self, VVXgOC, name, isFile):
  subj = "File" if isFile else "Directory"
  title = "Create New %s" % subj
  FF4z45(self, BF(self.VVRRa2, VVXgOC, name, isFile, title), title=title, defaultText=name, message="Enter %s Name:" % subj)
 def VVRRa2(self, VVXgOC, name, isFile, title, nName):
  if not nName or not nName.strip(): return
  nName = nName.strip()
  path = os.path.join(VVXgOC, nName)
  if nName != FFOu5Y(nName):
   self.VVEcgH(VVXgOC, nName, isFile)
   FFdw58(self, "Unallowed characters in name", title)
  elif FFCyVu(path):
   self.VVEcgH(VVXgOC, nName, isFile)
   FFdw58(self, "Already exists:\n\n%s" % VVXgOC, title)
  else:
   if isFile: cmd = "touch '%s' %s" % (path, VV1jg5)
   else  : cmd = "mkdir '%s' %s" % (path, VV1jg5)
   result = FFTKR0(cmd)
   if not "Successful" in result:
    FFdw58(self, result, title)
   self.VVcPTN(moveTo=os.path.basename(path) if isFile else FFoWxR(path))
 def VV8nL2(self, path):
  c1, c2, c3, c4 = VVJEMb, VVFuwR, VVIH76, VVA4XU
  VV3wat = []
  VV3wat.append((c1 + "List Package Files"         , "VVI3xN"     ))
  VV3wat.append((c1 + "Package Information"         , "package_Info"     ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c2 + "Install Package"          , "VVtZVo_CheckVersion" ))
  VV3wat.append((c2 + "Install Package (force reinstall)"     , "VVtZVo_ForceReinstall" ))
  VV3wat.append((c2 + "Install Package (force overwrite)"     , "VVtZVo_ForceOverwrite" ))
  VV3wat.append((c2 + "Install Package (force downgrade)"     , "VVtZVo_ForceDowngrade" ))
  VV3wat.append((c2 + "Install Package (ignore failed dependencies)"  , "VVtZVo_IgnoreDepends" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Remove Related Package"        , "VVGjSm_ExistingPackage" ))
  VV3wat.append((c3 + "Remove Related Package (force remove)"    , "VVGjSm_ForceRemove"  ))
  VV3wat.append((c3 + "Remove Related Package (ignore failed dependencies)" , "VVGjSm_IgnoreDepends" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Generate Feed Listing Info."        , "VV2eko"    ))
  VV3wat.append(("Convert to %s" % ("DEB" if path[-3:] == "ipk" else "IPK") , "VVcd3p1"     ))
  VV3wat.append(("Convert to .tar.gz %s(data part only)" % c4    , "VVcd3p2"     ))
  VV3wat.append(("Extract Files"           , "VVtTVH"     ))
  VV3wat.append(("Unbuild Package"           , "VVfaxL"     ))
  FFLFTC(self, BF(self.VVJKZj, path), VV3wat=VV3wat, VVwdmN=28, height=1000)
 def VVJKZj(self, path, item=None):
  if item is not None:
   if   item == "VVI3xN"      : self.VVI3xN(path)
   elif item == "package_Info"      : FFimQ3(self, BF(CCeSkW.VVLFsP, self, path))
   elif item == "VVtZVo_CheckVersion"  : self.VVtZVo(path, VVwFAi     )
   elif item == "VVtZVo_ForceReinstall" : self.VVtZVo(path, VVj9MD )
   elif item == "VVtZVo_ForceOverwrite" : self.VVtZVo(path, VVD9EU )
   elif item == "VVtZVo_ForceDowngrade" : self.VVtZVo(path, VVRA2G )
   elif item == "VVtZVo_IgnoreDepends" : self.VVtZVo(path, VVA8Es )
   elif item == "VVGjSm_ExistingPackage" : self.VVGjSm(path, VVAdjB    )
   elif item == "VVGjSm_ForceRemove"  : self.VVGjSm(path, VV9Fg4 )
   elif item == "VVGjSm_IgnoreDepends"  : self.VVGjSm(path, VVYJEp )
   elif item == "VV2eko"     : self.VV2eko(path)
   elif item == "VVcd3p1"     : self.VVcd3p(path, False)
   elif item == "VVcd3p2"     : self.VVcd3p(path, True)
   elif item == "VVtTVH"     : self.VVtTVH(path)
   elif item == "VVfaxL"     : self.VVfaxL(path)
 def VVI3xN(self, path):
  cTxt = lambda x: " echo -e '\n%s' %s;" % (x, FFSPDv(x, VV1fx4))
  txt  = FFjt5L("Package File:\n", VV1fx4)
  txt += "%s\n\n" % path
  txt += FFjt5L("Contents\n", VV1fx4)
  txt += "\n".join(FF3xOt("ar -t '%s';" % path))
  FF4lCP(self, txt)
 def VV2eko(self, path):
  if CCeSkW.VVq71e(self):
   txt, mTime = CCeSkW.VVy0xB(path)
   pFile = "%s-Packages-File.txt" % path
   tFile = "%s-Packages.stamps.txt" % path
   with open(pFile, "w") as pF: pF.write("%s\n" % txt)
   with open(tFile, "w") as tF: tF.write("%s\n" % mTime)
   self.VVcPTN()
   txt  = "Result files:\n\n"
   txt += "%s\n\n" % os.path.basename(pFile)
   txt += "%s" % os.path.basename(tFile)
   FF4lCP(self, txt)
 def VVtTVH(self, path):
  dest = FFx9pN(path, True) + os.path.basename(path)[:-4]
  cmd  =  FFvQ9y()
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd +=    FFb2oQ("mkdir '%s'" % dest)
  cmd +=    FFb2oQ("cd '%s'" % dest)
  cmd += "  echo 'Extrcting files ...';"
  cmd += "  ar -xo '%s';" % path
  cmd += "  echo -e 'Done.\n';"
  cmd += "  echo -e 'Output Directory:\n%s' %s;" % (dest, FFSPDv(dest, VVSGsk))
  cmd += "fi;"
  FFbi5l(self, cmd, VVoasw=self.VVcPTN)
 def VVfaxL(self, path):
  outP = path + "_"
  VVtdm0 = "DEBIAN" if path.endswith(".deb") else "CONTROL"
  binCmd = "&& rm -f \"$FILE\";"
  dataCmd = "\"$FILE\" -C '%s' && rm -f \"$FILE\";" % outP
  contCmd = "\"$FILE\" -C \"$CONTPATH\" && rm -f \"$FILE\";"
  zstCmd = "--use-compress-program=unzstd"
  zstErr = "NOTE: zstd not installed to decompress :"
  cmd  = FFvQ9y()
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += "  rm -rf '%s' > /dev/null 2>&1;" % outP
  cmd += "  mkdir '%s';"      % outP
  cmd += "  CONTPATH='%s/%s';"    % (outP, VVtdm0)
  cmd += '  mkdir "$CONTPATH";'
  cmd += "  cd '%s';"       % outP
  cmd += "  echo 'Unpacking ...';"
  cmd += "  ar -x '%s';"      % path
  cmd += "  FILE='%s/debian-binary';  [ -f \"$FILE\" ]             %s"  % (outP, binCmd)
  cmd += "  FILE='%s/data.tar.gz';    [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, dataCmd)
  cmd += "  FILE='%s/control.tar.gz'; [ -f \"$FILE\" ] && tar -xzf %s"  % (outP, contCmd)
  cmd += "  FILE='%s/data.tar.xz';    [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, dataCmd)
  cmd += "  FILE='%s/control.tar.xz'; [ -f \"$FILE\" ] && tar -xJf %s"  % (outP, contCmd)
  if FFayeZ("unzstd"):
   cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, dataCmd)
   cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && tar %s -xf  %s" % (outP, zstCmd, contCmd)
  else:
   cmd += "  FILE='%s/data.tar.zst';   [ -f \"$FILE\" ] && echo '%s data.tar.zst' %s;" % (outP, zstErr, FFSPDv(zstErr, VVYjI5))
   cmd += "  FILE='%s/control.tar.zst';[ -f \"$FILE\" ] && echo '%s control.tar.zst' %s;" % (outP, zstErr, FFSPDv(zstErr, VVYjI5))
  cmd += "  echo -e 'Done.\n';"
  cmd += "  echo -e '\nOutput Directory:\n%s' %s;" % (outP, FFSPDv(outP, VVSGsk))
  cmd += "fi;"
  FFbi5l(self, cmd, VVoasw=self.VVcPTN)
 def VVcd3p(self, path, toTar):
  if CCeSkW.VVq71e(self):
   outF = path[:-3]
   if toTar:
    title = "Convert to tar.gz"
    outF += "tar.gz"
   elif path.endswith(".ipk"):
    title = "Convert to DEB"
    outF += "deb"
   else:
    title = "Convert to IPK"
    outF += "ipk"
   if FFCyVu(path):
    fnc = BF(self.VVlbUI, path, outF, toTar, title)
    if FFCyVu(outF) : FFRMYv(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(outF))
    else    : fnc()
   else:
    FF8Wsn(self, path)
 @FFOAKH("Converting ...")
 def VVlbUI(self, path, outF, toTar, title):
  wDir = "/tmp/ajp_tmpDir"
  def VVs0FP():
   FFpwZS("rm -rf '%s'" % wDir)
  def VVQ5VQ(txt):
   FFdw58(self, txt, title=title)
  def VVOujN():
   FFipXT(self, "Converted to:\n\n%s" % outF, title=title)
   VVs0FP()
   self.VVcPTN()
  VVs0FP()
  FFpwZS("rm -f '%s'" % outF)
  if not FFpwZS("mkdir -p '%s';" % wDir):
   VVQ5VQ("Cannot create working dir.")
   return
  if not FFpwZS("cd '%s'; ar -x '%s'" % (wDir, path)):
   VVQ5VQ("Cannot extract package files.")
   return
  files = FF3xOt("find '%s' -type f" % wDir)
  if files:
   for fil in files:
    if   fil.endswith(".gz"): tool = "gzip"
    elif fil.endswith(".xz"): tool = "xz"
    else     : tool = ""
    if tool:
     if not FF7ymp("which %s" % tool):
      VVQ5VQ("You need to install : %s" % tool)
      return
     if not FF7ymp("%s -d '%s'" % (tool, fil)):
      VVQ5VQ("Cannot decompress file:\n\n%s" % os.path.basename(fil))
      return
  else:
   VVQ5VQ("No files extracted from package.")
   return
  if toTar:
   fName = os.path.basename(path)
   dFile = os.path.join(wDir, "data.tar")
   if FFCyVu(dFile):
    if FF7ymp("gzip < '%s' > '%s'" % (dFile, outF)):
     VVOujN()
    else:
     VVQ5VQ("Cannot create .tar.gz file for:\n\n%s" % fName)
   else:
    VVQ5VQ("No data in package file:\n\n%s" % fName)
   return
  tool = "gzip" if outF.endswith("ipk") else "xz"
  for fil in FF3xOt("find '%s' -type f" % wDir):
   if fil.endswith(".tar"):
    if not FF7ymp("%s '%s'" % (tool, fil)):
     VVQ5VQ("Cannot compress file:\n\n%s" % os.path.basename(fil))
     return
  files = FF3xOt("find '%s' -type f" % wDir)
  if not files :
   VVQ5VQ("Not enough files in package.")
   return
  debF = ctrlF = dataF = ""
  for fil in files:
   fName = os.path.splitext(os.path.basename(fil))[0]
   if   fName == "debian-binary" : debF = fil
   elif fName == "control.tar"  : ctrlF = fil
   elif fName == "data.tar"  : dataF = fil
  if   not debF : err = "debian-binary"
  elif not ctrlF : err = "control"
  elif not dataF : err = "data"
  else   : err = ""
  if err :
   VVQ5VQ("Missing '%s' file." % err)
   return
  if FFpwZS("ar -r '%s' '%s' '%s' '%s'" % (outF, debF, ctrlF, dataF)):
   VVOujN()
  else:
   VVQ5VQ("Cannot create package ('ar' failed).")
 def VVtZVo(self, path, cmdOpt):
  cmd = FF5sZa(cmdOpt, path)
  if cmd:
   cmd = "%s && echo -e '\nSUCCESSFUL' || echo -e '\nERROR FOUND !'" % cmd
   FFRMYv(self, BF(FFbi5l, self, cmd, VVoasw=FF2Wqb), "Install Package ?\n\n%s" % os.path.basename(path))
  else:
   FFfone(self)
 @FFOAKH()
 def VVGjSm(self, path, cmdOpt):
  infCmd = FF5sZa(VVaS8u, path)
  if not infCmd:
   FFfone(self)
   return
  pkg = FFQ45w("%s | grep Package" % infCmd)
  pkg = pkg.partition(":")[2].strip()
  if not pkg:
   FFdw58(self, "Cannot read Package Name from file.")
   return
  if CCeSkW.VVvDqA(pkg):
   cmd = FF5sZa(cmdOpt, pkg)
   FFRMYv(self, BF(FFbi5l, self, cmd, VVoasw=FF2Wqb), "Remove Package:\n\n%s" % pkg)
  else:
   FFdw58(self, "Package not installed:\n( %s )\n\nFrom file:\n%s" % (pkg, os.path.basename(path)))
 @FFOAKH()
 def VVKeBf(self, path):
  title = FFxtW5(path)
  pkg, err = CCeSkW.VVV8mM(path)
  if pkg : CCeSkW.VVLFsP(self, pkg, title)
  else : FFdw58(self, "No package info.", title)
 def VVwKHY(self, path, isDir):
  txt1 = "Archive to "
  txt2 = "Archive (Preserve Path Structure) to "
  VV3wat = []
  VV3wat.append(("%s.tar"  % txt1 , "archDir_tar"  ))
  VV3wat.append(("%s.tar.gz" % txt1 , "archDir_tar_gz" ))
  VV3wat.append(("%s.tar.xz" % txt1 , "archDir_tar_xz" ))
  VV3wat.append(("%s.tar.bz2" % txt1 , "archDir_tar_bz2" ))
  VV3wat.append(("%s.zip"  % txt1 , "archDir_zip"  ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("%s.tar"  % txt2 , "archPath_tar" ))
  VV3wat.append(("%s.tar.gz" % txt2 , "archPath_tar_gz" ))
  VV3wat.append(("%s.tar.xz" % txt2 , "archPath_tar_xz" ))
  VV3wat.append(("%s.tar.bz2" % txt2 , "archPath_tar_bz2"))
  VV3wat.append(("%s.zip"  % txt2 , "archPath_zip" ))
  if isDir and not self.VVJuPG:
   VV3wat.append(VVAL3j)
   VV3wat.append(('Convert to "ipk" Package', "convertDirToIpk" ))
   VV3wat.append(('Convert to "deb" Package', "convertDirToDeb" ))
  if isDir: c1, c2, title = "#11003322", "#11002222", "Archive Directory"
  else : c1, c2, title = "#11003344", "#11002244", "Archive File"
  FFLFTC(self, BF(self.VVOcev, path, isDir, title), VV3wat=VV3wat, title=title, VVwltY=c1, VVkxBG=c2)
 def VVOcev(self, path, isDir, title, item):
  if item is not None:
   if   item == "archDir_tar"  : self.VVXyc1(title, path, isDir, ".tar" , False)
   elif item == "archDir_tar_gz" : self.VVXyc1(title, path, isDir, ".tar.gz" , False)
   elif item == "archDir_tar_xz" : self.VVXyc1(title, path, isDir, ".tar.xz" , False)
   elif item == "archDir_tar_bz2" : self.VVXyc1(title, path, isDir, ".tar.bz2", False)
   elif item == "archDir_zip"  : self.VVXyc1(title, path, isDir, ".zip" , False)
   elif item == "archPath_tar"  : self.VVXyc1(title, path, isDir, ".tar" , True)
   elif item == "archPath_tar_gz" : self.VVXyc1(title, path, isDir, ".tar.gz" , True)
   elif item == "archPath_tar_xz" : self.VVXyc1(title, path, isDir, ".tar.xz" , True)
   elif item == "archPath_tar_bz2" : self.VVXyc1(title, path, isDir, ".tar.bz2", True)
   elif item == "archPath_zip"  : self.VVXyc1(title, path, isDir, ".zip" , True)
   elif item == "convertDirToIpk" : self.VVNgAR(path, False)
   elif item == "convertDirToDeb" : self.VVNgAR(path, True)
 def VVNgAR(self, path, VVyCS0):
  self.session.openWithCallback(self.VVcPTN, CCxz86, path=path, VVyCS0=VVyCS0)
 def VVXyc1(self, title, path, isDir, fileExt, preserveDirStruct):
  parent  = FFx9pN(path, True)
  lastPart = FFxtW5(path)
  archFile = lastPart + fileExt
  resultFile = parent + archFile
  if preserveDirStruct:
   archFile = resultFile
   targetDir = parent + lastPart
  else:
   targetDir = lastPart
  if isDir: outFile, srcTxt = archFile , "Source Directory"
  else : outFile, srcTxt = resultFile , "Source File"
  if   fileExt == ".tar"  : archCmd, toolCmd = "tar -cvf"  , "allOK='1';"
  elif fileExt == ".tar.gz" : archCmd, toolCmd = "tar -cvzf" , "allOK='1';"
  elif fileExt == ".tar.xz" : archCmd, toolCmd = "tar -cvJf" , FFKbNE()
  elif fileExt == ".tar.bz2" : archCmd, toolCmd = "tar -cvjf" , FFMAzK("bzip2" , "bzip2" , "BZip2" )
  elif fileExt == ".zip"  : archCmd, toolCmd = "zip -r"  , FFMAzK("zip" , "zip"  , "Zip"  )
  if preserveDirStruct:
   if archCmd.startswith("tar") and targetDir.startswith("/") : archCmd = "%s '%s' -C / '%s';" % (archCmd, outFile, targetDir[1:])
   else              : archCmd = "%s '%s' '%s';"    % (archCmd, outFile, targetDir)
  else:
   if isDir: archCmd = "cd '%s'; %s '../%s' *;" % (path, archCmd, outFile)
   else : archCmd = "cd '%s'; %s '%s' '%s';" % (parent, archCmd, outFile, os.path.basename(path))
  failed = "Process failed !"
  sep  = " echo -e '%s';" % SEP
  cmd  = toolCmd
  cmd += 'if [ "$allOK" -eq "1" ]; then '
  cmd += " echo -e 'Archiving ...\n';"
  cmd +=   sep
  cmd +=   FFb2oQ("rm -f '%s'" % archFile)
  cmd +=   archCmd
  cmd += " cd '%s';"      % parent
  cmd +=   sep
  cmd += " if [ $? -ne 0 ]; then "
  cmd += "  echo -e '\n%s\n' %s;"   % (failed, FFSPDv(failed, VVyFI2))
  cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
  cmd += " elif [ -f '%s' ]; then "  % archFile
  cmd += "  chmod 644 '%s';"    % archFile
  cmd += "  echo -e '\nDONE\n';"
  cmd += "  echo -e '%s:' %s;"   % (srcTxt, FFSPDv(srcTxt, VVGCYL))
  cmd += "  echo -e '%s\n';"    % path
  cmd += "  echo -e '%s:' %s;"   % ("Output", FFSPDv("Output", VVSGsk))
  cmd += "  echo -e '%s\n';"    % outFile
  cmd += " else"
  cmd += "  echo -e '\n%s\n' %s;"   % (failed, FFSPDv(failed, VVYjI5))
  cmd += "  rm -f '%s' > /dev/null 2>&1;" % archFile
  cmd += " fi;"
  cmd +=   sep
  cmd += "fi;"
  FFIdSm(self, cmd, VVoasw=self.VVcPTN, title=title)
 def VV2Fo3(self, path, isAll):
  if isAll: title, pathLst = "Add all Media in Directory to a Bouquet", CClYaF.VVhadP(FFx9pN(path, True))
  else : title, pathLst = "Add Media File to a Bouquet"   , [path]
  picker = CCMvE7(self, self, title, BF(self.VVZXrb, pathLst))
 def VVZXrb(self, pathLst):
  return CCMvE7.VVvoK9(pathLst)
 def VVJf2H(self, VVTiJ2):
  title = "Convert .zip to .tar.gz"
  if iZip.is_zipfile(VVTiJ2):
   tarPath = os.path.splitext(VVTiJ2)[0] + ".tar.gz"
   fnc  = BF(self.VVuyIo, VVTiJ2, tarPath, title)
   if FFCyVu(tarPath) : FFRMYv(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(tarPath), title=title)
   else     : fnc()
  else:
   FFdw58(self, "Invalid zip file:\n\n%s" % os.path.basename(VVTiJ2), title=title)
 @FFOAKH("Converting ...")
 def VVuyIo(self, VVTiJ2, tarPath, title):
  try:
   with iZip.ZipFile(VVTiJ2) as zipF:
    with iTar.open(tarPath, "w:gz") as tarF:
     for zipInfo in zipF.infolist():
      tarInfo = iTar.TarInfo(name=zipInfo.filename)
      tarInfo.size = zipInfo.file_size
      try: tarInfo.mtime = mktime(tuple(list(zipInfo.date_time) + [-1, -1, -1]))
      except: tarInfo.mtime = mktime((2025, 1, 1, 0, 0, 0, -1, -1, -1))
      tarF.addfile(tarinfo=tarInfo, fileobj=zipF.open(zipInfo.filename))
   ok = True
  except:
   ok = False
  if ok and FFCyVu(tarPath):
   FF4lCP(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(VVTiJ2), os.path.basename(tarPath)), title=title)
   self.VVcPTN()
  else:
   FFwgGB(tarPath)
   FFdw58(self, "Error while converting.", title=title)
 def VVmefC(self, tarPath):
  title = "Convert .tar.gz to .zip"
  if iTar.is_tarfile(tarPath):
   VVTiJ2 = tarPath[:-7] + ".zip"
   fnc  = BF(self.VV3B8l, tarPath, VVTiJ2, title)
   if FFCyVu(VVTiJ2) : FFRMYv(self, fnc, "File already exists:\n\n%s\n\nOverwrite ?" % os.path.basename(VVTiJ2), title=title)
   else     : fnc()
  else:
   FFdw58(self, "Invalid tar file:\n\n%s" % os.path.basename(tarPath), title=title)
 @FFOAKH("Converting ...")
 def VV3B8l(self, tarPath, VVTiJ2, title):
  try:
   with iTar.open(tarPath) as tar:
    with iZip.ZipFile(VVTiJ2, mode='w', compression=iZip.ZIP_DEFLATED) as zipF:
     for mem in tar.getmembers():
      if mem.isfile():
       mtime = datetime.fromtimestamp(mem.mtime)
       try: zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(mtime.year, mtime.month, mtime.day, mtime.hour, mtime.minute, mtime.second))
       except: zipInfo = iZip.ZipInfo(filename=mem.name, date_time=(2025, 1, 1, 0, 0, 0))
       zipF.writestr(zipInfo, tar.extractfile(mem).read(), compress_type=iZip.ZIP_DEFLATED)
   ok = True
  except:
   ok = False
  if ok and FFCyVu(tarPath):
   FF4lCP(self, "Done\n\nSource File\t: %s\nOutput File\t: %s" % (os.path.basename(tarPath), os.path.basename(VVTiJ2)), title=title)
   self.VVcPTN()
  else:
   FFwgGB(VVTiJ2)
   FFdw58(self, "Error while converting.", title=title)
 @FFOAKH("Converting ...")
 def VVCQLE(self, path, ext2):
  title = "Convert to .%s" % ext2
  p1, ext1 = os.path.splitext(path)
  p2 = "%s.%s" % (p1, ext2)
  if   ext1 == ".zst" : cmd1 = "zstd"
  elif ext1 == ".xz" : cmd1 = "xz"
  else    : cmd1 = "gzip"
  cmd2 = ext2 if ext2 == "xz" else "gzip"
  cmd  = FFb2oQ("rm -f '%s'" % p2)
  cmd += "%s -d < '%s' | %s > '%s'" % (cmd1, path, cmd2, p2)
  if FF7ymp(cmd):
   FFipXT(self, "Result:\n\n%s" % os.path.basename(p2), title=title)
   self.VVcPTN()
  else:
   FFdw58(self, "Could not convert:\n\n%s" % path, title=title)
 @FFOAKH()
 def VV2if2(self, path, isFhd):
  size = "1920x1080" if isFhd else "1280x720"
  title = "Convert to MVI (%s)" % size
  Dir  = FFoWxR(os.path.dirname(path))
  filName = os.path.splitext(os.path.basename(path))[0]
  m1v  = "%s%s_%s.m1v" % (Dir, filName, size)
  mvi  = "%s%s_%s.mvi" % (Dir, filName, size)
  FFpwZS("rm -f '%s' '%s'" % (m1v, mvi))
  if FFpwZS("ffmpeg -i '%s' -r 25 -b:v 20000 -s %s '%s'" % (path, size, m1v)) and FFCyVu(m1v):
   FFpwZS("mv -f '%s' '%s'" % (m1v, mvi))
   self.VVcPTN()
   FFipXT(self, "Converted to:\n\n%s" % os.path.basename(mvi), title=title)
  else:
   FFdw58(self, "Cannot convert this file !", title=title)
 def VVL2ZB(self, path):
  VV3wat, title, degS = [], "Rotate Image", str(u"\u00b0")
  if CC6u6z.VV181X(self, title, False, install=True):
   for i in range(90, 360, 90): VV3wat.append(("%s%s" % (i, degS), str(i)))
   VV3wat.append(VVAL3j)
   for i in range(1, 360): VV3wat.append(("%s%s" % (i, degS), str(i)))
   VVaTeF = ("Expand", BF(self.VVBhnp, path, title))
   FFLFTC(self, BF(self.VVjH68, path, title), VV3wat=VV3wat, width=700, VVaTeF=VVaTeF, VVlaGv=True, VVW5y5="OK = Same Size", title=title)
 def VVBhnp(self, path, title, VV7tND, angle):
  self.VVjH68(path, title, angle, rotExp=True)
 def VVImxq(self, path):
  VV3wat, title = [], "Flip Image"
  if CC6u6z.VV181X(self, title, False, install=True):
   VV3wat.append(("Horizontally" , "h"))
   VV3wat.append(("Vertically" , "v"))
   FFLFTC(self, BF(self.VVjH68, path, title), VV3wat=VV3wat, width=500, title=title)
 @FFOAKH()
 def VVjH68(self, path, title, item, rotExp=False):
  if not item: return
  rotTxt = "rotated_%s%s" % (item, "_exp" if rotExp else "")
  flpTxt = "flipped_"
  try:
   from PIL import Image, ImageOps
   im = Image.open(path)
   if   item == "h" : res, im = flpTxt + "H", ImageOps.mirror(im)
   elif item == "v" : res, im = flpTxt + "V", ImageOps.flip(im)
   else    : res, im = rotTxt  , im.rotate(-int(item), expand=rotExp, resample=3)
   fil, ext = os.path.splitext(path)
   outF = "%s_%s%s" % (fil, res, ext)
   im.save(outF)
   self.VVcPTN()
   FFipXT(self, "Saved to:\n\n%s" % outF, title=title)
  except Exception as e:
   FFdw58(self, str(e), title=title)
 def VVpeV4(self, path):
  title = "Save as"
  if CC6u6z.VV181X(self, title, False, install=True):
   fil, ext = os.path.splitext(path)
   VV3wat = []
   for s in ("png", "jpg", "gif", "tif", "bmp"):
    VV3wat.append((s, ) if s == ext[1:] else (s, s))
   FFLFTC(self, BF(self.VVgOjh, path, title), VV3wat=VV3wat, width=500, title=title)
 @FFOAKH()
 def VVgOjh(self, path, title, dstExt):
  if not dstExt: return
  try:
   from PIL import Image, ImageSequence
   im = Image.open(path)
   outTyp = "RGBA" if dstExt == "png" else "RGB"
   srcF, srcExt = os.path.splitext(path)
   if srcExt in (".tif", ".gif"):
    txt = "Saved tif Frames:\n\n"
    name = "page" if srcExt == ".tif" else "frame"
    for i, page in enumerate(ImageSequence.Iterator(im), start=1):
     outF = "%s_%s_%03d.%s" % (path, name, i, dstExt)
     page = page.convert(outTyp)
     page.save(outF)
     txt += "  %s\n" % os.path.basename(outF)
    self.VVcPTN()
    FF4lCP(self, txt, title=title)
   else:
    im = im.convert(outTyp)
    outF = "%s.%s" % (srcF, dstExt)
    fnc = BF(self.VVHG7m, title, im, outF)
    if FFCyVu(outF) : FFRMYv(self, fnc, "Overwrite existing file ?\n\n%s" % outF, title=title)
    else    : fnc()
  except Exception as e:
   FFdw58(self, str(e), title=title)
 def VVHG7m(self, title, im, outF):
  try:
   im.save(outF)
   self.VVcPTN()
   FFipXT(self, "Saved to:\n\n%s" % outF, title=title)
  except Exception as e:
   FFdw58(self, str(e), title=title)
 @FFOAKH()
 def VV72l5(self, path, mode):
  ext = "png" if mode == 1 else "jpg"
  title = "Convert to %s" % ext
  outF = path[:-3] + ext
  FFwgGB(outF)
  res = FFQ45w('ffmpeg -hide_banner -i "%s" -frames:v 1 "%s"' % (path, outF))
  if FFCyVu(outF):
   FFipXT(self, "Saved to:\n\n%s" % outF, title=title)
   self.VVcPTN()
  elif "unhandled version" in res : FFdw58(self, "Your ffmpeg cannot handle mvi.", title=title)
  else       : FFdw58(self, "Conversion Error", title=title)
 @FFOAKH()
 def VVOiJy(self, path):
  title = "Convert to Base64 String"
  try:
   ext = os.path.splitext(path)[1][1:].lower().replace("jpg", "jpeg")
   outF = os.path.join(os.path.dirname(path), os.path.basename(path) + "_base64.txt")
   with open(path, "rb") as f: b64 = b64encode(f.read()).decode()
   with open(outF, "w") as f: f.write("data:image/%s;base64,%s" % (ext, b64))
   FFipXT(self, "Saved to : %s\n\n" % outF, title=title)
   self.VVcPTN()
  except Exception as e:
   FFdw58(self, str(e), title=title)
 def VVxzz6(self, path):
  title = "Set as PIcon for current channel"
  pPath = CCafIt.VVjkKT()
  if VVmJwX(pPath):
   if CC6u6z.VV181X(self, title, False, cbFnc=BF(self.VVxzz6, path)):
    picon = "%s%s.png" % (pPath, CC3rDi(self.session).VVXbok.strip(":").replace(":", "_").upper())
    VV3wat = []
    for item in ((50,30),(96,64),(100,60),(220,132),(400,160),(400,240),(500,300)):
     VV3wat.append(("%d x %d" % (item), item))
    VVJbOd = self.VVNcbR
    VVaTeF = ("Stretch", BF(self.VVvLyr, title, path, picon))
    VV7tND = FFLFTC(self, BF(self.VVkdu9, title, path, picon, False), VV3wat=VV3wat, width=700, title='PIcon Max. Size', VVJbOd=VVJbOd, VVaTeF=VVaTeF, VVW5y5="OK = Fit within size")
    VV7tND.VVx2yy(3)
  else:
   FFdw58(self, "PIcons path not found:\n\n%s\n\n( You can change it in Settings )" % pPath, title=title)
 def VVvLyr(self, title, path, picon, selectionObj, item):
  self.VVkdu9(title, path, picon, True, item)
  selectionObj.cancel()
 def VVkdu9(self, title, path, picon, stretch, sz=None):
  if sz:
   try:
    from PIL import Image
    im = Image.open(path)
    if stretch: im = im.resize(sz, Image.ANTIALIAS)
    else   : im.thumbnail(sz)
    im.save(picon)
    CCvjVs.VV0Xds(self, VV7VUc=CCvjVs.VVvrVY)
   except Exception as e:
    FFdw58(self, "Image Processing error:\n\n%s" % e)
 def VVNcbR(self, VV7tND, txt, ref, ndx):
  FFw2rR(self, "_help_resize", "Picture File Resizing")
 def VVi42l(self, path):
  CCkEI5.VVMYQY(self, BF(self.VVgZQF, path))
 def VVgZQF(self, path, rType=None):
  if rType:
   FFimQ3(self, BF(self.VVTWR0, self, path, rType), title="Playing Media ...")
 @staticmethod
 def VVTWR0(SELF, path, rType=""):
  if   rType     : prefix = rType
  elif path.endswith(".ts") : prefix = "1"
  else      : prefix = CFG.iptvAddToBouquetRefType.getValue()
  VVPxk5 = "%s:%s%s" % (prefix, "0:" * 9, path)
  CCqWM2.VVHc02(SELF.session, VVEBd5=False, VVdxwH=False, VVaHNe=VVPxk5)
 @staticmethod
 def VV4zSS(SELF):
  serv = SELF.session.nav.getCurrentlyPlayingServiceReference()
  fPath = serv and serv.getPath()
  if fPath and FFCyVu(fPath):
   fDir, fName = os.path.split(fPath)
   return fPath, FFoWxR(fDir), fName
  return "", "", ""
 @staticmethod
 def VVdlF7(path):
  try:
   st = os.statvfs(path)
   total = st.f_frsize * st.f_blocks
   used = st.f_frsize * (st.f_blocks - st.f_bfree)
   free = st.f_frsize * st.f_bfree
   avail = st.f_frsize * st.f_bavail
   return total, used, free, avail, ""
  except Exception as e:
   return 0, 0, 0, 0, str(e)
 @staticmethod
 def VV99gM(size, mode=0):
  txt = CClYaF.VVAi2d(size)
  if size >= 1024 :
   commaSize = format(size, ',d')
   if mode == 1: return "%s (%s)"   % (txt, commaSize)
   if mode == 2: return "%s (%s)"   % (commaSize, txt)
   if mode == 3: return "%s (%s)"   % (size, txt)
   if mode == 4: return "%s"    % txt
   else  : return "%s  ( %s bytes )" % (txt, commaSize)
  else:
   return txt
 @staticmethod
 def VVAi2d(bytes):
  kilo, unit = 1024.0, ("B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
  if bytes < kilo:
   return "%d B" % bytes
  i = int(iFloor(iLog(bytes, 1024)))
  s = str("%.2f" % (bytes / (kilo ** i))).rstrip(".0")
  return "%s %s" % (s, unit[i])
 @staticmethod
 def VVgIOw(path):
  rangeList = list(range(0x20, 0x100))
  try:
   with open(path, 'rb') as f:
    bytes = f.read(1024)
   textchars = bytearray({7,8,9,10,12,13,27} | set(rangeList) - {0x7f})
   return bool(bytes.translate(None, textchars))
  except:
   return True
 @staticmethod
 def VVSOog(SELF, path, title=""):
  try:
   with ioOpen(path, "r", encoding="UTF-8") as f:
    txt = f.read()
   return True
  except:
   if title:
    FFdw58(SELF, "File is not in 'UTF-8' Encoding:\n\n%s" % path, title=title.strip())
   return False
 @staticmethod
 def VVI46y(addDot=False):
  tDict = CCHmnm.VViatp()
  lst = list(tDict["mov"])
  lst.extend(list(tDict["mus"]))
  if addDot: lst = ["." + x for x in lst]
  return tuple(lst)
 @staticmethod
 def VVhadP(path):
  lst = []
  for ext in CClYaF.VVI46y():
   lst.extend(FFkzic(path, "*.%s" % ext))
  return sorted(lst, key=FFgEff(FFa9eD))
 @staticmethod
 def VVJ1XA(path):
  return FFpwZS("tar -tzf '%s'" % path)
 @staticmethod
 def VVuTcL(path):
  path = os.path.abspath(path)
  while not os.path.ismount(path):
   path = os.path.dirname(path)
  return path
 @staticmethod
 def VVR33x(addTrailingSlash=True):
  Dict = {}
  for line in FFL19l("/proc/mounts"):
   parts = line.split(" ")
   if len(parts) > 2:
    fs, mp, typ = parts[:3]
    if addTrailingSlash and os.path.isdir(mp):
     mp = FFoWxR(mp)
    isNet = ":" in fs or fs.startswith("//")
    Dict[mp] = (fs, typ, isNet)
  return Dict
 @staticmethod
 def VVOBE5():
  lst = []
  for key, val in CClYaF.VVR33x().items():
   if val[2]: lst.append(key)
  return lst
 @staticmethod
 def VV8isu(lst, fromFind=True):
  if len(lst) == 1 and lst[0] == VVfDY7:
   return VVfDY7
  elif fromFind:
   for line in lst:
    span = iSearch(r"find:\s*(.+):\s*Input\/output error", line, IGNORECASE)
    if span:
     return 'Filesystem Error in:\n\n%s' % span.group(1)
  for ln in lst:
   if not ln.startswith("/"): return "Error: %s" % ln
  return ""
 @staticmethod
 def VVVDVC(path, name):
  c = 0
  newNm = name
  while VVmJwX(os.path.join(path, newNm)):
   c += 1
   newNm = "%s%s" % (name, c)
  return newNm
class CCHmnm(MenuList):
 VVY06p   = 0
 VVGwB9   = 1
 VVg9Rj   = 2
 VVVUY9   = 3
 VV2gkr   = 4
 VVYQP6   = 5
 VVYWUJ   = 6
 VVoTQa   = 7
 VVoQ0w   = "<List of Storage Devices>"
 VVXivL  = "<Parent Directory>"
 VV4dV3   = 0
 VVS98t   = 1
 VVPC3A = 2
 VVPZRP  = 3
 VVzq0M   = 4
 VV8NQQ   = 5
 FILE_TYPE_LINK   = 6
 VVP8p8  = 7
 PROHIBITED_FILES  = ["/%s/" % x for x in ("DEBIAN","bin","boot","dev","etc","hdd","home","lib","media","mnt","network","proc","run","sbin","sys","tmp","usr","var")]
 def __init__(self, enableWrapAround=False, directory="/", VVEpbW=True, VV1aG0=True, VVodaQ=True, VV2mDa=None, VVWIJv=False, VVwbd9=False, isTop=False, VVa3hn=None, VVVljT=1000, VVwdmN=30, VV8c7y=30):
  MenuList.__init__(self, list, enableWrapAround, eListboxPythonMultiContent)
  self.VVEpbW  = VVEpbW
  self.VV1aG0    = VV1aG0
  self.VVodaQ  = VVodaQ
  self.VV2mDa  = VV2mDa
  self.VVWIJv   = VVWIJv or []
  self.VVwbd9   = VVwbd9 or []
  self.isTop     = isTop
  self.additional_extensions = VVa3hn
  self.VVVljT    = VVVljT
  self.VVwdmN    = VVwdmN
  self.VV8c7y    = VV8c7y
  self.VVX5XV   = eServiceCenter.getInstance()
  self.mountpoints   = []
  self.networkMounts   = CClYaF.VVOBE5()
  self.current_directory  = None
  self.current_mountpoint  = None
  self.multiSelect_color  = FFRUST("#11ff4444")
  self.l.setFont(0, gFont(VVNhAq, self.VVwdmN))
  self.l.setItemHeight(self.VV8c7y)
  self.png_mntN   = CCHmnm.VVKUQG("mntN")
  self.png_mntL   = CCHmnm.VVKUQG("mntL")
  self.png_mem   = CCHmnm.VVKUQG("mem")
  self.png_usb   = CCHmnm.VVKUQG("usb")
  self.png_fil   = CCHmnm.VVKUQG("fil")
  self.png_dir   = CCHmnm.VVKUQG("dir")
  self.png_dirup   = CCHmnm.VVKUQG("dirup")
  self.png_slwfil   = CCHmnm.VVKUQG("slwfil")
  self.png_slbfil   = CCHmnm.VVKUQG("slbfil")
  self.png_slwdir   = CCHmnm.VVKUQG("slwdir")
  self.VVjChm()
  self.VVf5s1(directory)
 @staticmethod
 def VVKUQG(category):
  return LoadPixmap("%s%s.png" % (VVIp2p, category), getDesktop(0))
 @staticmethod
 def VViatp():
  return {"pic":("bmp","gif","jpe","jpeg","jpg","png","svg"),"mov":("3g2","3gp","asf","avi","divx","flv","ifo","iso","m2ts","m4v","mkv","mod","mov","mp4","mpe","mpeg","mpg","mts","mvi","ogm","ogv","pva","rm","rmvb","stream","ts","vob","webm","wmv","wtv","h264","h265","mjpeg","mk3d","mks","xvid"),"mus":("aac","ac3","alac","amr","ape","au","dts","flac","m2a","m4a","mid","mka","mp2","mp3","oga","ogg","wav","wave","wma","wv","m4b","m4p","mpc","wpl"),"txt":("cfg","conf","htm","html","txt","xml"),"py":("py","pyo","pyc"),"tar":("bz2","gz","tar","xz"),"rar":("rar",),"zip":("zip",),"p7z":("7z",),"zst":("zst",),"ipk":("ipk",),"deb":("deb",),"scr":("sh",),"m3u":("m3u","m3u8")}
 def VVnyoE(self, name, absolute=None, isDir=False, typ=None, png=None):
  if absolute and isDir:
   path = absolute
   path = FFVc4H(path)
   if os.path.islink(path) and not name in (self.VVoQ0w, self.VVXivL):
    png = self.png_slwdir
    name += FFjt5L(" -> " , VV1fx4) + FFjt5L(os.readlink(path), VVSGsk)
  tableRow = [ (absolute, isDir, typ) ]
  tableRow.append((eListboxPythonMultiContent.TYPE_TEXT, self.VV8c7y + 10, 0, self.VVVljT, self.VV8c7y, 0, LEFT | RT_VALIGN_CENTER, name))
  if png is not None:
   tableRow.append(CCnES5.VVmxDV(0, 2, self.VV8c7y-4, self.VV8c7y-4, png))
  return tableRow
 @staticmethod
 def VVMyky(path):
  ext = os.path.splitext(path)[1]
  if ext:
   ext = ext.lstrip(".").lower()
   for cat, lst in CCHmnm.VViatp().items():
    if ext in lst:
     return cat
  return ""
 def VVjChm(self):
  self.mountpoints = [os.path.join(p.mountpoint, "") for p in harddiskmanager.getMountedPartitions()]
  self.mountpoints.sort(reverse=True)
 def VVMaWM(self, file):
  file = os.path.join(os.path.realpath(file), "")
  for m in self.mountpoints:
   if file.startswith(m):
    return m
  return False
 def VV2lMp(self, file):
  if os.path.realpath(file) == file:
   return self.VVMaWM(file)
  else:
   if file[-1] == "/":
    file = file[:-1]
   mp = self.VVMaWM(file)
   last = file
   file = os.path.dirname(file)
   while last != "/" and mp == self.VVMaWM(file):
    last = file
    file = os.path.dirname(file)
   return os.path.join(last, "")
 def getSelection(self):
  if self.l.getCurrentSelection() is None:
   return None
  return self.l.getCurrentSelection()[0]
 def VVRH7p(self, isUp):
  ndx = self.l.getCurrentSelectionIndex()
  row = self.list[ndx]
  bg = self.multiSelect_color if row[2][6] == None else None
  ndx = self.getSelectionIndex()
  if isUp:
   if ndx > 0:
    self.moveToIndex(self.getSelectionIndex() - 1)
  else:
   if ndx < len(self.list) - 1:
    self.moveToIndex(self.getSelectionIndex() + 1)
  iconData = self.VVkjkG(row, bg)
  if iconData:
   row[2] = iconData
   self.l.setList(self.list)
   return True
  else:
   return False
 def VV0y0E(self, isSel, fManMode, cbFnc):
  bg = self.multiSelect_color if isSel else None
  if isSel and fManMode in (CClYaF.VVkJTs, CClYaF.VV9N82):
   VVXgOC = self.VVWyCw()
   for ndx, row in enumerate(self.list):
    if row[0][0]:
     path = os.path.join(VVXgOC, row[0][0])
     isDir = os.path.isdir(path)
     if fManMode == CClYaF.VVkJTs and not isDir or fManMode == CClYaF.VV9N82 and isDir:
      iconData = self.VVkjkG(row, bg)
      if iconData:
       row[2] = iconData
  else:
   for ndx, row in enumerate(self.list):
    iconData = self.VVkjkG(row, bg)
    if iconData:
     row[2] = iconData
  self.l.setList(self.list)
  cbFnc()
 def VVkjkG(self, row, bg):
  if self.VVsyuA(row):
   iconData = list(row[2])
   iconData[6] = bg
   iconData[7] = bg
   return tuple(iconData)
  else:
   return None
 def VVsyuA(self, row):
  if not row[0][0] in self.mountpoints:
   if   row[0][2] in (self.VV8NQQ, self.FILE_TYPE_LINK): return True
   elif row[0][2] == self.VVzq0M:
    if   VVWe5f           : return True
    elif not row[0][0] in self.PROHIBITED_FILES    : return True
  return False
 def VVK4p4(self):
  return self.VVsyuA(self.list[self.l.getCurrentSelectionIndex()])
 def VVhxM5(self):
  tot = 0
  for row in self.list:
   if row[2][6]:
    tot += 1
  return tot
 def VVuXHI(self, dir, parents):
  dir = os.path.realpath(dir)
  for p in parents:
   if dir.startswith(p):
    return True
  return False
 def VVf5s1(self, directory, selItem=None):
  self.list = []
  directories = []
  files = []
  if self.current_directory is None:
   if directory and self.VVodaQ:
    self.current_mountpoint = self.VV2lMp(directory)
   else:
    self.current_mountpoint = None
  self.current_directory = directory
  if directory is None:
   if self.VVodaQ:
    for p in harddiskmanager.getMountedPartitions():
     path = os.path.join(p.mountpoint, "")
     if path not in self.VVwbd9 and not self.VVuXHI(path, self.VVWIJv):
      if path == "/" : png = self.png_mem
      else   : png = self.png_usb
      self.list.append(self.VVnyoE(name=p.description, absolute=path, isDir=True, typ=self.VV4dV3, png=png))
    path = "/"
    if path not in self.VVwbd9 and not self.VVuXHI(path, self.VVWIJv):
     for item in self.list:
      if path == item[0][0]:
       break
     else:
      self.list.append(self.VVnyoE(name="INTERNAL FLASH", absolute="/", isDir=True, typ=self.VVS98t, png=self.png_mem))
  else:
   if FFCyVu(directory):
    try:
     files = os.listdir(directory)
    except:
     files = []
    tmpfiles = files[:]
    for x in tmpfiles:
     tPath = directory + x
     if os.path.isdir(tPath):
      directories.append(tPath + "/")
      files.remove(x)
     elif not FFq2rn(tPath):
      files.remove(x)
  if directory is not None and self.VVEpbW and not self.isTop:
   if directory == self.current_mountpoint and self.VVodaQ:
    self.list.append(self.VVnyoE(name=self.VVoQ0w, absolute=None, isDir=True, typ=self.VVPC3A, png=self.png_dirup))
   elif (directory != "/") and not (self.VVwbd9 and self.VVMaWM(directory) in self.VVwbd9):
    self.list.append(self.VVnyoE(name=self.VVXivL, absolute='/'.join(directory.split('/')[:-2]) + '/', isDir=True, typ=self.VVPZRP, png=self.png_dirup))
  if self.VVEpbW:
   for x1 in directories:
    if not (self.VVwbd9 and self.VVMaWM(x1) in self.VVwbd9) and not self.VVuXHI(x1, self.VVWIJv):
     name = x1.split('/')[-2]
     x2 = FFoWxR(os.path.realpath(x1))
     if os.path.ismount(x2):
      if   x2 in self.mountpoints  : png = self.png_usb
      elif x2 in self.networkMounts : png = self.png_mntN
      else       : png = self.png_mntL
     else        : png = self.png_dir
     self.list.append(self.VVnyoE(name=name, absolute=x1, isDir=True, typ=self.FILE_TYPE_LINK if os.path.islink(FFVc4H(x1)) else self.VVzq0M, png=png))
  if self.VV1aG0:
   for x in files:
    path = directory + x
    name = x
    png  = self.png_fil
    if os.path.islink(FFVc4H(path)):
     try:
      target = os.readlink(path)
      if FFCyVu(target):
       png = self.png_slwfil
       name += FFjt5L(" -> " , VV1fx4) + FFjt5L(target, VVSGsk)
      else:
       png = self.png_slbfil
       name += FFjt5L(" -> " , VV1fx4) + FFjt5L(target, VVYjI5)
     except:
      png = self.png_slbfil
    elif "." in name:
     category = self.VVMyky(name)
     if category:
      png = LoadPixmap("%s%s.png" % (VVIp2p, category))
    elif not FFq2rn(path):
     png = LoadPixmap("%serr.png" % VVIp2p)
    if (self.VV2mDa is None) or iCompile(self.VV2mDa[0], flags=self.VV2mDa[1]).search(path):
     self.list.append(self.VVnyoE(name=name, absolute=x , isDir=False, typ=self.VV8NQQ, png=png))
  if self.VVodaQ and len(self.list) == 0:
   self.list.append(self.VVnyoE(name=FFjt5L("No USB connected", VVA4XU), absolute=None, isDir=False, typ=self.VVP8p8, png=self.png_usb))
  self.l.setList(self.list)
  self.VVhNXg()
  if selItem is not None:
   i = 0
   self.moveToIndex(0)
   for x in self.list:
    p = x[0][0]
    if isinstance(p, eServiceReference): p = p.getPath()
    if p == selItem: self.moveToIndex(i)
    i += 1
 def VVWyCw(self):
  return self.current_directory
 def VV2bmH(self):
  if self.getSelection() is None:
   return False
  return self.getSelection()[1]
 def VVe2l0(self):
  return self.VViSlA() and self.VVWyCw()
 def VViSlA(self):
  return self.list[0][1][7] in (self.VVoQ0w, self.VVXivL)
 def descent(self):
  if self.getSelection() is None:
   return
  self.VVf5s1(self.getSelection()[0], self.current_directory)
 def VVvQmA(self):
  if self.getSelection() is None:
   return None
  x = self.getSelection()[0]
  if isinstance(x, eServiceReference):
   x = x.getPath()
  return x
 def execBegin(self):
  harddiskmanager.on_partition_list_change.append(self.VVMrsl)
 def execEnd(self):
  harddiskmanager.on_partition_list_change.remove(self.VVMrsl)
 def VVMrsl(self, action, device):
  self.VVjChm()
  if self.current_directory is None:
   self.VVs0ks()
 def VVs0ks(self):
  tDict = {}
  for row in self.list:
   if row[2][6]:
    tDict[row[0][0]] = 1
  fName = self.VVvQmA()
  self.VVf5s1(self.current_directory, fName if fName and FFCyVu(os.path.join(self.current_directory, fName)) else None)
  isSel = 0
  if tDict:
   for row in self.list:
    if tDict.get(row[0][0], 0):
     row[2] = list(row[2])
     row[2][6] = row[2][7] = self.multiSelect_color
     row[2] = tuple(row[2])
     isSel = 1
   self.l.setList(self.list)
  return isSel
 def VVdj0P(self):
  mode = CFG.browserSortMode.getValue()
  mix  = CFG.browserSortMix.getValue()
  sAZ, sZA, s09, s90, sNO, sON = "A > Z", "Z > A", "0 > 9", "9 > 0", "New > Old", "Old > New"
  if mode == self.VVY06p : nameAlpMode, nameAlpTxt = self.VVGwB9, sZA
  else       : nameAlpMode, nameAlpTxt = self.VVY06p, sAZ
  if mode == self.VVg9Rj : nameNumMode, nameNumTxt = self.VVVUY9, s90
  else       : nameNumMode, nameNumTxt = self.VVg9Rj, s09
  if mode == self.VV2gkr : dateMode, dateTxt = self.VVYQP6, sON
  else       : dateMode, dateTxt = self.VV2gkr, sNO
  if mode == self.VVYWUJ : typeMode, typeTxt = self.VVoTQa, sZA
  else       : typeMode, typeTxt = self.VVYWUJ, sAZ
  if   mode in (self.VVY06p, self.VVGwB9): txt = "Name (%s)" % (sAZ if mode == self.VVY06p else sZA)
  elif mode in (self.VVg9Rj, self.VVVUY9): txt = "Name (%s)" % (s09 if mode == self.VVY06p else s90)
  elif mode in (self.VV2gkr, self.VVYQP6): txt = "Date (%s)" % (sNO if mode == self.VV2gkr else sON)
  elif mode in (self.VVYWUJ, self.VVoTQa): txt = "Type (%s)" % (sAZ if mode == self.VVYWUJ else sZA)
  if mix:
   txt += " .. Mixed"
  return nameAlpMode, nameAlpTxt, nameNumMode, nameNumTxt, dateMode, dateTxt, typeMode, typeTxt, "Cur = by %s" % txt
 def VVhNXg(self, mode=None, isMix=False, isNum=False):
  if not mode is None:
   FFjt1c(CFG.browserSortMode, mode)
   FFjt1c(CFG.browserSortMix, isMix)
  if self.list:
   if self.VViSlA() : item0, topRow = 1, self.list[0]
   else    : item0, topRow = 0, None
   mode = CFG.browserSortMode.getValue()
   isMix = CFG.browserSortMix.getValue()
   if mode in (self.VVY06p, self.VVGwB9):
    rev = True if mode == self.VVGwB9 else False
    if isMix: self.list = sorted(self.list[item0:], key=lambda x: x[1][7]         , reverse=rev)
    else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], x[1][7]), reverse=rev)
   elif mode in (self.VVg9Rj, self.VVVUY9):
    rev = True if mode == self.VVVUY9 else False
    self.list = sorted(self.list[item0:], key=FFgEff(BF(self.VVMJna, isMix, rev)), reverse=rev)
   elif mode in (self.VV2gkr, self.VVYQP6):
    rev = True if mode == self.VVYQP6 else False
    self.list = sorted(self.list[item0:], key=FFgEff(BF(self.VVJXRa, isMix)), reverse=rev)
   else:
    rev = True if mode == self.VVoTQa else False
    if isMix: self.list = sorted(self.list[item0:], key=lambda x: os.path.splitext(x[1][7])[1]            , reverse=rev)
    else : self.list = sorted(self.list[item0:], key=lambda x: (x[0][1] if rev else not x[0][1], os.path.splitext(x[1][7])[1], x[1][7]) , reverse=rev)
   if topRow:
    self.list.insert(0, topRow)
   self.l.setList(self.list)
 def VVMJna(self, mix, rev, p1, p2):
  dir1, name1 = p1[0][1], p1[1][7]
  dir2, name2 = p2[0][1], p2[1][7]
  if mix:
   return FFa9eD(name1.lower(), name2.lower())
  else:
   if rev: dir1, dir2 = dir2, dir1
   return FFyH6N(dir2, dir1) or FFa9eD(name1, name2)
 def VVJXRa(self, mix, p1, p2):
  dir1 = p1[0][1]
  dir2 = p2[0][1]
  if mix or dir1 == dir2:
   path1 = "" if dir1 else self.current_directory
   path2 = "" if dir2 else self.current_directory
   try:
    stat1 = os.stat(path1 + p1[0][0])
    stat2 = os.stat(path2 + p2[0][0])
    if mix : return FFyH6N(stat2.st_ctime, stat1.st_ctime)
    else : return FFyH6N(dir2, dir1) or FFyH6N(stat2.st_ctime, stat1.st_ctime)
   except:
    pass
  return 0
class CC1FS2(Screen):
 def __init__(self, session, defFG="", defBG="", onlyBG=False, isBgMode=True):
  self.skin, self.VVfOli = FFiNEe(VVrQU9, 900, 700, 35, 10, 14, "#22333333", "#22333333", 30, VVeFSs=40)
  self.session  = session
  self.onlyBG   = onlyBG
  self.Title   = "Color"
  self.VVQ3Dp  = 6
  self.VVsHeH  = 8
  self.VVGape   = []
  self.curRow   = 0
  self.curCol   = 0
  self.isBgMode  = isBgMode
  self.defFG   = self.VVjn8i(defFG, "#00FFFFFF")
  self.defBG   = self.VVjn8i(defBG, "#11000000")
  self.transpFg  = int(self.defFG[1:3], 16)
  self.transpBg  = int(self.defBG[1:3], 16)
  self.colors   = (   ("FFFFFF", "FFC0C0", "FFE0C0", "FFFFC0", "C0FFC0", "C0FFFF", "C0C0FF", "FFC0FF")
        , ("E0E0E0", "FF8080", "FFC080", "FFFF80", "80FF80", "80FFFF", "8080FF", "FF80FF")
        , ("C0C0C0", "FF0000", "FF8000", "FFFF00", "00FF00", "00FFFF", "0000FF", "FF00FF")
        , ("808080", "C00000", "C04000", "C0C000", "00C000", "00C0C0", "0000C0", "C000C0")
        , ("404040", "800000", "804000", "808000", "008000", "008080", "000080", "800080")
        , ("000000", "400000", "804040", "404000", "004000", "004040", "000040", "400040")
        )
  FFZMxC(self, self.Title)
  self["keyRed"].show()
  FFRLNq(self["keyGreen"] , "< > Transp.")
  FFRLNq(self["keyYellow"], "Foreground")
  FFRLNq(self["keyBlue"] , "Background")
  if self.onlyBG:
   self["keyYellow"].hide()
   self["keyBlue"].hide()
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    self["myColor%d%d" % (row, col)] = Label()
  self["myColorPtr"] = Label()
  self["myColorTst"] = Label("This is a test message.\n0123456789")
  FFHlAU(self,
  {
   "ok"   : self.VVxY7G     ,
   "green"   : self.VVxY7G     ,
   "yellow"  : BF(self.VVrkD4, False)  ,
   "blue"   : BF(self.VVrkD4, True)  ,
   "up"   : self.VVx0di       ,
   "down"   : self.VVDBsZ      ,
   "left"   : self.VVziFC      ,
   "right"   : self.VVLe1s      ,
   "last"   : BF(self.VVOXz3, -5) ,
   "next"   : BF(self.VVOXz3, 5) ,
   "cancel"  : BF(self.close, None, None)
  })
  self.onShown.append(self.VV7OzD)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    FFZ0AC(self["myColor%d%d" % (row, col)], "#11%s" % self.colors[row][col])
  c = "#11333333"
  FFZ0AC(self["keyRed"] , c)
  FFZ0AC(self["keyGreen"] , c)
  self.VV5Mg7()
  self.VV1EGy()
  FF7hy1(self["myColorTst"], self.defFG, self.defBG)
  self.VVD5ah(0, 0)
 def VVjn8i(self, color, defColor):
  color = color.upper()
  span = iSearch(r"([#][a-fA-F0-9]{8})", color, IGNORECASE)
  if span : return color
  else : return defColor
 def VV1EGy(self):
  for row in range(self.VVQ3Dp):
   for col in range(self.VVsHeH):
    color = self.colors[row][col]
    found = False
    if self.isBgMode:
     if self.defBG[3:] == self.colors[row][col]:
      found = True
    else:
     if self.defFG[3:] == self.colors[row][col]:
      found = True
    if found:
     self.curRow = row
     self.curCol = col
     self.VVD5ah(0, 0)
     return
 def VVxY7G(self):
  self.close(self.defFG, self.defBG)
 def VVx0di(self): self.VVD5ah(-1, 0)
 def VVDBsZ(self): self.VVD5ah(1, 0)
 def VVziFC(self): self.VVD5ah(0, -1)
 def VVLe1s(self): self.VVD5ah(0, 1)
 def VVD5ah(self, row, col):
  self.curRow += row
  self.curCol += col
  if   self.curRow > self.VVQ3Dp -1 : self.curRow = 0
  elif self.curRow < 0     : self.curRow = self.VVQ3Dp - 1
  if   self.curCol > self.VVsHeH -1 : self.curCol = 0
  elif self.curCol < 0     : self.curCol = self.VVsHeH - 1
  color = self.VVb26C()
  self["keyRed"].setText(color)
  if self.isBgMode: self.defBG = color
  else   : self.defFG = color
  gap = int(self.VVfOli["VVSZWt"] / 2)
  pos = self["myColor%d%d" % (self.curRow, self.curCol)].getPosition()
  self["myColorPtr"].instance.move(ePoint(pos[0] - gap - 2, pos[1] - gap - 2))
  self.VVGQuK()
 def VV5Mg7(self):
  self["myTitle"].setText("  %s %s" % ("Background" if self.isBgMode else "Foreground", self.Title))
 def VVGQuK(self):
  color = self.VVb26C()
  if self.isBgMode: FFZ0AC(self["myColorTst"], color)
  else   : FFGUI5(self["myColorTst"], color)
 def VVrkD4(self, isBg):
  if not self.onlyBG:
   self.isBgMode = isBg
   self.VV5Mg7()
   self.VV1EGy()
 def VVOXz3(self, val):
  if self.isBgMode: self.transpBg = FFsRWN(self.transpBg + val, 0, 255)
  else   : self.transpFg = FFsRWN(self.transpFg + val, 0, 255)
  self. VVD5ah(0, 0)
 def VVU80K(self):
  if self.isBgMode: return hex(self.transpBg)[2:].zfill(2)
  else   : return hex(self.transpFg)[2:].zfill(2)
 def VVb26C(self):
  return ("#%s%s" % (self.VVU80K(), self.colors[self.curRow][self.curCol])).upper()
class CCfpAm(Screen, CCwklK):
 def __init__(self, session, playerObj=None):
  self.skin, self.VVfOli = FFiNEe(VVspuu, 1860, 1030, 20, 20, 30, "#33002233", "#33002233", 25, VV0Ay7=2)
  self.session   = session
  self.playerObj   = playerObj
  self.VVeEaQ  = eTimer()
  self.VVOAGe  = eTimer()
  self.VVxJJL  = eTimer()
  self.VVoJze = eTimer()
  self.subtLinesTable  = None
  self.subtLinesTableNdx = -1
  self.subtList   = []
  self.curSubtFullData = None
  self.lastSubtInfo  = ""
  self.lastSubtFile  = ""
  self.lastSubtEnc  = ""
  self.settingShown  = False
  self.CursorPos   = 0
  self.Title    = "Subtitle Settings"
  self.VV7tND  = None
  self.subtMenuFromPlayer = True
  if FFgrjX() and CC674y.VVSwko() in ("Gemini", "Dream-Elite"):
   self.VVfJF0 = 400
   self.VV0Ov6 = 0.4
  else:
   self.VVfJF0 = 50
   self.VV0Ov6 = 0.18
  self.minDelay, self.maxDelay = self.VVmwD5()
  self.diac    = u"\u0610\u0611\u0612\u0613\u0614\u0615\u0616\u0617\u0618\u0619\u061a\u064b\u064c\u064d\u064e\u064f\u0650\u0651\u0652\u0653\u0654\u0655\u0656\u0657\u0658\u0659\u065a\u065b\u065c\u065d\u065e\u0670\u06d6\u06d7\u06d8\u06d9\u06da\u06db\u06dc\u06df\u06e0\u06e1\u06e2\u06e3\u06e4\u06e7\u06e8\u06ea\u06eb\u06ec\u06ed"
  CCwklK.__init__(self)
  FFZMxC(self, title="%s%s%s" % (self.Title, " " * 10, FFjt5L("Change values with Up , Down, < , 0 , >", VVA4XU)))
  self["mySubtCover"] = Label()
  self.ctrlBtns = ("keyRed", "keyGreen", "keyYellow", "keyBlue")
  subj = ("Reset All", "Save", "Reset Delay", "Pick Line")
  for i, name in enumerate(self.ctrlBtns):
   self[name] = Label(subj[i])
  self["mySubtCursor"] = Label()
  subj = ("Delay", "BG Trans %", "Text Color", "Text Font", "Text Size", "Alignment", "Shadow Color", "Shadow Size", "Position")
  self.settingLabels = ["Del", "BGTr", "TxtFg", "TxtFnt", "TxtSiz", "Align", "ShadFg", "ShadSiz", "Pos"]
  self.settingLabels1 = list(self.settingLabels)
  for i, name in enumerate(self.settingLabels):
   self.settingLabels[i]  = "mySubt%s"   % name
   self.settingLabels1[i] = "mySubt%s1"  % name
   self[self.settingLabels[i]]  = Label(subj[i])
   self[self.settingLabels1[i]] = Label(subj[i])
  self["mySubtFr"] = Label()
  for i in range(3): self["mySubt%d"  % i] = Label()
  for i in range(4): self["mySubtSep%d" % i] = Label()
  for i in range(4): self["mySubtChng%d" % i] = Label()
  self["mySubtChng1"].setText("Line (Left/Right) , Delay (Up/Down)")
  self["myRest1"] = Label("Reset")
  self.VVKKbg()
  FFHlAU(self,
  {
   "ok"  : self.VVPr1F      ,
   "cancel" : self.VVfXzC      ,
   "info"  : self.VVbZLl    ,
   "red"  : self.VV7y8M  ,
   "green"  : self.VVUosz   ,
   "yellow" : BF(self.VVRIDu, 0)  ,
   "blue"  : self.VVsdgY    ,
   "menu"  : self.VVkrkn      ,
   "left"  : BF(self.VVuLkD, -1),
   "right"  : BF(self.VVuLkD, 1) ,
   "last"  : self.VVbyWX     ,
   "next"  : self.VVe6KA     ,
   "0"   : self.VVKUAt    ,
   "up"  : self.VVx0di       ,
   "down"  : self.VVDBsZ      ,
   "pageUp" : BF(self.VVoC5Z, True) ,
   "pageDown" : BF(self.VVoC5Z, False) ,
   "chanUp" : BF(self.VVoC5Z, True) ,
   "chanDown" : BF(self.VVoC5Z, False) ,
   "longPlay" : BF(self.VV1XNb, "longPlay") ,
   "play"  : BF(self.VV1XNb, "pause")  ,
   "pause"  : BF(self.VV1XNb, "pause")  ,
   "playPause" : BF(self.VV1XNb, "pause")  ,
   "stop"  : BF(self.VV1XNb, "pause")  ,
   "audio"  : BF(self.VV1XNb, "audio")  ,
   "subtitle" : BF(self.VV1XNb, "subtitle") ,
   "rewind" : BF(self.VVFHmB, "rewind") ,
   "forward" : BF(self.VVFHmB, "forward") ,
   "rewindDm" : BF(self.VVFHmB, "rewind") ,
   "forwardDm" : BF(self.VVFHmB, "forward")
  })
  self.VVXAYe()
  self.onShown.append(self.VV7OzD)
  self.onClose.append(self.VV7Hkn)
 def VVXAYe(self):
  lst = []
  for fil in FFkzic(resolveFilename(SCOPE_FONTS), "*.[tToO][tT][fF]"):
   name = os.path.splitext(os.path.basename(fil))[0]
   lst.append((fil, name))
  if lst:
   lst.sort(key=lambda x: x[1].lower())
   default = CFG.subtTextFont.default
   if default == VV8nt5:
    for path, name in lst:
     if "almateen" in name.lower():
      default = name
      break
   CFG.subtTextFont = ConfigSelection(default=default, choices=lst)
 def VV7OzD(self):
  self.onShown.remove(self.VV7OzD)
  FFWgBS(self)
  FF6W0I(self)
  FFK4PQ(self["myRest1"], "#000000", 3)
  for i in range(3):
   self["mySubt%d" % i].hide()
  self.VVQjDh()
  self.VVvsHp()
  srtCfgPath = CCfpAm.VVXUuh(self)
  FFpwZS("mv -f '%s.dis' '%s'" % (srtCfgPath, srtCfgPath))
  self.VV0xaU()
 def VV7Hkn(self):
  self.VVeEaQ.stop()
  self.VVOAGe.stop()
  self.VVxJJL.stop()
  self.VVoJze.stop()
 def VVFBoa(self):
  self.settingShown = True
  for name in self.ctrlBtns: self[name].show()
  for name in self.settingLabels : self[name].show()
  for name in self.settingLabels1: self[name].show()
  for i in range(4): self["mySubtSep%d" % i].show()
  self["myTitle"].show()
  self["mySubtFr"].show()
  FFZ0AC(self["myBody"], "#33002233")
  self["keyMenu"].show()
  self["keyInfo"].show()
  self["mySubtCover"].hide()
  self.VVwsJV()
 def VVQjDh(self):
  self.settingShown = False
  for name in self.ctrlBtns: self[name].hide()
  for name in self.settingLabels : self[name].hide()
  for name in self.settingLabels1: self[name].hide()
  for i in range(4): self["mySubtSep%d" % i].hide()
  self["myTitle"].hide()
  self["mySubtFr"].hide()
  FFZ0AC(self["myBody"], "#ff000000")
  self["keyMenu"].hide()
  self["keyInfo"].hide()
  self["mySubtCover"].show()
 def VVPr1F(self):
  if self.settingShown:
   confItem = self.VVymx1()[self.CursorPos]
   title = self[self.settingLabels[self.CursorPos]].getText()
   CCJaSw.VV5YpJ(self, confItem, title, cbFnc=self.VVo2gc)
  elif self.VV1s50():
   self.VVKKbg()
  else:
   self.close("subtExit")
 def VVo2gc(self):
  self.VVwsJV()
  self.VVvsHp()
  self.VVIE7K(True)
 def VVfXzC(self):
  for confItem in self.VVymx1():
   if FFI3NO(confItem):
    FFRMYv(self, BF(self.VVM20Q, cbFnc=self.VVeE99), "Save Changes ?", callBack_No=self.VVoE7f, title=self.Title)
    break
  else:
   self.VVeE99()
 def VVeE99(self):
  if  self.settingShown   : self.VVQjDh()
  elif self.VV1s50() : self.VVKKbg()
  else       : self.close("subtExit")
 def VVoE7f(self):
  for confItem in self.VVymx1(): confItem.cancel()
  if self.settingShown:
   self.VVwsJV()
   self.VVvsHp()
   self.VVQjDh()
  else:
   self.close("subtExit")
 def VVkrkn(self):
  if self.settingShown   : self.VVYDfu()
  elif self.VV1s50() : pass
  else       : self.VVFBoa()
 def VVuLkD(self, pos):
  if self.settingShown:
   self.CursorPos += pos
   if   self.CursorPos > len(self.settingLabels) - 1: self.CursorPos = 0
   elif self.CursorPos < 0        : self.CursorPos = len(self.settingLabels) - 1
   inst = self[self.settingLabels[self.CursorPos]].instance
   left = inst.position().x() - 5
   inst = self["mySubtCursor"].instance
   inst.move(ePoint(left, int(inst.position().y())))
  else:
   self.VVa6DV(pos)
 def VVa6DV(self, pos):
  posVal, durVal = self.VV2kXj()
  if pos == -1: ndx = self.VV8JPJ(posVal)
  else  : ndx = self.VVbEqG(posVal)
  if   ndx < 0      : FF28n1(self, "No lines"  , 500)
  elif ndx == 0      : FF28n1(self, "First line", 500)
  elif ndx == len(self.subtList) - 1 : FF28n1(self, "Last line" , 500)
  else:
   capNum, frmSec, toSec, subtLines = self.subtList[ndx]
   delay, color, allow = self.VVauIP(frmSec)
   if allow:
    if self.VV1s50():
     self.VVRIDu(delay, True)
     self.VVIE7K(force=True)
    else:
     self.VVoPF3(delay, frmSec)
   else:
    FF28n1(self, "Delay out of range", 800)
 def VVPCRE(self, val):
  self.VVRIDu(CFG.subtDelaySec.getValue() + val)
  self.VVIE7K(force=True)
 def VVoPF3(self, delay, frmSec):
  self["mySubtChng2"].setText("Line Time = %s" % FFFHEC(frmSec))
  self["mySubtChng3"].setText("Delay = %s second%s" % (delay, FFcacr(delay)))
  for i in range(4): self["mySubtChng%d" % i].show()
  self["myRest1"].show()
  try: self.VVoJze_conn = self.VVoJze.timeout.connect(self.VVCQjm)
  except: self.VVoJze.callback.append(self.VVCQjm)
  self.VVoJze.start(100, False)
 def VVCQjm(self):
  if self.curSubtFullData:
   capNum, frmSec, toSec, subtLines, VVBGsZ = self.curSubtFullData
   if frmSec > 0 and toSec - frmSec > 0:
    self["mySubtChng2"].setText("Line %s      %s" % (capNum, FFFHEC(frmSec)))
    self["mySubtChng3"].setText("Delay = %s Sec" % CFG.subtDelaySec.getValue())
 def VVKKbg(self):
  self.VVoJze.stop()
  for i in range(4): self["mySubtChng%d" % i].hide()
  self["myRest1"].hide()
 def VV1s50(self):
  return self["mySubtChng1"].getVisible()
 def VVoC5Z(self, isUp):
  if not self.settingShown and not self.VV1s50():
   self.close("subtZapUp" if isUp else "subtZapDn")
 def VV1XNb(self, reason):
  if not self.settingShown:
   self.close(reason)
 def VVFHmB(self, act):
  if self.playerObj:
   if   act == "rewind" : self.playerObj.VVJup6()
   elif act == "forward" : self.playerObj.VVzX0n()
 def VVbyWX(self) : self.VVFj7n(5)
 def VVe6KA(self) : self.VVFj7n(6)
 def VVKUAt(self) : self.VVFj7n(-1)
 def VVx0di(self):
  if  self.settingShown   : self.VVFj7n(1)
  elif self.VV1s50() : self.VVPCRE(1)
  else       : self.VVoC5Z(True)
 def VVDBsZ(self):
  if self.settingShown: self.VVFj7n(0)
  elif self.VV1s50() : self.VVPCRE(-1)
  else    : self.VVoC5Z(False)
 def VVFj7n(self, direction):
  if self.settingShown:
   confItem = self.VVymx1()[self.CursorPos]
   if direction == -1:
    confItem.setValue(confItem.default)
   else:
    if direction in (0, 1) and confItem in (CFG.subtTextFg, CFG.subtTextFont, CFG.subtTextAlign, CFG.subtShadowColor, CFG.subtVerticalPos):
     direction = 0 if direction == 1 else 1
    confItem.handleKey(direction)
   if confItem is CFG.subtTextAlign:
    align = CFG.subtTextAlign.getValue()
    boxWidth= self.instance.size().width()
    for i in range(3):
     inst = self["mySubt%d" % i].instance
     w   = inst.calculateSize().width() + 50
     if   align == "0" : left = 0
     elif align == "2" : left = boxWidth - w
     else    : left = int((getDesktop(0).size().width() - w) / 2.0)
     inst.move(ePoint(left, int(inst.position().y())))
   self.VVwsJV()
   self.VVvsHp()
   self.VVIE7K(True)
 def VVymx1(self):
  return (  CFG.subtDelaySec
    , CFG.subtBGTransp
    , CFG.subtTextFg
    , CFG.subtTextFont
    , CFG.subtTextSize
    , CFG.subtTextAlign
    , CFG.subtShadowColor
    , CFG.subtShadowSize
    , CFG.subtVerticalPos)
 def VV7y8M(self):
  if self.settingShown:
   FFRMYv(self, self.VVT7Sd, "Reset Subtitle Settings to default ?", title=self.Title)
 def VVT7Sd(self):
  for confItem in self.VVymx1(): confItem.setValue(confItem.default)
  self.VVM20Q()
  self.VVwsJV()
  self.VVvsHp()
 def VVRIDu(self, delay, force=False):
  if self.settingShown or self.VV1s50() or force:
   FFjt1c(CFG.subtDelaySec, delay)
   self.VVhAuT()
   self.VVwsJV()
   self.VVvsHp()
   if  self.settingShown and delay == 0: FF1mVE(self, 'Reset to "0"', 800)
   elif self.VV1s50()   : self.VVCQjm()
 def VVSQ1n(self):
  Max = CFG.subtDelayMax.getValue() * 60
  CFG.subtDelaySec = ConfigSelectionNumber(default=0, stepwidth=1, min=-Max, max=Max, wraparound=False)
  FFjt1c(CFG.subtDelaySec, 0)
  self.minDelay, self.maxDelay = self.VVmwD5()
  self.VVM20Q()
  self.VVwsJV()
 def VVUosz(self):
  if self.settingShown:
   self.VVM20Q()
   self.VVQjDh()
 def VVM20Q(self, cbFnc=None):
  for confItem in self.VVymx1(): confItem.save()
  configfile.save()
  self.VVhAuT()
  FF1mVE(self, "Saved")
  if cbFnc:
   cbFnc()
 def VVwsJV(self):
  cfgLst = self.VVymx1()
  for i, name in enumerate(self.settingLabels1):
   self[name].setText(str(cfgLst[i].getText()))
 def VVvsHp(self):
  path = CFG.subtTextFont.getValue()
  if FFCyVu(path):
   fnt = "AJP_Subtitle"
   FFXcbU(path, fnt, isRepl=1)
  else:
   fnt = VVNhAq
  lineH = 0
  top = self["mySubt0"].instance.position().y()
  bg = int(FFjFSv(CFG.subtBGTransp.getValue(), 0, 100, 0, 255))
  try:
   for i in range(3):
    obj = self["mySubt%d" % i]
    inst = obj.instance
    if CFG.subtTextFg.getValue().startswith("#"):
     FFGUI5(obj, CFG.subtTextFg.getValue())
    VVgbF2 = CFG.subtTextSize.getValue()
    inst.setFont(gFont(fnt, VVgbF2))
    FFZ0AC(obj, "#%0.2X000000" % bg)
    FFK4PQ(self["mySubt%d" % i], CFG.subtShadowColor.getValue(), int(CFG.subtShadowSize.getValue()))
    lineH = FFGrBZ(VVgbF2, self.VV0Ov6)
    inst.resize(eSize(*(int(inst.size().width()), lineH)))
    if i > 0:
     inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
   for i in range(1, 4):
    inst = self["mySubtSep%d" % i].instance
    inst.move(ePoint(int(inst.position().x()), int(top + lineH * i + i * 1 )))
  except:
   pass
  inst = self["mySubt2"].instance
  winH = inst.position().y() + inst.size().height() + 2
  winW = self.instance.size().width()
  self.instance.resize(eSize(*(int(winW), int(winH))))
  y = int(FFjFSv(CFG.subtVerticalPos.getValue(), 0, 100, 0, FFrPd1()[1] - winH))
  self.instance.move(ePoint(int(self.instance.position().x()), y))
  FF9sDw(self, winW, winH)
 def VVbZLl(self):
  sp = "    "
  txt  = "%s\n"   % FFjt5L("Subtitle File:", VVFuwR)
  txt += sp + "%s\n\n" % self.lastSubtFile
  txt += "%s\n"     % FFjt5L("Subtitle Settings:", VVFuwR)
  txt += sp + "Encoding\t: %s\n" % (self.lastSubtEnc or "Default")
  txt += sp + "Delay\t: %s sec\n" % CFG.subtDelaySec.getValue()
  if self.subtList:
   posVal, durVal = self.VV2kXj()
   capNum1, frmSec1, toSec1, subtLines1 = self.subtList[0]
   capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
   time1 = FFFHEC(frmSec1)
   time2 = FFFHEC(toSec2)
   txt += "\n"
   txt += "%s\n"       % FFjt5L("Timing:", VVFuwR)
   txt += sp + "Captions\t: %s - %s\n"  % (capNum1, capNum2)
   txt += sp + "Subt. Time\t: %s - %s\n" % (time1, time2)
   txt += sp + "Event Dur.\t: %s\n"  % FFFHEC(durVal)
   txt += sp + "Progress\t: %s\n" % FFFHEC(posVal)
   err = self.VVCrXT(posVal)
   if err:
    txt += sp + "Remarks\t: %s\n" % FFjt5L(err, VVz22H)
  FF4lCP(self, txt, title="Current Subtitle")
 @FFOAKH("Checking Subtitle ...", clearMsg=False)
 def VV0xaU(self, path="", delay=0, enc=""):
  try:
   self.VVeEaQ.stop()
   if path:
    subtList, err = self.VVmqiE(path, enc=enc)
    if err    : self.close(err)
    elif not subtList : self.close("subtInval")
    else    :
     self.subtList = subtList
     CFG.subtDelaySec.setValue(int(delay))
     FFjt1c(CFG.subtDelaySec, int(delay))
     self.VVwsJV()
     self.VVJclP()
   else:
    path, delay, enc = CCfpAm.VVuuUw(self)
    if path:
     self.VV0xaU(path=path, delay=delay, enc=enc)
    else:
     self.VVYDfu()
  except:
   pass
 def VVJclP(self):
  CCfpAm.VVDjVi(None)
  try: self.VVeEaQ_conn = self.VVeEaQ.timeout.connect(self.VVIE7K)
  except: self.VVeEaQ.callback.append(self.VVIE7K)
  self.VVeEaQ.start(500, False)
  try: self.VVOAGe_conn = self.VVOAGe.timeout.connect(self.VVPIYj)
  except: self.VVOAGe.callback.append(self.VVPIYj)
  err = self.VVCrXT()
  if err : FF1mVE(self, err)
  else : FF1mVE(self, "Subtitle started", 700)
 def VVCrXT(self, posVal=None):
  if posVal == None:
   posVal, durVal = self.VV2kXj()
  capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
  return "Subtitle end reached" if (posVal - int(CFG.subtDelaySec.getValue()) > toSec2) else ""
 def VVfaeX(self, posVal, margin=0):
  capNum2, frmSec2, toSec2, subtLines2 = self.subtList[len(self.subtList) - 1]
  if posVal + self.maxDelay > toSec2:
   path = CCfpAm.VVXUuh(self)
   FF1mVE(self, "End of subtitle reached")
   return True
  else:
   return False
 def VVYDfu(self):
  c1, c2, c3, c4, c5, c6 = VVFuwR, VVJEMb, VVZtfx, VVcPtB, VVIH76, VVz22H
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  txt1 = FFjt5L("... from Favourite Path", VVo7S9)
  VV3wat = []
  VV3wat.append(("Select from Favourites Path"     , "listFav"  ))
  VV3wat.append(("Select from All Paths"      , "listAll"  ))
  VV3wat.append((c1 + "Select from File Manager"    , "listFMan" ))
  VV3wat.append(FFsLU5("Select from Current Movie Path" , "listCur", fPath, c2 ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Set Maximum Delay (Minutes)"     , "setMaxDelay" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Set Favourite Path"      , "setFavPath" ))
  VV3wat.append((c3 + "Set Auto-Find Event Name Language"  , "setFavLang" ))
  VV3wat.append(VVAL3j)
  VV3wat.append((c3 + "Suggest files (%s35%%%s match) %s" % (c4, c3, txt1), "sugSrt0.35"))
  VV3wat.append((c3 + "Suggest files (%s50%%%s match) %s" % (c4, c3, txt1), "sugSrt0.50"))
  VV3wat.append((c3 + "Suggest files (%s80%%%s match) %s" % (c4, c3, txt1), "sugSrt0.80"))
  if self.settingShown:
   VV3wat.append(VVAL3j)
   VV3wat.append((c5 + "Change Subtitle File Encoding" , "enc"  ))
   VV3wat.append(VVAL3j)
   VV3wat.append((c6 + "Disable Current Subtitle"  , "disb" ))
   VV3wat.append(VVAL3j)
   VV3wat.append(("Help (Keys)"       , "help" ))
  VVOa1G = self.VVA7Bn
  FFLFTC(self, self.VVlBeI, VV3wat=VV3wat, width=900, height=1000, title='Find Subtitle "srt" File', VVOa1G=VVOa1G, VVwltY="#22001122", VVkxBG="#11000509", VVoCB2="#08554455")
 def VVA7Bn(self, item=None):
  if item:
   VV7tND, title, item, ndx = item
   self.VV7tND = VV7tND
   title = FFzBfi(title).partition("...")[0].strip()
   if   item == "listFav"   : self.VVGZ4w(0, title)
   elif item == "listAll"   : self.VVGZ4w(1, title)
   elif item == "listFMan"   : self.session.openWithCallback(self.VV3eWi, BF(CClYaF, VV1gDA="srt", VV1pbK=CFG.lastSubtFManFindDir.getValue()))
   elif item == "listCur"   : self.VVGZ4w(2, title)
   elif item == "setMaxDelay"  : CCJaSw.VV5YpJ(self, CFG.subtDelayMax, "Subtitle Delay Limit (Minutes)", cbFnc=self.VVSQ1n, isSave=True, width=700)
   elif item == "setFavPath"  : self.session.openWithCallback(self.VVjvca, BF(CClYaF, mode=CClYaF.VV9N82, VV1pbK=CFG.subtitleFavPath.getValue()))
   elif item == "setFavLang"  : CCJaSw.VV5YpJ(self, CFG.subtitleEventLang, "Event Name Search Language", cbFnc=BF(FF1mVE, self.VV7tND or self, "Saved"), isSave=True, width=700)
   elif item.startswith("sugSrt") : self.VVGZ4w(3, title, coeff=float(item[6:]))
   elif item == "enc":
    if self.lastSubtFile and FFCyVu(self.lastSubtFile) : FFimQ3(self.VV7tND or self, BF(CC7ocD.VV9PZW, self, self.lastSubtFile, self.VVTQw2, self.lastSubtEnc or CFG.subtDefaultEnc.getValue()), title="Loading Codecs ...")
    else             : FF28n1(self, "SRT File error", 1000)
   elif item == "disb"    : self.VVnKGQ()
   elif item == "help"    : FFw2rR(self, "_help_subt", "Subtitle (Keys)")
 def VVnKGQ(self, item=None):
  subtRefFile = CCfpAm.VVXUuh(self)
  fPath, fDir, fName = CClYaF.VV4zSS(self)
  if fPath and subtRefFile:
   fPath += ".ajp"
   if FFCyVu(fPath):
    FFpwZS("mv -f '%s' '%s.dis'" % (fPath, fPath))
  else:
   FFwgGB(subtRefFile)
  self.VVCnc1()
  self.close("subtExit")
 def VVlBeI(self, item=None):
  if not self.settingShown and self.subtMenuFromPlayer:
   self.close("subtCancel")
 def VVCnc1(self):
  self.subtMenuFromPlayer = False
  if self.VV7tND: self.VV7tND.cancel()
  if self.settingShown: self.VVQjDh()
 def VVTQw2(self, item=None):
  if item:
   self.VVCnc1()
   FFimQ3(self.VV7tND or self, BF(self.VV0xaU, path=self.lastSubtFile, delay=CFG.subtDelaySec.getValue(), enc=item), title="Loading Subtitle ...")
 def VV3eWi(self, path):
  if path:
   self.VVCnc1()
   FFjt1c(CFG.lastSubtFManFindDir, os.path.dirname(path))
   self.VV0xaU(path=path)
 def VVjvca(self, path):
  if path:
   FFjt1c(CFG.subtitleFavPath, path)
   FF1mVE(self.VV7tND or self, "Saved")
 def VVGZ4w(self, mode, title, coeff=0.25):
  FFimQ3(self.VV7tND or self, BF(self.VVLDgS, mode, title, coeff), title="Searching for srt files")
 def VVLDgS(self, mode, title, coeff):
  evName = CC5TsO.VVMZqx(self).strip()
  if mode == 3 and not evName:
   FFjADj(self.VV7tND or self, "No event Name", 2000)
   return
  if   mode == 0: sPath = CFG.subtitleFavPath.getValue()
  elif mode == 1: sPath = "/"
  elif mode == 2: sPath = CClYaF.VV4zSS(self)[1]
  elif mode == 3: sPath = CFG.subtitleFavPath.getValue()
  srtList = FFycDu(r'find "%s" %s \( -iname "*.srt" \) | grep -i "\.srt"' % (sPath, FF5W9s(1)))
  if srtList and srtList[0].startswith("find:"):
   FFdw58(self, "Error in path:\n\n%s" % sPath, title=title)
   return
  if not srtList:
   FFjADj(self.VV7tND or self, "No srt files", 1500)
   return
  srtList.sort(key=lambda x: x.lower())
  if mode == 3:
   trName = evName
   if CFG.subtitleEventLang.getValue() == "s":
    trName = CC5TsO.VV6IMT(evName, "en")[0] or evName
   title = "%s %s\t%s %s" % (title, VVA4XU, VV1fx4, trName)
   self.VVQebZ(self.VV7tND or self, BF(self.VVtLEg, mode, evName, trName, title), trName, srtList, 20, coeff)
  else:
   self.VVtLEg(mode, evName, "", title, srtList, "")
 def VVtLEg(self, mode, evName, trName, title, srtList, err):
  if mode == 3:
   if not srtList: err = err or "No Similar Names"
   if err:
    if evName == trName : FFjADj(self.VV7tND or self, err, 2000)
    else    : FFdw58(self, err, title="Event : %s" % trName)
    return
  VVAkuK = []
  curColor = "#f#0000FF00#"
  for path in srtList:
   fName, Dir = os.path.basename(path), FFoWxR(os.path.dirname(path))
   if self.lastSubtFile == Dir + fName:
    fName, Dir = curColor + fName, curColor + Dir
   VVAkuK.append((fName, Dir))
  VVu1YM  = ("Select"    , self.VVyFPG        , [])
  VV2ytr = (""     , self.VVZqbx          , [])
  VVCOpO = (""     , BF(self.VVlNCd, self.lastSubtFile, False) , [])
  VVwSzI = ("Find Current File" , BF(self.VVlNCd, self.lastSubtFile, True) , [])
  header   = ("File" , "Directory" )
  widths   = (60  , 40   )
  FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VV3cHe=widths, VVwdmN=28, VVu1YM=VVu1YM, VV2ytr=VV2ytr, VVCOpO=VVCOpO, VVwSzI=VVwSzI, VVSLOq=CFG.lastFindSubtitle
    , VVwltY="#11002222", VVkxBG="#22001111", VVemyB="#22001111", VVoRat="#11ffff00", VVJKqd="#11552233", VVbcr0="#22222222", VVX9AA="#11002233")
 def VVZqbx(self, VV6A99, title, txt, colList):
  fName, Dir = colList
  FF4lCP(VV6A99, "%s\n\n%s%s" % (FFjt5L("Path:", VVFuwR), Dir, fName), title=title)
 def VVlNCd(self, path, VVwb7n, VV6A99, title, txt, colList):
  for ndx, row in enumerate(VV6A99.VVrrm9()):
   if path == row[1].strip() + row[0].strip():
    VV6A99.VVrqBw(ndx)
    break
  else:
   if VVwb7n:
    FF28n1(VV6A99, "Not in list !", 1000)
 def VVyFPG(self, VV6A99, title, txt, colList):
  VV6A99.cancel()
  self.VVCnc1()
  path = "%s%s" % (colList[1].strip(), colList[0].strip())
  FFimQ3(self.VV7tND, BF(self.VV0xaU, path=path))
 def VVmqiE(self, path, enc=None):
  if enc and CC7ocD.VVRTBW(path, enc)      : enc = enc
  elif CC7ocD.VVRTBW(path, CFG.subtDefaultEnc.getValue()): enc = CFG.subtDefaultEnc.getValue()
  else                   : enc = None
  if not FFCyVu(path):
   return [], "File not found"
  if (FFXhoc(path) > 1024 * 700):
   return [], "File too big"
  frmSec = toSec = bold = italic = under = 0
  capNum  = ""
  capFound = True
  color  = ""
  subtLines = []
  subtList = []
  lines  = FFL19l(path, encLst=enc)
  lastNdx  = len(lines) - 1
  for ndx, line in enumerate(lines):
   line = str(line).strip()
   if line:
    if line.isdigit():
     capNum = line
    else:
     span = iSearch(r'(\d{2}:\d{2}:\d{2},\d{3})\s*\-->\s*(\d{2}:\d{2}:\d{2},\d{3})', line, IGNORECASE)
     if span:
      p  = list(map(int, span.group(1).replace(",", ":").split(":")))
      frmSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
      p  = list(map(int, span.group(2).replace(",", ":").split(":")))
      toSec = p[0] * 3600 + p[1] * 60 + p[2] + p[3] / 1000.0
      subtLines = []
     else:
      span = iSearch(r'<font color="(.+)">(.+)', line, IGNORECASE)
      if span:
       color = self.VVlzrA(span.group(1))
       line = span.group(2)
      if "<b>" in line: bold = 1
      if "<i>" in line: italic = 1
      if "<u>" in line: under = 1
      line = line.replace("</font>", "").replace("</b>", "").replace("</i>", "").replace("</u>", "")
      line = line.replace("<b>", "").replace("<i>", "").replace("<u>", "")
      span = iSearch(r"{\\a\d}(.+)", line, IGNORECASE)
      if span:
       line = span.group(1)
      line = self.VVtBZY(line)
      subtLines.append((line.strip(), color, bold, italic, under))
      if ndx == lastNdx and subtList and (toSec - frmSec) > 0 and not subtList[len(subtList) - 1] == (capNum, frmSec, toSec, subtLines):
       subtList.append((capNum, frmSec, toSec, subtLines))
   else:
    if toSec > frmSec and subtLines:
     subtList.append((capNum, frmSec, toSec, subtLines))
    frmSec = toSec = bold = italic = under = 0
    capNum  = ""
    color  = ""
    subtLines = []
  if subtList:
   self.lastSubtFile = path
   self.lastSubtEnc  = enc
   self.VVhAuT()
  return subtList, ""
 def VVtBZY(self, line):
  line = line.replace(u"\u202A", "")
  line = line.replace(u"\u202B", "")
  line = line.replace(u"\u202C", "")
  for char in line:
   if 0x600 <= ord(char) <= 0x6FF and char in self.diac:
    line = line.replace(char, "")
  line = line.replace("\r", "..").replace("\n", "..")
  return str(line)
 def VVlzrA(self, color):
  lst = { "black": "#000000", "blue": "#0000ff", "brown":"#a52a2a", "cyan":"#00ffff", "darkblue": "#0000a0", "gray":"#808080", "green":"#008000", "grey": "#808080", "lightblue":"#add8E6", "lime":"#00ff00", "magenta":"#ff00ff", "maroon":"#800000", "olive":"#808000", "orange":"#ffa500", "purple":"#800080", "red":"#ff0000", "silver":"#c0c0c0", "white":"#ffffff", "yellow":"#ffff00"}
  code = lst.get(color.lower(), "")
  if code:
   return code
  else:
   span = iSearch(r"(#[A-Fa-f0-9]{6})", color, IGNORECASE)
   if span : return span.group(1)
   else : return ""
 def VVhAuT(self):
  path = CCfpAm.VVXUuh(self)
  if path:
   try:
    with open(path, "w") as f:
     f.write("srt=%s\n" % self.lastSubtFile)
     f.write("delay=%s\n" % CFG.subtDelaySec.getValue())
     if self.lastSubtEnc:
      f.write("enc=%s\n" % self.lastSubtEnc)
   except:
    pass
 def VVIE7K(self, force=False):
  posVal, durVal = self.VV2kXj()
  err = self.VVCrXT(posVal)
  if err:
   return
  VVBGsZ = self.VVB4vs(posVal)
  if VVBGsZ < 0:
   return
  txtDur = 0
  if posVal:
   capNum, frmSec, toSec, subtLines = self.subtList[VVBGsZ]
   if force or not self.lastSubtInfo == subtLines:
    self.lastSubtInfo = subtLines
    self.curSubtFullData = (capNum, frmSec, toSec, subtLines, VVBGsZ)
    settingColor = ""
    if CFG.subtTextFg.getValue().startswith("#"):
     settingColor = CFG.subtTextFg.getValue()
    self.VVPIYj()
    subtLines = list(subtLines)
    l = len(subtLines)
    for i in range(3 - len(subtLines)):
     subtLines.insert(0, ("", "", 0, 0, 0))
    align = CFG.subtTextAlign.getValue()
    boxWidth= self.instance.size().width()
    txtDur = int(toSec * 1000 - frmSec * 1000)
    if txtDur > 0:
     for ndx, (line, color, bold, italic, under) in enumerate(subtLines):
      if line:
       if   bold   : newColor = "#aaffff"
       elif italic   : newColor = "#aaaaaa"
       elif under   : newColor = "#ffffaa"
       elif settingColor : newColor = settingColor
       elif color   : newColor = color
       else    : newColor = ""
       if ndx < 3:
        obj  = self["mySubt%d" % ndx]
        inst = obj.instance
        if newColor:
         FFGUI5(obj, newColor)
        obj.setText(line)
        obj.show()
        w = inst.calculateSize().width() + self.VVfJF0
        inst.resize(eSize(*(w, inst.size().height())))
        if   align == "0" : left = 0
        elif align == "2" : left = boxWidth - w
        else    : left = int((getDesktop(0).size().width() - w) / 2.0)
        inst.move(ePoint(left, int(inst.position().y())))
    if txtDur > 0:
     self.VVOAGe.start(txtDur, True)
 def VV2kXj(self):
  seekable, percVal, durVal, posVal, remVal, percTxt, durTxt, posTxt, remTxt = CCqWM2.VVVxSJ(self)
  if not durVal and not posVal:
   evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVgoJl(self)
   if evTime and evDur:
    posVal, durVal = iTime() - evTime, evDur
  return posVal, durVal
 def VVB4vs(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if posVal > frmSec and posVal < toSec:
     return ndx
  return -1
 def VV8JPJ(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if toSec > posVal:
     return ndx -1
  return -1
 def VVbEqG(self, posVal):
  if posVal > 0:
   delay = CFG.subtDelaySec.getValue()
   for ndx, item in enumerate(self.subtList):
    frmSec = item[1] + delay
    toSec = item[2] + delay
    if frmSec > posVal:
     return ndx
  return -1
 def VVPIYj(self):
  for i in range(3):
   self["mySubt%d" % i].setText("")
   FFGUI5(self["mySubt%d" % i], "#00ffffff")
   self["mySubt%d" % i].hide()
 def VVsdgY(self):
  if not self.VV1s50():
   self.VVc7QB()
 @FFOAKH("Loading Lines ...")
 def VVc7QB(self):
  VVAkuK = []
  for cap, frm, to, lines in self.subtList:
   firstLine = lines[0][0] if lines else ""
   VVAkuK.append((cap, FFFHEC(frm), str(frm), firstLine))
  if VVAkuK:
   title = "Select Current Subtitle Line"
   VVu8qI = self.VVx5RW
   VVCOpO = (""    , self.VVCiYt , [])
   VVu1YM  = ("Select"   , self.VVdVmL , [title])
   VVwSzI = ("Current Line" , self.VVg4bx , [True])
   VVScQz = ("Reset Delay" , self.VV4qS4 , [])
   header   = ("Cap" , "Time", "Time Val", "Subtitle Text" )
   widths   = (8  , 15 , 0    , 77    )
   VVLIqP  = (CENTER , CENTER, CENTER , LEFT    )
   VV6A99 = FFUQ0v(self, None, title=title, header=header, VVGape=VVAkuK, VVLIqP=VVLIqP, VV3cHe=widths, VVwdmN=28, VVCOpO=VVCOpO, VVu8qI=VVu8qI, VVu1YM=VVu1YM, VVwSzI=VVwSzI, VVScQz=VVScQz
          , VVwltY="#33002222", VVkxBG="#33001111", VVemyB="#33110011", VVoRat="#11ffff00", VVJKqd="#0a334455", VVbcr0="#22222222", VVX9AA="#33002233")
   err = self.VVCrXT()
   if err:
    VV6A99.VVMjPT()
    FF28n1(VV6A99, err, 1500)
  else:
   FFjADj(self, "Cannot read lines !", 2000)
 def VVCiYt(self, VV6A99, title, txt, colList):
  self.subtLinesTable = VV6A99
  if int(CFG.subtDelaySec.getValue()):
   VV6A99["keyYellow"].show()
   VV6A99["keyYellow"].setText("Reset Delay (%s sec)" % CFG.subtDelaySec.getValue())
  else:
   VV6A99["keyYellow"].hide()
  VV6A99["keyBlue"].setText("New Delay: %s sec" % CFG.subtDelaySec.getValue())
  VV6A99["keyBlue"].show()
  FFZ0AC(VV6A99["keyBlue"], "#22222222")
  VV6A99.VVIOX6(BF(self.VV0r1T, VV6A99))
  self.VVg4bx(VV6A99, False)
  try: self.VVxJJL_conn = self.VVxJJL.timeout.connect(self.VVnhGm)
  except: self.VVxJJL.callback.append(self.VVnhGm)
  self.VVxJJL.start(500, False)
 def VVx5RW(self, VV6A99):
  self.VVxJJL.stop()
  self.subtLinesTable  = None
  self.subtLinesTableNdx = -1
  VV6A99.cancel()
 def VVnhGm(self):
  if self.subtLinesTable:
   VV6A99 = self.subtLinesTable
   posVal, durVal = self.VV2kXj()
   color = "#b#11551111#"
   if posVal > 0:
    curTime = posVal - float(CFG.subtDelaySec.getValue())
    VVBGsZ = self.VVB4vs(posVal)
    if VVBGsZ > -1:
     if self.subtLinesTableNdx > -1:
      row = VV6A99.VVMADj(self.subtLinesTableNdx)
      row[0] = row[0].replace(color, "")
      VV6A99.VVEOou(self.subtLinesTableNdx, row)
     row = VV6A99.VVMADj(VVBGsZ)
     row[0] = color + row[0]
     VV6A99.VVEOou(VVBGsZ, row)
     self.subtLinesTableNdx = VVBGsZ
 def VVdVmL(self, VV6A99, Title):
  delay, color, allow = self.VVLLr9(VV6A99)
  if allow:
   self.VVx5RW(VV6A99)
   self.VVRIDu(delay, True)
  else:
   FF28n1(VV6A99, "Delay out of range", 1500)
 def VVg4bx(self, VV6A99, VVwb7n, onlyColor=False):
  if VV6A99:
   posVal, durVal = self.VV2kXj()
   if posVal > 0:
    curTime = posVal - float(CFG.subtDelaySec.getValue())
    VVBGsZ = self.VVB4vs(posVal)
    if VVBGsZ > -1:
     VV6A99.VVrqBw(VVBGsZ)
    else:
     ndx = self.VV8JPJ(posVal)
     if ndx > -1:
      VV6A99.VVrqBw(ndx)
 def VV4qS4(self, VV6A99, title, txt, colList):
  if VV6A99["keyYellow"].getVisible():
   self.VVRIDu(0, True)
   VV6A99["keyYellow"].hide()
   self.VVg4bx(VV6A99, False)
 def VV0r1T(self, VV6A99):
  delay, color, allow = self.VVLLr9(VV6A99)
  VV6A99["keyBlue"].setText("%sNew Delay: %s sec" % (color, delay))
 def VVLLr9(self, VV6A99):
  lineTime = float(VV6A99.VV5crm()[2].strip())
  return self.VVauIP(lineTime)
 def VVauIP(self, lineTime):
  posVal, durVal = self.VV2kXj()
  delay, color, allow = 0, "", False
  if posVal > 0:
   val = int(round(posVal - lineTime))
   if self.minDelay <= val <= self.maxDelay: allow, color = True , VVJEMb
   else          : allow, color = False, VVyFI2
   delay = FFsRWN(val, self.minDelay, self.maxDelay)
  return delay, color, allow
 def VVmwD5(self):
  lst = CFG.subtDelaySec.choices.choices
  tMin = lst[0]
  tMax = lst[len(lst) - 1]
  if isinstance(tMin, tuple):
   tMin = tMin[0]
   tMax = tMax[0]
  return int(tMin), int(tMax)
 @staticmethod
 def VVjvxF(SELF):
  srtCfgPath = CCfpAm.VVXUuh(SELF)
  if srtCfgPath and FFCyVu(srtCfgPath + ".dis"):
   return False
  path, delay, enc = CCfpAm.VVuuUw(SELF)
  return True if path else False
 @staticmethod
 def VVuuUw(SELF):
  path, delay, enc = CCfpAm.VVTsdU(SELF)
  if not path:
   path = CCfpAm.VVzzYc(SELF)
  return path, delay, enc
 @staticmethod
 def VVTsdU(SELF):
  srtCfgPath = CCfpAm.VVXUuh(SELF)
  path = enc = ""
  delay = 0
  if srtCfgPath:
   if FFCyVu(srtCfgPath):
    lines = FFL19l(srtCfgPath)
    for line in lines:
     line = line.strip()
     if   line.startswith("srt=") : path = line.split("=")[1].strip()
     elif line.startswith("delay=") : delay = line.split("=")[1].strip()
     elif line.startswith("enc=") : enc = line.split("=")[1].strip()
  if path and FFCyVu(path):
   try:
    delay = int(delay)
   except:
    pass
   return path, delay, enc
  else:
   return "", 0, ""
 @staticmethod
 def VVXUuh(SELF):
  fPath, fDir, fName = CClYaF.VV4zSS(SELF)
  if not fPath:
   evName, evTime, evDur, evShort, evDesc, genre, PR = CC5TsO.VVgoJl(SELF)
   if evName.strip() and evTime and evDur:
    fPath = "/tmp/" + evName[:30].strip()
  if not fPath:
   VV1wIO = CC3rDi(SELF.session).VV1wIO.strip()
   if VV1wIO:
    fPath = "/tmp/" + VV1wIO
  if fPath: return fPath + ".ajp"
  else : return ""
 @staticmethod
 def VVzzYc(SELF):
  bestRatio = 0
  fPath, fDir, fName = CClYaF.VV4zSS(SELF)
  if fName:
   bestSrt = os.path.splitext(fPath)[0] + ".srt"
   if FFCyVu(bestSrt):
    return bestSrt
   else:
    movName = os.path.splitext(fName)[0]
    paths = CCfpAm.VVWHup(SELF)
    nm = CCwklK()
    bLst, err = nm.VVUziJ(movName, paths, 1, 0.3)
    if bLst:
     return bLst[0]
  return ""
 @staticmethod
 def VVWHup(SELF):
  fPath, fDir, fName = CClYaF.VV4zSS(SELF)
  if VVmJwX(fDir):
   files = FFkzic(fDir, "*.srt")
   if files:
    return files
  return []
 @staticmethod
 def VVeLpu():
  try:
   return InfoBar.instance.selected_subtitle
  except:
   try:
    return InfoBar.instance.__selected_subtitle
   except:
    return None
 @staticmethod
 def VVDjVi(subt):
  if subt and isinstance(subt, tuple) and len(subt) >= 4 : state = True
  else             : subt, state = None, False
  try:
   InfoBar.instance.enableSubtitle(subt)
  except:
   try:
    if state:
     InfoBar.instance.__selected_subtitle = subt
    InfoBar.instance.setSubtitlesEnable(state)
   except:
    pass
  CCfpAm.VVKmei()
 @staticmethod
 def VVKmei():
  try:
   if config.subtitles.show.value : InfoBar.instance.subtitle_window.show()
   else       : InfoBar.instance.subtitle_window.hide()
  except:
   pass
class CCyjWK(ScrollLabel):
 def __init__(self, VV0PQG, text="", VVZvtr=True):
  ScrollLabel.__init__(self, text)
  self.VVZvtr   = VVZvtr
  self.long_text    = None
  self.scrollbar    = None
  self.message    = text
  self.instance    = None
  self.VVQz6a  = 0
  self.curPos     = 0
  self.pageHeight    = 0
  self.pageLines    = 0
  self.column     = 0
  self.VVRhqH  = ""
  self.VV0PQG    = VV0PQG
  self.VV7u0U   = None
  self.fontFamily    = None
  self.VVwdmN    = None
  self.parentW    = None
  self.parentH    = None
  self.VViW1R   = True
  self.addNewLine    = True
  self.maxChars    = 0
  self.VVyhy1  = 50 if FFgrjX() else 0
  VV0PQG["keyRedTop"]  = Label("Menu")
  VV0PQG["keyGreenTop"] = Label("Reset")
  VV0PQG["keyYellowTop"] = Label("Font -")
  VV0PQG["keyBlueTop"] = Label("Font +")
  for s in ("Red", "Green", "Yellow", "Blue"):
   VV0PQG["key%sTop1" % s] = Label()
  FFHlAU(VV0PQG,
  {
   "ok"   : VV0PQG.close  ,
   "cancel"  : VV0PQG.close  ,
   "menu"   : self.VVDaGE ,
   "green"   : self.VVc4HF ,
   "yellow"  : self.VV8AUA ,
   "blue"   : self.VV7yIn ,
   "up"   : self.VVLlE3   ,
   "down"   : self.VVSYHQ  ,
   "left"   : self.VVLlE3   ,
   "right"   : self.VVSYHQ  ,
   "last"   : BF(self.VVrpxr, 0) ,
   "0"    : BF(self.VVrpxr, 1) ,
   "next"   : BF(self.VVrpxr, 2) ,
   "pageUp"  : self.VVHyNK   ,
   "chanUp"  : self.VVHyNK   ,
   "pageDown"  : self.VVSI5d   ,
   "chanDown"  : self.VVSI5d
  })
 def VV5kEH(self, VV7u0U=True, VViOjF=False, VVRhqH="", addNewLine=True, hideBtns=False, maxChars=0):
  self.VVRhqH = VVRhqH
  self.addNewLine = addNewLine
  self.maxChars = maxChars
  if hideBtns:
   for b in ("keyRedTop", "keyGreenTop", "keyYellowTop", "keyBlueTop", "keyRedTop1", "keyGreenTop1", "keyYellowTop1", "keyBlueTop1"):
    self.VV0PQG[b].hide()
  FF7hy1(self.VV0PQG["keyRedTop"], "#00FFFF55" if VVRhqH else "#00FFFFFF", "#11000000")
  FFWgBS(self.VV0PQG, True)
  self.VV7u0U = VV7u0U
  if VViOjF:
   self.long_text.setHAlign(1)
  size    = self.VV0PQG.instance.size()
  self.parentW  = size.width()
  self.parentH  = size.height()
  font    = self.long_text.getFont()
  self.fontFamily  = font.family
  self.VVwdmN  = font.pointSize
  try:  self.scrollbar.setBorderColor(parseColor("#11555555"))
  except: pass
  try:  self.scrollbar.setForegroundColor(parseColor("#11AA8E48"))
  except: pass
  try:  self.scrollbar.setBackgroundColor(parseColor("#11111111"))
  except: pass
  color = self.VV0PQG.VVfOli["VVPTnB"]
  FFZ0AC(self, color)
 def VVYmCe(self, color):
  self.long_text.setBackgroundColor(parseColor(color))
 def applySkin(self, desktop, parent):
  import skin
  from enigma import eLabel, eSlider
  self.long_text = eLabel(self.instance)
  self.scrollbar = eSlider(self.instance)
  skin.applyAllAttributes(self.long_text, desktop, self.skinAttributes, parent.scale)
  self.pageWidth = self.long_text.size().width()
  VV8c7y  = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont())) or 30
  self.pageLines = int(self.long_text.size().height() / VV8c7y)
  margin   = int(VV8c7y / 6)
  self.pageHeight = int(self.pageLines * VV8c7y)
  self.instance.move(self.long_text.position())
  self.instance.resize(eSize(self.pageWidth, self.pageHeight + margin))
  w = 20
  self.scrollbar.move(ePoint(self.pageWidth - w, 0))
  self.scrollbar.resize(eSize(w, self.pageHeight + margin))
  self.scrollbar.setOrientation(eSlider.orVertical)
  self.scrollbar.setRange(0, 100)
  self.scrollbar.setBorderWidth(1)
  return True
 def setPos(self, pos):
  self.curPos = max(0, min(pos, self.VVQz6a - self.pageHeight))
  self.long_text.move(ePoint(0, -self.curPos))
  self.VVAmEO()
 def VVLlE3(self):
  if self.VVQz6a > self.pageHeight:
   self.setPos(self.curPos - self.pageHeight)
 def VVSYHQ(self):
  if self.VVQz6a > self.pageHeight:
   self.setPos(self.curPos + self.pageHeight)
 def VVHyNK(self):
  self.setPos(0)
 def VVSI5d(self):
  self.setPos(self.VVQz6a-self.pageHeight)
 def VVbV7h(self):
  return self.VVQz6a <= self.pageHeight or self.curPos == self.VVQz6a - self.pageHeight
 def getText(self):
  return self.message
 def VVAmEO(self):
  try:
   vis = int(max(100 * self.pageHeight / self.VVQz6a, 3))
   start = int((100 - vis) * self.curPos / (self.VVQz6a - self.pageHeight))
   self.scrollbar.setStartEnd(start, start + vis)
  except:
   pass
 def setText(self, text, VV47Xm=VVje9A):
  old_VVbV7h = self.VVbV7h()
  self.message = str(text)
  if self.maxChars > 0 and len(self.message) > self.maxChars:
   self.message = self.message[-self.maxChars:]
   if "\n" in self.message[:100]:
    self.message = self.message[self.message.index("\n"):]
  if self.pageHeight:
   if self.addNewLine and len(self.message.splitlines()) < self.pageLines - 2:
    if not self.message.startswith("\n"):
     self.message = "\n" + self.message
    self.message = self.message.rstrip() + "\n"
   self.long_text.setText(self.message)
   self.VVQz6a = self.long_text.calculateSize().height()
   if self.VVZvtr and self.VVQz6a > self.pageHeight:
    self.scrollbar.show()
    self.VVAmEO()
    w = self.VV0PQG.VVfOli["scrollBarW"] + 5
    pageWidth  = self.instance.size().width() - w
    self.long_text.resize(eSize(pageWidth, self.VVQz6a))
    self.VVQz6a = self.long_text.calculateSize().height()
    self.long_text.resize(eSize(pageWidth, self.VVQz6a))
   else:
    self.scrollbar.hide()
   if   VV47Xm == VV5jA8: self.setPos(0)
   elif VV47Xm == VVYAtm : self.VVSI5d()
   elif old_VVbV7h    : self.VVSI5d()
 def appendText(self, text, VV47Xm=VVYAtm):
  self.setText(self.message + str(text), VV47Xm=VV47Xm)
 def VV8AUA(self):
  size = int(self.long_text.getFont().pointSize * 0.8)
  if size > 5:
   self.VVkyRg(size)
 def VV7yIn(self):
  size = int(self.long_text.getFont().pointSize * 1.2)
  if size < 80:
   self.VVkyRg(size)
 def VVc4HF(self):
  self.VVkyRg(self.VVwdmN)
 def VVkyRg(self, VVwdmN):
  self.long_text.setFont(gFont(self.fontFamily, VVwdmN))
  self.setText(self.message, VV47Xm=VVje9A)
  self.VVfu0l()
 def VVrpxr(self, align):
  self.long_text.setHAlign(align)
 def VVDaGE(self):
  VV3wat = []
  VV3wat.append(("%s Wrapping" % ("Disable" if self.VViW1R else "Enable"), "wrap" ))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Align Left" , "left" ))
  VV3wat.append(("Align Center" , "center" ))
  VV3wat.append(("Align Right" , "right" ))
  if self.VVRhqH:
   VV3wat.append(VVAL3j)
   VV3wat.append((FFjt5L("Save to File", VVFuwR), "save"))
  VV3wat.append(VVAL3j)
  VV3wat.append(("Keys (Shortcuts)", "help"))
  FFLFTC(self.VV0PQG, self.VVjTXc, VV3wat=VV3wat, title="Text Option", width=500)
 def VVjTXc(self, item=None):
  if item:
   if item == "wrap"  : self.VVOJVi()
   elif item == "left"  : self.VVrpxr(0)
   elif item == "center" : self.VVrpxr(1)
   elif item == "right" : self.VVrpxr(2)
   elif item == "save"  : self.VVxeSU()
   elif item == "help"  : FFw2rR(self.VV0PQG, "_help_txt", "Text Viewer (Keys)")
 def VVv22o(self, isOn):
  self.VViW1R = isOn
  self.long_text.setNoWrap(not isOn)
 def VVOJVi(self):
  self.VVv22o(not self.VViW1R)
 def VVxeSU(self):
  title = "%s Log File" % self.VVRhqH.capitalize()
  expPath = FFeAlZ()
  try:
   outF = "%sAJPanel_log_%s_%s.txt" % (FFoWxR(expPath), self.VVRhqH, FFjTQe())
   with open(outF, "w") as f:
    f.write(FFzBfi(self.message))
   FFipXT(self.VV0PQG, "Saved to:\n\n%s" % outF, title=title)
  except:
   FFdw58(self.VV0PQG, "Could not save to:\n\n%s" % expPath, title=title)
 def VVfu0l(self, minHeight=0):
  if self.VV7u0U:
   VV8c7y = int(fontRenderClass.getInstance().getLineHeight(self.long_text.getFont()))
   textH = min(self.pageHeight, VV8c7y * (len(self.message.splitlines()) + 1))
   if textH < self.pageHeight and self.VVQz6a < self.pageHeight:
    textH = max(textH, self.VVQz6a) + self.VVyhy1
   self.resize(eSize(*(self.instance.size().width(), textH + 6)))
   diff = self.pageHeight - textH
   newH = self.parentH - diff
   if diff < 0:
    newH = self.parentH
   if minHeight > 0:
    newH = max(newH, minHeight + self.VV0PQG.VVfOli["titleH"] + self.VV0PQG.VVfOli["VVpeQE"] * 2 + 1)
   screenSize = getDesktop(0).size()
   self.VV0PQG.instance.resize(eSize(*(self.parentW, min(self.parentH, newH))))
   self.VV0PQG.instance.move(ePoint((screenSize.width() - self.parentW) // 2, (screenSize.height() - newH) // 2))
